#[allow(unused_imports)]
use progenitor_client::{encode_path, RequestBuilderExt};
pub use progenitor_client::{ByteStream, Error, ResponseValue};
#[allow(unused_imports)]
use reqwest::header::{HeaderMap, HeaderValue};
pub mod types {
    use serde::{Deserialize, Serialize};
    #[allow(unused_imports)]
    use std::convert::TryFrom;
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct DependSubmit {
        pub copy_outputs: bool,
        pub on_completed: bool,
        pub on_failed: bool,
        pub prior_job: String,
    }

    impl From<&DependSubmit> for DependSubmit {
        fn from(value: &DependSubmit) -> Self {
            value.clone()
        }
    }

    impl DependSubmit {
        pub fn builder() -> builder::DependSubmit {
            builder::DependSubmit::default()
        }
    }

    ///Error information from a response.
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Error {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_code: Option<String>,
        pub message: String,
        pub request_id: String,
    }

    impl From<&Error> for Error {
        fn from(value: &Error) -> Self {
            value.clone()
        }
    }

    impl Error {
        pub fn builder() -> builder::Error {
            builder::Error::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryAddresses {
        pub cidr: String,
        pub count: u32,
        pub first: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gateway: Option<String>,
        pub name: String,
        pub routed: bool,
    }

    impl From<&FactoryAddresses> for FactoryAddresses {
        fn from(value: &FactoryAddresses) -> Self {
            value.clone()
        }
    }

    impl FactoryAddresses {
        pub fn builder() -> builder::FactoryAddresses {
            builder::FactoryAddresses::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryCreate {
        pub name: String,
    }

    impl From<&FactoryCreate> for FactoryCreate {
        fn from(value: &FactoryCreate) -> Self {
            value.clone()
        }
    }

    impl FactoryCreate {
        pub fn builder() -> builder::FactoryCreate {
            builder::FactoryCreate::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryCreateResult {
        pub id: String,
        pub name: String,
        pub token: String,
    }

    impl From<&FactoryCreateResult> for FactoryCreateResult {
        fn from(value: &FactoryCreateResult) -> Self {
            value.clone()
        }
    }

    impl FactoryCreateResult {
        pub fn builder() -> builder::FactoryCreateResult {
            builder::FactoryCreateResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryLease {
        pub job: String,
        pub target: String,
    }

    impl From<&FactoryLease> for FactoryLease {
        fn from(value: &FactoryLease) -> Self {
            value.clone()
        }
    }

    impl FactoryLease {
        pub fn builder() -> builder::FactoryLease {
            builder::FactoryLease::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryLeaseResult {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lease: Option<FactoryLease>,
    }

    impl From<&FactoryLeaseResult> for FactoryLeaseResult {
        fn from(value: &FactoryLeaseResult) -> Self {
            value.clone()
        }
    }

    impl FactoryLeaseResult {
        pub fn builder() -> builder::FactoryLeaseResult {
            builder::FactoryLeaseResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "v")]
    pub enum FactoryMetadata {
        #[serde(rename = "1")]
        _1 {
            #[serde(default, skip_serializing_if = "Vec::is_empty")]
            addresses: Vec<FactoryAddresses>,
        },
    }

    impl From<&FactoryMetadata> for FactoryMetadata {
        fn from(value: &FactoryMetadata) -> Self {
            value.clone()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryPingResult {
        pub ok: bool,
    }

    impl From<&FactoryPingResult> for FactoryPingResult {
        fn from(value: &FactoryPingResult) -> Self {
            value.clone()
        }
    }

    impl FactoryPingResult {
        pub fn builder() -> builder::FactoryPingResult {
            builder::FactoryPingResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryWhatsNext {
        pub supported_targets: Vec<String>,
    }

    impl From<&FactoryWhatsNext> for FactoryWhatsNext {
        fn from(value: &FactoryWhatsNext) -> Self {
            value.clone()
        }
    }

    impl FactoryWhatsNext {
        pub fn builder() -> builder::FactoryWhatsNext {
            builder::FactoryWhatsNext::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryWorker {
        pub bootstrap: String,
        pub id: String,
        pub online: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<String>,
        pub recycle: bool,
    }

    impl From<&FactoryWorker> for FactoryWorker {
        fn from(value: &FactoryWorker) -> Self {
            value.clone()
        }
    }

    impl FactoryWorker {
        pub fn builder() -> builder::FactoryWorker {
            builder::FactoryWorker::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryWorkerAppend {
        pub payload: String,
        pub stream: String,
        pub time: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&FactoryWorkerAppend> for FactoryWorkerAppend {
        fn from(value: &FactoryWorkerAppend) -> Self {
            value.clone()
        }
    }

    impl FactoryWorkerAppend {
        pub fn builder() -> builder::FactoryWorkerAppend {
            builder::FactoryWorkerAppend::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryWorkerAppendResult {
        pub retry: bool,
    }

    impl From<&FactoryWorkerAppendResult> for FactoryWorkerAppendResult {
        fn from(value: &FactoryWorkerAppendResult) -> Self {
            value.clone()
        }
    }

    impl FactoryWorkerAppendResult {
        pub fn builder() -> builder::FactoryWorkerAppendResult {
            builder::FactoryWorkerAppendResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryWorkerAssociate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub metadata: Option<FactoryMetadata>,
        pub private: String,
    }

    impl From<&FactoryWorkerAssociate> for FactoryWorkerAssociate {
        fn from(value: &FactoryWorkerAssociate) -> Self {
            value.clone()
        }
    }

    impl FactoryWorkerAssociate {
        pub fn builder() -> builder::FactoryWorkerAssociate {
            builder::FactoryWorkerAssociate::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryWorkerCreate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub job: Option<String>,
        pub target: String,
        #[serde(default)]
        pub wait_for_flush: bool,
    }

    impl From<&FactoryWorkerCreate> for FactoryWorkerCreate {
        fn from(value: &FactoryWorkerCreate) -> Self {
            value.clone()
        }
    }

    impl FactoryWorkerCreate {
        pub fn builder() -> builder::FactoryWorkerCreate {
            builder::FactoryWorkerCreate::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FactoryWorkerResult {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub worker: Option<FactoryWorker>,
    }

    impl From<&FactoryWorkerResult> for FactoryWorkerResult {
        fn from(value: &FactoryWorkerResult) -> Self {
            value.clone()
        }
    }

    impl FactoryWorkerResult {
        pub fn builder() -> builder::FactoryWorkerResult {
            builder::FactoryWorkerResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Job {
        pub cancelled: bool,
        pub id: String,
        pub name: String,
        pub output_rules: Vec<String>,
        pub owner: String,
        pub state: String,
        pub tags: std::collections::HashMap<String, String>,
        pub target: String,
        pub target_real: String,
        pub tasks: Vec<Task>,
        #[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub times: std::collections::HashMap<String, chrono::DateTime<chrono::offset::Utc>>,
    }

    impl From<&Job> for Job {
        fn from(value: &Job) -> Self {
            value.clone()
        }
    }

    impl Job {
        pub fn builder() -> builder::Job {
            builder::Job::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct JobAddInput {
        pub chunks: Vec<String>,
        pub commit_id: String,
        pub name: String,
        pub size: u64,
    }

    impl From<&JobAddInput> for JobAddInput {
        fn from(value: &JobAddInput) -> Self {
            value.clone()
        }
    }

    impl JobAddInput {
        pub fn builder() -> builder::JobAddInput {
            builder::JobAddInput::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct JobAddInputResult {
        pub complete: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<String>,
    }

    impl From<&JobAddInputResult> for JobAddInputResult {
        fn from(value: &JobAddInputResult) -> Self {
            value.clone()
        }
    }

    impl JobAddInputResult {
        pub fn builder() -> builder::JobAddInputResult {
            builder::JobAddInputResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct JobEvent {
        pub payload: String,
        pub seq: u32,
        pub stream: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub task: Option<u32>,
        pub time: chrono::DateTime<chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub time_remote: Option<chrono::DateTime<chrono::offset::Utc>>,
    }

    impl From<&JobEvent> for JobEvent {
        fn from(value: &JobEvent) -> Self {
            value.clone()
        }
    }

    impl JobEvent {
        pub fn builder() -> builder::JobEvent {
            builder::JobEvent::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct JobOutput {
        pub id: String,
        pub path: String,
        pub size: u64,
    }

    impl From<&JobOutput> for JobOutput {
        fn from(value: &JobOutput) -> Self {
            value.clone()
        }
    }

    impl JobOutput {
        pub fn builder() -> builder::JobOutput {
            builder::JobOutput::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct JobOutputPublish {
        pub name: String,
        pub series: String,
        pub version: String,
    }

    impl From<&JobOutputPublish> for JobOutputPublish {
        fn from(value: &JobOutputPublish) -> Self {
            value.clone()
        }
    }

    impl JobOutputPublish {
        pub fn builder() -> builder::JobOutputPublish {
            builder::JobOutputPublish::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct JobOutputSignedUrl {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub content_disposition: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub content_type: Option<String>,
        pub expiry_seconds: u64,
    }

    impl From<&JobOutputSignedUrl> for JobOutputSignedUrl {
        fn from(value: &JobOutputSignedUrl) -> Self {
            value.clone()
        }
    }

    impl JobOutputSignedUrl {
        pub fn builder() -> builder::JobOutputSignedUrl {
            builder::JobOutputSignedUrl::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct JobOutputSignedUrlResult {
        pub url: String,
    }

    impl From<&JobOutputSignedUrlResult> for JobOutputSignedUrlResult {
        fn from(value: &JobOutputSignedUrlResult) -> Self {
            value.clone()
        }
    }

    impl JobOutputSignedUrlResult {
        pub fn builder() -> builder::JobOutputSignedUrlResult {
            builder::JobOutputSignedUrlResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct JobStoreValue {
        pub secret: bool,
        pub value: String,
    }

    impl From<&JobStoreValue> for JobStoreValue {
        fn from(value: &JobStoreValue) -> Self {
            value.clone()
        }
    }

    impl JobStoreValue {
        pub fn builder() -> builder::JobStoreValue {
            builder::JobStoreValue::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct JobStoreValueInfo {
        pub secret: bool,
        pub source: String,
        pub time_update: chrono::DateTime<chrono::offset::Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub value: Option<String>,
    }

    impl From<&JobStoreValueInfo> for JobStoreValueInfo {
        fn from(value: &JobStoreValueInfo) -> Self {
            value.clone()
        }
    }

    impl JobStoreValueInfo {
        pub fn builder() -> builder::JobStoreValueInfo {
            builder::JobStoreValueInfo::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct JobSubmit {
        #[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub depends: std::collections::HashMap<String, DependSubmit>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub inputs: Vec<String>,
        pub name: String,
        pub output_rules: Vec<String>,
        #[serde(default, skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub tags: std::collections::HashMap<String, String>,
        pub target: String,
        pub tasks: Vec<TaskSubmit>,
    }

    impl From<&JobSubmit> for JobSubmit {
        fn from(value: &JobSubmit) -> Self {
            value.clone()
        }
    }

    impl JobSubmit {
        pub fn builder() -> builder::JobSubmit {
            builder::JobSubmit::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct JobSubmitResult {
        pub id: String,
    }

    impl From<&JobSubmitResult> for JobSubmitResult {
        fn from(value: &JobSubmitResult) -> Self {
            value.clone()
        }
    }

    impl JobSubmitResult {
        pub fn builder() -> builder::JobSubmitResult {
            builder::JobSubmitResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Quota {
        pub max_bytes_per_input: u64,
    }

    impl From<&Quota> for Quota {
        fn from(value: &Quota) -> Self {
            value.clone()
        }
    }

    impl Quota {
        pub fn builder() -> builder::Quota {
            builder::Quota::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Target {
        pub desc: String,
        pub id: String,
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub privilege: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redirect: Option<String>,
    }

    impl From<&Target> for Target {
        fn from(value: &Target) -> Self {
            value.clone()
        }
    }

    impl Target {
        pub fn builder() -> builder::Target {
            builder::Target::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct TargetCreate {
        pub desc: String,
        pub name: String,
    }

    impl From<&TargetCreate> for TargetCreate {
        fn from(value: &TargetCreate) -> Self {
            value.clone()
        }
    }

    impl TargetCreate {
        pub fn builder() -> builder::TargetCreate {
            builder::TargetCreate::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct TargetCreateResult {
        pub id: String,
    }

    impl From<&TargetCreateResult> for TargetCreateResult {
        fn from(value: &TargetCreateResult) -> Self {
            value.clone()
        }
    }

    impl TargetCreateResult {
        pub fn builder() -> builder::TargetCreateResult {
            builder::TargetCreateResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct TargetRedirect {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redirect: Option<String>,
    }

    impl From<&TargetRedirect> for TargetRedirect {
        fn from(value: &TargetRedirect) -> Self {
            value.clone()
        }
    }

    impl TargetRedirect {
        pub fn builder() -> builder::TargetRedirect {
            builder::TargetRedirect::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct TargetRename {
        pub new_name: String,
        pub signpost_description: String,
    }

    impl From<&TargetRename> for TargetRename {
        fn from(value: &TargetRename) -> Self {
            value.clone()
        }
    }

    impl TargetRename {
        pub fn builder() -> builder::TargetRename {
            builder::TargetRename::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Task {
        pub env: std::collections::HashMap<String, String>,
        pub env_clear: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gid: Option<u32>,
        pub name: String,
        pub script: String,
        pub state: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub uid: Option<u32>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub workdir: Option<String>,
    }

    impl From<&Task> for Task {
        fn from(value: &Task) -> Self {
            value.clone()
        }
    }

    impl Task {
        pub fn builder() -> builder::Task {
            builder::Task::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct TaskSubmit {
        pub env: std::collections::HashMap<String, String>,
        pub env_clear: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gid: Option<u32>,
        pub name: String,
        pub script: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub uid: Option<u32>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub workdir: Option<String>,
    }

    impl From<&TaskSubmit> for TaskSubmit {
        fn from(value: &TaskSubmit) -> Self {
            value.clone()
        }
    }

    impl TaskSubmit {
        pub fn builder() -> builder::TaskSubmit {
            builder::TaskSubmit::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UploadedChunk {
        pub id: String,
    }

    impl From<&UploadedChunk> for UploadedChunk {
        fn from(value: &UploadedChunk) -> Self {
            value.clone()
        }
    }

    impl UploadedChunk {
        pub fn builder() -> builder::UploadedChunk {
            builder::UploadedChunk::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct User {
        pub id: String,
        pub name: String,
        pub privileges: Vec<String>,
        pub time_create: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&User> for User {
        fn from(value: &User) -> Self {
            value.clone()
        }
    }

    impl User {
        pub fn builder() -> builder::User {
            builder::User::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UserCreate {
        pub name: String,
    }

    impl From<&UserCreate> for UserCreate {
        fn from(value: &UserCreate) -> Self {
            value.clone()
        }
    }

    impl UserCreate {
        pub fn builder() -> builder::UserCreate {
            builder::UserCreate::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UserCreateResult {
        pub id: String,
        pub name: String,
        pub token: String,
    }

    impl From<&UserCreateResult> for UserCreateResult {
        fn from(value: &UserCreateResult) -> Self {
            value.clone()
        }
    }

    impl UserCreateResult {
        pub fn builder() -> builder::UserCreateResult {
            builder::UserCreateResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WhoamiResult {
        pub id: String,
        pub name: String,
    }

    impl From<&WhoamiResult> for WhoamiResult {
        fn from(value: &WhoamiResult) -> Self {
            value.clone()
        }
    }

    impl WhoamiResult {
        pub fn builder() -> builder::WhoamiResult {
            builder::WhoamiResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Worker {
        pub bootstrap: bool,
        pub deleted: bool,
        pub factory: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub factory_private: Option<String>,
        pub id: String,
        pub jobs: Vec<WorkerJob>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lastping: Option<chrono::DateTime<chrono::offset::Utc>>,
        pub recycle: bool,
        pub target: String,
    }

    impl From<&Worker> for Worker {
        fn from(value: &Worker) -> Self {
            value.clone()
        }
    }

    impl Worker {
        pub fn builder() -> builder::Worker {
            builder::Worker::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerAddOutput {
        pub chunks: Vec<String>,
        pub commit_id: String,
        pub path: String,
        pub size: u64,
    }

    impl From<&WorkerAddOutput> for WorkerAddOutput {
        fn from(value: &WorkerAddOutput) -> Self {
            value.clone()
        }
    }

    impl WorkerAddOutput {
        pub fn builder() -> builder::WorkerAddOutput {
            builder::WorkerAddOutput::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerAddOutputResult {
        pub complete: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<String>,
    }

    impl From<&WorkerAddOutputResult> for WorkerAddOutputResult {
        fn from(value: &WorkerAddOutputResult) -> Self {
            value.clone()
        }
    }

    impl WorkerAddOutputResult {
        pub fn builder() -> builder::WorkerAddOutputResult {
            builder::WorkerAddOutputResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerAppendJob {
        pub payload: String,
        pub stream: String,
        pub time: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&WorkerAppendJob> for WorkerAppendJob {
        fn from(value: &WorkerAppendJob) -> Self {
            value.clone()
        }
    }

    impl WorkerAppendJob {
        pub fn builder() -> builder::WorkerAppendJob {
            builder::WorkerAppendJob::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerAppendJobOrTask {
        pub payload: String,
        pub stream: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub task: Option<u32>,
        pub time: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&WorkerAppendJobOrTask> for WorkerAppendJobOrTask {
        fn from(value: &WorkerAppendJobOrTask) -> Self {
            value.clone()
        }
    }

    impl WorkerAppendJobOrTask {
        pub fn builder() -> builder::WorkerAppendJobOrTask {
            builder::WorkerAppendJobOrTask::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerBootstrap {
        pub bootstrap: String,
        pub token: String,
    }

    impl From<&WorkerBootstrap> for WorkerBootstrap {
        fn from(value: &WorkerBootstrap) -> Self {
            value.clone()
        }
    }

    impl WorkerBootstrap {
        pub fn builder() -> builder::WorkerBootstrap {
            builder::WorkerBootstrap::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerBootstrapResult {
        pub id: String,
    }

    impl From<&WorkerBootstrapResult> for WorkerBootstrapResult {
        fn from(value: &WorkerBootstrapResult) -> Self {
            value.clone()
        }
    }

    impl WorkerBootstrapResult {
        pub fn builder() -> builder::WorkerBootstrapResult {
            builder::WorkerBootstrapResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerCompleteJob {
        pub failed: bool,
    }

    impl From<&WorkerCompleteJob> for WorkerCompleteJob {
        fn from(value: &WorkerCompleteJob) -> Self {
            value.clone()
        }
    }

    impl WorkerCompleteJob {
        pub fn builder() -> builder::WorkerCompleteJob {
            builder::WorkerCompleteJob::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerCompleteTask {
        pub failed: bool,
    }

    impl From<&WorkerCompleteTask> for WorkerCompleteTask {
        fn from(value: &WorkerCompleteTask) -> Self {
            value.clone()
        }
    }

    impl WorkerCompleteTask {
        pub fn builder() -> builder::WorkerCompleteTask {
            builder::WorkerCompleteTask::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerJob {
        pub id: String,
        pub name: String,
        pub owner: String,
        pub state: String,
        pub tags: std::collections::HashMap<String, String>,
    }

    impl From<&WorkerJob> for WorkerJob {
        fn from(value: &WorkerJob) -> Self {
            value.clone()
        }
    }

    impl WorkerJob {
        pub fn builder() -> builder::WorkerJob {
            builder::WorkerJob::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerJobQuota {
        pub max_bytes_per_output: u64,
    }

    impl From<&WorkerJobQuota> for WorkerJobQuota {
        fn from(value: &WorkerJobQuota) -> Self {
            value.clone()
        }
    }

    impl WorkerJobQuota {
        pub fn builder() -> builder::WorkerJobQuota {
            builder::WorkerJobQuota::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerJobStoreGet {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub value: Option<WorkerJobStoreValue>,
    }

    impl From<&WorkerJobStoreGet> for WorkerJobStoreGet {
        fn from(value: &WorkerJobStoreGet) -> Self {
            value.clone()
        }
    }

    impl WorkerJobStoreGet {
        pub fn builder() -> builder::WorkerJobStoreGet {
            builder::WorkerJobStoreGet::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerJobStoreValue {
        pub secret: bool,
        pub value: String,
    }

    impl From<&WorkerJobStoreValue> for WorkerJobStoreValue {
        fn from(value: &WorkerJobStoreValue) -> Self {
            value.clone()
        }
    }

    impl WorkerJobStoreValue {
        pub fn builder() -> builder::WorkerJobStoreValue {
            builder::WorkerJobStoreValue::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerPingInput {
        pub id: String,
        pub name: String,
    }

    impl From<&WorkerPingInput> for WorkerPingInput {
        fn from(value: &WorkerPingInput) -> Self {
            value.clone()
        }
    }

    impl WorkerPingInput {
        pub fn builder() -> builder::WorkerPingInput {
            builder::WorkerPingInput::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerPingJob {
        pub id: String,
        pub inputs: Vec<WorkerPingInput>,
        pub name: String,
        pub output_rules: Vec<WorkerPingOutputRule>,
        pub tasks: Vec<WorkerPingTask>,
    }

    impl From<&WorkerPingJob> for WorkerPingJob {
        fn from(value: &WorkerPingJob) -> Self {
            value.clone()
        }
    }

    impl WorkerPingJob {
        pub fn builder() -> builder::WorkerPingJob {
            builder::WorkerPingJob::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerPingOutputRule {
        pub ignore: bool,
        pub require_match: bool,
        pub rule: String,
        pub size_change_ok: bool,
    }

    impl From<&WorkerPingOutputRule> for WorkerPingOutputRule {
        fn from(value: &WorkerPingOutputRule) -> Self {
            value.clone()
        }
    }

    impl WorkerPingOutputRule {
        pub fn builder() -> builder::WorkerPingOutputRule {
            builder::WorkerPingOutputRule::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerPingResult {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub factory_metadata: Option<FactoryMetadata>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub job: Option<WorkerPingJob>,
        pub poweroff: bool,
    }

    impl From<&WorkerPingResult> for WorkerPingResult {
        fn from(value: &WorkerPingResult) -> Self {
            value.clone()
        }
    }

    impl WorkerPingResult {
        pub fn builder() -> builder::WorkerPingResult {
            builder::WorkerPingResult::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkerPingTask {
        pub env: std::collections::HashMap<String, String>,
        pub env_clear: bool,
        pub gid: u32,
        pub id: u32,
        pub name: String,
        pub script: String,
        pub uid: u32,
        pub workdir: String,
    }

    impl From<&WorkerPingTask> for WorkerPingTask {
        fn from(value: &WorkerPingTask) -> Self {
            value.clone()
        }
    }

    impl WorkerPingTask {
        pub fn builder() -> builder::WorkerPingTask {
            builder::WorkerPingTask::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct WorkersResult {
        pub workers: Vec<Worker>,
    }

    impl From<&WorkersResult> for WorkersResult {
        fn from(value: &WorkersResult) -> Self {
            value.clone()
        }
    }

    impl WorkersResult {
        pub fn builder() -> builder::WorkersResult {
            builder::WorkersResult::default()
        }
    }

    pub mod builder {
        #[derive(Clone, Debug)]
        pub struct DependSubmit {
            copy_outputs: Result<bool, String>,
            on_completed: Result<bool, String>,
            on_failed: Result<bool, String>,
            prior_job: Result<String, String>,
        }

        impl Default for DependSubmit {
            fn default() -> Self {
                Self {
                    copy_outputs: Err("no value supplied for copy_outputs".to_string()),
                    on_completed: Err("no value supplied for on_completed".to_string()),
                    on_failed: Err("no value supplied for on_failed".to_string()),
                    prior_job: Err("no value supplied for prior_job".to_string()),
                }
            }
        }

        impl DependSubmit {
            pub fn copy_outputs<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.copy_outputs = value.try_into().map_err(|e| {
                    format!("error converting supplied value for copy_outputs: {}", e)
                });
                self
            }
            pub fn on_completed<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.on_completed = value.try_into().map_err(|e| {
                    format!("error converting supplied value for on_completed: {}", e)
                });
                self
            }
            pub fn on_failed<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.on_failed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for on_failed: {}", e));
                self
            }
            pub fn prior_job<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.prior_job = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for prior_job: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DependSubmit> for super::DependSubmit {
            type Error = String;
            fn try_from(value: DependSubmit) -> Result<Self, String> {
                Ok(Self {
                    copy_outputs: value.copy_outputs?,
                    on_completed: value.on_completed?,
                    on_failed: value.on_failed?,
                    prior_job: value.prior_job?,
                })
            }
        }

        impl From<super::DependSubmit> for DependSubmit {
            fn from(value: super::DependSubmit) -> Self {
                Self {
                    copy_outputs: Ok(value.copy_outputs),
                    on_completed: Ok(value.on_completed),
                    on_failed: Ok(value.on_failed),
                    prior_job: Ok(value.prior_job),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Error {
            error_code: Result<Option<String>, String>,
            message: Result<String, String>,
            request_id: Result<String, String>,
        }

        impl Default for Error {
            fn default() -> Self {
                Self {
                    error_code: Ok(Default::default()),
                    message: Err("no value supplied for message".to_string()),
                    request_id: Err("no value supplied for request_id".to_string()),
                }
            }
        }

        impl Error {
            pub fn error_code<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.error_code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_code: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
            pub fn request_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.request_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for request_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Error> for super::Error {
            type Error = String;
            fn try_from(value: Error) -> Result<Self, String> {
                Ok(Self {
                    error_code: value.error_code?,
                    message: value.message?,
                    request_id: value.request_id?,
                })
            }
        }

        impl From<super::Error> for Error {
            fn from(value: super::Error) -> Self {
                Self {
                    error_code: Ok(value.error_code),
                    message: Ok(value.message),
                    request_id: Ok(value.request_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryAddresses {
            cidr: Result<String, String>,
            count: Result<u32, String>,
            first: Result<String, String>,
            gateway: Result<Option<String>, String>,
            name: Result<String, String>,
            routed: Result<bool, String>,
        }

        impl Default for FactoryAddresses {
            fn default() -> Self {
                Self {
                    cidr: Err("no value supplied for cidr".to_string()),
                    count: Err("no value supplied for count".to_string()),
                    first: Err("no value supplied for first".to_string()),
                    gateway: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    routed: Err("no value supplied for routed".to_string()),
                }
            }
        }

        impl FactoryAddresses {
            pub fn cidr<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.cidr = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cidr: {}", e));
                self
            }
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u32>,
                T::Error: std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn first<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.first = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for first: {}", e));
                self
            }
            pub fn gateway<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.gateway = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gateway: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn routed<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.routed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for routed: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FactoryAddresses> for super::FactoryAddresses {
            type Error = String;
            fn try_from(value: FactoryAddresses) -> Result<Self, String> {
                Ok(Self {
                    cidr: value.cidr?,
                    count: value.count?,
                    first: value.first?,
                    gateway: value.gateway?,
                    name: value.name?,
                    routed: value.routed?,
                })
            }
        }

        impl From<super::FactoryAddresses> for FactoryAddresses {
            fn from(value: super::FactoryAddresses) -> Self {
                Self {
                    cidr: Ok(value.cidr),
                    count: Ok(value.count),
                    first: Ok(value.first),
                    gateway: Ok(value.gateway),
                    name: Ok(value.name),
                    routed: Ok(value.routed),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryCreate {
            name: Result<String, String>,
        }

        impl Default for FactoryCreate {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl FactoryCreate {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FactoryCreate> for super::FactoryCreate {
            type Error = String;
            fn try_from(value: FactoryCreate) -> Result<Self, String> {
                Ok(Self { name: value.name? })
            }
        }

        impl From<super::FactoryCreate> for FactoryCreate {
            fn from(value: super::FactoryCreate) -> Self {
                Self {
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryCreateResult {
            id: Result<String, String>,
            name: Result<String, String>,
            token: Result<String, String>,
        }

        impl Default for FactoryCreateResult {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }

        impl FactoryCreateResult {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FactoryCreateResult> for super::FactoryCreateResult {
            type Error = String;
            fn try_from(value: FactoryCreateResult) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    name: value.name?,
                    token: value.token?,
                })
            }
        }

        impl From<super::FactoryCreateResult> for FactoryCreateResult {
            fn from(value: super::FactoryCreateResult) -> Self {
                Self {
                    id: Ok(value.id),
                    name: Ok(value.name),
                    token: Ok(value.token),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryLease {
            job: Result<String, String>,
            target: Result<String, String>,
        }

        impl Default for FactoryLease {
            fn default() -> Self {
                Self {
                    job: Err("no value supplied for job".to_string()),
                    target: Err("no value supplied for target".to_string()),
                }
            }
        }

        impl FactoryLease {
            pub fn job<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.job = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for job: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FactoryLease> for super::FactoryLease {
            type Error = String;
            fn try_from(value: FactoryLease) -> Result<Self, String> {
                Ok(Self {
                    job: value.job?,
                    target: value.target?,
                })
            }
        }

        impl From<super::FactoryLease> for FactoryLease {
            fn from(value: super::FactoryLease) -> Self {
                Self {
                    job: Ok(value.job),
                    target: Ok(value.target),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryLeaseResult {
            lease: Result<Option<super::FactoryLease>, String>,
        }

        impl Default for FactoryLeaseResult {
            fn default() -> Self {
                Self {
                    lease: Ok(Default::default()),
                }
            }
        }

        impl FactoryLeaseResult {
            pub fn lease<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::FactoryLease>>,
                T::Error: std::fmt::Display,
            {
                self.lease = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for lease: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FactoryLeaseResult> for super::FactoryLeaseResult {
            type Error = String;
            fn try_from(value: FactoryLeaseResult) -> Result<Self, String> {
                Ok(Self {
                    lease: value.lease?,
                })
            }
        }

        impl From<super::FactoryLeaseResult> for FactoryLeaseResult {
            fn from(value: super::FactoryLeaseResult) -> Self {
                Self {
                    lease: Ok(value.lease),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryPingResult {
            ok: Result<bool, String>,
        }

        impl Default for FactoryPingResult {
            fn default() -> Self {
                Self {
                    ok: Err("no value supplied for ok".to_string()),
                }
            }
        }

        impl FactoryPingResult {
            pub fn ok<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.ok = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ok: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FactoryPingResult> for super::FactoryPingResult {
            type Error = String;
            fn try_from(value: FactoryPingResult) -> Result<Self, String> {
                Ok(Self { ok: value.ok? })
            }
        }

        impl From<super::FactoryPingResult> for FactoryPingResult {
            fn from(value: super::FactoryPingResult) -> Self {
                Self { ok: Ok(value.ok) }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryWhatsNext {
            supported_targets: Result<Vec<String>, String>,
        }

        impl Default for FactoryWhatsNext {
            fn default() -> Self {
                Self {
                    supported_targets: Err("no value supplied for supported_targets".to_string()),
                }
            }
        }

        impl FactoryWhatsNext {
            pub fn supported_targets<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.supported_targets = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for supported_targets: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<FactoryWhatsNext> for super::FactoryWhatsNext {
            type Error = String;
            fn try_from(value: FactoryWhatsNext) -> Result<Self, String> {
                Ok(Self {
                    supported_targets: value.supported_targets?,
                })
            }
        }

        impl From<super::FactoryWhatsNext> for FactoryWhatsNext {
            fn from(value: super::FactoryWhatsNext) -> Self {
                Self {
                    supported_targets: Ok(value.supported_targets),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryWorker {
            bootstrap: Result<String, String>,
            id: Result<String, String>,
            online: Result<bool, String>,
            private: Result<Option<String>, String>,
            recycle: Result<bool, String>,
        }

        impl Default for FactoryWorker {
            fn default() -> Self {
                Self {
                    bootstrap: Err("no value supplied for bootstrap".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    online: Err("no value supplied for online".to_string()),
                    private: Ok(Default::default()),
                    recycle: Err("no value supplied for recycle".to_string()),
                }
            }
        }

        impl FactoryWorker {
            pub fn bootstrap<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.bootstrap = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bootstrap: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn online<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.online = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for online: {}", e));
                self
            }
            pub fn private<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.private = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for private: {}", e));
                self
            }
            pub fn recycle<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.recycle = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for recycle: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FactoryWorker> for super::FactoryWorker {
            type Error = String;
            fn try_from(value: FactoryWorker) -> Result<Self, String> {
                Ok(Self {
                    bootstrap: value.bootstrap?,
                    id: value.id?,
                    online: value.online?,
                    private: value.private?,
                    recycle: value.recycle?,
                })
            }
        }

        impl From<super::FactoryWorker> for FactoryWorker {
            fn from(value: super::FactoryWorker) -> Self {
                Self {
                    bootstrap: Ok(value.bootstrap),
                    id: Ok(value.id),
                    online: Ok(value.online),
                    private: Ok(value.private),
                    recycle: Ok(value.recycle),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryWorkerAppend {
            payload: Result<String, String>,
            stream: Result<String, String>,
            time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for FactoryWorkerAppend {
            fn default() -> Self {
                Self {
                    payload: Err("no value supplied for payload".to_string()),
                    stream: Err("no value supplied for stream".to_string()),
                    time: Err("no value supplied for time".to_string()),
                }
            }
        }

        impl FactoryWorkerAppend {
            pub fn payload<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.payload = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for payload: {}", e));
                self
            }
            pub fn stream<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.stream = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for stream: {}", e));
                self
            }
            pub fn time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for time: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FactoryWorkerAppend> for super::FactoryWorkerAppend {
            type Error = String;
            fn try_from(value: FactoryWorkerAppend) -> Result<Self, String> {
                Ok(Self {
                    payload: value.payload?,
                    stream: value.stream?,
                    time: value.time?,
                })
            }
        }

        impl From<super::FactoryWorkerAppend> for FactoryWorkerAppend {
            fn from(value: super::FactoryWorkerAppend) -> Self {
                Self {
                    payload: Ok(value.payload),
                    stream: Ok(value.stream),
                    time: Ok(value.time),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryWorkerAppendResult {
            retry: Result<bool, String>,
        }

        impl Default for FactoryWorkerAppendResult {
            fn default() -> Self {
                Self {
                    retry: Err("no value supplied for retry".to_string()),
                }
            }
        }

        impl FactoryWorkerAppendResult {
            pub fn retry<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.retry = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for retry: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FactoryWorkerAppendResult> for super::FactoryWorkerAppendResult {
            type Error = String;
            fn try_from(value: FactoryWorkerAppendResult) -> Result<Self, String> {
                Ok(Self {
                    retry: value.retry?,
                })
            }
        }

        impl From<super::FactoryWorkerAppendResult> for FactoryWorkerAppendResult {
            fn from(value: super::FactoryWorkerAppendResult) -> Self {
                Self {
                    retry: Ok(value.retry),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryWorkerAssociate {
            metadata: Result<Option<super::FactoryMetadata>, String>,
            private: Result<String, String>,
        }

        impl Default for FactoryWorkerAssociate {
            fn default() -> Self {
                Self {
                    metadata: Ok(Default::default()),
                    private: Err("no value supplied for private".to_string()),
                }
            }
        }

        impl FactoryWorkerAssociate {
            pub fn metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::FactoryMetadata>>,
                T::Error: std::fmt::Display,
            {
                self.metadata = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metadata: {}", e));
                self
            }
            pub fn private<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.private = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for private: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FactoryWorkerAssociate> for super::FactoryWorkerAssociate {
            type Error = String;
            fn try_from(value: FactoryWorkerAssociate) -> Result<Self, String> {
                Ok(Self {
                    metadata: value.metadata?,
                    private: value.private?,
                })
            }
        }

        impl From<super::FactoryWorkerAssociate> for FactoryWorkerAssociate {
            fn from(value: super::FactoryWorkerAssociate) -> Self {
                Self {
                    metadata: Ok(value.metadata),
                    private: Ok(value.private),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryWorkerCreate {
            job: Result<Option<String>, String>,
            target: Result<String, String>,
            wait_for_flush: Result<bool, String>,
        }

        impl Default for FactoryWorkerCreate {
            fn default() -> Self {
                Self {
                    job: Ok(Default::default()),
                    target: Err("no value supplied for target".to_string()),
                    wait_for_flush: Ok(Default::default()),
                }
            }
        }

        impl FactoryWorkerCreate {
            pub fn job<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.job = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for job: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
            pub fn wait_for_flush<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.wait_for_flush = value.try_into().map_err(|e| {
                    format!("error converting supplied value for wait_for_flush: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<FactoryWorkerCreate> for super::FactoryWorkerCreate {
            type Error = String;
            fn try_from(value: FactoryWorkerCreate) -> Result<Self, String> {
                Ok(Self {
                    job: value.job?,
                    target: value.target?,
                    wait_for_flush: value.wait_for_flush?,
                })
            }
        }

        impl From<super::FactoryWorkerCreate> for FactoryWorkerCreate {
            fn from(value: super::FactoryWorkerCreate) -> Self {
                Self {
                    job: Ok(value.job),
                    target: Ok(value.target),
                    wait_for_flush: Ok(value.wait_for_flush),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FactoryWorkerResult {
            worker: Result<Option<super::FactoryWorker>, String>,
        }

        impl Default for FactoryWorkerResult {
            fn default() -> Self {
                Self {
                    worker: Ok(Default::default()),
                }
            }
        }

        impl FactoryWorkerResult {
            pub fn worker<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::FactoryWorker>>,
                T::Error: std::fmt::Display,
            {
                self.worker = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for worker: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FactoryWorkerResult> for super::FactoryWorkerResult {
            type Error = String;
            fn try_from(value: FactoryWorkerResult) -> Result<Self, String> {
                Ok(Self {
                    worker: value.worker?,
                })
            }
        }

        impl From<super::FactoryWorkerResult> for FactoryWorkerResult {
            fn from(value: super::FactoryWorkerResult) -> Self {
                Self {
                    worker: Ok(value.worker),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Job {
            cancelled: Result<bool, String>,
            id: Result<String, String>,
            name: Result<String, String>,
            output_rules: Result<Vec<String>, String>,
            owner: Result<String, String>,
            state: Result<String, String>,
            tags: Result<std::collections::HashMap<String, String>, String>,
            target: Result<String, String>,
            target_real: Result<String, String>,
            tasks: Result<Vec<super::Task>, String>,
            times: Result<
                std::collections::HashMap<String, chrono::DateTime<chrono::offset::Utc>>,
                String,
            >,
        }

        impl Default for Job {
            fn default() -> Self {
                Self {
                    cancelled: Err("no value supplied for cancelled".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    output_rules: Err("no value supplied for output_rules".to_string()),
                    owner: Err("no value supplied for owner".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    tags: Err("no value supplied for tags".to_string()),
                    target: Err("no value supplied for target".to_string()),
                    target_real: Err("no value supplied for target_real".to_string()),
                    tasks: Err("no value supplied for tasks".to_string()),
                    times: Ok(Default::default()),
                }
            }
        }

        impl Job {
            pub fn cancelled<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.cancelled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cancelled: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn output_rules<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.output_rules = value.try_into().map_err(|e| {
                    format!("error converting supplied value for output_rules: {}", e)
                });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owner: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn tags<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::collections::HashMap<String, String>>,
                T::Error: std::fmt::Display,
            {
                self.tags = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tags: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
            pub fn target_real<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.target_real = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target_real: {}", e));
                self
            }
            pub fn tasks<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Task>>,
                T::Error: std::fmt::Display,
            {
                self.tasks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tasks: {}", e));
                self
            }
            pub fn times<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<
                    std::collections::HashMap<String, chrono::DateTime<chrono::offset::Utc>>,
                >,
                T::Error: std::fmt::Display,
            {
                self.times = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for times: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Job> for super::Job {
            type Error = String;
            fn try_from(value: Job) -> Result<Self, String> {
                Ok(Self {
                    cancelled: value.cancelled?,
                    id: value.id?,
                    name: value.name?,
                    output_rules: value.output_rules?,
                    owner: value.owner?,
                    state: value.state?,
                    tags: value.tags?,
                    target: value.target?,
                    target_real: value.target_real?,
                    tasks: value.tasks?,
                    times: value.times?,
                })
            }
        }

        impl From<super::Job> for Job {
            fn from(value: super::Job) -> Self {
                Self {
                    cancelled: Ok(value.cancelled),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    output_rules: Ok(value.output_rules),
                    owner: Ok(value.owner),
                    state: Ok(value.state),
                    tags: Ok(value.tags),
                    target: Ok(value.target),
                    target_real: Ok(value.target_real),
                    tasks: Ok(value.tasks),
                    times: Ok(value.times),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct JobAddInput {
            chunks: Result<Vec<String>, String>,
            commit_id: Result<String, String>,
            name: Result<String, String>,
            size: Result<u64, String>,
        }

        impl Default for JobAddInput {
            fn default() -> Self {
                Self {
                    chunks: Err("no value supplied for chunks".to_string()),
                    commit_id: Err("no value supplied for commit_id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    size: Err("no value supplied for size".to_string()),
                }
            }
        }

        impl JobAddInput {
            pub fn chunks<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.chunks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chunks: {}", e));
                self
            }
            pub fn commit_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.commit_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for commit_id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<JobAddInput> for super::JobAddInput {
            type Error = String;
            fn try_from(value: JobAddInput) -> Result<Self, String> {
                Ok(Self {
                    chunks: value.chunks?,
                    commit_id: value.commit_id?,
                    name: value.name?,
                    size: value.size?,
                })
            }
        }

        impl From<super::JobAddInput> for JobAddInput {
            fn from(value: super::JobAddInput) -> Self {
                Self {
                    chunks: Ok(value.chunks),
                    commit_id: Ok(value.commit_id),
                    name: Ok(value.name),
                    size: Ok(value.size),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct JobAddInputResult {
            complete: Result<bool, String>,
            error: Result<Option<String>, String>,
        }

        impl Default for JobAddInputResult {
            fn default() -> Self {
                Self {
                    complete: Err("no value supplied for complete".to_string()),
                    error: Ok(Default::default()),
                }
            }
        }

        impl JobAddInputResult {
            pub fn complete<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.complete = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for complete: {}", e));
                self
            }
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<JobAddInputResult> for super::JobAddInputResult {
            type Error = String;
            fn try_from(value: JobAddInputResult) -> Result<Self, String> {
                Ok(Self {
                    complete: value.complete?,
                    error: value.error?,
                })
            }
        }

        impl From<super::JobAddInputResult> for JobAddInputResult {
            fn from(value: super::JobAddInputResult) -> Self {
                Self {
                    complete: Ok(value.complete),
                    error: Ok(value.error),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct JobEvent {
            payload: Result<String, String>,
            seq: Result<u32, String>,
            stream: Result<String, String>,
            task: Result<Option<u32>, String>,
            time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_remote: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
        }

        impl Default for JobEvent {
            fn default() -> Self {
                Self {
                    payload: Err("no value supplied for payload".to_string()),
                    seq: Err("no value supplied for seq".to_string()),
                    stream: Err("no value supplied for stream".to_string()),
                    task: Ok(Default::default()),
                    time: Err("no value supplied for time".to_string()),
                    time_remote: Ok(Default::default()),
                }
            }
        }

        impl JobEvent {
            pub fn payload<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.payload = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for payload: {}", e));
                self
            }
            pub fn seq<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u32>,
                T::Error: std::fmt::Display,
            {
                self.seq = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for seq: {}", e));
                self
            }
            pub fn stream<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.stream = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for stream: {}", e));
                self
            }
            pub fn task<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<u32>>,
                T::Error: std::fmt::Display,
            {
                self.task = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for task: {}", e));
                self
            }
            pub fn time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for time: {}", e));
                self
            }
            pub fn time_remote<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<chrono::DateTime<chrono::offset::Utc>>>,
                T::Error: std::fmt::Display,
            {
                self.time_remote = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for time_remote: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<JobEvent> for super::JobEvent {
            type Error = String;
            fn try_from(value: JobEvent) -> Result<Self, String> {
                Ok(Self {
                    payload: value.payload?,
                    seq: value.seq?,
                    stream: value.stream?,
                    task: value.task?,
                    time: value.time?,
                    time_remote: value.time_remote?,
                })
            }
        }

        impl From<super::JobEvent> for JobEvent {
            fn from(value: super::JobEvent) -> Self {
                Self {
                    payload: Ok(value.payload),
                    seq: Ok(value.seq),
                    stream: Ok(value.stream),
                    task: Ok(value.task),
                    time: Ok(value.time),
                    time_remote: Ok(value.time_remote),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct JobOutput {
            id: Result<String, String>,
            path: Result<String, String>,
            size: Result<u64, String>,
        }

        impl Default for JobOutput {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    path: Err("no value supplied for path".to_string()),
                    size: Err("no value supplied for size".to_string()),
                }
            }
        }

        impl JobOutput {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<JobOutput> for super::JobOutput {
            type Error = String;
            fn try_from(value: JobOutput) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    path: value.path?,
                    size: value.size?,
                })
            }
        }

        impl From<super::JobOutput> for JobOutput {
            fn from(value: super::JobOutput) -> Self {
                Self {
                    id: Ok(value.id),
                    path: Ok(value.path),
                    size: Ok(value.size),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct JobOutputPublish {
            name: Result<String, String>,
            series: Result<String, String>,
            version: Result<String, String>,
        }

        impl Default for JobOutputPublish {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    series: Err("no value supplied for series".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl JobOutputPublish {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn series<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.series = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for series: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<JobOutputPublish> for super::JobOutputPublish {
            type Error = String;
            fn try_from(value: JobOutputPublish) -> Result<Self, String> {
                Ok(Self {
                    name: value.name?,
                    series: value.series?,
                    version: value.version?,
                })
            }
        }

        impl From<super::JobOutputPublish> for JobOutputPublish {
            fn from(value: super::JobOutputPublish) -> Self {
                Self {
                    name: Ok(value.name),
                    series: Ok(value.series),
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct JobOutputSignedUrl {
            content_disposition: Result<Option<String>, String>,
            content_type: Result<Option<String>, String>,
            expiry_seconds: Result<u64, String>,
        }

        impl Default for JobOutputSignedUrl {
            fn default() -> Self {
                Self {
                    content_disposition: Ok(Default::default()),
                    content_type: Ok(Default::default()),
                    expiry_seconds: Err("no value supplied for expiry_seconds".to_string()),
                }
            }
        }

        impl JobOutputSignedUrl {
            pub fn content_disposition<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.content_disposition = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for content_disposition: {}",
                        e
                    )
                });
                self
            }
            pub fn content_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.content_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for content_type: {}", e)
                });
                self
            }
            pub fn expiry_seconds<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.expiry_seconds = value.try_into().map_err(|e| {
                    format!("error converting supplied value for expiry_seconds: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<JobOutputSignedUrl> for super::JobOutputSignedUrl {
            type Error = String;
            fn try_from(value: JobOutputSignedUrl) -> Result<Self, String> {
                Ok(Self {
                    content_disposition: value.content_disposition?,
                    content_type: value.content_type?,
                    expiry_seconds: value.expiry_seconds?,
                })
            }
        }

        impl From<super::JobOutputSignedUrl> for JobOutputSignedUrl {
            fn from(value: super::JobOutputSignedUrl) -> Self {
                Self {
                    content_disposition: Ok(value.content_disposition),
                    content_type: Ok(value.content_type),
                    expiry_seconds: Ok(value.expiry_seconds),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct JobOutputSignedUrlResult {
            url: Result<String, String>,
        }

        impl Default for JobOutputSignedUrlResult {
            fn default() -> Self {
                Self {
                    url: Err("no value supplied for url".to_string()),
                }
            }
        }

        impl JobOutputSignedUrlResult {
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<JobOutputSignedUrlResult> for super::JobOutputSignedUrlResult {
            type Error = String;
            fn try_from(value: JobOutputSignedUrlResult) -> Result<Self, String> {
                Ok(Self { url: value.url? })
            }
        }

        impl From<super::JobOutputSignedUrlResult> for JobOutputSignedUrlResult {
            fn from(value: super::JobOutputSignedUrlResult) -> Self {
                Self { url: Ok(value.url) }
            }
        }

        #[derive(Clone, Debug)]
        pub struct JobStoreValue {
            secret: Result<bool, String>,
            value: Result<String, String>,
        }

        impl Default for JobStoreValue {
            fn default() -> Self {
                Self {
                    secret: Err("no value supplied for secret".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }

        impl JobStoreValue {
            pub fn secret<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.secret = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for secret: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<JobStoreValue> for super::JobStoreValue {
            type Error = String;
            fn try_from(value: JobStoreValue) -> Result<Self, String> {
                Ok(Self {
                    secret: value.secret?,
                    value: value.value?,
                })
            }
        }

        impl From<super::JobStoreValue> for JobStoreValue {
            fn from(value: super::JobStoreValue) -> Self {
                Self {
                    secret: Ok(value.secret),
                    value: Ok(value.value),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct JobStoreValueInfo {
            secret: Result<bool, String>,
            source: Result<String, String>,
            time_update: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            value: Result<Option<String>, String>,
        }

        impl Default for JobStoreValueInfo {
            fn default() -> Self {
                Self {
                    secret: Err("no value supplied for secret".to_string()),
                    source: Err("no value supplied for source".to_string()),
                    time_update: Err("no value supplied for time_update".to_string()),
                    value: Ok(Default::default()),
                }
            }
        }

        impl JobStoreValueInfo {
            pub fn secret<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.secret = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for secret: {}", e));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {}", e));
                self
            }
            pub fn time_update<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_update = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for time_update: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<JobStoreValueInfo> for super::JobStoreValueInfo {
            type Error = String;
            fn try_from(value: JobStoreValueInfo) -> Result<Self, String> {
                Ok(Self {
                    secret: value.secret?,
                    source: value.source?,
                    time_update: value.time_update?,
                    value: value.value?,
                })
            }
        }

        impl From<super::JobStoreValueInfo> for JobStoreValueInfo {
            fn from(value: super::JobStoreValueInfo) -> Self {
                Self {
                    secret: Ok(value.secret),
                    source: Ok(value.source),
                    time_update: Ok(value.time_update),
                    value: Ok(value.value),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct JobSubmit {
            depends: Result<std::collections::HashMap<String, super::DependSubmit>, String>,
            inputs: Result<Vec<String>, String>,
            name: Result<String, String>,
            output_rules: Result<Vec<String>, String>,
            tags: Result<std::collections::HashMap<String, String>, String>,
            target: Result<String, String>,
            tasks: Result<Vec<super::TaskSubmit>, String>,
        }

        impl Default for JobSubmit {
            fn default() -> Self {
                Self {
                    depends: Ok(Default::default()),
                    inputs: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    output_rules: Err("no value supplied for output_rules".to_string()),
                    tags: Ok(Default::default()),
                    target: Err("no value supplied for target".to_string()),
                    tasks: Err("no value supplied for tasks".to_string()),
                }
            }
        }

        impl JobSubmit {
            pub fn depends<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::collections::HashMap<String, super::DependSubmit>>,
                T::Error: std::fmt::Display,
            {
                self.depends = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for depends: {}", e));
                self
            }
            pub fn inputs<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.inputs = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for inputs: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn output_rules<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.output_rules = value.try_into().map_err(|e| {
                    format!("error converting supplied value for output_rules: {}", e)
                });
                self
            }
            pub fn tags<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::collections::HashMap<String, String>>,
                T::Error: std::fmt::Display,
            {
                self.tags = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tags: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
            pub fn tasks<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::TaskSubmit>>,
                T::Error: std::fmt::Display,
            {
                self.tasks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tasks: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<JobSubmit> for super::JobSubmit {
            type Error = String;
            fn try_from(value: JobSubmit) -> Result<Self, String> {
                Ok(Self {
                    depends: value.depends?,
                    inputs: value.inputs?,
                    name: value.name?,
                    output_rules: value.output_rules?,
                    tags: value.tags?,
                    target: value.target?,
                    tasks: value.tasks?,
                })
            }
        }

        impl From<super::JobSubmit> for JobSubmit {
            fn from(value: super::JobSubmit) -> Self {
                Self {
                    depends: Ok(value.depends),
                    inputs: Ok(value.inputs),
                    name: Ok(value.name),
                    output_rules: Ok(value.output_rules),
                    tags: Ok(value.tags),
                    target: Ok(value.target),
                    tasks: Ok(value.tasks),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct JobSubmitResult {
            id: Result<String, String>,
        }

        impl Default for JobSubmitResult {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                }
            }
        }

        impl JobSubmitResult {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<JobSubmitResult> for super::JobSubmitResult {
            type Error = String;
            fn try_from(value: JobSubmitResult) -> Result<Self, String> {
                Ok(Self { id: value.id? })
            }
        }

        impl From<super::JobSubmitResult> for JobSubmitResult {
            fn from(value: super::JobSubmitResult) -> Self {
                Self { id: Ok(value.id) }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Quota {
            max_bytes_per_input: Result<u64, String>,
        }

        impl Default for Quota {
            fn default() -> Self {
                Self {
                    max_bytes_per_input: Err(
                        "no value supplied for max_bytes_per_input".to_string()
                    ),
                }
            }
        }

        impl Quota {
            pub fn max_bytes_per_input<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.max_bytes_per_input = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for max_bytes_per_input: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<Quota> for super::Quota {
            type Error = String;
            fn try_from(value: Quota) -> Result<Self, String> {
                Ok(Self {
                    max_bytes_per_input: value.max_bytes_per_input?,
                })
            }
        }

        impl From<super::Quota> for Quota {
            fn from(value: super::Quota) -> Self {
                Self {
                    max_bytes_per_input: Ok(value.max_bytes_per_input),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Target {
            desc: Result<String, String>,
            id: Result<String, String>,
            name: Result<String, String>,
            privilege: Result<Option<String>, String>,
            redirect: Result<Option<String>, String>,
        }

        impl Default for Target {
            fn default() -> Self {
                Self {
                    desc: Err("no value supplied for desc".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    privilege: Ok(Default::default()),
                    redirect: Ok(Default::default()),
                }
            }
        }

        impl Target {
            pub fn desc<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.desc = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for desc: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn privilege<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.privilege = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for privilege: {}", e));
                self
            }
            pub fn redirect<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.redirect = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for redirect: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Target> for super::Target {
            type Error = String;
            fn try_from(value: Target) -> Result<Self, String> {
                Ok(Self {
                    desc: value.desc?,
                    id: value.id?,
                    name: value.name?,
                    privilege: value.privilege?,
                    redirect: value.redirect?,
                })
            }
        }

        impl From<super::Target> for Target {
            fn from(value: super::Target) -> Self {
                Self {
                    desc: Ok(value.desc),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    privilege: Ok(value.privilege),
                    redirect: Ok(value.redirect),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TargetCreate {
            desc: Result<String, String>,
            name: Result<String, String>,
        }

        impl Default for TargetCreate {
            fn default() -> Self {
                Self {
                    desc: Err("no value supplied for desc".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl TargetCreate {
            pub fn desc<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.desc = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for desc: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<TargetCreate> for super::TargetCreate {
            type Error = String;
            fn try_from(value: TargetCreate) -> Result<Self, String> {
                Ok(Self {
                    desc: value.desc?,
                    name: value.name?,
                })
            }
        }

        impl From<super::TargetCreate> for TargetCreate {
            fn from(value: super::TargetCreate) -> Self {
                Self {
                    desc: Ok(value.desc),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TargetCreateResult {
            id: Result<String, String>,
        }

        impl Default for TargetCreateResult {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                }
            }
        }

        impl TargetCreateResult {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<TargetCreateResult> for super::TargetCreateResult {
            type Error = String;
            fn try_from(value: TargetCreateResult) -> Result<Self, String> {
                Ok(Self { id: value.id? })
            }
        }

        impl From<super::TargetCreateResult> for TargetCreateResult {
            fn from(value: super::TargetCreateResult) -> Self {
                Self { id: Ok(value.id) }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TargetRedirect {
            redirect: Result<Option<String>, String>,
        }

        impl Default for TargetRedirect {
            fn default() -> Self {
                Self {
                    redirect: Ok(Default::default()),
                }
            }
        }

        impl TargetRedirect {
            pub fn redirect<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.redirect = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for redirect: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<TargetRedirect> for super::TargetRedirect {
            type Error = String;
            fn try_from(value: TargetRedirect) -> Result<Self, String> {
                Ok(Self {
                    redirect: value.redirect?,
                })
            }
        }

        impl From<super::TargetRedirect> for TargetRedirect {
            fn from(value: super::TargetRedirect) -> Self {
                Self {
                    redirect: Ok(value.redirect),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TargetRename {
            new_name: Result<String, String>,
            signpost_description: Result<String, String>,
        }

        impl Default for TargetRename {
            fn default() -> Self {
                Self {
                    new_name: Err("no value supplied for new_name".to_string()),
                    signpost_description: Err(
                        "no value supplied for signpost_description".to_string()
                    ),
                }
            }
        }

        impl TargetRename {
            pub fn new_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.new_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for new_name: {}", e));
                self
            }
            pub fn signpost_description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.signpost_description = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for signpost_description: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<TargetRename> for super::TargetRename {
            type Error = String;
            fn try_from(value: TargetRename) -> Result<Self, String> {
                Ok(Self {
                    new_name: value.new_name?,
                    signpost_description: value.signpost_description?,
                })
            }
        }

        impl From<super::TargetRename> for TargetRename {
            fn from(value: super::TargetRename) -> Self {
                Self {
                    new_name: Ok(value.new_name),
                    signpost_description: Ok(value.signpost_description),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Task {
            env: Result<std::collections::HashMap<String, String>, String>,
            env_clear: Result<bool, String>,
            gid: Result<Option<u32>, String>,
            name: Result<String, String>,
            script: Result<String, String>,
            state: Result<String, String>,
            uid: Result<Option<u32>, String>,
            workdir: Result<Option<String>, String>,
        }

        impl Default for Task {
            fn default() -> Self {
                Self {
                    env: Err("no value supplied for env".to_string()),
                    env_clear: Err("no value supplied for env_clear".to_string()),
                    gid: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    script: Err("no value supplied for script".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    uid: Ok(Default::default()),
                    workdir: Ok(Default::default()),
                }
            }
        }

        impl Task {
            pub fn env<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::collections::HashMap<String, String>>,
                T::Error: std::fmt::Display,
            {
                self.env = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for env: {}", e));
                self
            }
            pub fn env_clear<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.env_clear = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for env_clear: {}", e));
                self
            }
            pub fn gid<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<u32>>,
                T::Error: std::fmt::Display,
            {
                self.gid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gid: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn script<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.script = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for script: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn uid<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<u32>>,
                T::Error: std::fmt::Display,
            {
                self.uid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uid: {}", e));
                self
            }
            pub fn workdir<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.workdir = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for workdir: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Task> for super::Task {
            type Error = String;
            fn try_from(value: Task) -> Result<Self, String> {
                Ok(Self {
                    env: value.env?,
                    env_clear: value.env_clear?,
                    gid: value.gid?,
                    name: value.name?,
                    script: value.script?,
                    state: value.state?,
                    uid: value.uid?,
                    workdir: value.workdir?,
                })
            }
        }

        impl From<super::Task> for Task {
            fn from(value: super::Task) -> Self {
                Self {
                    env: Ok(value.env),
                    env_clear: Ok(value.env_clear),
                    gid: Ok(value.gid),
                    name: Ok(value.name),
                    script: Ok(value.script),
                    state: Ok(value.state),
                    uid: Ok(value.uid),
                    workdir: Ok(value.workdir),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TaskSubmit {
            env: Result<std::collections::HashMap<String, String>, String>,
            env_clear: Result<bool, String>,
            gid: Result<Option<u32>, String>,
            name: Result<String, String>,
            script: Result<String, String>,
            uid: Result<Option<u32>, String>,
            workdir: Result<Option<String>, String>,
        }

        impl Default for TaskSubmit {
            fn default() -> Self {
                Self {
                    env: Err("no value supplied for env".to_string()),
                    env_clear: Err("no value supplied for env_clear".to_string()),
                    gid: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    script: Err("no value supplied for script".to_string()),
                    uid: Ok(Default::default()),
                    workdir: Ok(Default::default()),
                }
            }
        }

        impl TaskSubmit {
            pub fn env<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::collections::HashMap<String, String>>,
                T::Error: std::fmt::Display,
            {
                self.env = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for env: {}", e));
                self
            }
            pub fn env_clear<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.env_clear = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for env_clear: {}", e));
                self
            }
            pub fn gid<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<u32>>,
                T::Error: std::fmt::Display,
            {
                self.gid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gid: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn script<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.script = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for script: {}", e));
                self
            }
            pub fn uid<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<u32>>,
                T::Error: std::fmt::Display,
            {
                self.uid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uid: {}", e));
                self
            }
            pub fn workdir<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.workdir = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for workdir: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<TaskSubmit> for super::TaskSubmit {
            type Error = String;
            fn try_from(value: TaskSubmit) -> Result<Self, String> {
                Ok(Self {
                    env: value.env?,
                    env_clear: value.env_clear?,
                    gid: value.gid?,
                    name: value.name?,
                    script: value.script?,
                    uid: value.uid?,
                    workdir: value.workdir?,
                })
            }
        }

        impl From<super::TaskSubmit> for TaskSubmit {
            fn from(value: super::TaskSubmit) -> Self {
                Self {
                    env: Ok(value.env),
                    env_clear: Ok(value.env_clear),
                    gid: Ok(value.gid),
                    name: Ok(value.name),
                    script: Ok(value.script),
                    uid: Ok(value.uid),
                    workdir: Ok(value.workdir),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UploadedChunk {
            id: Result<String, String>,
        }

        impl Default for UploadedChunk {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                }
            }
        }

        impl UploadedChunk {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UploadedChunk> for super::UploadedChunk {
            type Error = String;
            fn try_from(value: UploadedChunk) -> Result<Self, String> {
                Ok(Self { id: value.id? })
            }
        }

        impl From<super::UploadedChunk> for UploadedChunk {
            fn from(value: super::UploadedChunk) -> Self {
                Self { id: Ok(value.id) }
            }
        }

        #[derive(Clone, Debug)]
        pub struct User {
            id: Result<String, String>,
            name: Result<String, String>,
            privileges: Result<Vec<String>, String>,
            time_create: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for User {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    privileges: Err("no value supplied for privileges".to_string()),
                    time_create: Err("no value supplied for time_create".to_string()),
                }
            }
        }

        impl User {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn privileges<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.privileges = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for privileges: {}", e));
                self
            }
            pub fn time_create<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_create = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for time_create: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<User> for super::User {
            type Error = String;
            fn try_from(value: User) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    name: value.name?,
                    privileges: value.privileges?,
                    time_create: value.time_create?,
                })
            }
        }

        impl From<super::User> for User {
            fn from(value: super::User) -> Self {
                Self {
                    id: Ok(value.id),
                    name: Ok(value.name),
                    privileges: Ok(value.privileges),
                    time_create: Ok(value.time_create),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UserCreate {
            name: Result<String, String>,
        }

        impl Default for UserCreate {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl UserCreate {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UserCreate> for super::UserCreate {
            type Error = String;
            fn try_from(value: UserCreate) -> Result<Self, String> {
                Ok(Self { name: value.name? })
            }
        }

        impl From<super::UserCreate> for UserCreate {
            fn from(value: super::UserCreate) -> Self {
                Self {
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UserCreateResult {
            id: Result<String, String>,
            name: Result<String, String>,
            token: Result<String, String>,
        }

        impl Default for UserCreateResult {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }

        impl UserCreateResult {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UserCreateResult> for super::UserCreateResult {
            type Error = String;
            fn try_from(value: UserCreateResult) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    name: value.name?,
                    token: value.token?,
                })
            }
        }

        impl From<super::UserCreateResult> for UserCreateResult {
            fn from(value: super::UserCreateResult) -> Self {
                Self {
                    id: Ok(value.id),
                    name: Ok(value.name),
                    token: Ok(value.token),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WhoamiResult {
            id: Result<String, String>,
            name: Result<String, String>,
        }

        impl Default for WhoamiResult {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl WhoamiResult {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WhoamiResult> for super::WhoamiResult {
            type Error = String;
            fn try_from(value: WhoamiResult) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    name: value.name?,
                })
            }
        }

        impl From<super::WhoamiResult> for WhoamiResult {
            fn from(value: super::WhoamiResult) -> Self {
                Self {
                    id: Ok(value.id),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Worker {
            bootstrap: Result<bool, String>,
            deleted: Result<bool, String>,
            factory: Result<String, String>,
            factory_private: Result<Option<String>, String>,
            id: Result<String, String>,
            jobs: Result<Vec<super::WorkerJob>, String>,
            lastping: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
            recycle: Result<bool, String>,
            target: Result<String, String>,
        }

        impl Default for Worker {
            fn default() -> Self {
                Self {
                    bootstrap: Err("no value supplied for bootstrap".to_string()),
                    deleted: Err("no value supplied for deleted".to_string()),
                    factory: Err("no value supplied for factory".to_string()),
                    factory_private: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jobs: Err("no value supplied for jobs".to_string()),
                    lastping: Ok(Default::default()),
                    recycle: Err("no value supplied for recycle".to_string()),
                    target: Err("no value supplied for target".to_string()),
                }
            }
        }

        impl Worker {
            pub fn bootstrap<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.bootstrap = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bootstrap: {}", e));
                self
            }
            pub fn deleted<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.deleted = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for deleted: {}", e));
                self
            }
            pub fn factory<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.factory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for factory: {}", e));
                self
            }
            pub fn factory_private<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.factory_private = value.try_into().map_err(|e| {
                    format!("error converting supplied value for factory_private: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn jobs<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::WorkerJob>>,
                T::Error: std::fmt::Display,
            {
                self.jobs = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for jobs: {}", e));
                self
            }
            pub fn lastping<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<chrono::DateTime<chrono::offset::Utc>>>,
                T::Error: std::fmt::Display,
            {
                self.lastping = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for lastping: {}", e));
                self
            }
            pub fn recycle<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.recycle = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for recycle: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Worker> for super::Worker {
            type Error = String;
            fn try_from(value: Worker) -> Result<Self, String> {
                Ok(Self {
                    bootstrap: value.bootstrap?,
                    deleted: value.deleted?,
                    factory: value.factory?,
                    factory_private: value.factory_private?,
                    id: value.id?,
                    jobs: value.jobs?,
                    lastping: value.lastping?,
                    recycle: value.recycle?,
                    target: value.target?,
                })
            }
        }

        impl From<super::Worker> for Worker {
            fn from(value: super::Worker) -> Self {
                Self {
                    bootstrap: Ok(value.bootstrap),
                    deleted: Ok(value.deleted),
                    factory: Ok(value.factory),
                    factory_private: Ok(value.factory_private),
                    id: Ok(value.id),
                    jobs: Ok(value.jobs),
                    lastping: Ok(value.lastping),
                    recycle: Ok(value.recycle),
                    target: Ok(value.target),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerAddOutput {
            chunks: Result<Vec<String>, String>,
            commit_id: Result<String, String>,
            path: Result<String, String>,
            size: Result<u64, String>,
        }

        impl Default for WorkerAddOutput {
            fn default() -> Self {
                Self {
                    chunks: Err("no value supplied for chunks".to_string()),
                    commit_id: Err("no value supplied for commit_id".to_string()),
                    path: Err("no value supplied for path".to_string()),
                    size: Err("no value supplied for size".to_string()),
                }
            }
        }

        impl WorkerAddOutput {
            pub fn chunks<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<String>>,
                T::Error: std::fmt::Display,
            {
                self.chunks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chunks: {}", e));
                self
            }
            pub fn commit_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.commit_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for commit_id: {}", e));
                self
            }
            pub fn path<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for path: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerAddOutput> for super::WorkerAddOutput {
            type Error = String;
            fn try_from(value: WorkerAddOutput) -> Result<Self, String> {
                Ok(Self {
                    chunks: value.chunks?,
                    commit_id: value.commit_id?,
                    path: value.path?,
                    size: value.size?,
                })
            }
        }

        impl From<super::WorkerAddOutput> for WorkerAddOutput {
            fn from(value: super::WorkerAddOutput) -> Self {
                Self {
                    chunks: Ok(value.chunks),
                    commit_id: Ok(value.commit_id),
                    path: Ok(value.path),
                    size: Ok(value.size),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerAddOutputResult {
            complete: Result<bool, String>,
            error: Result<Option<String>, String>,
        }

        impl Default for WorkerAddOutputResult {
            fn default() -> Self {
                Self {
                    complete: Err("no value supplied for complete".to_string()),
                    error: Ok(Default::default()),
                }
            }
        }

        impl WorkerAddOutputResult {
            pub fn complete<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.complete = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for complete: {}", e));
                self
            }
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerAddOutputResult> for super::WorkerAddOutputResult {
            type Error = String;
            fn try_from(value: WorkerAddOutputResult) -> Result<Self, String> {
                Ok(Self {
                    complete: value.complete?,
                    error: value.error?,
                })
            }
        }

        impl From<super::WorkerAddOutputResult> for WorkerAddOutputResult {
            fn from(value: super::WorkerAddOutputResult) -> Self {
                Self {
                    complete: Ok(value.complete),
                    error: Ok(value.error),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerAppendJob {
            payload: Result<String, String>,
            stream: Result<String, String>,
            time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for WorkerAppendJob {
            fn default() -> Self {
                Self {
                    payload: Err("no value supplied for payload".to_string()),
                    stream: Err("no value supplied for stream".to_string()),
                    time: Err("no value supplied for time".to_string()),
                }
            }
        }

        impl WorkerAppendJob {
            pub fn payload<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.payload = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for payload: {}", e));
                self
            }
            pub fn stream<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.stream = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for stream: {}", e));
                self
            }
            pub fn time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for time: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerAppendJob> for super::WorkerAppendJob {
            type Error = String;
            fn try_from(value: WorkerAppendJob) -> Result<Self, String> {
                Ok(Self {
                    payload: value.payload?,
                    stream: value.stream?,
                    time: value.time?,
                })
            }
        }

        impl From<super::WorkerAppendJob> for WorkerAppendJob {
            fn from(value: super::WorkerAppendJob) -> Self {
                Self {
                    payload: Ok(value.payload),
                    stream: Ok(value.stream),
                    time: Ok(value.time),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerAppendJobOrTask {
            payload: Result<String, String>,
            stream: Result<String, String>,
            task: Result<Option<u32>, String>,
            time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for WorkerAppendJobOrTask {
            fn default() -> Self {
                Self {
                    payload: Err("no value supplied for payload".to_string()),
                    stream: Err("no value supplied for stream".to_string()),
                    task: Ok(Default::default()),
                    time: Err("no value supplied for time".to_string()),
                }
            }
        }

        impl WorkerAppendJobOrTask {
            pub fn payload<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.payload = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for payload: {}", e));
                self
            }
            pub fn stream<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.stream = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for stream: {}", e));
                self
            }
            pub fn task<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<u32>>,
                T::Error: std::fmt::Display,
            {
                self.task = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for task: {}", e));
                self
            }
            pub fn time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for time: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerAppendJobOrTask> for super::WorkerAppendJobOrTask {
            type Error = String;
            fn try_from(value: WorkerAppendJobOrTask) -> Result<Self, String> {
                Ok(Self {
                    payload: value.payload?,
                    stream: value.stream?,
                    task: value.task?,
                    time: value.time?,
                })
            }
        }

        impl From<super::WorkerAppendJobOrTask> for WorkerAppendJobOrTask {
            fn from(value: super::WorkerAppendJobOrTask) -> Self {
                Self {
                    payload: Ok(value.payload),
                    stream: Ok(value.stream),
                    task: Ok(value.task),
                    time: Ok(value.time),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerBootstrap {
            bootstrap: Result<String, String>,
            token: Result<String, String>,
        }

        impl Default for WorkerBootstrap {
            fn default() -> Self {
                Self {
                    bootstrap: Err("no value supplied for bootstrap".to_string()),
                    token: Err("no value supplied for token".to_string()),
                }
            }
        }

        impl WorkerBootstrap {
            pub fn bootstrap<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.bootstrap = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bootstrap: {}", e));
                self
            }
            pub fn token<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.token = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for token: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerBootstrap> for super::WorkerBootstrap {
            type Error = String;
            fn try_from(value: WorkerBootstrap) -> Result<Self, String> {
                Ok(Self {
                    bootstrap: value.bootstrap?,
                    token: value.token?,
                })
            }
        }

        impl From<super::WorkerBootstrap> for WorkerBootstrap {
            fn from(value: super::WorkerBootstrap) -> Self {
                Self {
                    bootstrap: Ok(value.bootstrap),
                    token: Ok(value.token),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerBootstrapResult {
            id: Result<String, String>,
        }

        impl Default for WorkerBootstrapResult {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                }
            }
        }

        impl WorkerBootstrapResult {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerBootstrapResult> for super::WorkerBootstrapResult {
            type Error = String;
            fn try_from(value: WorkerBootstrapResult) -> Result<Self, String> {
                Ok(Self { id: value.id? })
            }
        }

        impl From<super::WorkerBootstrapResult> for WorkerBootstrapResult {
            fn from(value: super::WorkerBootstrapResult) -> Self {
                Self { id: Ok(value.id) }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerCompleteJob {
            failed: Result<bool, String>,
        }

        impl Default for WorkerCompleteJob {
            fn default() -> Self {
                Self {
                    failed: Err("no value supplied for failed".to_string()),
                }
            }
        }

        impl WorkerCompleteJob {
            pub fn failed<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.failed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for failed: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerCompleteJob> for super::WorkerCompleteJob {
            type Error = String;
            fn try_from(value: WorkerCompleteJob) -> Result<Self, String> {
                Ok(Self {
                    failed: value.failed?,
                })
            }
        }

        impl From<super::WorkerCompleteJob> for WorkerCompleteJob {
            fn from(value: super::WorkerCompleteJob) -> Self {
                Self {
                    failed: Ok(value.failed),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerCompleteTask {
            failed: Result<bool, String>,
        }

        impl Default for WorkerCompleteTask {
            fn default() -> Self {
                Self {
                    failed: Err("no value supplied for failed".to_string()),
                }
            }
        }

        impl WorkerCompleteTask {
            pub fn failed<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.failed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for failed: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerCompleteTask> for super::WorkerCompleteTask {
            type Error = String;
            fn try_from(value: WorkerCompleteTask) -> Result<Self, String> {
                Ok(Self {
                    failed: value.failed?,
                })
            }
        }

        impl From<super::WorkerCompleteTask> for WorkerCompleteTask {
            fn from(value: super::WorkerCompleteTask) -> Self {
                Self {
                    failed: Ok(value.failed),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerJob {
            id: Result<String, String>,
            name: Result<String, String>,
            owner: Result<String, String>,
            state: Result<String, String>,
            tags: Result<std::collections::HashMap<String, String>, String>,
        }

        impl Default for WorkerJob {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    owner: Err("no value supplied for owner".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    tags: Err("no value supplied for tags".to_string()),
                }
            }
        }

        impl WorkerJob {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owner: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn tags<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::collections::HashMap<String, String>>,
                T::Error: std::fmt::Display,
            {
                self.tags = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tags: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerJob> for super::WorkerJob {
            type Error = String;
            fn try_from(value: WorkerJob) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    name: value.name?,
                    owner: value.owner?,
                    state: value.state?,
                    tags: value.tags?,
                })
            }
        }

        impl From<super::WorkerJob> for WorkerJob {
            fn from(value: super::WorkerJob) -> Self {
                Self {
                    id: Ok(value.id),
                    name: Ok(value.name),
                    owner: Ok(value.owner),
                    state: Ok(value.state),
                    tags: Ok(value.tags),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerJobQuota {
            max_bytes_per_output: Result<u64, String>,
        }

        impl Default for WorkerJobQuota {
            fn default() -> Self {
                Self {
                    max_bytes_per_output: Err(
                        "no value supplied for max_bytes_per_output".to_string()
                    ),
                }
            }
        }

        impl WorkerJobQuota {
            pub fn max_bytes_per_output<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.max_bytes_per_output = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for max_bytes_per_output: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<WorkerJobQuota> for super::WorkerJobQuota {
            type Error = String;
            fn try_from(value: WorkerJobQuota) -> Result<Self, String> {
                Ok(Self {
                    max_bytes_per_output: value.max_bytes_per_output?,
                })
            }
        }

        impl From<super::WorkerJobQuota> for WorkerJobQuota {
            fn from(value: super::WorkerJobQuota) -> Self {
                Self {
                    max_bytes_per_output: Ok(value.max_bytes_per_output),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerJobStoreGet {
            value: Result<Option<super::WorkerJobStoreValue>, String>,
        }

        impl Default for WorkerJobStoreGet {
            fn default() -> Self {
                Self {
                    value: Ok(Default::default()),
                }
            }
        }

        impl WorkerJobStoreGet {
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::WorkerJobStoreValue>>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerJobStoreGet> for super::WorkerJobStoreGet {
            type Error = String;
            fn try_from(value: WorkerJobStoreGet) -> Result<Self, String> {
                Ok(Self {
                    value: value.value?,
                })
            }
        }

        impl From<super::WorkerJobStoreGet> for WorkerJobStoreGet {
            fn from(value: super::WorkerJobStoreGet) -> Self {
                Self {
                    value: Ok(value.value),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerJobStoreValue {
            secret: Result<bool, String>,
            value: Result<String, String>,
        }

        impl Default for WorkerJobStoreValue {
            fn default() -> Self {
                Self {
                    secret: Err("no value supplied for secret".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }

        impl WorkerJobStoreValue {
            pub fn secret<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.secret = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for secret: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerJobStoreValue> for super::WorkerJobStoreValue {
            type Error = String;
            fn try_from(value: WorkerJobStoreValue) -> Result<Self, String> {
                Ok(Self {
                    secret: value.secret?,
                    value: value.value?,
                })
            }
        }

        impl From<super::WorkerJobStoreValue> for WorkerJobStoreValue {
            fn from(value: super::WorkerJobStoreValue) -> Self {
                Self {
                    secret: Ok(value.secret),
                    value: Ok(value.value),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerPingInput {
            id: Result<String, String>,
            name: Result<String, String>,
        }

        impl Default for WorkerPingInput {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl WorkerPingInput {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerPingInput> for super::WorkerPingInput {
            type Error = String;
            fn try_from(value: WorkerPingInput) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    name: value.name?,
                })
            }
        }

        impl From<super::WorkerPingInput> for WorkerPingInput {
            fn from(value: super::WorkerPingInput) -> Self {
                Self {
                    id: Ok(value.id),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerPingJob {
            id: Result<String, String>,
            inputs: Result<Vec<super::WorkerPingInput>, String>,
            name: Result<String, String>,
            output_rules: Result<Vec<super::WorkerPingOutputRule>, String>,
            tasks: Result<Vec<super::WorkerPingTask>, String>,
        }

        impl Default for WorkerPingJob {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    inputs: Err("no value supplied for inputs".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    output_rules: Err("no value supplied for output_rules".to_string()),
                    tasks: Err("no value supplied for tasks".to_string()),
                }
            }
        }

        impl WorkerPingJob {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn inputs<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::WorkerPingInput>>,
                T::Error: std::fmt::Display,
            {
                self.inputs = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for inputs: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn output_rules<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::WorkerPingOutputRule>>,
                T::Error: std::fmt::Display,
            {
                self.output_rules = value.try_into().map_err(|e| {
                    format!("error converting supplied value for output_rules: {}", e)
                });
                self
            }
            pub fn tasks<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::WorkerPingTask>>,
                T::Error: std::fmt::Display,
            {
                self.tasks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tasks: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerPingJob> for super::WorkerPingJob {
            type Error = String;
            fn try_from(value: WorkerPingJob) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    inputs: value.inputs?,
                    name: value.name?,
                    output_rules: value.output_rules?,
                    tasks: value.tasks?,
                })
            }
        }

        impl From<super::WorkerPingJob> for WorkerPingJob {
            fn from(value: super::WorkerPingJob) -> Self {
                Self {
                    id: Ok(value.id),
                    inputs: Ok(value.inputs),
                    name: Ok(value.name),
                    output_rules: Ok(value.output_rules),
                    tasks: Ok(value.tasks),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerPingOutputRule {
            ignore: Result<bool, String>,
            require_match: Result<bool, String>,
            rule: Result<String, String>,
            size_change_ok: Result<bool, String>,
        }

        impl Default for WorkerPingOutputRule {
            fn default() -> Self {
                Self {
                    ignore: Err("no value supplied for ignore".to_string()),
                    require_match: Err("no value supplied for require_match".to_string()),
                    rule: Err("no value supplied for rule".to_string()),
                    size_change_ok: Err("no value supplied for size_change_ok".to_string()),
                }
            }
        }

        impl WorkerPingOutputRule {
            pub fn ignore<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.ignore = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ignore: {}", e));
                self
            }
            pub fn require_match<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.require_match = value.try_into().map_err(|e| {
                    format!("error converting supplied value for require_match: {}", e)
                });
                self
            }
            pub fn rule<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.rule = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rule: {}", e));
                self
            }
            pub fn size_change_ok<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.size_change_ok = value.try_into().map_err(|e| {
                    format!("error converting supplied value for size_change_ok: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<WorkerPingOutputRule> for super::WorkerPingOutputRule {
            type Error = String;
            fn try_from(value: WorkerPingOutputRule) -> Result<Self, String> {
                Ok(Self {
                    ignore: value.ignore?,
                    require_match: value.require_match?,
                    rule: value.rule?,
                    size_change_ok: value.size_change_ok?,
                })
            }
        }

        impl From<super::WorkerPingOutputRule> for WorkerPingOutputRule {
            fn from(value: super::WorkerPingOutputRule) -> Self {
                Self {
                    ignore: Ok(value.ignore),
                    require_match: Ok(value.require_match),
                    rule: Ok(value.rule),
                    size_change_ok: Ok(value.size_change_ok),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerPingResult {
            factory_metadata: Result<Option<super::FactoryMetadata>, String>,
            job: Result<Option<super::WorkerPingJob>, String>,
            poweroff: Result<bool, String>,
        }

        impl Default for WorkerPingResult {
            fn default() -> Self {
                Self {
                    factory_metadata: Ok(Default::default()),
                    job: Ok(Default::default()),
                    poweroff: Err("no value supplied for poweroff".to_string()),
                }
            }
        }

        impl WorkerPingResult {
            pub fn factory_metadata<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::FactoryMetadata>>,
                T::Error: std::fmt::Display,
            {
                self.factory_metadata = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for factory_metadata: {}",
                        e
                    )
                });
                self
            }
            pub fn job<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::WorkerPingJob>>,
                T::Error: std::fmt::Display,
            {
                self.job = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for job: {}", e));
                self
            }
            pub fn poweroff<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.poweroff = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for poweroff: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerPingResult> for super::WorkerPingResult {
            type Error = String;
            fn try_from(value: WorkerPingResult) -> Result<Self, String> {
                Ok(Self {
                    factory_metadata: value.factory_metadata?,
                    job: value.job?,
                    poweroff: value.poweroff?,
                })
            }
        }

        impl From<super::WorkerPingResult> for WorkerPingResult {
            fn from(value: super::WorkerPingResult) -> Self {
                Self {
                    factory_metadata: Ok(value.factory_metadata),
                    job: Ok(value.job),
                    poweroff: Ok(value.poweroff),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkerPingTask {
            env: Result<std::collections::HashMap<String, String>, String>,
            env_clear: Result<bool, String>,
            gid: Result<u32, String>,
            id: Result<u32, String>,
            name: Result<String, String>,
            script: Result<String, String>,
            uid: Result<u32, String>,
            workdir: Result<String, String>,
        }

        impl Default for WorkerPingTask {
            fn default() -> Self {
                Self {
                    env: Err("no value supplied for env".to_string()),
                    env_clear: Err("no value supplied for env_clear".to_string()),
                    gid: Err("no value supplied for gid".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    script: Err("no value supplied for script".to_string()),
                    uid: Err("no value supplied for uid".to_string()),
                    workdir: Err("no value supplied for workdir".to_string()),
                }
            }
        }

        impl WorkerPingTask {
            pub fn env<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::collections::HashMap<String, String>>,
                T::Error: std::fmt::Display,
            {
                self.env = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for env: {}", e));
                self
            }
            pub fn env_clear<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.env_clear = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for env_clear: {}", e));
                self
            }
            pub fn gid<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u32>,
                T::Error: std::fmt::Display,
            {
                self.gid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gid: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u32>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn script<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.script = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for script: {}", e));
                self
            }
            pub fn uid<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u32>,
                T::Error: std::fmt::Display,
            {
                self.uid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for uid: {}", e));
                self
            }
            pub fn workdir<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.workdir = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for workdir: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkerPingTask> for super::WorkerPingTask {
            type Error = String;
            fn try_from(value: WorkerPingTask) -> Result<Self, String> {
                Ok(Self {
                    env: value.env?,
                    env_clear: value.env_clear?,
                    gid: value.gid?,
                    id: value.id?,
                    name: value.name?,
                    script: value.script?,
                    uid: value.uid?,
                    workdir: value.workdir?,
                })
            }
        }

        impl From<super::WorkerPingTask> for WorkerPingTask {
            fn from(value: super::WorkerPingTask) -> Self {
                Self {
                    env: Ok(value.env),
                    env_clear: Ok(value.env_clear),
                    gid: Ok(value.gid),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    script: Ok(value.script),
                    uid: Ok(value.uid),
                    workdir: Ok(value.workdir),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WorkersResult {
            workers: Result<Vec<super::Worker>, String>,
        }

        impl Default for WorkersResult {
            fn default() -> Self {
                Self {
                    workers: Err("no value supplied for workers".to_string()),
                }
            }
        }

        impl WorkersResult {
            pub fn workers<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Worker>>,
                T::Error: std::fmt::Display,
            {
                self.workers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for workers: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<WorkersResult> for super::WorkersResult {
            type Error = String;
            fn try_from(value: WorkersResult) -> Result<Self, String> {
                Ok(Self {
                    workers: value.workers?,
                })
            }
        }

        impl From<super::WorkersResult> for WorkersResult {
            fn from(value: super::WorkersResult) -> Self {
                Self {
                    workers: Ok(value.workers),
                }
            }
        }
    }
}

#[derive(Clone, Debug)]
///Client for Buildomat
///
///Version: 1.0
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }

    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }

    /// Get the base URL to which requests are made.
    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }

    /// Get the internal `reqwest::Client` used to make requests.
    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }

    /// Get the version of this API.
    ///
    /// This string is pulled directly from the source OpenAPI
    /// document and may be in any format the API selects.
    pub fn api_version(&self) -> &'static str {
        "1.0"
    }
}

impl Client {
    ///Sends a `POST` request to `/0/admin/factory`
    ///
    ///```ignore
    /// let response = client.factory_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn factory_create(&self) -> builder::FactoryCreate {
        builder::FactoryCreate::new(self)
    }

    ///Sends a `GET` request to `/0/admin/jobs`
    ///
    ///```ignore
    /// let response = client.admin_jobs_get()
    ///    .active(active)
    ///    .completed(completed)
    ///    .send()
    ///    .await;
    /// ```
    pub fn admin_jobs_get(&self) -> builder::AdminJobsGet {
        builder::AdminJobsGet::new(self)
    }

    ///Sends a `GET` request to `/0/admin/jobs/{job}`
    ///
    ///```ignore
    /// let response = client.admin_job_get()
    ///    .job(job)
    ///    .send()
    ///    .await;
    /// ```
    pub fn admin_job_get(&self) -> builder::AdminJobGet {
        builder::AdminJobGet::new(self)
    }

    ///Sends a `POST` request to `/0/admin/jobs/{job}/archive`
    ///
    ///```ignore
    /// let response = client.admin_job_archive_request()
    ///    .job(job)
    ///    .send()
    ///    .await;
    /// ```
    pub fn admin_job_archive_request(&self) -> builder::AdminJobArchiveRequest {
        builder::AdminJobArchiveRequest::new(self)
    }

    ///Sends a `POST` request to `/0/admin/target`
    ///
    ///```ignore
    /// let response = client.target_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn target_create(&self) -> builder::TargetCreate {
        builder::TargetCreate::new(self)
    }

    ///Sends a `GET` request to `/0/admin/targets`
    ///
    ///```ignore
    /// let response = client.targets_list()
    ///    .send()
    ///    .await;
    /// ```
    pub fn targets_list(&self) -> builder::TargetsList {
        builder::TargetsList::new(self)
    }

    ///Sends a `PUT` request to `/0/admin/targets/{target}/redirect`
    ///
    ///```ignore
    /// let response = client.target_redirect()
    ///    .target(target)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn target_redirect(&self) -> builder::TargetRedirect {
        builder::TargetRedirect::new(self)
    }

    ///Sends a `POST` request to `/0/admin/targets/{target}/rename`
    ///
    ///```ignore
    /// let response = client.target_rename()
    ///    .target(target)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn target_rename(&self) -> builder::TargetRename {
        builder::TargetRename::new(self)
    }

    ///Sends a `DELETE` request to `/0/admin/targets/{target}/require`
    ///
    ///```ignore
    /// let response = client.target_require_no_privilege()
    ///    .target(target)
    ///    .send()
    ///    .await;
    /// ```
    pub fn target_require_no_privilege(&self) -> builder::TargetRequireNoPrivilege {
        builder::TargetRequireNoPrivilege::new(self)
    }

    ///Sends a `PUT` request to `/0/admin/targets/{target}/require/{privilege}`
    ///
    ///```ignore
    /// let response = client.target_require_privilege()
    ///    .target(target)
    ///    .privilege(privilege)
    ///    .send()
    ///    .await;
    /// ```
    pub fn target_require_privilege(&self) -> builder::TargetRequirePrivilege {
        builder::TargetRequirePrivilege::new(self)
    }

    ///Sends a `POST` request to `/0/admin/worker/{worker}/recycle`
    ///
    ///```ignore
    /// let response = client.worker_recycle()
    ///    .worker(worker)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_recycle(&self) -> builder::WorkerRecycle {
        builder::WorkerRecycle::new(self)
    }

    ///Sends a `POST` request to `/0/control/hold`
    ///
    ///```ignore
    /// let response = client.control_hold()
    ///    .send()
    ///    .await;
    /// ```
    pub fn control_hold(&self) -> builder::ControlHold {
        builder::ControlHold::new(self)
    }

    ///Sends a `POST` request to `/0/control/resume`
    ///
    ///```ignore
    /// let response = client.control_resume()
    ///    .send()
    ///    .await;
    /// ```
    pub fn control_resume(&self) -> builder::ControlResume {
        builder::ControlResume::new(self)
    }

    ///Sends a `POST` request to `/0/factory/lease`
    ///
    ///```ignore
    /// let response = client.factory_lease()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn factory_lease(&self) -> builder::FactoryLease {
        builder::FactoryLease::new(self)
    }

    ///Sends a `POST` request to `/0/factory/lease/{job}`
    ///
    ///```ignore
    /// let response = client.factory_lease_renew()
    ///    .job(job)
    ///    .send()
    ///    .await;
    /// ```
    pub fn factory_lease_renew(&self) -> builder::FactoryLeaseRenew {
        builder::FactoryLeaseRenew::new(self)
    }

    ///Sends a `GET` request to `/0/factory/ping`
    ///
    ///```ignore
    /// let response = client.factory_ping()
    ///    .send()
    ///    .await;
    /// ```
    pub fn factory_ping(&self) -> builder::FactoryPing {
        builder::FactoryPing::new(self)
    }

    ///Sends a `POST` request to `/0/factory/worker`
    ///
    ///```ignore
    /// let response = client.factory_worker_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn factory_worker_create(&self) -> builder::FactoryWorkerCreate {
        builder::FactoryWorkerCreate::new(self)
    }

    ///Sends a `GET` request to `/0/factory/worker/{worker}`
    ///
    ///```ignore
    /// let response = client.factory_worker_get()
    ///    .worker(worker)
    ///    .send()
    ///    .await;
    /// ```
    pub fn factory_worker_get(&self) -> builder::FactoryWorkerGet {
        builder::FactoryWorkerGet::new(self)
    }

    ///Sends a `DELETE` request to `/0/factory/worker/{worker}`
    ///
    ///```ignore
    /// let response = client.factory_worker_destroy()
    ///    .worker(worker)
    ///    .send()
    ///    .await;
    /// ```
    pub fn factory_worker_destroy(&self) -> builder::FactoryWorkerDestroy {
        builder::FactoryWorkerDestroy::new(self)
    }

    ///Sends a `PATCH` request to `/0/factory/worker/{worker}`
    ///
    ///```ignore
    /// let response = client.factory_worker_associate()
    ///    .worker(worker)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn factory_worker_associate(&self) -> builder::FactoryWorkerAssociate {
        builder::FactoryWorkerAssociate::new(self)
    }

    ///Sends a `POST` request to `/0/factory/worker/{worker}/append`
    ///
    ///```ignore
    /// let response = client.factory_worker_append()
    ///    .worker(worker)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn factory_worker_append(&self) -> builder::FactoryWorkerAppend {
        builder::FactoryWorkerAppend::new(self)
    }

    ///Sends a `POST` request to `/0/factory/worker/{worker}/flush`
    ///
    ///```ignore
    /// let response = client.factory_worker_flush()
    ///    .worker(worker)
    ///    .send()
    ///    .await;
    /// ```
    pub fn factory_worker_flush(&self) -> builder::FactoryWorkerFlush {
        builder::FactoryWorkerFlush::new(self)
    }

    ///Sends a `GET` request to `/0/factory/workers`
    ///
    ///```ignore
    /// let response = client.factory_workers()
    ///    .send()
    ///    .await;
    /// ```
    pub fn factory_workers(&self) -> builder::FactoryWorkers {
        builder::FactoryWorkers::new(self)
    }

    ///Sends a `GET` request to `/0/job/{job}`
    ///
    ///```ignore
    /// let response = client.job_get()
    ///    .job(job)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_get(&self) -> builder::JobGet {
        builder::JobGet::new(self)
    }

    ///Sends a `GET` request to `/0/jobs`
    ///
    ///```ignore
    /// let response = client.jobs_get()
    ///    .send()
    ///    .await;
    /// ```
    pub fn jobs_get(&self) -> builder::JobsGet {
        builder::JobsGet::new(self)
    }

    ///Sends a `POST` request to `/0/jobs`
    ///
    ///```ignore
    /// let response = client.job_submit()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_submit(&self) -> builder::JobSubmit {
        builder::JobSubmit::new(self)
    }

    ///Sends a `POST` request to `/0/jobs/{job}/cancel`
    ///
    ///```ignore
    /// let response = client.job_cancel()
    ///    .job(job)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_cancel(&self) -> builder::JobCancel {
        builder::JobCancel::new(self)
    }

    ///Sends a `POST` request to `/0/jobs/{job}/chunk`
    ///
    ///```ignore
    /// let response = client.job_upload_chunk()
    ///    .job(job)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_upload_chunk(&self) -> builder::JobUploadChunk {
        builder::JobUploadChunk::new(self)
    }

    ///Sends a `GET` request to `/0/jobs/{job}/events`
    ///
    ///```ignore
    /// let response = client.job_events_get()
    ///    .job(job)
    ///    .minseq(minseq)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_events_get(&self) -> builder::JobEventsGet {
        builder::JobEventsGet::new(self)
    }

    ///Sends a `GET` request to `/0/jobs/{job}/outputs`
    ///
    ///```ignore
    /// let response = client.job_outputs_get()
    ///    .job(job)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_outputs_get(&self) -> builder::JobOutputsGet {
        builder::JobOutputsGet::new(self)
    }

    ///Sends a `GET` request to `/0/jobs/{job}/outputs/{output}`
    ///
    ///```ignore
    /// let response = client.job_output_download()
    ///    .job(job)
    ///    .output(output)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_output_download(&self) -> builder::JobOutputDownload {
        builder::JobOutputDownload::new(self)
    }

    ///Sends a `POST` request to `/0/jobs/{job}/outputs/{output}/publish`
    ///
    ///```ignore
    /// let response = client.job_output_publish()
    ///    .job(job)
    ///    .output(output)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_output_publish(&self) -> builder::JobOutputPublish {
        builder::JobOutputPublish::new(self)
    }

    ///Sends a `POST` request to `/0/jobs/{job}/outputs/{output}/sign`
    ///
    ///```ignore
    /// let response = client.job_output_signed_url()
    ///    .job(job)
    ///    .output(output)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_output_signed_url(&self) -> builder::JobOutputSignedUrl {
        builder::JobOutputSignedUrl::new(self)
    }

    ///Sends a `GET` request to `/0/jobs/{job}/store`
    ///
    ///```ignore
    /// let response = client.job_store_get_all()
    ///    .job(job)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_store_get_all(&self) -> builder::JobStoreGetAll {
        builder::JobStoreGetAll::new(self)
    }

    ///Sends a `PUT` request to `/0/jobs/{job}/store/{name}`
    ///
    ///```ignore
    /// let response = client.job_store_put()
    ///    .job(job)
    ///    .name(name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_store_put(&self) -> builder::JobStorePut {
        builder::JobStorePut::new(self)
    }

    ///Sends a `GET` request to
    /// `/0/public/file/{username}/{series}/{version}/{name}`
    ///
    ///```ignore
    /// let response = client.public_file_download()
    ///    .username(username)
    ///    .series(series)
    ///    .version(version)
    ///    .name(name)
    ///    .send()
    ///    .await;
    /// ```
    pub fn public_file_download(&self) -> builder::PublicFileDownload {
        builder::PublicFileDownload::new(self)
    }

    ///Sends a `GET` request to `/0/quota`
    ///
    ///```ignore
    /// let response = client.quota()
    ///    .send()
    ///    .await;
    /// ```
    pub fn quota(&self) -> builder::Quota {
        builder::Quota::new(self)
    }

    ///Sends a `GET` request to `/0/users`
    ///
    ///```ignore
    /// let response = client.users_list()
    ///    .name(name)
    ///    .send()
    ///    .await;
    /// ```
    pub fn users_list(&self) -> builder::UsersList {
        builder::UsersList::new(self)
    }

    ///Sends a `POST` request to `/0/users`
    ///
    ///```ignore
    /// let response = client.user_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn user_create(&self) -> builder::UserCreate {
        builder::UserCreate::new(self)
    }

    ///Sends a `GET` request to `/0/users/{user}`
    ///
    ///```ignore
    /// let response = client.user_get()
    ///    .user(user)
    ///    .send()
    ///    .await;
    /// ```
    pub fn user_get(&self) -> builder::UserGet {
        builder::UserGet::new(self)
    }

    ///Sends a `PUT` request to `/0/users/{user}/privilege/{privilege}`
    ///
    ///```ignore
    /// let response = client.user_privilege_grant()
    ///    .user(user)
    ///    .privilege(privilege)
    ///    .send()
    ///    .await;
    /// ```
    pub fn user_privilege_grant(&self) -> builder::UserPrivilegeGrant {
        builder::UserPrivilegeGrant::new(self)
    }

    ///Sends a `DELETE` request to `/0/users/{user}/privilege/{privilege}`
    ///
    ///```ignore
    /// let response = client.user_privilege_revoke()
    ///    .user(user)
    ///    .privilege(privilege)
    ///    .send()
    ///    .await;
    /// ```
    pub fn user_privilege_revoke(&self) -> builder::UserPrivilegeRevoke {
        builder::UserPrivilegeRevoke::new(self)
    }

    ///Sends a `GET` request to `/0/whoami`
    ///
    ///```ignore
    /// let response = client.whoami()
    ///    .send()
    ///    .await;
    /// ```
    pub fn whoami(&self) -> builder::Whoami {
        builder::Whoami::new(self)
    }

    ///Sends a `POST` request to `/0/worker/bootstrap`
    ///
    ///```ignore
    /// let response = client.worker_bootstrap()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_bootstrap(&self) -> builder::WorkerBootstrap {
        builder::WorkerBootstrap::new(self)
    }

    ///Sends a `POST` request to `/0/worker/job/{job}/chunk`
    ///
    ///```ignore
    /// let response = client.worker_job_upload_chunk()
    ///    .job(job)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_job_upload_chunk(&self) -> builder::WorkerJobUploadChunk {
        builder::WorkerJobUploadChunk::new(self)
    }

    ///Sends a `POST` request to `/0/worker/job/{job}/complete`
    ///
    ///```ignore
    /// let response = client.worker_job_complete()
    ///    .job(job)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_job_complete(&self) -> builder::WorkerJobComplete {
        builder::WorkerJobComplete::new(self)
    }

    ///Sends a `GET` request to `/0/worker/job/{job}/inputs/{input}`
    ///
    ///```ignore
    /// let response = client.worker_job_input_download()
    ///    .job(job)
    ///    .input(input)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_job_input_download(&self) -> builder::WorkerJobInputDownload {
        builder::WorkerJobInputDownload::new(self)
    }

    ///Sends a `GET` request to `/0/worker/job/{job}/quota`
    ///
    ///```ignore
    /// let response = client.worker_job_quota()
    ///    .job(job)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_job_quota(&self) -> builder::WorkerJobQuota {
        builder::WorkerJobQuota::new(self)
    }

    ///Sends a `GET` request to `/0/worker/job/{job}/store/{name}`
    ///
    ///```ignore
    /// let response = client.worker_job_store_get()
    ///    .job(job)
    ///    .name(name)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_job_store_get(&self) -> builder::WorkerJobStoreGet {
        builder::WorkerJobStoreGet::new(self)
    }

    ///Sends a `PUT` request to `/0/worker/job/{job}/store/{name}`
    ///
    ///```ignore
    /// let response = client.worker_job_store_put()
    ///    .job(job)
    ///    .name(name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_job_store_put(&self) -> builder::WorkerJobStorePut {
        builder::WorkerJobStorePut::new(self)
    }

    ///Sends a `POST` request to `/0/worker/job/{job}/task/{task}/append`
    ///
    ///```ignore
    /// let response = client.worker_task_append()
    ///    .job(job)
    ///    .task(task)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_task_append(&self) -> builder::WorkerTaskAppend {
        builder::WorkerTaskAppend::new(self)
    }

    ///Sends a `POST` request to `/0/worker/job/{job}/task/{task}/complete`
    ///
    ///```ignore
    /// let response = client.worker_task_complete()
    ///    .job(job)
    ///    .task(task)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_task_complete(&self) -> builder::WorkerTaskComplete {
        builder::WorkerTaskComplete::new(self)
    }

    ///Sends a `GET` request to `/0/worker/ping`
    ///
    ///```ignore
    /// let response = client.worker_ping()
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_ping(&self) -> builder::WorkerPing {
        builder::WorkerPing::new(self)
    }

    ///Sends a `GET` request to `/0/workers`
    ///
    ///```ignore
    /// let response = client.workers_list()
    ///    .active(active)
    ///    .send()
    ///    .await;
    /// ```
    pub fn workers_list(&self) -> builder::WorkersList {
        builder::WorkersList::new(self)
    }

    ///Sends a `POST` request to `/0/workers/recycle`
    ///
    ///```ignore
    /// let response = client.workers_recycle()
    ///    .send()
    ///    .await;
    /// ```
    pub fn workers_recycle(&self) -> builder::WorkersRecycle {
        builder::WorkersRecycle::new(self)
    }

    ///Sends a `POST` request to `/1/jobs/{job}/input`
    ///
    ///```ignore
    /// let response = client.job_add_input()
    ///    .job(job)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn job_add_input(&self) -> builder::JobAddInput {
        builder::JobAddInput::new(self)
    }

    ///Sends a `POST` request to `/1/worker/job/{job}/append`
    ///
    ///```ignore
    /// let response = client.worker_job_append()
    ///    .job(job)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_job_append(&self) -> builder::WorkerJobAppend {
        builder::WorkerJobAppend::new(self)
    }

    ///Sends a `POST` request to `/1/worker/job/{job}/output`
    ///
    ///```ignore
    /// let response = client.worker_job_add_output()
    ///    .job(job)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn worker_job_add_output(&self) -> builder::WorkerJobAddOutput {
        builder::WorkerJobAddOutput::new(self)
    }
}

pub mod builder {
    use super::types;
    #[allow(unused_imports)]
    use super::{
        encode_path, ByteStream, Error, HeaderMap, HeaderValue, RequestBuilderExt, ResponseValue,
    };
    ///Builder for [`Client::factory_create`]
    ///
    ///[`Client::factory_create`]: super::Client::factory_create
    #[derive(Debug, Clone)]
    pub struct FactoryCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::FactoryCreate, String>,
    }

    impl<'a> FactoryCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::FactoryCreate::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FactoryCreate>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `FactoryCreate` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::FactoryCreate) -> types::builder::FactoryCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/admin/factory`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FactoryCreateResult>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::FactoryCreate>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/0/admin/factory", client.baseurl,);
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::admin_jobs_get`]
    ///
    ///[`Client::admin_jobs_get`]: super::Client::admin_jobs_get
    #[derive(Debug, Clone)]
    pub struct AdminJobsGet<'a> {
        client: &'a super::Client,
        active: Result<Option<bool>, String>,
        completed: Result<Option<u64>, String>,
    }

    impl<'a> AdminJobsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                active: Ok(None),
                completed: Ok(None),
            }
        }

        pub fn active<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.active = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for active failed".to_string());
            self
        }

        pub fn completed<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.completed = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for completed failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/admin/jobs`
        pub async fn send(self) -> Result<ResponseValue<Vec<types::Job>>, Error<types::Error>> {
            let Self {
                client,
                active,
                completed,
            } = self;
            let active = active.map_err(Error::InvalidRequest)?;
            let completed = completed.map_err(Error::InvalidRequest)?;
            let url = format!("{}/0/admin/jobs", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &active {
                query.push(("active", v.to_string()));
            }
            if let Some(v) = &completed {
                query.push(("completed", v.to_string()));
            }
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::admin_job_get`]
    ///
    ///[`Client::admin_job_get`]: super::Client::admin_job_get
    #[derive(Debug, Clone)]
    pub struct AdminJobGet<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
    }

    impl<'a> AdminJobGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/admin/jobs/{job}`
        pub async fn send(self) -> Result<ResponseValue<types::Job>, Error<types::Error>> {
            let Self { client, job } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/admin/jobs/{}",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::admin_job_archive_request`]
    ///
    ///[`Client::admin_job_archive_request`]: super::Client::admin_job_archive_request
    #[derive(Debug, Clone)]
    pub struct AdminJobArchiveRequest<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
    }

    impl<'a> AdminJobArchiveRequest<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        ///Sends a `POST` request to `/0/admin/jobs/{job}/archive`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, job } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/admin/jobs/{}/archive",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::target_create`]
    ///
    ///[`Client::target_create`]: super::Client::target_create
    #[derive(Debug, Clone)]
    pub struct TargetCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TargetCreate, String>,
    }

    impl<'a> TargetCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::TargetCreate::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TargetCreate>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `TargetCreate` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::TargetCreate) -> types::builder::TargetCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/admin/target`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TargetCreateResult>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::TargetCreate>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/0/admin/target", client.baseurl,);
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::targets_list`]
    ///
    ///[`Client::targets_list`]: super::Client::targets_list
    #[derive(Debug, Clone)]
    pub struct TargetsList<'a> {
        client: &'a super::Client,
    }

    impl<'a> TargetsList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/0/admin/targets`
        pub async fn send(self) -> Result<ResponseValue<Vec<types::Target>>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/0/admin/targets", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::target_redirect`]
    ///
    ///[`Client::target_redirect`]: super::Client::target_redirect
    #[derive(Debug, Clone)]
    pub struct TargetRedirect<'a> {
        client: &'a super::Client,
        target: Result<String, String>,
        body: Result<types::builder::TargetRedirect, String>,
    }

    impl<'a> TargetRedirect<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                target: Err("target was not initialized".to_string()),
                body: Ok(types::builder::TargetRedirect::default()),
            }
        }

        pub fn target<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.target = value
                .try_into()
                .map_err(|_| "conversion to `String` for target failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TargetRedirect>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `TargetRedirect` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::TargetRedirect) -> types::builder::TargetRedirect,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/0/admin/targets/{target}/redirect`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                target,
                body,
            } = self;
            let target = target.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::TargetRedirect>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/admin/targets/{}/redirect",
                client.baseurl,
                encode_path(&target.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::target_rename`]
    ///
    ///[`Client::target_rename`]: super::Client::target_rename
    #[derive(Debug, Clone)]
    pub struct TargetRename<'a> {
        client: &'a super::Client,
        target: Result<String, String>,
        body: Result<types::builder::TargetRename, String>,
    }

    impl<'a> TargetRename<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                target: Err("target was not initialized".to_string()),
                body: Ok(types::builder::TargetRename::default()),
            }
        }

        pub fn target<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.target = value
                .try_into()
                .map_err(|_| "conversion to `String` for target failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TargetRename>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `TargetRename` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::TargetRename) -> types::builder::TargetRename,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/admin/targets/{target}/rename`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TargetCreateResult>, Error<types::Error>> {
            let Self {
                client,
                target,
                body,
            } = self;
            let target = target.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::TargetRename>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/admin/targets/{}/rename",
                client.baseurl,
                encode_path(&target.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::target_require_no_privilege`]
    ///
    ///[`Client::target_require_no_privilege`]: super::Client::target_require_no_privilege
    #[derive(Debug, Clone)]
    pub struct TargetRequireNoPrivilege<'a> {
        client: &'a super::Client,
        target: Result<String, String>,
    }

    impl<'a> TargetRequireNoPrivilege<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                target: Err("target was not initialized".to_string()),
            }
        }

        pub fn target<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.target = value
                .try_into()
                .map_err(|_| "conversion to `String` for target failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/0/admin/targets/{target}/require`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, target } = self;
            let target = target.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/admin/targets/{}/require",
                client.baseurl,
                encode_path(&target.to_string()),
            );
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::target_require_privilege`]
    ///
    ///[`Client::target_require_privilege`]: super::Client::target_require_privilege
    #[derive(Debug, Clone)]
    pub struct TargetRequirePrivilege<'a> {
        client: &'a super::Client,
        target: Result<String, String>,
        privilege: Result<String, String>,
    }

    impl<'a> TargetRequirePrivilege<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                target: Err("target was not initialized".to_string()),
                privilege: Err("privilege was not initialized".to_string()),
            }
        }

        pub fn target<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.target = value
                .try_into()
                .map_err(|_| "conversion to `String` for target failed".to_string());
            self
        }

        pub fn privilege<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.privilege = value
                .try_into()
                .map_err(|_| "conversion to `String` for privilege failed".to_string());
            self
        }

        ///Sends a `PUT` request to
        /// `/0/admin/targets/{target}/require/{privilege}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                target,
                privilege,
            } = self;
            let target = target.map_err(Error::InvalidRequest)?;
            let privilege = privilege.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/admin/targets/{}/require/{}",
                client.baseurl,
                encode_path(&target.to_string()),
                encode_path(&privilege.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_recycle`]
    ///
    ///[`Client::worker_recycle`]: super::Client::worker_recycle
    #[derive(Debug, Clone)]
    pub struct WorkerRecycle<'a> {
        client: &'a super::Client,
        worker: Result<String, String>,
    }

    impl<'a> WorkerRecycle<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                worker: Err("worker was not initialized".to_string()),
            }
        }

        pub fn worker<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.worker = value
                .try_into()
                .map_err(|_| "conversion to `String` for worker failed".to_string());
            self
        }

        ///Sends a `POST` request to `/0/admin/worker/{worker}/recycle`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, worker } = self;
            let worker = worker.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/admin/worker/{}/recycle",
                client.baseurl,
                encode_path(&worker.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::control_hold`]
    ///
    ///[`Client::control_hold`]: super::Client::control_hold
    #[derive(Debug, Clone)]
    pub struct ControlHold<'a> {
        client: &'a super::Client,
    }

    impl<'a> ControlHold<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `POST` request to `/0/control/hold`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/0/control/hold", client.baseurl,);
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::control_resume`]
    ///
    ///[`Client::control_resume`]: super::Client::control_resume
    #[derive(Debug, Clone)]
    pub struct ControlResume<'a> {
        client: &'a super::Client,
    }

    impl<'a> ControlResume<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `POST` request to `/0/control/resume`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/0/control/resume", client.baseurl,);
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::factory_lease`]
    ///
    ///[`Client::factory_lease`]: super::Client::factory_lease
    #[derive(Debug, Clone)]
    pub struct FactoryLease<'a> {
        client: &'a super::Client,
        body: Result<types::builder::FactoryWhatsNext, String>,
    }

    impl<'a> FactoryLease<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::FactoryWhatsNext::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FactoryWhatsNext>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `FactoryWhatsNext` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::FactoryWhatsNext,
            ) -> types::builder::FactoryWhatsNext,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/factory/lease`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FactoryLeaseResult>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::FactoryWhatsNext>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/0/factory/lease", client.baseurl,);
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::factory_lease_renew`]
    ///
    ///[`Client::factory_lease_renew`]: super::Client::factory_lease_renew
    #[derive(Debug, Clone)]
    pub struct FactoryLeaseRenew<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
    }

    impl<'a> FactoryLeaseRenew<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        ///Sends a `POST` request to `/0/factory/lease/{job}`
        pub async fn send(self) -> Result<ResponseValue<bool>, Error<types::Error>> {
            let Self { client, job } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/factory/lease/{}",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::factory_ping`]
    ///
    ///[`Client::factory_ping`]: super::Client::factory_ping
    #[derive(Debug, Clone)]
    pub struct FactoryPing<'a> {
        client: &'a super::Client,
    }

    impl<'a> FactoryPing<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/0/factory/ping`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FactoryPingResult>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/0/factory/ping", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::factory_worker_create`]
    ///
    ///[`Client::factory_worker_create`]: super::Client::factory_worker_create
    #[derive(Debug, Clone)]
    pub struct FactoryWorkerCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::FactoryWorkerCreate, String>,
    }

    impl<'a> FactoryWorkerCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::FactoryWorkerCreate::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FactoryWorkerCreate>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `FactoryWorkerCreate` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::FactoryWorkerCreate,
            ) -> types::builder::FactoryWorkerCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/factory/worker`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FactoryWorker>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::FactoryWorkerCreate>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/0/factory/worker", client.baseurl,);
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::factory_worker_get`]
    ///
    ///[`Client::factory_worker_get`]: super::Client::factory_worker_get
    #[derive(Debug, Clone)]
    pub struct FactoryWorkerGet<'a> {
        client: &'a super::Client,
        worker: Result<String, String>,
    }

    impl<'a> FactoryWorkerGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                worker: Err("worker was not initialized".to_string()),
            }
        }

        pub fn worker<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.worker = value
                .try_into()
                .map_err(|_| "conversion to `String` for worker failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/factory/worker/{worker}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FactoryWorkerResult>, Error<types::Error>> {
            let Self { client, worker } = self;
            let worker = worker.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/factory/worker/{}",
                client.baseurl,
                encode_path(&worker.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::factory_worker_destroy`]
    ///
    ///[`Client::factory_worker_destroy`]: super::Client::factory_worker_destroy
    #[derive(Debug, Clone)]
    pub struct FactoryWorkerDestroy<'a> {
        client: &'a super::Client,
        worker: Result<String, String>,
    }

    impl<'a> FactoryWorkerDestroy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                worker: Err("worker was not initialized".to_string()),
            }
        }

        pub fn worker<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.worker = value
                .try_into()
                .map_err(|_| "conversion to `String` for worker failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/0/factory/worker/{worker}`
        pub async fn send(self) -> Result<ResponseValue<bool>, Error<types::Error>> {
            let Self { client, worker } = self;
            let worker = worker.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/factory/worker/{}",
                client.baseurl,
                encode_path(&worker.to_string()),
            );
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::factory_worker_associate`]
    ///
    ///[`Client::factory_worker_associate`]: super::Client::factory_worker_associate
    #[derive(Debug, Clone)]
    pub struct FactoryWorkerAssociate<'a> {
        client: &'a super::Client,
        worker: Result<String, String>,
        body: Result<types::builder::FactoryWorkerAssociate, String>,
    }

    impl<'a> FactoryWorkerAssociate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                worker: Err("worker was not initialized".to_string()),
                body: Ok(types::builder::FactoryWorkerAssociate::default()),
            }
        }

        pub fn worker<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.worker = value
                .try_into()
                .map_err(|_| "conversion to `String` for worker failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FactoryWorkerAssociate>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `FactoryWorkerAssociate` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::FactoryWorkerAssociate,
            ) -> types::builder::FactoryWorkerAssociate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PATCH` request to `/0/factory/worker/{worker}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                worker,
                body,
            } = self;
            let worker = worker.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::FactoryWorkerAssociate>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/factory/worker/{}",
                client.baseurl,
                encode_path(&worker.to_string()),
            );
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::factory_worker_append`]
    ///
    ///[`Client::factory_worker_append`]: super::Client::factory_worker_append
    #[derive(Debug, Clone)]
    pub struct FactoryWorkerAppend<'a> {
        client: &'a super::Client,
        worker: Result<String, String>,
        body: Result<types::builder::FactoryWorkerAppend, String>,
    }

    impl<'a> FactoryWorkerAppend<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                worker: Err("worker was not initialized".to_string()),
                body: Ok(types::builder::FactoryWorkerAppend::default()),
            }
        }

        pub fn worker<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.worker = value
                .try_into()
                .map_err(|_| "conversion to `String` for worker failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FactoryWorkerAppend>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `FactoryWorkerAppend` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::FactoryWorkerAppend,
            ) -> types::builder::FactoryWorkerAppend,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/factory/worker/{worker}/append`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FactoryWorkerAppendResult>, Error<types::Error>> {
            let Self {
                client,
                worker,
                body,
            } = self;
            let worker = worker.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::FactoryWorkerAppend>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/factory/worker/{}/append",
                client.baseurl,
                encode_path(&worker.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::factory_worker_flush`]
    ///
    ///[`Client::factory_worker_flush`]: super::Client::factory_worker_flush
    #[derive(Debug, Clone)]
    pub struct FactoryWorkerFlush<'a> {
        client: &'a super::Client,
        worker: Result<String, String>,
    }

    impl<'a> FactoryWorkerFlush<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                worker: Err("worker was not initialized".to_string()),
            }
        }

        pub fn worker<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.worker = value
                .try_into()
                .map_err(|_| "conversion to `String` for worker failed".to_string());
            self
        }

        ///Sends a `POST` request to `/0/factory/worker/{worker}/flush`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, worker } = self;
            let worker = worker.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/factory/worker/{}/flush",
                client.baseurl,
                encode_path(&worker.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::factory_workers`]
    ///
    ///[`Client::factory_workers`]: super::Client::factory_workers
    #[derive(Debug, Clone)]
    pub struct FactoryWorkers<'a> {
        client: &'a super::Client,
    }

    impl<'a> FactoryWorkers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/0/factory/workers`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<Vec<types::FactoryWorker>>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/0/factory/workers", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::job_get`]
    ///
    ///[`Client::job_get`]: super::Client::job_get
    #[derive(Debug, Clone)]
    pub struct JobGet<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
    }

    impl<'a> JobGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/job/{job}`
        pub async fn send(self) -> Result<ResponseValue<types::Job>, Error<types::Error>> {
            let Self { client, job } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let url = format!("{}/0/job/{}", client.baseurl, encode_path(&job.to_string()),);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::jobs_get`]
    ///
    ///[`Client::jobs_get`]: super::Client::jobs_get
    #[derive(Debug, Clone)]
    pub struct JobsGet<'a> {
        client: &'a super::Client,
    }

    impl<'a> JobsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/0/jobs`
        pub async fn send(self) -> Result<ResponseValue<Vec<types::Job>>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/0/jobs", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::job_submit`]
    ///
    ///[`Client::job_submit`]: super::Client::job_submit
    #[derive(Debug, Clone)]
    pub struct JobSubmit<'a> {
        client: &'a super::Client,
        body: Result<types::builder::JobSubmit, String>,
    }

    impl<'a> JobSubmit<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::JobSubmit::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::JobSubmit>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `JobSubmit` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::JobSubmit) -> types::builder::JobSubmit,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/jobs`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::JobSubmitResult>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::JobSubmit>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/0/jobs", client.baseurl,);
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::job_cancel`]
    ///
    ///[`Client::job_cancel`]: super::Client::job_cancel
    #[derive(Debug, Clone)]
    pub struct JobCancel<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
    }

    impl<'a> JobCancel<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        ///Sends a `POST` request to `/0/jobs/{job}/cancel`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, job } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/jobs/{}/cancel",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::job_upload_chunk`]
    ///
    ///[`Client::job_upload_chunk`]: super::Client::job_upload_chunk
    #[derive(Debug)]
    pub struct JobUploadChunk<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        body: Result<reqwest::Body, String>,
    }

    impl<'a> JobUploadChunk<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn body<B>(mut self, value: B) -> Self
        where
            B: std::convert::TryInto<reqwest::Body>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `reqwest::Body` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/0/jobs/{job}/chunk`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UploadedChunk>, Error<types::Error>> {
            let Self { client, job, body } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/jobs/{}/chunk",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .header(
                    reqwest::header::CONTENT_TYPE,
                    reqwest::header::HeaderValue::from_static("application/octet-stream"),
                )
                .body(body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::job_events_get`]
    ///
    ///[`Client::job_events_get`]: super::Client::job_events_get
    #[derive(Debug, Clone)]
    pub struct JobEventsGet<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        minseq: Result<Option<u32>, String>,
    }

    impl<'a> JobEventsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                minseq: Ok(None),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn minseq<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u32>,
        {
            self.minseq = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u32` for minseq failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/jobs/{job}/events`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<Vec<types::JobEvent>>, Error<types::Error>> {
            let Self {
                client,
                job,
                minseq,
            } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let minseq = minseq.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/jobs/{}/events",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &minseq {
                query.push(("minseq", v.to_string()));
            }
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::job_outputs_get`]
    ///
    ///[`Client::job_outputs_get`]: super::Client::job_outputs_get
    #[derive(Debug, Clone)]
    pub struct JobOutputsGet<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
    }

    impl<'a> JobOutputsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/jobs/{job}/outputs`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<Vec<types::JobOutput>>, Error<types::Error>> {
            let Self { client, job } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/jobs/{}/outputs",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::job_output_download`]
    ///
    ///[`Client::job_output_download`]: super::Client::job_output_download
    #[derive(Debug, Clone)]
    pub struct JobOutputDownload<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        output: Result<String, String>,
    }

    impl<'a> JobOutputDownload<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                output: Err("output was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn output<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.output = value
                .try_into()
                .map_err(|_| "conversion to `String` for output failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/jobs/{job}/outputs/{output}`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self {
                client,
                job,
                output,
            } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let output = output.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/jobs/{}/outputs/{}",
                client.baseurl,
                encode_path(&job.to_string()),
                encode_path(&output.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    ///Builder for [`Client::job_output_publish`]
    ///
    ///[`Client::job_output_publish`]: super::Client::job_output_publish
    #[derive(Debug, Clone)]
    pub struct JobOutputPublish<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        output: Result<String, String>,
        body: Result<types::builder::JobOutputPublish, String>,
    }

    impl<'a> JobOutputPublish<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                output: Err("output was not initialized".to_string()),
                body: Ok(types::builder::JobOutputPublish::default()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn output<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.output = value
                .try_into()
                .map_err(|_| "conversion to `String` for output failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::JobOutputPublish>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `JobOutputPublish` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::JobOutputPublish,
            ) -> types::builder::JobOutputPublish,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/jobs/{job}/outputs/{output}/publish`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                job,
                output,
                body,
            } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let output = output.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::JobOutputPublish>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/jobs/{}/outputs/{}/publish",
                client.baseurl,
                encode_path(&job.to_string()),
                encode_path(&output.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::job_output_signed_url`]
    ///
    ///[`Client::job_output_signed_url`]: super::Client::job_output_signed_url
    #[derive(Debug, Clone)]
    pub struct JobOutputSignedUrl<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        output: Result<String, String>,
        body: Result<types::builder::JobOutputSignedUrl, String>,
    }

    impl<'a> JobOutputSignedUrl<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                output: Err("output was not initialized".to_string()),
                body: Ok(types::builder::JobOutputSignedUrl::default()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn output<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.output = value
                .try_into()
                .map_err(|_| "conversion to `String` for output failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::JobOutputSignedUrl>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `JobOutputSignedUrl` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::JobOutputSignedUrl,
            ) -> types::builder::JobOutputSignedUrl,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/jobs/{job}/outputs/{output}/sign`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::JobOutputSignedUrlResult>, Error<types::Error>> {
            let Self {
                client,
                job,
                output,
                body,
            } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let output = output.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::JobOutputSignedUrl>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/jobs/{}/outputs/{}/sign",
                client.baseurl,
                encode_path(&job.to_string()),
                encode_path(&output.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::job_store_get_all`]
    ///
    ///[`Client::job_store_get_all`]: super::Client::job_store_get_all
    #[derive(Debug, Clone)]
    pub struct JobStoreGetAll<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
    }

    impl<'a> JobStoreGetAll<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/jobs/{job}/store`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<std::collections::HashMap<String, types::JobStoreValueInfo>>,
            Error<types::Error>,
        > {
            let Self { client, job } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/jobs/{}/store",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::job_store_put`]
    ///
    ///[`Client::job_store_put`]: super::Client::job_store_put
    #[derive(Debug, Clone)]
    pub struct JobStorePut<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        name: Result<String, String>,
        body: Result<types::builder::JobStoreValue, String>,
    }

    impl<'a> JobStorePut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
                body: Ok(types::builder::JobStoreValue::default()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.name = value
                .try_into()
                .map_err(|_| "conversion to `String` for name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::JobStoreValue>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `JobStoreValue` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::JobStoreValue) -> types::builder::JobStoreValue,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/0/jobs/{job}/store/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                job,
                name,
                body,
            } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::JobStoreValue>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/jobs/{}/store/{}",
                client.baseurl,
                encode_path(&job.to_string()),
                encode_path(&name.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::public_file_download`]
    ///
    ///[`Client::public_file_download`]: super::Client::public_file_download
    #[derive(Debug, Clone)]
    pub struct PublicFileDownload<'a> {
        client: &'a super::Client,
        username: Result<String, String>,
        series: Result<String, String>,
        version: Result<String, String>,
        name: Result<String, String>,
    }

    impl<'a> PublicFileDownload<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                username: Err("username was not initialized".to_string()),
                series: Err("series was not initialized".to_string()),
                version: Err("version was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
            }
        }

        pub fn username<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.username = value
                .try_into()
                .map_err(|_| "conversion to `String` for username failed".to_string());
            self
        }

        pub fn series<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.series = value
                .try_into()
                .map_err(|_| "conversion to `String` for series failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.version = value
                .try_into()
                .map_err(|_| "conversion to `String` for version failed".to_string());
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.name = value
                .try_into()
                .map_err(|_| "conversion to `String` for name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/0/public/file/{username}/{series}/{version}/{name}`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self {
                client,
                username,
                series,
                version,
                name,
            } = self;
            let username = username.map_err(Error::InvalidRequest)?;
            let series = series.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/public/file/{}/{}/{}/{}",
                client.baseurl,
                encode_path(&username.to_string()),
                encode_path(&series.to_string()),
                encode_path(&version.to_string()),
                encode_path(&name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    ///Builder for [`Client::quota`]
    ///
    ///[`Client::quota`]: super::Client::quota
    #[derive(Debug, Clone)]
    pub struct Quota<'a> {
        client: &'a super::Client,
    }

    impl<'a> Quota<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/0/quota`
        pub async fn send(self) -> Result<ResponseValue<types::Quota>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/0/quota", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::users_list`]
    ///
    ///[`Client::users_list`]: super::Client::users_list
    #[derive(Debug, Clone)]
    pub struct UsersList<'a> {
        client: &'a super::Client,
        name: Result<Option<String>, String>,
    }

    impl<'a> UsersList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                name: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.name = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/users`
        pub async fn send(self) -> Result<ResponseValue<Vec<types::User>>, Error<types::Error>> {
            let Self { client, name } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let url = format!("{}/0/users", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &name {
                query.push(("name", v.to_string()));
            }
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::user_create`]
    ///
    ///[`Client::user_create`]: super::Client::user_create
    #[derive(Debug, Clone)]
    pub struct UserCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::UserCreate, String>,
    }

    impl<'a> UserCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::UserCreate::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UserCreate>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `UserCreate` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::UserCreate) -> types::builder::UserCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/users`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserCreateResult>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::UserCreate>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/0/users", client.baseurl,);
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::user_get`]
    ///
    ///[`Client::user_get`]: super::Client::user_get
    #[derive(Debug, Clone)]
    pub struct UserGet<'a> {
        client: &'a super::Client,
        user: Result<String, String>,
    }

    impl<'a> UserGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user: Err("user was not initialized".to_string()),
            }
        }

        pub fn user<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.user = value
                .try_into()
                .map_err(|_| "conversion to `String` for user failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/users/{user}`
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self { client, user } = self;
            let user = user.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/users/{}",
                client.baseurl,
                encode_path(&user.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::user_privilege_grant`]
    ///
    ///[`Client::user_privilege_grant`]: super::Client::user_privilege_grant
    #[derive(Debug, Clone)]
    pub struct UserPrivilegeGrant<'a> {
        client: &'a super::Client,
        user: Result<String, String>,
        privilege: Result<String, String>,
    }

    impl<'a> UserPrivilegeGrant<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user: Err("user was not initialized".to_string()),
                privilege: Err("privilege was not initialized".to_string()),
            }
        }

        pub fn user<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.user = value
                .try_into()
                .map_err(|_| "conversion to `String` for user failed".to_string());
            self
        }

        pub fn privilege<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.privilege = value
                .try_into()
                .map_err(|_| "conversion to `String` for privilege failed".to_string());
            self
        }

        ///Sends a `PUT` request to `/0/users/{user}/privilege/{privilege}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                user,
                privilege,
            } = self;
            let user = user.map_err(Error::InvalidRequest)?;
            let privilege = privilege.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/users/{}/privilege/{}",
                client.baseurl,
                encode_path(&user.to_string()),
                encode_path(&privilege.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::user_privilege_revoke`]
    ///
    ///[`Client::user_privilege_revoke`]: super::Client::user_privilege_revoke
    #[derive(Debug, Clone)]
    pub struct UserPrivilegeRevoke<'a> {
        client: &'a super::Client,
        user: Result<String, String>,
        privilege: Result<String, String>,
    }

    impl<'a> UserPrivilegeRevoke<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user: Err("user was not initialized".to_string()),
                privilege: Err("privilege was not initialized".to_string()),
            }
        }

        pub fn user<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.user = value
                .try_into()
                .map_err(|_| "conversion to `String` for user failed".to_string());
            self
        }

        pub fn privilege<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.privilege = value
                .try_into()
                .map_err(|_| "conversion to `String` for privilege failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/0/users/{user}/privilege/{privilege}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                user,
                privilege,
            } = self;
            let user = user.map_err(Error::InvalidRequest)?;
            let privilege = privilege.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/users/{}/privilege/{}",
                client.baseurl,
                encode_path(&user.to_string()),
                encode_path(&privilege.to_string()),
            );
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::whoami`]
    ///
    ///[`Client::whoami`]: super::Client::whoami
    #[derive(Debug, Clone)]
    pub struct Whoami<'a> {
        client: &'a super::Client,
    }

    impl<'a> Whoami<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/0/whoami`
        pub async fn send(self) -> Result<ResponseValue<types::WhoamiResult>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/0/whoami", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_bootstrap`]
    ///
    ///[`Client::worker_bootstrap`]: super::Client::worker_bootstrap
    #[derive(Debug, Clone)]
    pub struct WorkerBootstrap<'a> {
        client: &'a super::Client,
        body: Result<types::builder::WorkerBootstrap, String>,
    }

    impl<'a> WorkerBootstrap<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::WorkerBootstrap::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WorkerBootstrap>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `WorkerBootstrap` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::WorkerBootstrap) -> types::builder::WorkerBootstrap,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/worker/bootstrap`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WorkerBootstrapResult>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::WorkerBootstrap>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/0/worker/bootstrap", client.baseurl,);
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_job_upload_chunk`]
    ///
    ///[`Client::worker_job_upload_chunk`]: super::Client::worker_job_upload_chunk
    #[derive(Debug)]
    pub struct WorkerJobUploadChunk<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        body: Result<reqwest::Body, String>,
    }

    impl<'a> WorkerJobUploadChunk<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn body<B>(mut self, value: B) -> Self
        where
            B: std::convert::TryInto<reqwest::Body>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `reqwest::Body` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/0/worker/job/{job}/chunk`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UploadedChunk>, Error<types::Error>> {
            let Self { client, job, body } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/worker/job/{}/chunk",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .header(
                    reqwest::header::CONTENT_TYPE,
                    reqwest::header::HeaderValue::from_static("application/octet-stream"),
                )
                .body(body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_job_complete`]
    ///
    ///[`Client::worker_job_complete`]: super::Client::worker_job_complete
    #[derive(Debug, Clone)]
    pub struct WorkerJobComplete<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        body: Result<types::builder::WorkerCompleteJob, String>,
    }

    impl<'a> WorkerJobComplete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                body: Ok(types::builder::WorkerCompleteJob::default()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WorkerCompleteJob>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `WorkerCompleteJob` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::WorkerCompleteJob,
            ) -> types::builder::WorkerCompleteJob,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/worker/job/{job}/complete`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, job, body } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::WorkerCompleteJob>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/worker/job/{}/complete",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_job_input_download`]
    ///
    ///[`Client::worker_job_input_download`]: super::Client::worker_job_input_download
    #[derive(Debug, Clone)]
    pub struct WorkerJobInputDownload<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        input: Result<String, String>,
    }

    impl<'a> WorkerJobInputDownload<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                input: Err("input was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn input<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.input = value
                .try_into()
                .map_err(|_| "conversion to `String` for input failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/worker/job/{job}/inputs/{input}`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self { client, job, input } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let input = input.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/worker/job/{}/inputs/{}",
                client.baseurl,
                encode_path(&job.to_string()),
                encode_path(&input.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    ///Builder for [`Client::worker_job_quota`]
    ///
    ///[`Client::worker_job_quota`]: super::Client::worker_job_quota
    #[derive(Debug, Clone)]
    pub struct WorkerJobQuota<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
    }

    impl<'a> WorkerJobQuota<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/worker/job/{job}/quota`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WorkerJobQuota>, Error<types::Error>> {
            let Self { client, job } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/worker/job/{}/quota",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_job_store_get`]
    ///
    ///[`Client::worker_job_store_get`]: super::Client::worker_job_store_get
    #[derive(Debug, Clone)]
    pub struct WorkerJobStoreGet<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        name: Result<String, String>,
    }

    impl<'a> WorkerJobStoreGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.name = value
                .try_into()
                .map_err(|_| "conversion to `String` for name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/worker/job/{job}/store/{name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WorkerJobStoreGet>, Error<types::Error>> {
            let Self { client, job, name } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/worker/job/{}/store/{}",
                client.baseurl,
                encode_path(&job.to_string()),
                encode_path(&name.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_job_store_put`]
    ///
    ///[`Client::worker_job_store_put`]: super::Client::worker_job_store_put
    #[derive(Debug, Clone)]
    pub struct WorkerJobStorePut<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        name: Result<String, String>,
        body: Result<types::builder::WorkerJobStoreValue, String>,
    }

    impl<'a> WorkerJobStorePut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
                body: Ok(types::builder::WorkerJobStoreValue::default()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.name = value
                .try_into()
                .map_err(|_| "conversion to `String` for name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WorkerJobStoreValue>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `WorkerJobStoreValue` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::WorkerJobStoreValue,
            ) -> types::builder::WorkerJobStoreValue,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/0/worker/job/{job}/store/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                job,
                name,
                body,
            } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::WorkerJobStoreValue>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/worker/job/{}/store/{}",
                client.baseurl,
                encode_path(&job.to_string()),
                encode_path(&name.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_task_append`]
    ///
    ///[`Client::worker_task_append`]: super::Client::worker_task_append
    #[derive(Debug, Clone)]
    pub struct WorkerTaskAppend<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        task: Result<u32, String>,
        body: Result<types::builder::WorkerAppendJob, String>,
    }

    impl<'a> WorkerTaskAppend<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                task: Err("task was not initialized".to_string()),
                body: Ok(types::builder::WorkerAppendJob::default()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn task<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u32>,
        {
            self.task = value
                .try_into()
                .map_err(|_| "conversion to `u32` for task failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WorkerAppendJob>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `WorkerAppendJob` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::WorkerAppendJob) -> types::builder::WorkerAppendJob,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/worker/job/{job}/task/{task}/append`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                job,
                task,
                body,
            } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let task = task.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::WorkerAppendJob>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/worker/job/{}/task/{}/append",
                client.baseurl,
                encode_path(&job.to_string()),
                encode_path(&task.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_task_complete`]
    ///
    ///[`Client::worker_task_complete`]: super::Client::worker_task_complete
    #[derive(Debug, Clone)]
    pub struct WorkerTaskComplete<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        task: Result<u32, String>,
        body: Result<types::builder::WorkerCompleteTask, String>,
    }

    impl<'a> WorkerTaskComplete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                task: Err("task was not initialized".to_string()),
                body: Ok(types::builder::WorkerCompleteTask::default()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn task<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u32>,
        {
            self.task = value
                .try_into()
                .map_err(|_| "conversion to `u32` for task failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WorkerCompleteTask>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `WorkerCompleteTask` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::WorkerCompleteTask,
            ) -> types::builder::WorkerCompleteTask,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/0/worker/job/{job}/task/{task}/complete`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                job,
                task,
                body,
            } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let task = task.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::WorkerCompleteTask>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/0/worker/job/{}/task/{}/complete",
                client.baseurl,
                encode_path(&job.to_string()),
                encode_path(&task.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_ping`]
    ///
    ///[`Client::worker_ping`]: super::Client::worker_ping
    #[derive(Debug, Clone)]
    pub struct WorkerPing<'a> {
        client: &'a super::Client,
    }

    impl<'a> WorkerPing<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/0/worker/ping`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WorkerPingResult>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/0/worker/ping", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::workers_list`]
    ///
    ///[`Client::workers_list`]: super::Client::workers_list
    #[derive(Debug, Clone)]
    pub struct WorkersList<'a> {
        client: &'a super::Client,
        active: Result<Option<bool>, String>,
    }

    impl<'a> WorkersList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                active: Ok(None),
            }
        }

        pub fn active<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.active = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for active failed".to_string());
            self
        }

        ///Sends a `GET` request to `/0/workers`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WorkersResult>, Error<types::Error>> {
            let Self { client, active } = self;
            let active = active.map_err(Error::InvalidRequest)?;
            let url = format!("{}/0/workers", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &active {
                query.push(("active", v.to_string()));
            }
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::workers_recycle`]
    ///
    ///[`Client::workers_recycle`]: super::Client::workers_recycle
    #[derive(Debug, Clone)]
    pub struct WorkersRecycle<'a> {
        client: &'a super::Client,
    }

    impl<'a> WorkersRecycle<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `POST` request to `/0/workers/recycle`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/0/workers/recycle", client.baseurl,);
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::job_add_input`]
    ///
    ///[`Client::job_add_input`]: super::Client::job_add_input
    #[derive(Debug, Clone)]
    pub struct JobAddInput<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        body: Result<types::builder::JobAddInput, String>,
    }

    impl<'a> JobAddInput<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                body: Ok(types::builder::JobAddInput::default()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::JobAddInput>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `JobAddInput` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::JobAddInput) -> types::builder::JobAddInput,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/1/jobs/{job}/input`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::JobAddInputResult>, Error<types::Error>> {
            let Self { client, job, body } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::JobAddInput>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/1/jobs/{}/input",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_job_append`]
    ///
    ///[`Client::worker_job_append`]: super::Client::worker_job_append
    #[derive(Debug, Clone)]
    pub struct WorkerJobAppend<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        body: Result<Vec<types::WorkerAppendJobOrTask>, String>,
    }

    impl<'a> WorkerJobAppend<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<types::WorkerAppendJobOrTask>>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `Vec < WorkerAppendJobOrTask >` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/1/worker/job/{job}/append`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, job, body } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/1/worker/job/{}/append",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::worker_job_add_output`]
    ///
    ///[`Client::worker_job_add_output`]: super::Client::worker_job_add_output
    #[derive(Debug, Clone)]
    pub struct WorkerJobAddOutput<'a> {
        client: &'a super::Client,
        job: Result<String, String>,
        body: Result<types::builder::WorkerAddOutput, String>,
    }

    impl<'a> WorkerJobAddOutput<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                job: Err("job was not initialized".to_string()),
                body: Ok(types::builder::WorkerAddOutput::default()),
            }
        }

        pub fn job<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.job = value
                .try_into()
                .map_err(|_| "conversion to `String` for job failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WorkerAddOutput>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `WorkerAddOutput` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::WorkerAddOutput) -> types::builder::WorkerAddOutput,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/1/worker/job/{job}/output`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WorkerAddOutputResult>, Error<types::Error>> {
            let Self { client, job, body } = self;
            let job = job.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::WorkerAddOutput>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/1/worker/job/{}/output",
                client.baseurl,
                encode_path(&job.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}

pub mod prelude {
    pub use super::Client;
}
