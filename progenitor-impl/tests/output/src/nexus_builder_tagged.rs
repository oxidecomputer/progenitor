#[allow(unused_imports)]
use progenitor_client::{encode_path, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, Error, ResponseValue};
#[allow(unused_imports)]
use reqwest::header::{HeaderMap, HeaderValue};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    use serde::{Deserialize, Serialize};
    #[allow(unused_imports)]
    use std::convert::TryFrom;
    /// Error types.
    pub mod error {
        /// Error from a TryFrom or FromStr implementation.
        pub struct ConversionError(std::borrow::Cow<'static, str>);
        impl std::error::Error for ConversionError {}
        impl std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                std::fmt::Display::fmt(&self.0, f)
            }
        }

        impl std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                std::fmt::Debug::fmt(&self.0, f)
            }
        }

        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }

        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }

    ///Describes properties that should uniquely identify a Gimlet.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes properties that should uniquely identify a
    /// Gimlet.",
    ///  "type": "object",
    ///  "required": [
    ///    "part",
    ///    "revision",
    ///    "serial"
    ///  ],
    ///  "properties": {
    ///    "part": {
    ///      "type": "string"
    ///    },
    ///    "revision": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "serial": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Baseboard {
        pub part: String,
        pub revision: i64,
        pub serial: String,
    }

    impl From<&Baseboard> for Baseboard {
        fn from(value: &Baseboard) -> Self {
            value.clone()
        }
    }

    impl Baseboard {
        pub fn builder() -> builder::Baseboard {
            Default::default()
        }
    }

    ///A type storing a range over `T`.
    ///
    ///This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "start": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type")]
    pub enum BinRangedouble {
        ///A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: f64 },
        ///A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: f64, start: f64 },
        ///A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: f64 },
    }

    impl From<&BinRangedouble> for BinRangedouble {
        fn from(value: &BinRangedouble) -> Self {
            value.clone()
        }
    }

    ///A type storing a range over `T`.
    ///
    ///This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type")]
    pub enum BinRangeint64 {
        ///A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: i64 },
        ///A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: i64, start: i64 },
        ///A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: i64 },
    }

    impl From<&BinRangeint64> for BinRangeint64 {
        fn from(value: &BinRangeint64) -> Self {
            value.clone()
        }
    }

    ///Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangedouble"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Bindouble {
        ///The total count of samples in this bin.
        pub count: u64,
        ///The range of the support covered by this bin.
        pub range: BinRangedouble,
    }

    impl From<&Bindouble> for Bindouble {
        fn from(value: &Bindouble) -> Self {
            value.clone()
        }
    }

    impl Bindouble {
        pub fn builder() -> builder::Bindouble {
            Default::default()
        }
    }

    ///Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangeint64"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Binint64 {
        ///The total count of samples in this bin.
        pub count: u64,
        ///The range of the support covered by this bin.
        pub range: BinRangeint64,
    }

    impl From<&Binint64> for Binint64 {
        fn from(value: &Binint64) -> Self {
            value.clone()
        }
    }

    impl Binint64 {
        pub fn builder() -> builder::Binint64 {
            Default::default()
        }
    }

    ///BlockSize
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "disk block size in bytes",
    ///  "type": "integer",
    ///  "enum": [
    ///    512,
    ///    2048,
    ///    4096
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Serialize)]
    pub struct BlockSize(i64);
    impl std::ops::Deref for BlockSize {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<BlockSize> for i64 {
        fn from(value: BlockSize) -> Self {
            value.0
        }
    }

    impl From<&BlockSize> for BlockSize {
        fn from(value: &BlockSize) -> Self {
            value.clone()
        }
    }

    impl std::convert::TryFrom<i64> for BlockSize {
        type Error = self::error::ConversionError;
        fn try_from(value: i64) -> Result<Self, self::error::ConversionError> {
            if ![512_i64, 2048_i64, 4096_i64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> serde::Deserialize<'de> for BlockSize {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            Self::try_from(<i64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    ///A count of bytes, typically used either for memory or storage capacity
    ///
    ///The maximum supported byte count is [`i64::MAX`].  This makes it
    /// somewhat inconvenient to define constructors: a u32 constructor can be
    /// infallible, but an i64 constructor can fail (if the value is negative)
    /// and a u64 constructor can fail (if the value is larger than i64::MAX).
    /// We provide all of these for consumers' convenience.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A count of bytes, typically used either for memory or
    /// storage capacity\n\nThe maximum supported byte count is [`i64::MAX`].
    /// This makes it somewhat inconvenient to define constructors: a u32
    /// constructor can be infallible, but an i64 constructor can fail (if the
    /// value is negative) and a u64 constructor can fail (if the value is
    /// larger than i64::MAX).  We provide all of these for consumers'
    /// convenience.",
    ///  "type": "integer",
    ///  "format": "uint64",
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ByteCount(pub u64);
    impl std::ops::Deref for ByteCount {
        type Target = u64;
        fn deref(&self) -> &u64 {
            &self.0
        }
    }

    impl From<ByteCount> for u64 {
        fn from(value: ByteCount) -> Self {
            value.0
        }
    }

    impl From<&ByteCount> for ByteCount {
        fn from(value: &ByteCount) -> Self {
            value.clone()
        }
    }

    impl From<u64> for ByteCount {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for ByteCount {
        type Err = <u64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for ByteCount {
        type Error = <u64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ByteCount {
        type Error = <u64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ByteCount {
        type Error = <u64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for ByteCount {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Client view of a [`Certificate`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Certificate`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "service",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "service": {
    ///      "$ref": "#/components/schemas/ServiceUsingCertificate"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Certificate {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub service: ServiceUsingCertificate,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Certificate> for Certificate {
        fn from(value: &Certificate) -> Self {
            value.clone()
        }
    }

    impl Certificate {
        pub fn builder() -> builder::Certificate {
            Default::default()
        }
    }

    ///Create-time parameters for a
    /// [`Certificate`](crate::external_api::views::Certificate)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Certificate`](crate::external_api::views::Certificate)",
    ///  "type": "object",
    ///  "required": [
    ///    "cert",
    ///    "description",
    ///    "key",
    ///    "name",
    ///    "service"
    ///  ],
    ///  "properties": {
    ///    "cert": {
    ///      "description": "PEM file containing public certificate chain",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint8",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "key": {
    ///      "description": "PEM file containing private key",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint8",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "service": {
    ///      "description": "The service using this certificate",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ServiceUsingCertificate"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CertificateCreate {
        ///PEM file containing public certificate chain
        pub cert: Vec<u8>,
        pub description: String,
        ///PEM file containing private key
        pub key: Vec<u8>,
        pub name: Name,
        ///The service using this certificate
        pub service: ServiceUsingCertificate,
    }

    impl From<&CertificateCreate> for CertificateCreate {
        fn from(value: &CertificateCreate) -> Self {
            value.clone()
        }
    }

    impl CertificateCreate {
        pub fn builder() -> builder::CertificateCreate {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Certificate"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct CertificateResultsPage {
        ///list of items on this page of results
        pub items: Vec<Certificate>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&CertificateResultsPage> for CertificateResultsPage {
        fn from(value: &CertificateResultsPage) -> Self {
            value.clone()
        }
    }

    impl CertificateResultsPage {
        pub fn builder() -> builder::CertificateResultsPage {
            Default::default()
        }
    }

    ///Identity-related metadata that's included in "asset" public API objects
    /// (which generally have no name or description)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in \"asset\"
    /// public API objects (which generally have no name or description)",
    ///  "type": "object",
    ///  "required": [
    ///    "component_type",
    ///    "id",
    ///    "time_created",
    ///    "time_modified",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "component_type": {
    ///      "$ref": "#/components/schemas/UpdateableComponentType"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ComponentUpdate {
        pub component_type: UpdateableComponentType,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl From<&ComponentUpdate> for ComponentUpdate {
        fn from(value: &ComponentUpdate) -> Self {
            value.clone()
        }
    }

    impl ComponentUpdate {
        pub fn builder() -> builder::ComponentUpdate {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ComponentUpdate"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ComponentUpdateResultsPage {
        ///list of items on this page of results
        pub items: Vec<ComponentUpdate>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&ComponentUpdateResultsPage> for ComponentUpdateResultsPage {
        fn from(value: &ComponentUpdateResultsPage) -> Self {
            value.clone()
        }
    }

    impl ComponentUpdateResultsPage {
        pub fn builder() -> builder::ComponentUpdateResultsPage {
            Default::default()
        }
    }

    ///A cumulative or counter data type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A cumulative or counter data type.",
    ///  "type": "object",
    ///  "required": [
    ///    "start_time",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "value": {
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Cumulativedouble {
        pub start_time: chrono::DateTime<chrono::offset::Utc>,
        pub value: f64,
    }

    impl From<&Cumulativedouble> for Cumulativedouble {
        fn from(value: &Cumulativedouble) -> Self {
            value.clone()
        }
    }

    impl Cumulativedouble {
        pub fn builder() -> builder::Cumulativedouble {
            Default::default()
        }
    }

    ///A cumulative or counter data type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A cumulative or counter data type.",
    ///  "type": "object",
    ///  "required": [
    ///    "start_time",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "value": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Cumulativeint64 {
        pub start_time: chrono::DateTime<chrono::offset::Utc>,
        pub value: i64,
    }

    impl From<&Cumulativeint64> for Cumulativeint64 {
        fn from(value: &Cumulativeint64) -> Self {
            value.clone()
        }
    }

    impl Cumulativeint64 {
        pub fn builder() -> builder::Cumulativeint64 {
            Default::default()
        }
    }

    ///A `Datum` is a single sampled data point from a metric.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `Datum` is a single sampled data point from a
    /// metric.",
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "boolean"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "bool"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "i64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "f64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "string"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "integer",
    ///            "format": "uint8",
    ///            "minimum": 0.0
    ///          }
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "bytes"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Cumulativeint64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "cumulative_i64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Cumulativedouble"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "cumulative_f64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramint64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_i64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramdouble"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_f64"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type", content = "datum")]
    pub enum Datum {
        #[serde(rename = "bool")]
        Bool(bool),
        #[serde(rename = "i64")]
        I64(i64),
        #[serde(rename = "f64")]
        F64(f64),
        #[serde(rename = "string")]
        String(String),
        #[serde(rename = "bytes")]
        Bytes(Vec<u8>),
        #[serde(rename = "cumulative_i64")]
        CumulativeI64(Cumulativeint64),
        #[serde(rename = "cumulative_f64")]
        CumulativeF64(Cumulativedouble),
        #[serde(rename = "histogram_i64")]
        HistogramI64(Histogramint64),
        #[serde(rename = "histogram_f64")]
        HistogramF64(Histogramdouble),
    }

    impl From<&Datum> for Datum {
        fn from(value: &Datum) -> Self {
            value.clone()
        }
    }

    impl From<bool> for Datum {
        fn from(value: bool) -> Self {
            Self::Bool(value)
        }
    }

    impl From<i64> for Datum {
        fn from(value: i64) -> Self {
            Self::I64(value)
        }
    }

    impl From<f64> for Datum {
        fn from(value: f64) -> Self {
            Self::F64(value)
        }
    }

    impl From<Vec<u8>> for Datum {
        fn from(value: Vec<u8>) -> Self {
            Self::Bytes(value)
        }
    }

    impl From<Cumulativeint64> for Datum {
        fn from(value: Cumulativeint64) -> Self {
            Self::CumulativeI64(value)
        }
    }

    impl From<Cumulativedouble> for Datum {
        fn from(value: Cumulativedouble) -> Self {
            Self::CumulativeF64(value)
        }
    }

    impl From<Histogramint64> for Datum {
        fn from(value: Histogramint64) -> Self {
            Self::HistogramI64(value)
        }
    }

    impl From<Histogramdouble> for Datum {
        fn from(value: Histogramdouble) -> Self {
            Self::HistogramF64(value)
        }
    }

    ///The type of an individual datum of a metric.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of an individual datum of a metric.",
    ///  "type": "string",
    ///  "enum": [
    ///    "bool",
    ///    "i64",
    ///    "f64",
    ///    "string",
    ///    "bytes",
    ///    "cumulative_i64",
    ///    "cumulative_f64",
    ///    "histogram_i64",
    ///    "histogram_f64"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum DatumType {
        #[serde(rename = "bool")]
        Bool,
        #[serde(rename = "i64")]
        I64,
        #[serde(rename = "f64")]
        F64,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "bytes")]
        Bytes,
        #[serde(rename = "cumulative_i64")]
        CumulativeI64,
        #[serde(rename = "cumulative_f64")]
        CumulativeF64,
        #[serde(rename = "histogram_i64")]
        HistogramI64,
        #[serde(rename = "histogram_f64")]
        HistogramF64,
    }

    impl From<&DatumType> for DatumType {
        fn from(value: &DatumType) -> Self {
            value.clone()
        }
    }

    impl ToString for DatumType {
        fn to_string(&self) -> String {
            match *self {
                Self::Bool => "bool".to_string(),
                Self::I64 => "i64".to_string(),
                Self::F64 => "f64".to_string(),
                Self::String => "string".to_string(),
                Self::Bytes => "bytes".to_string(),
                Self::CumulativeI64 => "cumulative_i64".to_string(),
                Self::CumulativeF64 => "cumulative_f64".to_string(),
                Self::HistogramI64 => "histogram_i64".to_string(),
                Self::HistogramF64 => "histogram_f64".to_string(),
            }
        }
    }

    impl std::str::FromStr for DatumType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "bool" => Ok(Self::Bool),
                "i64" => Ok(Self::I64),
                "f64" => Ok(Self::F64),
                "string" => Ok(Self::String),
                "bytes" => Ok(Self::Bytes),
                "cumulative_i64" => Ok(Self::CumulativeI64),
                "cumulative_f64" => Ok(Self::CumulativeF64),
                "histogram_i64" => Ok(Self::HistogramI64),
                "histogram_f64" => Ok(Self::HistogramF64),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for DatumType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DatumType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DatumType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///DerEncodedKeyPair
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "private_key",
    ///    "public_cert"
    ///  ],
    ///  "properties": {
    ///    "private_key": {
    ///      "description": "request signing private key (base64 encoded der
    /// file)",
    ///      "type": "string"
    ///    },
    ///    "public_cert": {
    ///      "description": "request signing public certificate (base64 encoded
    /// der file)",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct DerEncodedKeyPair {
        ///request signing private key (base64 encoded der file)
        pub private_key: String,
        ///request signing public certificate (base64 encoded der file)
        pub public_cert: String,
    }

    impl From<&DerEncodedKeyPair> for DerEncodedKeyPair {
        fn from(value: &DerEncodedKeyPair) -> Self {
            value.clone()
        }
    }

    impl DerEncodedKeyPair {
        pub fn builder() -> builder::DerEncodedKeyPair {
            Default::default()
        }
    }

    ///DeviceAccessTokenRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "client_id",
    ///    "device_code",
    ///    "grant_type"
    ///  ],
    ///  "properties": {
    ///    "client_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "device_code": {
    ///      "type": "string"
    ///    },
    ///    "grant_type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct DeviceAccessTokenRequest {
        pub client_id: uuid::Uuid,
        pub device_code: String,
        pub grant_type: String,
    }

    impl From<&DeviceAccessTokenRequest> for DeviceAccessTokenRequest {
        fn from(value: &DeviceAccessTokenRequest) -> Self {
            value.clone()
        }
    }

    impl DeviceAccessTokenRequest {
        pub fn builder() -> builder::DeviceAccessTokenRequest {
            Default::default()
        }
    }

    ///DeviceAuthRequest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "client_id"
    ///  ],
    ///  "properties": {
    ///    "client_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct DeviceAuthRequest {
        pub client_id: uuid::Uuid,
    }

    impl From<&DeviceAuthRequest> for DeviceAuthRequest {
        fn from(value: &DeviceAuthRequest) -> Self {
            value.clone()
        }
    }

    impl DeviceAuthRequest {
        pub fn builder() -> builder::DeviceAuthRequest {
            Default::default()
        }
    }

    ///DeviceAuthVerify
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "user_code"
    ///  ],
    ///  "properties": {
    ///    "user_code": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct DeviceAuthVerify {
        pub user_code: String,
    }

    impl From<&DeviceAuthVerify> for DeviceAuthVerify {
        fn from(value: &DeviceAuthVerify) -> Self {
            value.clone()
        }
    }

    impl DeviceAuthVerify {
        pub fn builder() -> builder::DeviceAuthVerify {
            Default::default()
        }
    }

    ///Digest
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "sha256"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type", content = "value")]
    pub enum Digest {
        #[serde(rename = "sha256")]
        Sha256(String),
    }

    impl From<&Digest> for Digest {
        fn from(value: &Digest) -> Self {
            value.clone()
        }
    }

    ///Client view of a [`Disk`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Disk`]",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "device_path",
    ///    "id",
    ///    "name",
    ///    "project_id",
    ///    "size",
    ///    "state",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "$ref": "#/components/schemas/ByteCount"
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "device_path": {
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "image_id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "size": {
    ///      "$ref": "#/components/schemas/ByteCount"
    ///    },
    ///    "snapshot_id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/DiskState"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Disk {
        pub block_size: ByteCount,
        ///human-readable free-form text about a resource
        pub description: String,
        pub device_path: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub image_id: Option<uuid::Uuid>,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub project_id: uuid::Uuid,
        pub size: ByteCount,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snapshot_id: Option<uuid::Uuid>,
        pub state: DiskState,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Disk> for Disk {
        fn from(value: &Disk) -> Self {
            value.clone()
        }
    }

    impl Disk {
        pub fn builder() -> builder::Disk {
            Default::default()
        }
    }

    ///Create-time parameters for a
    /// [`Disk`](omicron_common::api::external::Disk)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Disk`](omicron_common::api::external::Disk)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "disk_source",
    ///    "name",
    ///    "size"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "disk_source": {
    ///      "description": "initial source for this disk",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/DiskSource"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "size": {
    ///      "description": "total size of the Disk in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct DiskCreate {
        pub description: String,
        ///initial source for this disk
        pub disk_source: DiskSource,
        pub name: Name,
        ///total size of the Disk in bytes
        pub size: ByteCount,
    }

    impl From<&DiskCreate> for DiskCreate {
        fn from(value: &DiskCreate) -> Self {
            value.clone()
        }
    }

    impl DiskCreate {
        pub fn builder() -> builder::DiskCreate {
            Default::default()
        }
    }

    ///TODO-v1: Delete this Parameters for the
    /// [`Disk`](omicron_common::api::external::Disk) to be attached or detached
    /// to an instance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "TODO-v1: Delete this Parameters for the
    /// [`Disk`](omicron_common::api::external::Disk) to be attached or detached
    /// to an instance",
    ///  "type": "object",
    ///  "required": [
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct DiskIdentifier {
        pub name: Name,
    }

    impl From<&DiskIdentifier> for DiskIdentifier {
        fn from(value: &DiskIdentifier) -> Self {
            value.clone()
        }
    }

    impl DiskIdentifier {
        pub fn builder() -> builder::DiskIdentifier {
            Default::default()
        }
    }

    ///DiskMetricName
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "activated",
    ///    "flush",
    ///    "read",
    ///    "read_bytes",
    ///    "write",
    ///    "write_bytes"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum DiskMetricName {
        #[serde(rename = "activated")]
        Activated,
        #[serde(rename = "flush")]
        Flush,
        #[serde(rename = "read")]
        Read,
        #[serde(rename = "read_bytes")]
        ReadBytes,
        #[serde(rename = "write")]
        Write,
        #[serde(rename = "write_bytes")]
        WriteBytes,
    }

    impl From<&DiskMetricName> for DiskMetricName {
        fn from(value: &DiskMetricName) -> Self {
            value.clone()
        }
    }

    impl ToString for DiskMetricName {
        fn to_string(&self) -> String {
            match *self {
                Self::Activated => "activated".to_string(),
                Self::Flush => "flush".to_string(),
                Self::Read => "read".to_string(),
                Self::ReadBytes => "read_bytes".to_string(),
                Self::Write => "write".to_string(),
                Self::WriteBytes => "write_bytes".to_string(),
            }
        }
    }

    impl std::str::FromStr for DiskMetricName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "activated" => Ok(Self::Activated),
                "flush" => Ok(Self::Flush),
                "read" => Ok(Self::Read),
                "read_bytes" => Ok(Self::ReadBytes),
                "write" => Ok(Self::Write),
                "write_bytes" => Ok(Self::WriteBytes),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for DiskMetricName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DiskMetricName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DiskMetricName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///DiskPath
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "disk"
    ///  ],
    ///  "properties": {
    ///    "disk": {
    ///      "$ref": "#/components/schemas/NameOrId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct DiskPath {
        pub disk: NameOrId,
    }

    impl From<&DiskPath> for DiskPath {
        fn from(value: &DiskPath) -> Self {
            value.clone()
        }
    }

    impl DiskPath {
        pub fn builder() -> builder::DiskPath {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Disk"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct DiskResultsPage {
        ///list of items on this page of results
        pub items: Vec<Disk>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&DiskResultsPage> for DiskResultsPage {
        fn from(value: &DiskResultsPage) -> Self {
            value.clone()
        }
    }

    impl DiskResultsPage {
        pub fn builder() -> builder::DiskResultsPage {
            Default::default()
        }
    }

    ///Different sources for a disk
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Different sources for a disk",
    ///  "oneOf": [
    ///    {
    ///      "description": "Create a blank disk",
    ///      "type": "object",
    ///      "required": [
    ///        "block_size",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "block_size": {
    ///          "description": "size of blocks for this Disk. valid values are:
    /// 512, 2048, or 4096",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/BlockSize"
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "blank"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Create a disk from a disk snapshot",
    ///      "type": "object",
    ///      "required": [
    ///        "snapshot_id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "snapshot_id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "snapshot"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Create a disk from a project image",
    ///      "type": "object",
    ///      "required": [
    ///        "image_id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "image_id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "image"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Create a disk from a global image",
    ///      "type": "object",
    ///      "required": [
    ///        "image_id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "image_id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "global_image"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type")]
    pub enum DiskSource {
        ///Create a blank disk
        #[serde(rename = "blank")]
        Blank {
            ///size of blocks for this Disk. valid values are: 512, 2048, or
            /// 4096
            block_size: BlockSize,
        },
        ///Create a disk from a disk snapshot
        #[serde(rename = "snapshot")]
        Snapshot { snapshot_id: uuid::Uuid },
        ///Create a disk from a project image
        #[serde(rename = "image")]
        Image { image_id: uuid::Uuid },
        ///Create a disk from a global image
        #[serde(rename = "global_image")]
        GlobalImage { image_id: uuid::Uuid },
    }

    impl From<&DiskSource> for DiskSource {
        fn from(value: &DiskSource) -> Self {
            value.clone()
        }
    }

    ///State of a Disk (primarily: attached or not)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "State of a Disk (primarily: attached or not)",
    ///  "oneOf": [
    ///    {
    ///      "description": "Disk is being initialized",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "creating"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is ready but detached from any Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "detached"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is being attached to the given Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "instance",
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "instance": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "attaching"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is attached to the given Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "instance",
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "instance": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "attached"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is being detached from the given Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "instance",
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "instance": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "detaching"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk has been destroyed",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "destroyed"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is unavailable",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "faulted"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "state", content = "instance")]
    pub enum DiskState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "detached")]
        Detached,
        ///Disk is being attached to the given Instance
        #[serde(rename = "attaching")]
        Attaching(uuid::Uuid),
        ///Disk is attached to the given Instance
        #[serde(rename = "attached")]
        Attached(uuid::Uuid),
        ///Disk is being detached from the given Instance
        #[serde(rename = "detaching")]
        Detaching(uuid::Uuid),
        #[serde(rename = "destroyed")]
        Destroyed,
        #[serde(rename = "faulted")]
        Faulted,
    }

    impl From<&DiskState> for DiskState {
        fn from(value: &DiskState) -> Self {
            value.clone()
        }
    }

    ///OS image distribution
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "OS image distribution",
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "The name of the distribution (e.g. \"alpine\" or
    /// \"ubuntu\")",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "version": {
    ///      "description": "The version of the distribution (e.g. \"3.10\" or
    /// \"18.04\")",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Distribution {
        ///The name of the distribution (e.g. "alpine" or "ubuntu")
        pub name: Name,
        ///The version of the distribution (e.g. "3.10" or "18.04")
        pub version: String,
    }

    impl From<&Distribution> for Distribution {
        fn from(value: &Distribution) -> Self {
            value.clone()
        }
    }

    impl Distribution {
        pub fn builder() -> builder::Distribution {
            Default::default()
        }
    }

    ///Error information from a response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Error information from a response.",
    ///  "type": "object",
    ///  "required": [
    ///    "message",
    ///    "request_id"
    ///  ],
    ///  "properties": {
    ///    "error_code": {
    ///      "type": "string"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    },
    ///    "request_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Error {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_code: Option<String>,
        pub message: String,
        pub request_id: String,
    }

    impl From<&Error> for Error {
        fn from(value: &Error) -> Self {
            value.clone()
        }
    }

    impl Error {
        pub fn builder() -> builder::Error {
            Default::default()
        }
    }

    ///ExternalIp
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "ip",
    ///    "kind"
    ///  ],
    ///  "properties": {
    ///    "ip": {
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "kind": {
    ///      "$ref": "#/components/schemas/IpKind"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ExternalIp {
        pub ip: std::net::IpAddr,
        pub kind: IpKind,
    }

    impl From<&ExternalIp> for ExternalIp {
        fn from(value: &ExternalIp) -> Self {
            value.clone()
        }
    }

    impl ExternalIp {
        pub fn builder() -> builder::ExternalIp {
            Default::default()
        }
    }

    ///Parameters for creating an external IP address for instances.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameters for creating an external IP address for
    /// instances.",
    ///  "oneOf": [
    ///    {
    ///      "description": "An IP address providing both inbound and outbound
    /// access. The address is automatically-assigned from the provided IP Pool,
    /// or all available pools if not specified.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "pool_name": {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ephemeral"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type")]
    pub enum ExternalIpCreate {
        ///An IP address providing both inbound and outbound access. The
        /// address is automatically-assigned from the provided IP Pool, or all
        /// available pools if not specified.
        #[serde(rename = "ephemeral")]
        Ephemeral {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pool_name: Option<Name>,
        },
    }

    impl From<&ExternalIpCreate> for ExternalIpCreate {
        fn from(value: &ExternalIpCreate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ExternalIp"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ExternalIpResultsPage {
        ///list of items on this page of results
        pub items: Vec<ExternalIp>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&ExternalIpResultsPage> for ExternalIpResultsPage {
        fn from(value: &ExternalIpResultsPage) -> Self {
            value.clone()
        }
    }

    impl ExternalIpResultsPage {
        pub fn builder() -> builder::ExternalIpResultsPage {
            Default::default()
        }
    }

    ///The name and type information for a field of a timeseries schema.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name and type information for a field of a
    /// timeseries schema.",
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "source",
    ///    "ty"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "source": {
    ///      "$ref": "#/components/schemas/FieldSource"
    ///    },
    ///    "ty": {
    ///      "$ref": "#/components/schemas/FieldType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FieldSchema {
        pub name: String,
        pub source: FieldSource,
        pub ty: FieldType,
    }

    impl From<&FieldSchema> for FieldSchema {
        fn from(value: &FieldSchema) -> Self {
            value.clone()
        }
    }

    impl FieldSchema {
        pub fn builder() -> builder::FieldSchema {
            Default::default()
        }
    }

    ///The source from which a field is derived, the target or metric.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The source from which a field is derived, the target or
    /// metric.",
    ///  "type": "string",
    ///  "enum": [
    ///    "target",
    ///    "metric"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum FieldSource {
        #[serde(rename = "target")]
        Target,
        #[serde(rename = "metric")]
        Metric,
    }

    impl From<&FieldSource> for FieldSource {
        fn from(value: &FieldSource) -> Self {
            value.clone()
        }
    }

    impl ToString for FieldSource {
        fn to_string(&self) -> String {
            match *self {
                Self::Target => "target".to_string(),
                Self::Metric => "metric".to_string(),
            }
        }
    }

    impl std::str::FromStr for FieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "target" => Ok(Self::Target),
                "metric" => Ok(Self::Metric),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for FieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for FieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for FieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The `FieldType` identifies the data type of a target or metric field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The `FieldType` identifies the data type of a target or
    /// metric field.",
    ///  "type": "string",
    ///  "enum": [
    ///    "string",
    ///    "i64",
    ///    "ip_addr",
    ///    "uuid",
    ///    "bool"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum FieldType {
        #[serde(rename = "string")]
        String,
        #[serde(rename = "i64")]
        I64,
        #[serde(rename = "ip_addr")]
        IpAddr,
        #[serde(rename = "uuid")]
        Uuid,
        #[serde(rename = "bool")]
        Bool,
    }

    impl From<&FieldType> for FieldType {
        fn from(value: &FieldType) -> Self {
            value.clone()
        }
    }

    impl ToString for FieldType {
        fn to_string(&self) -> String {
            match *self {
                Self::String => "string".to_string(),
                Self::I64 => "i64".to_string(),
                Self::IpAddr => "ip_addr".to_string(),
                Self::Uuid => "uuid".to_string(),
                Self::Bool => "bool".to_string(),
            }
        }
    }

    impl std::str::FromStr for FieldType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "string" => Ok(Self::String),
                "i64" => Ok(Self::I64),
                "ip_addr" => Ok(Self::IpAddr),
                "uuid" => Ok(Self::Uuid),
                "bool" => Ok(Self::Bool),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for FieldType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for FieldType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for FieldType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///FleetRole
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "admin",
    ///    "collaborator",
    ///    "viewer"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum FleetRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl From<&FleetRole> for FleetRole {
        fn from(value: &FleetRole) -> Self {
            value.clone()
        }
    }

    impl ToString for FleetRole {
        fn to_string(&self) -> String {
            match *self {
                Self::Admin => "admin".to_string(),
                Self::Collaborator => "collaborator".to_string(),
                Self::Viewer => "viewer".to_string(),
            }
        }
    }

    impl std::str::FromStr for FleetRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for FleetRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for FleetRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for FleetRole {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Policy`], which describes how this
    /// resource may be accessed\n\nNote that the Policy only describes access
    /// granted explicitly for this resource.  The policies of parent resources
    /// can also cause a user to have access to this resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "role_assignments"
    ///  ],
    ///  "properties": {
    ///    "role_assignments": {
    ///      "description": "Roles directly assigned on this resource",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/FleetRoleRoleAssignment"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FleetRolePolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: Vec<FleetRoleRoleAssignment>,
    }

    impl From<&FleetRolePolicy> for FleetRolePolicy {
        fn from(value: &FleetRolePolicy) -> Self {
            value.clone()
        }
    }

    impl FleetRolePolicy {
        pub fn builder() -> builder::FleetRolePolicy {
            Default::default()
        }
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the assignment of a particular role on a
    /// particular resource to a particular identity (user, group, etc.)\n\nThe
    /// resource is not part of this structure.  Rather, [`RoleAssignment`]s are
    /// put into a [`Policy`] and that Policy is applied to a particular
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "identity_id",
    ///    "identity_type",
    ///    "role_name"
    ///  ],
    ///  "properties": {
    ///    "identity_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_type": {
    ///      "$ref": "#/components/schemas/IdentityType"
    ///    },
    ///    "role_name": {
    ///      "$ref": "#/components/schemas/FleetRole"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct FleetRoleRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: FleetRole,
    }

    impl From<&FleetRoleRoleAssignment> for FleetRoleRoleAssignment {
        fn from(value: &FleetRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    impl FleetRoleRoleAssignment {
        pub fn builder() -> builder::FleetRoleRoleAssignment {
            Default::default()
        }
    }

    ///Client view of global Images
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of global Images",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "distribution",
    ///    "id",
    ///    "name",
    ///    "size",
    ///    "time_created",
    ///    "time_modified",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "description": "size of blocks in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "digest": {
    ///      "description": "Hash of the image contents, if applicable",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Digest"
    ///        }
    ///      ]
    ///    },
    ///    "distribution": {
    ///      "description": "Image distribution",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "size": {
    ///      "description": "total size in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "url": {
    ///      "description": "URL source of this image, if any",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "version": {
    ///      "description": "Image version",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GlobalImage {
        ///size of blocks in bytes
        pub block_size: ByteCount,
        ///human-readable free-form text about a resource
        pub description: String,
        ///Hash of the image contents, if applicable
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub digest: Option<Digest>,
        ///Image distribution
        pub distribution: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///total size in bytes
        pub size: ByteCount,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///URL source of this image, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        ///Image version
        pub version: String,
    }

    impl From<&GlobalImage> for GlobalImage {
        fn from(value: &GlobalImage) -> Self {
            value.clone()
        }
    }

    impl GlobalImage {
        pub fn builder() -> builder::GlobalImage {
            Default::default()
        }
    }

    ///Create-time parameters for an
    /// [`GlobalImage`](crate::external_api::views::GlobalImage)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an
    /// [`GlobalImage`](crate::external_api::views::GlobalImage)",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "distribution",
    ///    "name",
    ///    "source"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "description": "block size in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BlockSize"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "distribution": {
    ///      "description": "OS image distribution",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Distribution"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "source": {
    ///      "description": "The source of the image's contents.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ImageSource"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GlobalImageCreate {
        ///block size in bytes
        pub block_size: BlockSize,
        pub description: String,
        ///OS image distribution
        pub distribution: Distribution,
        pub name: Name,
        ///The source of the image's contents.
        pub source: ImageSource,
    }

    impl From<&GlobalImageCreate> for GlobalImageCreate {
        fn from(value: &GlobalImageCreate) -> Self {
            value.clone()
        }
    }

    impl GlobalImageCreate {
        pub fn builder() -> builder::GlobalImageCreate {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GlobalImage"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GlobalImageResultsPage {
        ///list of items on this page of results
        pub items: Vec<GlobalImage>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&GlobalImageResultsPage> for GlobalImageResultsPage {
        fn from(value: &GlobalImageResultsPage) -> Self {
            value.clone()
        }
    }

    impl GlobalImageResultsPage {
        pub fn builder() -> builder::GlobalImageResultsPage {
            Default::default()
        }
    }

    ///Client view of a [`Group`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Group`]",
    ///  "type": "object",
    ///  "required": [
    ///    "display_name",
    ///    "id",
    ///    "silo_id"
    ///  ],
    ///  "properties": {
    ///    "display_name": {
    ///      "description": "Human-readable name that can identify the group",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "silo_id": {
    ///      "description": "Uuid of the silo to which this group belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Group {
        ///Human-readable name that can identify the group
        pub display_name: String,
        pub id: uuid::Uuid,
        ///Uuid of the silo to which this group belongs
        pub silo_id: uuid::Uuid,
    }

    impl From<&Group> for Group {
        fn from(value: &Group) -> Self {
            value.clone()
        }
    }

    impl Group {
        pub fn builder() -> builder::Group {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Group"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct GroupResultsPage {
        ///list of items on this page of results
        pub items: Vec<Group>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&GroupResultsPage> for GroupResultsPage {
        fn from(value: &GroupResultsPage) -> Self {
            value.clone()
        }
    }

    impl GroupResultsPage {
        pub fn builder() -> builder::GroupResultsPage {
            Default::default()
        }
    }

    ///A simple type for managing a histogram metric.
    ///
    ///A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    ///Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    ///Example ------- ```rust use oximeter::histogram::{BinRange, Histogram};
    ///
    ///let edges = [0i64, 10, 20]; let mut hist =
    /// Histogram::new(&edges).unwrap(); assert_eq!(hist.n_bins(), 4); // One
    /// additional bin for the range (20..) assert_eq!(hist.n_samples(), 0);
    /// hist.sample(4); hist.sample(100); assert_eq!(hist.n_samples(), 2);
    ///
    ///let data = hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range,
    /// BinRange::range(i64::MIN, 0)); // An additional bin for `..0`
    /// assert_eq!(data[0].count, 0); // Nothing is in this bin
    ///
    ///assert_eq!(data[1].range, BinRange::range(0, 10)); // The range `0..10`
    /// assert_eq!(data[1].count, 1); // 4 is sampled into this bin ```
    ///
    ///Notes -----
    ///
    ///Histograms may be constructed either from their left bin edges, or from
    /// a sequence of ranges. In either case, the left-most bin may be converted
    /// upon construction. In particular, if the left-most value is not equal to
    /// the minimum of the support, a new bin will be added from the minimum to
    /// that provided value. If the left-most value _is_ the support's minimum,
    /// because the provided bin was unbounded below, such as `(..0)`, then that
    /// bin will be converted into one bounded below, `(MIN..0)` in this case.
    ///
    ///The short of this is that, most of the time, it shouldn't matter. If one
    /// specifies the extremes of the support as their bins, be aware that the
    /// left-most may be converted from a `BinRange::RangeTo` into a
    /// `BinRange::Range`. In other words, the first bin of a histogram is
    /// _always_ a `Bin::Range` or a `Bin::RangeFrom` after construction. In
    /// fact, every bin is one of those variants, the `BinRange::RangeTo` is
    /// only provided as a convenience during construction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A simple type for managing a histogram metric.\n\nA
    /// histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any \"gaps\" in the bins, and an additional
    /// bin may be added to the left, right, or both so that the bins extend to
    /// the entire range of the support.\n\nNote that any gaps, unsorted bins,
    /// or non-finite values will result in an error.\n\nExample ------- ```rust
    /// use oximeter::histogram::{BinRange, Histogram};\n\nlet edges = [0i64,
    /// 10, 20]; let mut hist = Histogram::new(&edges).unwrap();
    /// assert_eq!(hist.n_bins(), 4); // One additional bin for the range (20..)
    /// assert_eq!(hist.n_samples(), 0); hist.sample(4); hist.sample(100);
    /// assert_eq!(hist.n_samples(), 2);\n\nlet data =
    /// hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range,
    /// BinRange::range(i64::MIN, 0)); // An additional bin for `..0`
    /// assert_eq!(data[0].count, 0); // Nothing is in this
    /// bin\n\nassert_eq!(data[1].range, BinRange::range(0, 10)); // The range
    /// `0..10` assert_eq!(data[1].count, 1); // 4 is sampled into this bin
    /// ```\n\nNotes -----\n\nHistograms may be constructed either from their
    /// left bin edges, or from a sequence of ranges. In either case, the
    /// left-most bin may be converted upon construction. In particular, if the
    /// left-most value is not equal to the minimum of the support, a new bin
    /// will be added from the minimum to that provided value. If the left-most
    /// value _is_ the support's minimum, because the provided bin was unbounded
    /// below, such as `(..0)`, then that bin will be converted into one bounded
    /// below, `(MIN..0)` in this case.\n\nThe short of this is that, most of
    /// the time, it shouldn't matter. If one specifies the extremes of the
    /// support as their bins, be aware that the left-most may be converted from
    /// a `BinRange::RangeTo` into a `BinRange::Range`. In other words, the
    /// first bin of a histogram is _always_ a `Bin::Range` or a
    /// `Bin::RangeFrom` after construction. In fact, every bin is one of those
    /// variants, the `BinRange::RangeTo` is only provided as a convenience
    /// during construction.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "n_samples",
    ///    "start_time"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Bindouble"
    ///      }
    ///    },
    ///    "n_samples": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Histogramdouble {
        pub bins: Vec<Bindouble>,
        pub n_samples: u64,
        pub start_time: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Histogramdouble> for Histogramdouble {
        fn from(value: &Histogramdouble) -> Self {
            value.clone()
        }
    }

    impl Histogramdouble {
        pub fn builder() -> builder::Histogramdouble {
            Default::default()
        }
    }

    ///A simple type for managing a histogram metric.
    ///
    ///A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    ///Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    ///Example ------- ```rust use oximeter::histogram::{BinRange, Histogram};
    ///
    ///let edges = [0i64, 10, 20]; let mut hist =
    /// Histogram::new(&edges).unwrap(); assert_eq!(hist.n_bins(), 4); // One
    /// additional bin for the range (20..) assert_eq!(hist.n_samples(), 0);
    /// hist.sample(4); hist.sample(100); assert_eq!(hist.n_samples(), 2);
    ///
    ///let data = hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range,
    /// BinRange::range(i64::MIN, 0)); // An additional bin for `..0`
    /// assert_eq!(data[0].count, 0); // Nothing is in this bin
    ///
    ///assert_eq!(data[1].range, BinRange::range(0, 10)); // The range `0..10`
    /// assert_eq!(data[1].count, 1); // 4 is sampled into this bin ```
    ///
    ///Notes -----
    ///
    ///Histograms may be constructed either from their left bin edges, or from
    /// a sequence of ranges. In either case, the left-most bin may be converted
    /// upon construction. In particular, if the left-most value is not equal to
    /// the minimum of the support, a new bin will be added from the minimum to
    /// that provided value. If the left-most value _is_ the support's minimum,
    /// because the provided bin was unbounded below, such as `(..0)`, then that
    /// bin will be converted into one bounded below, `(MIN..0)` in this case.
    ///
    ///The short of this is that, most of the time, it shouldn't matter. If one
    /// specifies the extremes of the support as their bins, be aware that the
    /// left-most may be converted from a `BinRange::RangeTo` into a
    /// `BinRange::Range`. In other words, the first bin of a histogram is
    /// _always_ a `Bin::Range` or a `Bin::RangeFrom` after construction. In
    /// fact, every bin is one of those variants, the `BinRange::RangeTo` is
    /// only provided as a convenience during construction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A simple type for managing a histogram metric.\n\nA
    /// histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any \"gaps\" in the bins, and an additional
    /// bin may be added to the left, right, or both so that the bins extend to
    /// the entire range of the support.\n\nNote that any gaps, unsorted bins,
    /// or non-finite values will result in an error.\n\nExample ------- ```rust
    /// use oximeter::histogram::{BinRange, Histogram};\n\nlet edges = [0i64,
    /// 10, 20]; let mut hist = Histogram::new(&edges).unwrap();
    /// assert_eq!(hist.n_bins(), 4); // One additional bin for the range (20..)
    /// assert_eq!(hist.n_samples(), 0); hist.sample(4); hist.sample(100);
    /// assert_eq!(hist.n_samples(), 2);\n\nlet data =
    /// hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range,
    /// BinRange::range(i64::MIN, 0)); // An additional bin for `..0`
    /// assert_eq!(data[0].count, 0); // Nothing is in this
    /// bin\n\nassert_eq!(data[1].range, BinRange::range(0, 10)); // The range
    /// `0..10` assert_eq!(data[1].count, 1); // 4 is sampled into this bin
    /// ```\n\nNotes -----\n\nHistograms may be constructed either from their
    /// left bin edges, or from a sequence of ranges. In either case, the
    /// left-most bin may be converted upon construction. In particular, if the
    /// left-most value is not equal to the minimum of the support, a new bin
    /// will be added from the minimum to that provided value. If the left-most
    /// value _is_ the support's minimum, because the provided bin was unbounded
    /// below, such as `(..0)`, then that bin will be converted into one bounded
    /// below, `(MIN..0)` in this case.\n\nThe short of this is that, most of
    /// the time, it shouldn't matter. If one specifies the extremes of the
    /// support as their bins, be aware that the left-most may be converted from
    /// a `BinRange::RangeTo` into a `BinRange::Range`. In other words, the
    /// first bin of a histogram is _always_ a `Bin::Range` or a
    /// `Bin::RangeFrom` after construction. In fact, every bin is one of those
    /// variants, the `BinRange::RangeTo` is only provided as a convenience
    /// during construction.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "n_samples",
    ///    "start_time"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Binint64"
    ///      }
    ///    },
    ///    "n_samples": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Histogramint64 {
        pub bins: Vec<Binint64>,
        pub n_samples: u64,
        pub start_time: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Histogramint64> for Histogramint64 {
        fn from(value: &Histogramint64) -> Self {
            value.clone()
        }
    }

    impl Histogramint64 {
        pub fn builder() -> builder::Histogramint64 {
            Default::default()
        }
    }

    ///Supported set of sort modes for scanning by id only.
    ///
    ///Currently, we only support scanning in ascending order.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Supported set of sort modes for scanning by id
    /// only.\n\nCurrently, we only support scanning in ascending order.",
    ///  "oneOf": [
    ///    {
    ///      "description": "sort in increasing order of \"id\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "id_ascending"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum IdSortMode {
        ///sort in increasing order of "id"
        #[serde(rename = "id_ascending")]
        IdAscending,
    }

    impl From<&IdSortMode> for IdSortMode {
        fn from(value: &IdSortMode) -> Self {
            value.clone()
        }
    }

    impl ToString for IdSortMode {
        fn to_string(&self) -> String {
            match *self {
                Self::IdAscending => "id_ascending".to_string(),
            }
        }
    }

    impl std::str::FromStr for IdSortMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "id_ascending" => Ok(Self::IdAscending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for IdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for IdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for IdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of an [`IdentityProvider`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of an [`IdentityProvider`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "provider_type",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "provider_type": {
    ///      "description": "Identity provider type",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IdentityProviderType"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IdentityProvider {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///Identity provider type
        pub provider_type: IdentityProviderType,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&IdentityProvider> for IdentityProvider {
        fn from(value: &IdentityProvider) -> Self {
            value.clone()
        }
    }

    impl IdentityProvider {
        pub fn builder() -> builder::IdentityProvider {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IdentityProvider"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IdentityProviderResultsPage {
        ///list of items on this page of results
        pub items: Vec<IdentityProvider>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&IdentityProviderResultsPage> for IdentityProviderResultsPage {
        fn from(value: &IdentityProviderResultsPage) -> Self {
            value.clone()
        }
    }

    impl IdentityProviderResultsPage {
        pub fn builder() -> builder::IdentityProviderResultsPage {
            Default::default()
        }
    }

    ///IdentityProviderType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "description": "SAML identity provider",
    ///      "type": "string",
    ///      "enum": [
    ///        "saml"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum IdentityProviderType {
        ///SAML identity provider
        #[serde(rename = "saml")]
        Saml,
    }

    impl From<&IdentityProviderType> for IdentityProviderType {
        fn from(value: &IdentityProviderType) -> Self {
            value.clone()
        }
    }

    impl ToString for IdentityProviderType {
        fn to_string(&self) -> String {
            match *self {
                Self::Saml => "saml".to_string(),
            }
        }
    }

    impl std::str::FromStr for IdentityProviderType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "saml" => Ok(Self::Saml),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for IdentityProviderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for IdentityProviderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for IdentityProviderType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Describes what kind of identity is described by an id
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes what kind of identity is described by an id",
    ///  "type": "string",
    ///  "enum": [
    ///    "silo_user",
    ///    "silo_group"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum IdentityType {
        #[serde(rename = "silo_user")]
        SiloUser,
        #[serde(rename = "silo_group")]
        SiloGroup,
    }

    impl From<&IdentityType> for IdentityType {
        fn from(value: &IdentityType) -> Self {
            value.clone()
        }
    }

    impl ToString for IdentityType {
        fn to_string(&self) -> String {
            match *self {
                Self::SiloUser => "silo_user".to_string(),
                Self::SiloGroup => "silo_group".to_string(),
            }
        }
    }

    impl std::str::FromStr for IdentityType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "silo_user" => Ok(Self::SiloUser),
                "silo_group" => Ok(Self::SiloGroup),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for IdentityType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for IdentityType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for IdentityType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///IdpMetadataSource
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "url"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "url"
    ///          ]
    ///        },
    ///        "url": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "data",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "data": {
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "base64_encoded_xml"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type")]
    pub enum IdpMetadataSource {
        #[serde(rename = "url")]
        Url { url: String },
        #[serde(rename = "base64_encoded_xml")]
        Base64EncodedXml { data: String },
    }

    impl From<&IdpMetadataSource> for IdpMetadataSource {
        fn from(value: &IdpMetadataSource) -> Self {
            value.clone()
        }
    }

    ///Client view of project Images
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of project Images",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "project_id",
    ///    "size",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "description": "size of blocks in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "digest": {
    ///      "description": "Hash of the image contents, if applicable",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Digest"
    ///        }
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "description": "The project the disk belongs to",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "size": {
    ///      "description": "total size in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "url": {
    ///      "description": "URL source of this image, if any",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "version": {
    ///      "description": "Version of this, if any",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Image {
        ///size of blocks in bytes
        pub block_size: ByteCount,
        ///human-readable free-form text about a resource
        pub description: String,
        ///Hash of the image contents, if applicable
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub digest: Option<Digest>,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///The project the disk belongs to
        pub project_id: uuid::Uuid,
        ///total size in bytes
        pub size: ByteCount,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///URL source of this image, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        ///Version of this, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub version: Option<String>,
    }

    impl From<&Image> for Image {
        fn from(value: &Image) -> Self {
            value.clone()
        }
    }

    impl Image {
        pub fn builder() -> builder::Image {
            Default::default()
        }
    }

    ///Create-time parameters for an
    /// [`Image`](crate::external_api::views::Image)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an
    /// [`Image`](crate::external_api::views::Image)",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "name",
    ///    "source"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "description": "block size in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BlockSize"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "source": {
    ///      "description": "The source of the image's contents.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ImageSource"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ImageCreate {
        ///block size in bytes
        pub block_size: BlockSize,
        pub description: String,
        pub name: Name,
        ///The source of the image's contents.
        pub source: ImageSource,
    }

    impl From<&ImageCreate> for ImageCreate {
        fn from(value: &ImageCreate) -> Self {
            value.clone()
        }
    }

    impl ImageCreate {
        pub fn builder() -> builder::ImageCreate {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Image"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ImageResultsPage {
        ///list of items on this page of results
        pub items: Vec<Image>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&ImageResultsPage> for ImageResultsPage {
        fn from(value: &ImageResultsPage) -> Self {
            value.clone()
        }
    }

    impl ImageResultsPage {
        pub fn builder() -> builder::ImageResultsPage {
            Default::default()
        }
    }

    ///The source of the underlying image.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The source of the underlying image.",
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "url"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "url"
    ///          ]
    ///        },
    ///        "url": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "snapshot"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Boot the Alpine ISO that ships with the Propolis
    /// zone. Intended for development purposes only.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "you_can_boot_anything_as_long_as_its_alpine"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type")]
    pub enum ImageSource {
        #[serde(rename = "url")]
        Url { url: String },
        #[serde(rename = "snapshot")]
        Snapshot { id: uuid::Uuid },
        #[serde(rename = "you_can_boot_anything_as_long_as_its_alpine")]
        YouCanBootAnythingAsLongAsItsAlpine,
    }

    impl From<&ImageSource> for ImageSource {
        fn from(value: &ImageSource) -> Self {
            value.clone()
        }
    }

    ///Client view of an [`Instance`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of an [`Instance`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "hostname",
    ///    "id",
    ///    "memory",
    ///    "name",
    ///    "ncpus",
    ///    "project_id",
    ///    "run_state",
    ///    "time_created",
    ///    "time_modified",
    ///    "time_run_state_updated"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "hostname": {
    ///      "description": "RFC1035-compliant hostname for the Instance.",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "memory": {
    ///      "description": "memory allocated for this Instance",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "ncpus": {
    ///      "description": "number of CPUs allocated for this Instance",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/InstanceCpuCount"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "description": "id for the project containing this Instance",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "run_state": {
    ///      "$ref": "#/components/schemas/InstanceState"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_run_state_updated": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Instance {
        ///human-readable free-form text about a resource
        pub description: String,
        ///RFC1035-compliant hostname for the Instance.
        pub hostname: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///memory allocated for this Instance
        pub memory: ByteCount,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///number of CPUs allocated for this Instance
        pub ncpus: InstanceCpuCount,
        ///id for the project containing this Instance
        pub project_id: uuid::Uuid,
        pub run_state: InstanceState,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub time_run_state_updated: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Instance> for Instance {
        fn from(value: &Instance) -> Self {
            value.clone()
        }
    }

    impl Instance {
        pub fn builder() -> builder::Instance {
            Default::default()
        }
    }

    ///The number of CPUs in an Instance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The number of CPUs in an Instance",
    ///  "type": "integer",
    ///  "format": "uint16",
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct InstanceCpuCount(pub u16);
    impl std::ops::Deref for InstanceCpuCount {
        type Target = u16;
        fn deref(&self) -> &u16 {
            &self.0
        }
    }

    impl From<InstanceCpuCount> for u16 {
        fn from(value: InstanceCpuCount) -> Self {
            value.0
        }
    }

    impl From<&InstanceCpuCount> for InstanceCpuCount {
        fn from(value: &InstanceCpuCount) -> Self {
            value.clone()
        }
    }

    impl From<u16> for InstanceCpuCount {
        fn from(value: u16) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for InstanceCpuCount {
        type Err = <u16 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for InstanceCpuCount {
        type Error = <u16 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for InstanceCpuCount {
        type Error = <u16 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for InstanceCpuCount {
        type Error = <u16 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for InstanceCpuCount {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Create-time parameters for an
    /// [`Instance`](omicron_common::api::external::Instance)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an
    /// [`Instance`](omicron_common::api::external::Instance)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "hostname",
    ///    "memory",
    ///    "name",
    ///    "ncpus"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "disks": {
    ///      "description": "The disks to be created or attached for this
    /// instance.",
    ///      "default": [],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InstanceDiskAttachment"
    ///      }
    ///    },
    ///    "external_ips": {
    ///      "description": "The external IP addresses provided to this
    /// instance.\n\nBy default, all instances have outbound connectivity, but
    /// no inbound connectivity. These external addresses can be used to provide
    /// a fixed, known IP address for making inbound connections to the
    /// instance.",
    ///      "default": [],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ExternalIpCreate"
    ///      }
    ///    },
    ///    "hostname": {
    ///      "type": "string"
    ///    },
    ///    "memory": {
    ///      "$ref": "#/components/schemas/ByteCount"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "ncpus": {
    ///      "$ref": "#/components/schemas/InstanceCpuCount"
    ///    },
    ///    "network_interfaces": {
    ///      "description": "The network interfaces to be created for this
    /// instance.",
    ///      "default": {
    ///        "type": "default"
    ///      },
    ///      "allOf": [
    ///        {
    ///          "$ref":
    /// "#/components/schemas/InstanceNetworkInterfaceAttachment"
    ///        }
    ///      ]
    ///    },
    ///    "start": {
    ///      "description": "Should this instance be started upon creation; true
    /// by default.",
    ///      "default": true,
    ///      "type": "boolean"
    ///    },
    ///    "user_data": {
    ///      "description": "User data for instance initialization systems (such
    /// as cloud-init). Must be a Base64-encoded string, as specified in RFC
    /// 4648  4 (+ and / characters with padding). Maximum 32 KiB unencoded
    /// data.",
    ///      "default": "",
    ///      "type": "string",
    ///      "format": "byte"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct InstanceCreate {
        pub description: String,
        ///The disks to be created or attached for this instance.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub disks: Vec<InstanceDiskAttachment>,
        ///The external IP addresses provided to this instance.
        ///
        ///By default, all instances have outbound connectivity, but no inbound
        /// connectivity. These external addresses can be used to provide a
        /// fixed, known IP address for making inbound connections to the
        /// instance.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub external_ips: Vec<ExternalIpCreate>,
        pub hostname: String,
        pub memory: ByteCount,
        pub name: Name,
        pub ncpus: InstanceCpuCount,
        ///The network interfaces to be created for this instance.
        #[serde(default = "defaults::instance_create_network_interfaces")]
        pub network_interfaces: InstanceNetworkInterfaceAttachment,
        ///Should this instance be started upon creation; true by default.
        #[serde(default = "defaults::default_bool::<true>")]
        pub start: bool,
        ///User data for instance initialization systems (such as cloud-init).
        /// Must be a Base64-encoded string, as specified in RFC 4648  4 (+ and
        /// / characters with padding). Maximum 32 KiB unencoded data.
        #[serde(default)]
        pub user_data: String,
    }

    impl From<&InstanceCreate> for InstanceCreate {
        fn from(value: &InstanceCreate) -> Self {
            value.clone()
        }
    }

    impl InstanceCreate {
        pub fn builder() -> builder::InstanceCreate {
            Default::default()
        }
    }

    ///Describe the instance's disks at creation time
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describe the instance's disks at creation time",
    ///  "oneOf": [
    ///    {
    ///      "description": "During instance creation, create and attach disks",
    ///      "type": "object",
    ///      "required": [
    ///        "description",
    ///        "disk_source",
    ///        "name",
    ///        "size",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "description": {
    ///          "type": "string"
    ///        },
    ///        "disk_source": {
    ///          "description": "initial source for this disk",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/DiskSource"
    ///            }
    ///          ]
    ///        },
    ///        "name": {
    ///          "$ref": "#/components/schemas/Name"
    ///        },
    ///        "size": {
    ///          "description": "total size of the Disk in bytes",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/ByteCount"
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "create"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "During instance creation, attach this disk",
    ///      "type": "object",
    ///      "required": [
    ///        "name",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "name": {
    ///          "description": "A disk name to attach",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "attach"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type")]
    pub enum InstanceDiskAttachment {
        ///During instance creation, create and attach disks
        #[serde(rename = "create")]
        Create {
            description: String,
            ///initial source for this disk
            disk_source: DiskSource,
            name: Name,
            ///total size of the Disk in bytes
            size: ByteCount,
        },
        ///During instance creation, attach this disk
        #[serde(rename = "attach")]
        Attach {
            ///A disk name to attach
            name: Name,
        },
    }

    impl From<&InstanceDiskAttachment> for InstanceDiskAttachment {
        fn from(value: &InstanceDiskAttachment) -> Self {
            value.clone()
        }
    }

    ///Migration parameters for an
    /// [`Instance`](omicron_common::api::external::Instance)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Migration parameters for an
    /// [`Instance`](omicron_common::api::external::Instance)",
    ///  "type": "object",
    ///  "required": [
    ///    "dst_sled_id"
    ///  ],
    ///  "properties": {
    ///    "dst_sled_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct InstanceMigrate {
        pub dst_sled_id: uuid::Uuid,
    }

    impl From<&InstanceMigrate> for InstanceMigrate {
        fn from(value: &InstanceMigrate) -> Self {
            value.clone()
        }
    }

    impl InstanceMigrate {
        pub fn builder() -> builder::InstanceMigrate {
            Default::default()
        }
    }

    ///Describes an attachment of a `NetworkInterface` to an `Instance`, at the
    /// time the instance is created.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes an attachment of a `NetworkInterface` to an
    /// `Instance`, at the time the instance is created.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Create one or more `NetworkInterface`s for the
    /// `Instance`.\n\nIf more than one interface is provided, then the first
    /// will be designated the primary interface for the instance.",
    ///      "type": "object",
    ///      "required": [
    ///        "params",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "params": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/NetworkInterfaceCreate"
    ///          }
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "create"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The default networking configuration for an
    /// instance is to create a single primary interface with an
    /// automatically-assigned IP address. The IP will be pulled from the
    /// Project's default VPC / VPC Subnet.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "default"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "No network interfaces at all will be created for
    /// the instance.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "none"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type", content = "params")]
    pub enum InstanceNetworkInterfaceAttachment {
        ///Create one or more `NetworkInterface`s for the `Instance`.
        ///
        ///If more than one interface is provided, then the first will be
        /// designated the primary interface for the instance.
        #[serde(rename = "create")]
        Create(Vec<NetworkInterfaceCreate>),
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "none")]
        None,
    }

    impl From<&InstanceNetworkInterfaceAttachment> for InstanceNetworkInterfaceAttachment {
        fn from(value: &InstanceNetworkInterfaceAttachment) -> Self {
            value.clone()
        }
    }

    impl From<Vec<NetworkInterfaceCreate>> for InstanceNetworkInterfaceAttachment {
        fn from(value: Vec<NetworkInterfaceCreate>) -> Self {
            Self::Create(value)
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Instance"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct InstanceResultsPage {
        ///list of items on this page of results
        pub items: Vec<Instance>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&InstanceResultsPage> for InstanceResultsPage {
        fn from(value: &InstanceResultsPage) -> Self {
            value.clone()
        }
    }

    impl InstanceResultsPage {
        pub fn builder() -> builder::InstanceResultsPage {
            Default::default()
        }
    }

    ///Contents of an Instance's serial console buffer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contents of an Instance's serial console buffer.",
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "last_byte_offset"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "description": "The bytes starting from the requested offset up to
    /// either the end of the buffer or the request's `max_bytes`. Provided as a
    /// u8 array rather than a string, as it may not be UTF-8.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint8",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "last_byte_offset": {
    ///      "description": "The absolute offset since boot (suitable for use as
    /// `byte_offset` in a subsequent request) of the last byte returned in
    /// `data`.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct InstanceSerialConsoleData {
        ///The bytes starting from the requested offset up to either the end of
        /// the buffer or the request's `max_bytes`. Provided as a u8 array
        /// rather than a string, as it may not be UTF-8.
        pub data: Vec<u8>,
        ///The absolute offset since boot (suitable for use as `byte_offset` in
        /// a subsequent request) of the last byte returned in `data`.
        pub last_byte_offset: u64,
    }

    impl From<&InstanceSerialConsoleData> for InstanceSerialConsoleData {
        fn from(value: &InstanceSerialConsoleData) -> Self {
            value.clone()
        }
    }

    impl InstanceSerialConsoleData {
        pub fn builder() -> builder::InstanceSerialConsoleData {
            Default::default()
        }
    }

    ///Running state of an Instance (primarily: booted or stopped)
    ///
    ///This typically reflects whether it's starting, running, stopping, or
    /// stopped, but also includes states related to the Instance's lifecycle
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Running state of an Instance (primarily: booted or
    /// stopped)\n\nThis typically reflects whether it's starting, running,
    /// stopping, or stopped, but also includes states related to the Instance's
    /// lifecycle",
    ///  "oneOf": [
    ///    {
    ///      "description": "The instance is being created.",
    ///      "type": "string",
    ///      "enum": [
    ///        "creating"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is currently starting up.",
    ///      "type": "string",
    ///      "enum": [
    ///        "starting"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is currently running.",
    ///      "type": "string",
    ///      "enum": [
    ///        "running"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance has been requested to stop and a
    /// transition to \"Stopped\" is imminent.",
    ///      "type": "string",
    ///      "enum": [
    ///        "stopping"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is currently stopped.",
    ///      "type": "string",
    ///      "enum": [
    ///        "stopped"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is in the process of rebooting - it
    /// will remain in the \"rebooting\" state until the VM is starting once
    /// more.",
    ///      "type": "string",
    ///      "enum": [
    ///        "rebooting"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is in the process of migrating - it will remain in the \"migrating\" state until the migration process is complete and the destination propolis is ready to continue execution.",
    ///      "type": "string",
    ///      "enum": [
    ///        "migrating"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is attempting to recover from a
    /// failure.",
    ///      "type": "string",
    ///      "enum": [
    ///        "repairing"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance has encountered a failure.",
    ///      "type": "string",
    ///      "enum": [
    ///        "failed"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance has been deleted.",
    ///      "type": "string",
    ///      "enum": [
    ///        "destroyed"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum InstanceState {
        ///The instance is being created.
        #[serde(rename = "creating")]
        Creating,
        ///The instance is currently starting up.
        #[serde(rename = "starting")]
        Starting,
        ///The instance is currently running.
        #[serde(rename = "running")]
        Running,
        ///The instance has been requested to stop and a transition to
        /// "Stopped" is imminent.
        #[serde(rename = "stopping")]
        Stopping,
        ///The instance is currently stopped.
        #[serde(rename = "stopped")]
        Stopped,
        ///The instance is in the process of rebooting - it will remain in the
        /// "rebooting" state until the VM is starting once more.
        #[serde(rename = "rebooting")]
        Rebooting,
        ///The instance is in the process of migrating - it will remain in the
        /// "migrating" state until the migration process is complete and the
        /// destination propolis is ready to continue execution.
        #[serde(rename = "migrating")]
        Migrating,
        ///The instance is attempting to recover from a failure.
        #[serde(rename = "repairing")]
        Repairing,
        ///The instance has encountered a failure.
        #[serde(rename = "failed")]
        Failed,
        ///The instance has been deleted.
        #[serde(rename = "destroyed")]
        Destroyed,
    }

    impl From<&InstanceState> for InstanceState {
        fn from(value: &InstanceState) -> Self {
            value.clone()
        }
    }

    impl ToString for InstanceState {
        fn to_string(&self) -> String {
            match *self {
                Self::Creating => "creating".to_string(),
                Self::Starting => "starting".to_string(),
                Self::Running => "running".to_string(),
                Self::Stopping => "stopping".to_string(),
                Self::Stopped => "stopped".to_string(),
                Self::Rebooting => "rebooting".to_string(),
                Self::Migrating => "migrating".to_string(),
                Self::Repairing => "repairing".to_string(),
                Self::Failed => "failed".to_string(),
                Self::Destroyed => "destroyed".to_string(),
            }
        }
    }

    impl std::str::FromStr for InstanceState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "creating" => Ok(Self::Creating),
                "starting" => Ok(Self::Starting),
                "running" => Ok(Self::Running),
                "stopping" => Ok(Self::Stopping),
                "stopped" => Ok(Self::Stopped),
                "rebooting" => Ok(Self::Rebooting),
                "migrating" => Ok(Self::Migrating),
                "repairing" => Ok(Self::Repairing),
                "failed" => Ok(Self::Failed),
                "destroyed" => Ok(Self::Destroyed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for InstanceState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for InstanceState {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for InstanceState {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The kind of an external IP address for an instance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The kind of an external IP address for an instance",
    ///  "type": "string",
    ///  "enum": [
    ///    "ephemeral",
    ///    "floating"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum IpKind {
        #[serde(rename = "ephemeral")]
        Ephemeral,
        #[serde(rename = "floating")]
        Floating,
    }

    impl From<&IpKind> for IpKind {
        fn from(value: &IpKind) -> Self {
            value.clone()
        }
    }

    impl ToString for IpKind {
        fn to_string(&self) -> String {
            match *self {
                Self::Ephemeral => "ephemeral".to_string(),
                Self::Floating => "floating".to_string(),
            }
        }
    }

    impl std::str::FromStr for IpKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ephemeral" => Ok(Self::Ephemeral),
                "floating" => Ok(Self::Floating),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for IpKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for IpKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for IpKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///IpNet
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "title": "v4",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Net"
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "title": "v6",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Net"
    ///        }
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum IpNet {
        V4(Ipv4Net),
        V6(Ipv6Net),
    }

    impl From<&IpNet> for IpNet {
        fn from(value: &IpNet) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for IpNet {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::V4(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::V6(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }

    impl std::convert::TryFrom<&str> for IpNet {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for IpNet {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for IpNet {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ToString for IpNet {
        fn to_string(&self) -> String {
            match self {
                Self::V4(x) => x.to_string(),
                Self::V6(x) => x.to_string(),
            }
        }
    }

    impl From<Ipv4Net> for IpNet {
        fn from(value: Ipv4Net) -> Self {
            Self::V4(value)
        }
    }

    impl From<Ipv6Net> for IpNet {
        fn from(value: Ipv6Net) -> Self {
            Self::V6(value)
        }
    }

    ///Identity-related metadata that's included in nearly all public API
    /// objects
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in nearly all
    /// public API objects",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IpPool {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&IpPool> for IpPool {
        fn from(value: &IpPool) -> Self {
            value.clone()
        }
    }

    impl IpPool {
        pub fn builder() -> builder::IpPool {
            Default::default()
        }
    }

    ///Create-time parameters for an IP Pool.
    ///
    ///See [`IpPool`](crate::external_api::views::IpPool)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an IP Pool.\n\nSee
    /// [`IpPool`](crate::external_api::views::IpPool)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IpPoolCreate {
        pub description: String,
        pub name: Name,
    }

    impl From<&IpPoolCreate> for IpPoolCreate {
        fn from(value: &IpPoolCreate) -> Self {
            value.clone()
        }
    }

    impl IpPoolCreate {
        pub fn builder() -> builder::IpPoolCreate {
            Default::default()
        }
    }

    ///IpPoolRange
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "range",
    ///    "time_created"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "range": {
    ///      "$ref": "#/components/schemas/IpRange"
    ///    },
    ///    "time_created": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IpPoolRange {
        pub id: uuid::Uuid,
        pub range: IpRange,
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&IpPoolRange> for IpPoolRange {
        fn from(value: &IpPoolRange) -> Self {
            value.clone()
        }
    }

    impl IpPoolRange {
        pub fn builder() -> builder::IpPoolRange {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpPoolRange"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IpPoolRangeResultsPage {
        ///list of items on this page of results
        pub items: Vec<IpPoolRange>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&IpPoolRangeResultsPage> for IpPoolRangeResultsPage {
        fn from(value: &IpPoolRangeResultsPage) -> Self {
            value.clone()
        }
    }

    impl IpPoolRangeResultsPage {
        pub fn builder() -> builder::IpPoolRangeResultsPage {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpPool"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IpPoolResultsPage {
        ///list of items on this page of results
        pub items: Vec<IpPool>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&IpPoolResultsPage> for IpPoolResultsPage {
        fn from(value: &IpPoolResultsPage) -> Self {
            value.clone()
        }
    }

    impl IpPoolResultsPage {
        pub fn builder() -> builder::IpPoolResultsPage {
            Default::default()
        }
    }

    ///Parameters for updating an IP Pool
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameters for updating an IP Pool",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct IpPoolUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&IpPoolUpdate> for IpPoolUpdate {
        fn from(value: &IpPoolUpdate) -> Self {
            value.clone()
        }
    }

    impl IpPoolUpdate {
        pub fn builder() -> builder::IpPoolUpdate {
            Default::default()
        }
    }

    ///IpRange
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "title": "v4",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Range"
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "title": "v6",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Range"
    ///        }
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum IpRange {
        V4(Ipv4Range),
        V6(Ipv6Range),
    }

    impl From<&IpRange> for IpRange {
        fn from(value: &IpRange) -> Self {
            value.clone()
        }
    }

    impl From<Ipv4Range> for IpRange {
        fn from(value: Ipv4Range) -> Self {
            Self::V4(value)
        }
    }

    impl From<Ipv6Range> for IpRange {
        fn from(value: Ipv6Range) -> Self {
            Self::V6(value)
        }
    }

    ///An IPv4 subnet, including prefix and subnet mask
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "An IPv4 subnet",
    ///  "description": "An IPv4 subnet, including prefix and subnet mask",
    ///  "examples": [
    ///    "192.168.1.0/24"
    ///  ],
    ///  "type": "string",
    ///  "pattern":
    /// "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.
    /// ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/
    /// ([8-9]|1[0-9]|2[0-9]|3[0-2])$"
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub struct Ipv4Net(String);
    impl std::ops::Deref for Ipv4Net {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Ipv4Net> for String {
        fn from(value: Ipv4Net) -> Self {
            value.0
        }
    }

    impl From<&Ipv4Net> for Ipv4Net {
        fn from(value: &Ipv4Net) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for Ipv4Net {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new(
                "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.\
                 ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/\
                 ([8-9]|1[0-9]|2[0-9]|3[0-2])$",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err("doesn't match pattern \
                            \"^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.\
                            ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/\
                            ([8-9]|1[0-9]|2[0-9]|3[0-2])$\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for Ipv4Net {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Ipv4Net {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Ipv4Net {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for Ipv4Net {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A non-decreasing IPv4 address range, inclusive of both ends.
    ///
    ///The first address must be less than or equal to the last address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A non-decreasing IPv4 address range, inclusive of both
    /// ends.\n\nThe first address must be less than or equal to the last
    /// address.",
    ///  "type": "object",
    ///  "required": [
    ///    "first",
    ///    "last"
    ///  ],
    ///  "properties": {
    ///    "first": {
    ///      "type": "string",
    ///      "format": "ipv4"
    ///    },
    ///    "last": {
    ///      "type": "string",
    ///      "format": "ipv4"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Ipv4Range {
        pub first: std::net::Ipv4Addr,
        pub last: std::net::Ipv4Addr,
    }

    impl From<&Ipv4Range> for Ipv4Range {
        fn from(value: &Ipv4Range) -> Self {
            value.clone()
        }
    }

    impl Ipv4Range {
        pub fn builder() -> builder::Ipv4Range {
            Default::default()
        }
    }

    ///An IPv6 subnet, including prefix and subnet mask
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "An IPv6 subnet",
    ///  "description": "An IPv6 subnet, including prefix and subnet mask",
    ///  "examples": [
    ///    "fd12:3456::/64"
    ///  ],
    ///  "type": "string",
    ///  "pattern":
    /// "^([fF][dD])[0-9a-fA-F]{2}:(([0-9a-fA-F]{1,4}:){6}[0-9a-fA-F]{1,
    /// 4}|([0-9a-fA-F]{1,4}:){1,6}:)\\/([1-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub struct Ipv6Net(String);
    impl std::ops::Deref for Ipv6Net {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Ipv6Net> for String {
        fn from(value: Ipv6Net) -> Self {
            value.0
        }
    }

    impl From<&Ipv6Net> for Ipv6Net {
        fn from(value: &Ipv6Net) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for Ipv6Net {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new(
                "^([fF][dD])[0-9a-fA-F]{2}:(([0-9a-fA-F]{1,4}:){6}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,\
                 4}:){1,6}:)\\/([1-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err("doesn't match pattern \
                            \"^([fF][dD])[0-9a-fA-F]{2}:(([0-9a-fA-F]{1,4}:){6}[0-9a-fA-F]{1,\
                            4}|([0-9a-fA-F]{1,4}:){1,6}:)\\/\
                            ([1-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for Ipv6Net {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Ipv6Net {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Ipv6Net {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for Ipv6Net {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A non-decreasing IPv6 address range, inclusive of both ends.
    ///
    ///The first address must be less than or equal to the last address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A non-decreasing IPv6 address range, inclusive of both
    /// ends.\n\nThe first address must be less than or equal to the last
    /// address.",
    ///  "type": "object",
    ///  "required": [
    ///    "first",
    ///    "last"
    ///  ],
    ///  "properties": {
    ///    "first": {
    ///      "type": "string",
    ///      "format": "ipv6"
    ///    },
    ///    "last": {
    ///      "type": "string",
    ///      "format": "ipv6"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Ipv6Range {
        pub first: std::net::Ipv6Addr,
        pub last: std::net::Ipv6Addr,
    }

    impl From<&Ipv6Range> for Ipv6Range {
        fn from(value: &Ipv6Range) -> Self {
            value.clone()
        }
    }

    impl Ipv6Range {
        pub fn builder() -> builder::Ipv6Range {
            Default::default()
        }
    }

    ///An inclusive-inclusive range of IP ports. The second port may be omitted
    /// to represent a single port
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A range of IP ports",
    ///  "description": "An inclusive-inclusive range of IP ports. The second
    /// port may be omitted to represent a single port",
    ///  "examples": [
    ///    "22"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 11,
    ///  "minLength": 1,
    ///  "pattern": "^[0-9]{1,5}(-[0-9]{1,5})?$"
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub struct L4PortRange(String);
    impl std::ops::Deref for L4PortRange {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<L4PortRange> for String {
        fn from(value: L4PortRange) -> Self {
            value.0
        }
    }

    impl From<&L4PortRange> for L4PortRange {
        fn from(value: &L4PortRange) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for L4PortRange {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 11usize {
                return Err("longer than 11 characters".into());
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            if regress::Regex::new("^[0-9]{1,5}(-[0-9]{1,5})?$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9]{1,5}(-[0-9]{1,5})?$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for L4PortRange {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for L4PortRange {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for L4PortRange {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for L4PortRange {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A Media Access Control address, in EUI-48 format
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A MAC address",
    ///  "description": "A Media Access Control address, in EUI-48 format",
    ///  "examples": [
    ///    "ff:ff:ff:ff:ff:ff"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 17,
    ///  "minLength": 17,
    ///  "pattern": "^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$"
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub struct MacAddr(String);
    impl std::ops::Deref for MacAddr {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<MacAddr> for String {
        fn from(value: MacAddr) -> Self {
            value.0
        }
    }

    impl From<&MacAddr> for MacAddr {
        fn from(value: &MacAddr) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for MacAddr {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 17usize {
                return Err("longer than 17 characters".into());
            }
            if value.len() < 17usize {
                return Err("shorter than 17 characters".into());
            }
            if regress::Regex::new("^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err(
                    "doesn't match pattern \"^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for MacAddr {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for MacAddr {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for MacAddr {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for MacAddr {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A `Measurement` is a timestamped datum from a single metric
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `Measurement` is a timestamped datum from a single
    /// metric",
    ///  "type": "object",
    ///  "required": [
    ///    "datum",
    ///    "timestamp"
    ///  ],
    ///  "properties": {
    ///    "datum": {
    ///      "$ref": "#/components/schemas/Datum"
    ///    },
    ///    "timestamp": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Measurement {
        pub datum: Datum,
        pub timestamp: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Measurement> for Measurement {
        fn from(value: &Measurement) -> Self {
            value.clone()
        }
    }

    impl Measurement {
        pub fn builder() -> builder::Measurement {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Measurement"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct MeasurementResultsPage {
        ///list of items on this page of results
        pub items: Vec<Measurement>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&MeasurementResultsPage> for MeasurementResultsPage {
        fn from(value: &MeasurementResultsPage) -> Self {
            value.clone()
        }
    }

    impl MeasurementResultsPage {
        pub fn builder() -> builder::MeasurementResultsPage {
            Default::default()
        }
    }

    ///Names must begin with a lower case ASCII letter, be composed exclusively
    /// of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end
    /// with a '-'. Names cannot be a UUID though they may contain a UUID.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A name unique within the parent collection",
    ///  "description": "Names must begin with a lower case ASCII letter, be
    /// composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and
    /// '-', and may not end with a '-'. Names cannot be a UUID though they may
    /// contain a UUID.",
    ///  "type": "string",
    ///  "maxLength": 63,
    ///  "pattern":
    /// "^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*
    /// [a-zA-Z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub struct Name(String);
    impl std::ops::Deref for Name {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Name> for String {
        fn from(value: Name) -> Self {
            value.0
        }
    }

    impl From<&Name> for Name {
        fn from(value: &Name) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for Name {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 63usize {
                return Err("longer than 63 characters".into());
            }
            if regress :: Regex :: new ("^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]$\"" . into ()) ; }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for Name {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Name {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Name {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for Name {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///NameOrId
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "title": "id",
    ///      "allOf": [
    ///        {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "title": "name",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum NameOrId {
        Id(uuid::Uuid),
        Name(Name),
    }

    impl From<&NameOrId> for NameOrId {
        fn from(value: &NameOrId) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for NameOrId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Id(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Name(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }

    impl std::convert::TryFrom<&str> for NameOrId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NameOrId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NameOrId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ToString for NameOrId {
        fn to_string(&self) -> String {
            match self {
                Self::Id(x) => x.to_string(),
                Self::Name(x) => x.to_string(),
            }
        }
    }

    impl From<uuid::Uuid> for NameOrId {
        fn from(value: uuid::Uuid) -> Self {
            Self::Id(value)
        }
    }

    impl From<Name> for NameOrId {
        fn from(value: Name) -> Self {
            Self::Name(value)
        }
    }

    ///Supported set of sort modes for scanning by name or id
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Supported set of sort modes for scanning by name or
    /// id",
    ///  "oneOf": [
    ///    {
    ///      "description": "sort in increasing order of \"name\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "name_ascending"
    ///      ]
    ///    },
    ///    {
    ///      "description": "sort in decreasing order of \"name\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "name_descending"
    ///      ]
    ///    },
    ///    {
    ///      "description": "sort in increasing order of \"id\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "id_ascending"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum NameOrIdSortMode {
        ///sort in increasing order of "name"
        #[serde(rename = "name_ascending")]
        NameAscending,
        ///sort in decreasing order of "name"
        #[serde(rename = "name_descending")]
        NameDescending,
        ///sort in increasing order of "id"
        #[serde(rename = "id_ascending")]
        IdAscending,
    }

    impl From<&NameOrIdSortMode> for NameOrIdSortMode {
        fn from(value: &NameOrIdSortMode) -> Self {
            value.clone()
        }
    }

    impl ToString for NameOrIdSortMode {
        fn to_string(&self) -> String {
            match *self {
                Self::NameAscending => "name_ascending".to_string(),
                Self::NameDescending => "name_descending".to_string(),
                Self::IdAscending => "id_ascending".to_string(),
            }
        }
    }

    impl std::str::FromStr for NameOrIdSortMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "name_ascending" => Ok(Self::NameAscending),
                "name_descending" => Ok(Self::NameDescending),
                "id_ascending" => Ok(Self::IdAscending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for NameOrIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NameOrIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NameOrIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Supported set of sort modes for scanning by name only
    ///
    ///Currently, we only support scanning in ascending order.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Supported set of sort modes for scanning by name
    /// only\n\nCurrently, we only support scanning in ascending order.",
    ///  "oneOf": [
    ///    {
    ///      "description": "sort in increasing order of \"name\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "name_ascending"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum NameSortMode {
        ///sort in increasing order of "name"
        #[serde(rename = "name_ascending")]
        NameAscending,
    }

    impl From<&NameSortMode> for NameSortMode {
        fn from(value: &NameSortMode) -> Self {
            value.clone()
        }
    }

    impl ToString for NameSortMode {
        fn to_string(&self) -> String {
            match *self {
                Self::NameAscending => "name_ascending".to_string(),
            }
        }
    }

    impl std::str::FromStr for NameSortMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "name_ascending" => Ok(Self::NameAscending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for NameSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NameSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NameSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A `NetworkInterface` represents a virtual network interface device.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `NetworkInterface` represents a virtual network
    /// interface device.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "instance_id",
    ///    "ip",
    ///    "mac",
    ///    "name",
    ///    "primary",
    ///    "subnet_id",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "instance_id": {
    ///      "description": "The Instance to which the interface belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ip": {
    ///      "description": "The IP address assigned to this interface.",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "mac": {
    ///      "description": "The MAC address assigned to this interface.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/MacAddr"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "primary": {
    ///      "description": "True if this interface is the primary for the
    /// instance to which it's attached.",
    ///      "type": "boolean"
    ///    },
    ///    "subnet_id": {
    ///      "description": "The subnet to which the interface belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "The VPC to which the interface belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NetworkInterface {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///The Instance to which the interface belongs.
        pub instance_id: uuid::Uuid,
        ///The IP address assigned to this interface.
        pub ip: std::net::IpAddr,
        ///The MAC address assigned to this interface.
        pub mac: MacAddr,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///True if this interface is the primary for the instance to which it's
        /// attached.
        pub primary: bool,
        ///The subnet to which the interface belongs.
        pub subnet_id: uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///The VPC to which the interface belongs.
        pub vpc_id: uuid::Uuid,
    }

    impl From<&NetworkInterface> for NetworkInterface {
        fn from(value: &NetworkInterface) -> Self {
            value.clone()
        }
    }

    impl NetworkInterface {
        pub fn builder() -> builder::NetworkInterface {
            Default::default()
        }
    }

    ///Create-time parameters for a
    /// [`NetworkInterface`](omicron_common::api::external::NetworkInterface)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a [`NetworkInterface`](omicron_common::api::external::NetworkInterface)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name",
    ///    "subnet_name",
    ///    "vpc_name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "ip": {
    ///      "description": "The IP address for the interface. One will be
    /// auto-assigned if not provided.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "ip"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "subnet_name": {
    ///      "description": "The VPC Subnet in which to create the interface.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "vpc_name": {
    ///      "description": "The VPC in which to create the interface.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NetworkInterfaceCreate {
        pub description: String,
        ///The IP address for the interface. One will be auto-assigned if not
        /// provided.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ip: Option<std::net::IpAddr>,
        pub name: Name,
        ///The VPC Subnet in which to create the interface.
        pub subnet_name: Name,
        ///The VPC in which to create the interface.
        pub vpc_name: Name,
    }

    impl From<&NetworkInterfaceCreate> for NetworkInterfaceCreate {
        fn from(value: &NetworkInterfaceCreate) -> Self {
            value.clone()
        }
    }

    impl NetworkInterfaceCreate {
        pub fn builder() -> builder::NetworkInterfaceCreate {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NetworkInterface"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NetworkInterfaceResultsPage {
        ///list of items on this page of results
        pub items: Vec<NetworkInterface>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&NetworkInterfaceResultsPage> for NetworkInterfaceResultsPage {
        fn from(value: &NetworkInterfaceResultsPage) -> Self {
            value.clone()
        }
    }

    impl NetworkInterfaceResultsPage {
        pub fn builder() -> builder::NetworkInterfaceResultsPage {
            Default::default()
        }
    }

    ///Parameters for updating a
    /// [`NetworkInterface`](omicron_common::api::external::NetworkInterface).
    ///
    ///Note that modifying IP addresses for an interface is not yet supported,
    /// a new interface must be created instead.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameters for updating a
    /// [`NetworkInterface`](omicron_common::api::external::NetworkInterface).\
    /// n\nNote that modifying IP addresses for an interface is not yet
    /// supported, a new interface must be created instead.",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "primary": {
    ///      "description": "Make a secondary interface the instance's primary
    /// interface.\n\nIf applied to a secondary interface, that interface will
    /// become the primary on the next reboot of the instance. Note that this
    /// may have implications for routing between instances, as the new primary
    /// interface will be on a distinct subnet from the previous primary
    /// interface.\n\nNote that this can only be used to select a new primary
    /// interface for an instance. Requests to change the primary interface into
    /// a secondary will return an error.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct NetworkInterfaceUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
        ///Make a secondary interface the instance's primary interface.
        ///
        ///If applied to a secondary interface, that interface will become the
        /// primary on the next reboot of the instance. Note that this may have
        /// implications for routing between instances, as the new primary
        /// interface will be on a distinct subnet from the previous primary
        /// interface.
        ///
        ///Note that this can only be used to select a new primary interface
        /// for an instance. Requests to change the primary interface into a
        /// secondary will return an error.
        #[serde(default)]
        pub primary: bool,
    }

    impl From<&NetworkInterfaceUpdate> for NetworkInterfaceUpdate {
        fn from(value: &NetworkInterfaceUpdate) -> Self {
            value.clone()
        }
    }

    impl NetworkInterfaceUpdate {
        pub fn builder() -> builder::NetworkInterfaceUpdate {
            Default::default()
        }
    }

    ///Unique name for a saga [`Node`]
    ///
    ///Each node requires a string name that's unique within its DAG.  The name
    /// is used to identify its output.  Nodes that depend on a given node
    /// (either directly or indirectly) can access the node's output using its
    /// name.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unique name for a saga [`Node`]\n\nEach node requires a
    /// string name that's unique within its DAG.  The name is used to identify
    /// its output.  Nodes that depend on a given node (either directly or
    /// indirectly) can access the node's output using its name.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub struct NodeName(pub String);
    impl std::ops::Deref for NodeName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<NodeName> for String {
        fn from(value: NodeName) -> Self {
            value.0
        }
    }

    impl From<&NodeName> for NodeName {
        fn from(value: &NodeName) -> Self {
            value.clone()
        }
    }

    impl From<String> for NodeName {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for NodeName {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for NodeName {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Client view of an [`Organization`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of an [`Organization`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Organization {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Organization> for Organization {
        fn from(value: &Organization) -> Self {
            value.clone()
        }
    }

    impl Organization {
        pub fn builder() -> builder::Organization {
            Default::default()
        }
    }

    ///Create-time parameters for an
    /// [`Organization`](crate::external_api::views::Organization)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an
    /// [`Organization`](crate::external_api::views::Organization)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrganizationCreate {
        pub description: String,
        pub name: Name,
    }

    impl From<&OrganizationCreate> for OrganizationCreate {
        fn from(value: &OrganizationCreate) -> Self {
            value.clone()
        }
    }

    impl OrganizationCreate {
        pub fn builder() -> builder::OrganizationCreate {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Organization"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrganizationResultsPage {
        ///list of items on this page of results
        pub items: Vec<Organization>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&OrganizationResultsPage> for OrganizationResultsPage {
        fn from(value: &OrganizationResultsPage) -> Self {
            value.clone()
        }
    }

    impl OrganizationResultsPage {
        pub fn builder() -> builder::OrganizationResultsPage {
            Default::default()
        }
    }

    ///OrganizationRole
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "admin",
    ///    "collaborator",
    ///    "viewer"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum OrganizationRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl From<&OrganizationRole> for OrganizationRole {
        fn from(value: &OrganizationRole) -> Self {
            value.clone()
        }
    }

    impl ToString for OrganizationRole {
        fn to_string(&self) -> String {
            match *self {
                Self::Admin => "admin".to_string(),
                Self::Collaborator => "collaborator".to_string(),
                Self::Viewer => "viewer".to_string(),
            }
        }
    }

    impl std::str::FromStr for OrganizationRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OrganizationRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OrganizationRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OrganizationRole {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Policy`], which describes how this
    /// resource may be accessed\n\nNote that the Policy only describes access
    /// granted explicitly for this resource.  The policies of parent resources
    /// can also cause a user to have access to this resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "role_assignments"
    ///  ],
    ///  "properties": {
    ///    "role_assignments": {
    ///      "description": "Roles directly assigned on this resource",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/OrganizationRoleRoleAssignment"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrganizationRolePolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: Vec<OrganizationRoleRoleAssignment>,
    }

    impl From<&OrganizationRolePolicy> for OrganizationRolePolicy {
        fn from(value: &OrganizationRolePolicy) -> Self {
            value.clone()
        }
    }

    impl OrganizationRolePolicy {
        pub fn builder() -> builder::OrganizationRolePolicy {
            Default::default()
        }
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the assignment of a particular role on a
    /// particular resource to a particular identity (user, group, etc.)\n\nThe
    /// resource is not part of this structure.  Rather, [`RoleAssignment`]s are
    /// put into a [`Policy`] and that Policy is applied to a particular
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "identity_id",
    ///    "identity_type",
    ///    "role_name"
    ///  ],
    ///  "properties": {
    ///    "identity_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_type": {
    ///      "$ref": "#/components/schemas/IdentityType"
    ///    },
    ///    "role_name": {
    ///      "$ref": "#/components/schemas/OrganizationRole"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrganizationRoleRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: OrganizationRole,
    }

    impl From<&OrganizationRoleRoleAssignment> for OrganizationRoleRoleAssignment {
        fn from(value: &OrganizationRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    impl OrganizationRoleRoleAssignment {
        pub fn builder() -> builder::OrganizationRoleRoleAssignment {
            Default::default()
        }
    }

    ///Updateable properties of an
    /// [`Organization`](crate::external_api::views::Organization)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of an
    /// [`Organization`](crate::external_api::views::Organization)",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct OrganizationUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&OrganizationUpdate> for OrganizationUpdate {
        fn from(value: &OrganizationUpdate) -> Self {
            value.clone()
        }
    }

    impl OrganizationUpdate {
        pub fn builder() -> builder::OrganizationUpdate {
            Default::default()
        }
    }

    ///Passwords may be subject to additional constraints.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A password used to authenticate a user",
    ///  "description": "Passwords may be subject to additional constraints.",
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub struct Password(String);
    impl std::ops::Deref for Password {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Password> for String {
        fn from(value: Password) -> Self {
            value.0
        }
    }

    impl From<&Password> for Password {
        fn from(value: &Password) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for Password {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for Password {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Password {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Password {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for Password {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Client view of a [`PhysicalDisk`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`PhysicalDisk`]",
    ///  "type": "object",
    ///  "required": [
    ///    "disk_type",
    ///    "id",
    ///    "model",
    ///    "serial",
    ///    "time_created",
    ///    "time_modified",
    ///    "vendor"
    ///  ],
    ///  "properties": {
    ///    "disk_type": {
    ///      "$ref": "#/components/schemas/PhysicalDiskType"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "model": {
    ///      "type": "string"
    ///    },
    ///    "serial": {
    ///      "type": "string"
    ///    },
    ///    "sled_id": {
    ///      "description": "The sled to which this disk is attached, if any.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vendor": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PhysicalDisk {
        pub disk_type: PhysicalDiskType,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        pub model: String,
        pub serial: String,
        ///The sled to which this disk is attached, if any.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sled_id: Option<uuid::Uuid>,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub vendor: String,
    }

    impl From<&PhysicalDisk> for PhysicalDisk {
        fn from(value: &PhysicalDisk) -> Self {
            value.clone()
        }
    }

    impl PhysicalDisk {
        pub fn builder() -> builder::PhysicalDisk {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PhysicalDisk"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct PhysicalDiskResultsPage {
        ///list of items on this page of results
        pub items: Vec<PhysicalDisk>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&PhysicalDiskResultsPage> for PhysicalDiskResultsPage {
        fn from(value: &PhysicalDiskResultsPage) -> Self {
            value.clone()
        }
    }

    impl PhysicalDiskResultsPage {
        pub fn builder() -> builder::PhysicalDiskResultsPage {
            Default::default()
        }
    }

    ///PhysicalDiskType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "internal",
    ///    "external"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum PhysicalDiskType {
        #[serde(rename = "internal")]
        Internal,
        #[serde(rename = "external")]
        External,
    }

    impl From<&PhysicalDiskType> for PhysicalDiskType {
        fn from(value: &PhysicalDiskType) -> Self {
            value.clone()
        }
    }

    impl ToString for PhysicalDiskType {
        fn to_string(&self) -> String {
            match *self {
                Self::Internal => "internal".to_string(),
                Self::External => "external".to_string(),
            }
        }
    }

    impl std::str::FromStr for PhysicalDiskType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "internal" => Ok(Self::Internal),
                "external" => Ok(Self::External),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PhysicalDiskType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PhysicalDiskType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PhysicalDiskType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`Project`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Project`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "organization_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "organization_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Project {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub organization_id: uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Project> for Project {
        fn from(value: &Project) -> Self {
            value.clone()
        }
    }

    impl Project {
        pub fn builder() -> builder::Project {
            Default::default()
        }
    }

    ///Create-time parameters for a
    /// [`Project`](crate::external_api::views::Project)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Project`](crate::external_api::views::Project)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ProjectCreate {
        pub description: String,
        pub name: Name,
    }

    impl From<&ProjectCreate> for ProjectCreate {
        fn from(value: &ProjectCreate) -> Self {
            value.clone()
        }
    }

    impl ProjectCreate {
        pub fn builder() -> builder::ProjectCreate {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Project"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ProjectResultsPage {
        ///list of items on this page of results
        pub items: Vec<Project>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&ProjectResultsPage> for ProjectResultsPage {
        fn from(value: &ProjectResultsPage) -> Self {
            value.clone()
        }
    }

    impl ProjectResultsPage {
        pub fn builder() -> builder::ProjectResultsPage {
            Default::default()
        }
    }

    ///ProjectRole
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "admin",
    ///    "collaborator",
    ///    "viewer"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum ProjectRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl From<&ProjectRole> for ProjectRole {
        fn from(value: &ProjectRole) -> Self {
            value.clone()
        }
    }

    impl ToString for ProjectRole {
        fn to_string(&self) -> String {
            match *self {
                Self::Admin => "admin".to_string(),
                Self::Collaborator => "collaborator".to_string(),
                Self::Viewer => "viewer".to_string(),
            }
        }
    }

    impl std::str::FromStr for ProjectRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ProjectRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ProjectRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ProjectRole {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Policy`], which describes how this
    /// resource may be accessed\n\nNote that the Policy only describes access
    /// granted explicitly for this resource.  The policies of parent resources
    /// can also cause a user to have access to this resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "role_assignments"
    ///  ],
    ///  "properties": {
    ///    "role_assignments": {
    ///      "description": "Roles directly assigned on this resource",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ProjectRoleRoleAssignment"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ProjectRolePolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: Vec<ProjectRoleRoleAssignment>,
    }

    impl From<&ProjectRolePolicy> for ProjectRolePolicy {
        fn from(value: &ProjectRolePolicy) -> Self {
            value.clone()
        }
    }

    impl ProjectRolePolicy {
        pub fn builder() -> builder::ProjectRolePolicy {
            Default::default()
        }
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the assignment of a particular role on a
    /// particular resource to a particular identity (user, group, etc.)\n\nThe
    /// resource is not part of this structure.  Rather, [`RoleAssignment`]s are
    /// put into a [`Policy`] and that Policy is applied to a particular
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "identity_id",
    ///    "identity_type",
    ///    "role_name"
    ///  ],
    ///  "properties": {
    ///    "identity_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_type": {
    ///      "$ref": "#/components/schemas/IdentityType"
    ///    },
    ///    "role_name": {
    ///      "$ref": "#/components/schemas/ProjectRole"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ProjectRoleRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: ProjectRole,
    }

    impl From<&ProjectRoleRoleAssignment> for ProjectRoleRoleAssignment {
        fn from(value: &ProjectRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    impl ProjectRoleRoleAssignment {
        pub fn builder() -> builder::ProjectRoleRoleAssignment {
            Default::default()
        }
    }

    ///Updateable properties of a
    /// [`Project`](crate::external_api::views::Project)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a
    /// [`Project`](crate::external_api::views::Project)",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct ProjectUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&ProjectUpdate> for ProjectUpdate {
        fn from(value: &ProjectUpdate) -> Self {
            value.clone()
        }
    }

    impl ProjectUpdate {
        pub fn builder() -> builder::ProjectUpdate {
            Default::default()
        }
    }

    ///Client view of an [`Rack`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of an [`Rack`]",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Rack {
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Rack> for Rack {
        fn from(value: &Rack) -> Self {
            value.clone()
        }
    }

    impl Rack {
        pub fn builder() -> builder::Rack {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Rack"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RackResultsPage {
        ///list of items on this page of results
        pub items: Vec<Rack>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&RackResultsPage> for RackResultsPage {
        fn from(value: &RackResultsPage) -> Self {
            value.clone()
        }
    }

    impl RackResultsPage {
        pub fn builder() -> builder::RackResultsPage {
            Default::default()
        }
    }

    ///Client view of a [`Role`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Role`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/RoleName"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Role {
        pub description: String,
        pub name: RoleName,
    }

    impl From<&Role> for Role {
        fn from(value: &Role) -> Self {
            value.clone()
        }
    }

    impl Role {
        pub fn builder() -> builder::Role {
            Default::default()
        }
    }

    ///Role names consist of two string components separated by dot (".").
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A name for a built-in role",
    ///  "description": "Role names consist of two string components separated
    /// by dot (\".\").",
    ///  "type": "string",
    ///  "maxLength": 63,
    ///  "pattern": "[a-z-]+\\.[a-z-]+"
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub struct RoleName(String);
    impl std::ops::Deref for RoleName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<RoleName> for String {
        fn from(value: RoleName) -> Self {
            value.0
        }
    }

    impl From<&RoleName> for RoleName {
        fn from(value: &RoleName) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for RoleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 63usize {
                return Err("longer than 63 characters".into());
            }
            if regress::Regex::new("[a-z-]+\\.[a-z-]+")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"[a-z-]+\\.[a-z-]+\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for RoleName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RoleName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RoleName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for RoleName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Role"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RoleResultsPage {
        ///list of items on this page of results
        pub items: Vec<Role>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&RoleResultsPage> for RoleResultsPage {
        fn from(value: &RoleResultsPage) -> Self {
            value.clone()
        }
    }

    impl RoleResultsPage {
        pub fn builder() -> builder::RoleResultsPage {
            Default::default()
        }
    }

    ///A `RouteDestination` is used to match traffic with a routing rule, on
    /// the destination of that traffic.
    ///
    ///When traffic is to be sent to a destination that is within a given
    /// `RouteDestination`, the corresponding [`RouterRoute`] applies, and
    /// traffic will be forward to the [`RouteTarget`] for that rule.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `RouteDestination` is used to match traffic with a
    /// routing rule, on the destination of that traffic.\n\nWhen traffic is to
    /// be sent to a destination that is within a given `RouteDestination`, the
    /// corresponding [`RouterRoute`] applies, and traffic will be forward to
    /// the [`RouteTarget`] for that rule.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Route applies to traffic destined for a specific IP
    /// address",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Route applies to traffic destined for a specific IP
    /// subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip_net"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Route applies to traffic destined for the given
    /// VPC.",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Route applies to traffic",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteDestination {
        ///Route applies to traffic destined for a specific IP address
        #[serde(rename = "ip")]
        Ip(std::net::IpAddr),
        ///Route applies to traffic destined for a specific IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
        ///Route applies to traffic destined for the given VPC.
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///Route applies to traffic
        #[serde(rename = "subnet")]
        Subnet(Name),
    }

    impl From<&RouteDestination> for RouteDestination {
        fn from(value: &RouteDestination) -> Self {
            value.clone()
        }
    }

    impl From<std::net::IpAddr> for RouteDestination {
        fn from(value: std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    impl From<IpNet> for RouteDestination {
        fn from(value: IpNet) -> Self {
            Self::IpNet(value)
        }
    }

    ///A `RouteTarget` describes the possible locations that traffic matching a
    /// route destination can be sent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `RouteTarget` describes the possible locations that
    /// traffic matching a route destination can be sent.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Forward traffic to a particular IP address.",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to a VPC",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to a VPC Subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to a specific instance",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to an internet gateway",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "internet_gateway"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteTarget {
        ///Forward traffic to a particular IP address.
        #[serde(rename = "ip")]
        Ip(std::net::IpAddr),
        ///Forward traffic to a VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///Forward traffic to a VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        ///Forward traffic to a specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        ///Forward traffic to an internet gateway
        #[serde(rename = "internet_gateway")]
        InternetGateway(Name),
    }

    impl From<&RouteTarget> for RouteTarget {
        fn from(value: &RouteTarget) -> Self {
            value.clone()
        }
    }

    impl From<std::net::IpAddr> for RouteTarget {
        fn from(value: std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    ///A route defines a rule that governs where traffic should be sent based
    /// on its destination.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A route defines a rule that governs where traffic
    /// should be sent based on its destination.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "destination",
    ///    "id",
    ///    "kind",
    ///    "name",
    ///    "target",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_router_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "destination": {
    ///      "$ref": "#/components/schemas/RouteDestination"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "kind": {
    ///      "description": "Describes the kind of router. Set at creation.
    /// `read-only`",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/RouterRouteKind"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "target": {
    ///      "$ref": "#/components/schemas/RouteTarget"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_router_id": {
    ///      "description": "The VPC Router to which the route belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RouterRoute {
        ///human-readable free-form text about a resource
        pub description: String,
        pub destination: RouteDestination,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///Describes the kind of router. Set at creation. `read-only`
        pub kind: RouterRouteKind,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub target: RouteTarget,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///The VPC Router to which the route belongs.
        pub vpc_router_id: uuid::Uuid,
    }

    impl From<&RouterRoute> for RouterRoute {
        fn from(value: &RouterRoute) -> Self {
            value.clone()
        }
    }

    impl RouterRoute {
        pub fn builder() -> builder::RouterRoute {
            Default::default()
        }
    }

    ///Create-time parameters for a [`RouterRoute`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a [`RouterRoute`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "destination",
    ///    "name",
    ///    "target"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "destination": {
    ///      "$ref": "#/components/schemas/RouteDestination"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "target": {
    ///      "$ref": "#/components/schemas/RouteTarget"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RouterRouteCreateParams {
        pub description: String,
        pub destination: RouteDestination,
        pub name: Name,
        pub target: RouteTarget,
    }

    impl From<&RouterRouteCreateParams> for RouterRouteCreateParams {
        fn from(value: &RouterRouteCreateParams) -> Self {
            value.clone()
        }
    }

    impl RouterRouteCreateParams {
        pub fn builder() -> builder::RouterRouteCreateParams {
            Default::default()
        }
    }

    ///The classification of a [`RouterRoute`] as defined by the system. The
    /// kind determines certain attributes such as if the route is modifiable
    /// and describes how or where the route was created.
    ///
    ///See [RFD-21](https://rfd.shared.oxide.computer/rfd/0021#concept-router) for more context
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The classification of a [`RouterRoute`] as defined by the system. The kind determines certain attributes such as if the route is modifiable and describes how or where the route was created.\n\nSee [RFD-21](https://rfd.shared.oxide.computer/rfd/0021#concept-router) for more context",
    ///  "oneOf": [
    ///    {
    ///      "description": "Determines the default destination of traffic, such
    /// as whether it goes to the internet or not.\n\n`Destination: An Internet
    /// Gateway` `Modifiable: true`",
    ///      "type": "string",
    ///      "enum": [
    ///        "default"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Automatically added for each VPC Subnet in the
    /// VPC\n\n`Destination: A VPC Subnet` `Modifiable: false`",
    ///      "type": "string",
    ///      "enum": [
    ///        "vpc_subnet"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Automatically added when VPC peering is
    /// established\n\n`Destination: A different VPC` `Modifiable: false`",
    ///      "type": "string",
    ///      "enum": [
    ///        "vpc_peering"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Created by a user See
    /// [`RouteTarget`]\n\n`Destination: User defined` `Modifiable: true`",
    ///      "type": "string",
    ///      "enum": [
    ///        "custom"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum RouterRouteKind {
        ///Determines the default destination of traffic, such as whether it
        /// goes to the internet or not.
        ///
        ///`Destination: An Internet Gateway` `Modifiable: true`
        #[serde(rename = "default")]
        Default,
        ///Automatically added for each VPC Subnet in the VPC
        ///
        ///`Destination: A VPC Subnet` `Modifiable: false`
        #[serde(rename = "vpc_subnet")]
        VpcSubnet,
        ///Automatically added when VPC peering is established
        ///
        ///`Destination: A different VPC` `Modifiable: false`
        #[serde(rename = "vpc_peering")]
        VpcPeering,
        ///Created by a user See [`RouteTarget`]
        ///
        ///`Destination: User defined` `Modifiable: true`
        #[serde(rename = "custom")]
        Custom,
    }

    impl From<&RouterRouteKind> for RouterRouteKind {
        fn from(value: &RouterRouteKind) -> Self {
            value.clone()
        }
    }

    impl ToString for RouterRouteKind {
        fn to_string(&self) -> String {
            match *self {
                Self::Default => "default".to_string(),
                Self::VpcSubnet => "vpc_subnet".to_string(),
                Self::VpcPeering => "vpc_peering".to_string(),
                Self::Custom => "custom".to_string(),
            }
        }
    }

    impl std::str::FromStr for RouterRouteKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "default" => Ok(Self::Default),
                "vpc_subnet" => Ok(Self::VpcSubnet),
                "vpc_peering" => Ok(Self::VpcPeering),
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for RouterRouteKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RouterRouteKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RouterRouteKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RouterRoute"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RouterRouteResultsPage {
        ///list of items on this page of results
        pub items: Vec<RouterRoute>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&RouterRouteResultsPage> for RouterRouteResultsPage {
        fn from(value: &RouterRouteResultsPage) -> Self {
            value.clone()
        }
    }

    impl RouterRouteResultsPage {
        pub fn builder() -> builder::RouterRouteResultsPage {
            Default::default()
        }
    }

    ///Updateable properties of a [`RouterRoute`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a [`RouterRoute`]",
    ///  "type": "object",
    ///  "required": [
    ///    "destination",
    ///    "target"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "destination": {
    ///      "$ref": "#/components/schemas/RouteDestination"
    ///    },
    ///    "name": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "target": {
    ///      "$ref": "#/components/schemas/RouteTarget"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct RouterRouteUpdateParams {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        pub destination: RouteDestination,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
        pub target: RouteTarget,
    }

    impl From<&RouterRouteUpdateParams> for RouterRouteUpdateParams {
        fn from(value: &RouterRouteUpdateParams) -> Self {
            value.clone()
        }
    }

    impl RouterRouteUpdateParams {
        pub fn builder() -> builder::RouterRouteUpdateParams {
            Default::default()
        }
    }

    ///Saga
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "state"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/SagaState"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Saga {
        pub id: uuid::Uuid,
        pub state: SagaState,
    }

    impl From<&Saga> for Saga {
        fn from(value: &Saga) -> Self {
            value.clone()
        }
    }

    impl Saga {
        pub fn builder() -> builder::Saga {
            Default::default()
        }
    }

    ///SagaErrorInfo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error",
    ///        "source_error"
    ///      ],
    ///      "properties": {
    ///        "error": {
    ///          "type": "string",
    ///          "enum": [
    ///            "action_failed"
    ///          ]
    ///        },
    ///        "source_error": {}
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error",
    ///        "message"
    ///      ],
    ///      "properties": {
    ///        "error": {
    ///          "type": "string",
    ///          "enum": [
    ///            "deserialize_failed"
    ///          ]
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error"
    ///      ],
    ///      "properties": {
    ///        "error": {
    ///          "type": "string",
    ///          "enum": [
    ///            "injected_error"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error",
    ///        "message"
    ///      ],
    ///      "properties": {
    ///        "error": {
    ///          "type": "string",
    ///          "enum": [
    ///            "serialize_failed"
    ///          ]
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error",
    ///        "message"
    ///      ],
    ///      "properties": {
    ///        "error": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subsaga_create_failed"
    ///          ]
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "error")]
    pub enum SagaErrorInfo {
        #[serde(rename = "action_failed")]
        ActionFailed { source_error: serde_json::Value },
        #[serde(rename = "deserialize_failed")]
        DeserializeFailed { message: String },
        #[serde(rename = "injected_error")]
        InjectedError,
        #[serde(rename = "serialize_failed")]
        SerializeFailed { message: String },
        #[serde(rename = "subsaga_create_failed")]
        SubsagaCreateFailed { message: String },
    }

    impl From<&SagaErrorInfo> for SagaErrorInfo {
        fn from(value: &SagaErrorInfo) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Saga"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SagaResultsPage {
        ///list of items on this page of results
        pub items: Vec<Saga>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SagaResultsPage> for SagaResultsPage {
        fn from(value: &SagaResultsPage) -> Self {
            value.clone()
        }
    }

    impl SagaResultsPage {
        pub fn builder() -> builder::SagaResultsPage {
            Default::default()
        }
    }

    ///SagaState
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "running"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "succeeded"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error_info",
    ///        "error_node_name",
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "error_info": {
    ///          "$ref": "#/components/schemas/SagaErrorInfo"
    ///        },
    ///        "error_node_name": {
    ///          "$ref": "#/components/schemas/NodeName"
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "failed"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "state")]
    pub enum SagaState {
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "succeeded")]
        Succeeded,
        #[serde(rename = "failed")]
        Failed {
            error_info: SagaErrorInfo,
            error_node_name: NodeName,
        },
    }

    impl From<&SagaState> for SagaState {
        fn from(value: &SagaState) -> Self {
            value.clone()
        }
    }

    ///Identity-related metadata that's included in nearly all public API
    /// objects
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in nearly all
    /// public API objects",
    ///  "type": "object",
    ///  "required": [
    ///    "acs_url",
    ///    "description",
    ///    "id",
    ///    "idp_entity_id",
    ///    "name",
    ///    "slo_url",
    ///    "sp_client_id",
    ///    "technical_contact_email",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "acs_url": {
    ///      "description": "service provider endpoint where the response will
    /// be sent",
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "idp_entity_id": {
    ///      "description": "idp's entity id",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "public_cert": {
    ///      "description": "optional request signing public certificate (base64
    /// encoded der file)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "slo_url": {
    ///      "description": "service provider endpoint where the idp should send
    /// log out requests",
    ///      "type": "string"
    ///    },
    ///    "sp_client_id": {
    ///      "description": "sp's client id",
    ///      "type": "string"
    ///    },
    ///    "technical_contact_email": {
    ///      "description": "customer's technical contact for saml
    /// configuration",
    ///      "type": "string"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SamlIdentityProvider {
        ///service provider endpoint where the response will be sent
        pub acs_url: String,
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///idp's entity id
        pub idp_entity_id: String,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///optional request signing public certificate (base64 encoded der
        /// file)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public_cert: Option<String>,
        ///service provider endpoint where the idp should send log out requests
        pub slo_url: String,
        ///sp's client id
        pub sp_client_id: String,
        ///customer's technical contact for saml configuration
        pub technical_contact_email: String,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&SamlIdentityProvider> for SamlIdentityProvider {
        fn from(value: &SamlIdentityProvider) -> Self {
            value.clone()
        }
    }

    impl SamlIdentityProvider {
        pub fn builder() -> builder::SamlIdentityProvider {
            Default::default()
        }
    }

    ///Create-time identity-related parameters
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time identity-related parameters",
    ///  "type": "object",
    ///  "required": [
    ///    "acs_url",
    ///    "description",
    ///    "idp_entity_id",
    ///    "idp_metadata_source",
    ///    "name",
    ///    "slo_url",
    ///    "sp_client_id",
    ///    "technical_contact_email"
    ///  ],
    ///  "properties": {
    ///    "acs_url": {
    ///      "description": "service provider endpoint where the response will
    /// be sent",
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "group_attribute_name": {
    ///      "description": "If set, SAML attributes with this name will be
    /// considered to denote a user's group membership, where the attribute
    /// value(s) should be a comma-separated list of group names.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "idp_entity_id": {
    ///      "description": "idp's entity id",
    ///      "type": "string"
    ///    },
    ///    "idp_metadata_source": {
    ///      "description": "the source of an identity provider metadata
    /// descriptor",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IdpMetadataSource"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "signing_keypair": {
    ///      "description": "optional request signing key pair",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/DerEncodedKeyPair"
    ///        }
    ///      ]
    ///    },
    ///    "slo_url": {
    ///      "description": "service provider endpoint where the idp should send
    /// log out requests",
    ///      "type": "string"
    ///    },
    ///    "sp_client_id": {
    ///      "description": "sp's client id",
    ///      "type": "string"
    ///    },
    ///    "technical_contact_email": {
    ///      "description": "customer's technical contact for saml
    /// configuration",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SamlIdentityProviderCreate {
        ///service provider endpoint where the response will be sent
        pub acs_url: String,
        pub description: String,
        ///If set, SAML attributes with this name will be considered to denote
        /// a user's group membership, where the attribute value(s) should be a
        /// comma-separated list of group names.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub group_attribute_name: Option<String>,
        ///idp's entity id
        pub idp_entity_id: String,
        ///the source of an identity provider metadata descriptor
        pub idp_metadata_source: IdpMetadataSource,
        pub name: Name,
        ///optional request signing key pair
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signing_keypair: Option<DerEncodedKeyPair>,
        ///service provider endpoint where the idp should send log out requests
        pub slo_url: String,
        ///sp's client id
        pub sp_client_id: String,
        ///customer's technical contact for saml configuration
        pub technical_contact_email: String,
    }

    impl From<&SamlIdentityProviderCreate> for SamlIdentityProviderCreate {
        fn from(value: &SamlIdentityProviderCreate) -> Self {
            value.clone()
        }
    }

    impl SamlIdentityProviderCreate {
        pub fn builder() -> builder::SamlIdentityProviderCreate {
            Default::default()
        }
    }

    ///SemverVersion
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^\\d+\\.\\d+\\.\\d+([\\-\\+].+)?$"
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub struct SemverVersion(String);
    impl std::ops::Deref for SemverVersion {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<SemverVersion> for String {
        fn from(value: SemverVersion) -> Self {
            value.0
        }
    }

    impl From<&SemverVersion> for SemverVersion {
        fn from(value: &SemverVersion) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for SemverVersion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^\\d+\\.\\d+\\.\\d+([\\-\\+].+)?$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^\\d+\\.\\d+\\.\\d+([\\-\\+].+)?$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for SemverVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SemverVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SemverVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for SemverVersion {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The service intended to use this certificate.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The service intended to use this certificate.",
    ///  "oneOf": [
    ///    {
    ///      "description": "This certificate is intended for access to the
    /// external API.",
    ///      "type": "string",
    ///      "enum": [
    ///        "external_api"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum ServiceUsingCertificate {
        ///This certificate is intended for access to the external API.
        #[serde(rename = "external_api")]
        ExternalApi,
    }

    impl From<&ServiceUsingCertificate> for ServiceUsingCertificate {
        fn from(value: &ServiceUsingCertificate) -> Self {
            value.clone()
        }
    }

    impl ToString for ServiceUsingCertificate {
        fn to_string(&self) -> String {
            match *self {
                Self::ExternalApi => "external_api".to_string(),
            }
        }
    }

    impl std::str::FromStr for ServiceUsingCertificate {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "external_api" => Ok(Self::ExternalApi),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ServiceUsingCertificate {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ServiceUsingCertificate {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ServiceUsingCertificate {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a ['Silo']
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a ['Silo']",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "discoverable",
    ///    "id",
    ///    "identity_mode",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "discoverable": {
    ///      "description": "A silo where discoverable is false can be retrieved only by its id - it will not be part of the \"list all silos\" output.",
    ///      "type": "boolean"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_mode": {
    ///      "description": "How users and groups are managed in this Silo",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SiloIdentityMode"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Silo {
        ///human-readable free-form text about a resource
        pub description: String,
        ///A silo where discoverable is false can be retrieved only by its id -
        /// it will not be part of the "list all silos" output.
        pub discoverable: bool,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///How users and groups are managed in this Silo
        pub identity_mode: SiloIdentityMode,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Silo> for Silo {
        fn from(value: &Silo) -> Self {
            value.clone()
        }
    }

    impl Silo {
        pub fn builder() -> builder::Silo {
            Default::default()
        }
    }

    ///Create-time parameters for a [`Silo`](crate::external_api::views::Silo)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Silo`](crate::external_api::views::Silo)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "discoverable",
    ///    "identity_mode",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "admin_group_name": {
    ///      "description": "If set, this group will be created during Silo
    /// creation and granted the \"Silo Admin\" role. Identity providers can
    /// assert that users belong to this group and those users can log in and
    /// further initialize the Silo.\n\nNote that if configuring a SAML based
    /// identity provider, group_attribute_name must be set for users to be
    /// considered part of a group. See [`SamlIdentityProviderCreate`] for more
    /// information.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "discoverable": {
    ///      "type": "boolean"
    ///    },
    ///    "identity_mode": {
    ///      "$ref": "#/components/schemas/SiloIdentityMode"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SiloCreate {
        ///If set, this group will be created during Silo creation and granted
        /// the "Silo Admin" role. Identity providers can assert that users
        /// belong to this group and those users can log in and further
        /// initialize the Silo.
        ///
        ///Note that if configuring a SAML based identity provider,
        /// group_attribute_name must be set for users to be considered part of
        /// a group. See [`SamlIdentityProviderCreate`] for more information.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub admin_group_name: Option<String>,
        pub description: String,
        pub discoverable: bool,
        pub identity_mode: SiloIdentityMode,
        pub name: Name,
    }

    impl From<&SiloCreate> for SiloCreate {
        fn from(value: &SiloCreate) -> Self {
            value.clone()
        }
    }

    impl SiloCreate {
        pub fn builder() -> builder::SiloCreate {
            Default::default()
        }
    }

    ///Describes how identities are managed and users are authenticated in this
    /// Silo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes how identities are managed and users are
    /// authenticated in this Silo",
    ///  "oneOf": [
    ///    {
    ///      "description": "Users are authenticated with SAML using an external
    /// authentication provider.  The system updates information about users and
    /// groups only during successful authentication (i.e,. \"JIT provisioning\"
    /// of users and groups).",
    ///      "type": "string",
    ///      "enum": [
    ///        "saml_jit"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The system is the source of truth about users.
    /// There is no linkage to an external authentication provider or identity
    /// provider.",
    ///      "type": "string",
    ///      "enum": [
    ///        "local_only"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum SiloIdentityMode {
        ///Users are authenticated with SAML using an external authentication
        /// provider.  The system updates information about users and groups
        /// only during successful authentication (i.e,. "JIT provisioning" of
        /// users and groups).
        #[serde(rename = "saml_jit")]
        SamlJit,
        ///The system is the source of truth about users.  There is no linkage
        /// to an external authentication provider or identity provider.
        #[serde(rename = "local_only")]
        LocalOnly,
    }

    impl From<&SiloIdentityMode> for SiloIdentityMode {
        fn from(value: &SiloIdentityMode) -> Self {
            value.clone()
        }
    }

    impl ToString for SiloIdentityMode {
        fn to_string(&self) -> String {
            match *self {
                Self::SamlJit => "saml_jit".to_string(),
                Self::LocalOnly => "local_only".to_string(),
            }
        }
    }

    impl std::str::FromStr for SiloIdentityMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "saml_jit" => Ok(Self::SamlJit),
                "local_only" => Ok(Self::LocalOnly),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SiloIdentityMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SiloIdentityMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SiloIdentityMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Silo"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SiloResultsPage {
        ///list of items on this page of results
        pub items: Vec<Silo>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SiloResultsPage> for SiloResultsPage {
        fn from(value: &SiloResultsPage) -> Self {
            value.clone()
        }
    }

    impl SiloResultsPage {
        pub fn builder() -> builder::SiloResultsPage {
            Default::default()
        }
    }

    ///SiloRole
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "admin",
    ///    "collaborator",
    ///    "viewer"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum SiloRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl From<&SiloRole> for SiloRole {
        fn from(value: &SiloRole) -> Self {
            value.clone()
        }
    }

    impl ToString for SiloRole {
        fn to_string(&self) -> String {
            match *self {
                Self::Admin => "admin".to_string(),
                Self::Collaborator => "collaborator".to_string(),
                Self::Viewer => "viewer".to_string(),
            }
        }
    }

    impl std::str::FromStr for SiloRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SiloRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SiloRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SiloRole {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Policy`], which describes how this
    /// resource may be accessed\n\nNote that the Policy only describes access
    /// granted explicitly for this resource.  The policies of parent resources
    /// can also cause a user to have access to this resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "role_assignments"
    ///  ],
    ///  "properties": {
    ///    "role_assignments": {
    ///      "description": "Roles directly assigned on this resource",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SiloRoleRoleAssignment"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SiloRolePolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: Vec<SiloRoleRoleAssignment>,
    }

    impl From<&SiloRolePolicy> for SiloRolePolicy {
        fn from(value: &SiloRolePolicy) -> Self {
            value.clone()
        }
    }

    impl SiloRolePolicy {
        pub fn builder() -> builder::SiloRolePolicy {
            Default::default()
        }
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the assignment of a particular role on a
    /// particular resource to a particular identity (user, group, etc.)\n\nThe
    /// resource is not part of this structure.  Rather, [`RoleAssignment`]s are
    /// put into a [`Policy`] and that Policy is applied to a particular
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "identity_id",
    ///    "identity_type",
    ///    "role_name"
    ///  ],
    ///  "properties": {
    ///    "identity_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_type": {
    ///      "$ref": "#/components/schemas/IdentityType"
    ///    },
    ///    "role_name": {
    ///      "$ref": "#/components/schemas/SiloRole"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SiloRoleRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: SiloRole,
    }

    impl From<&SiloRoleRoleAssignment> for SiloRoleRoleAssignment {
        fn from(value: &SiloRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    impl SiloRoleRoleAssignment {
        pub fn builder() -> builder::SiloRoleRoleAssignment {
            Default::default()
        }
    }

    ///Client view of a [`Sled`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Sled`]",
    ///  "type": "object",
    ///  "required": [
    ///    "baseboard",
    ///    "id",
    ///    "service_address",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "baseboard": {
    ///      "$ref": "#/components/schemas/Baseboard"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "service_address": {
    ///      "type": "string"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Sled {
        pub baseboard: Baseboard,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        pub service_address: String,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Sled> for Sled {
        fn from(value: &Sled) -> Self {
            value.clone()
        }
    }

    impl Sled {
        pub fn builder() -> builder::Sled {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Sled"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SledResultsPage {
        ///list of items on this page of results
        pub items: Vec<Sled>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SledResultsPage> for SledResultsPage {
        fn from(value: &SledResultsPage) -> Self {
            value.clone()
        }
    }

    impl SledResultsPage {
        pub fn builder() -> builder::SledResultsPage {
            Default::default()
        }
    }

    ///Client view of a Snapshot
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a Snapshot",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "disk_id",
    ///    "id",
    ///    "name",
    ///    "project_id",
    ///    "size",
    ///    "state",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "disk_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "size": {
    ///      "$ref": "#/components/schemas/ByteCount"
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/SnapshotState"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Snapshot {
        ///human-readable free-form text about a resource
        pub description: String,
        pub disk_id: uuid::Uuid,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub project_id: uuid::Uuid,
        pub size: ByteCount,
        pub state: SnapshotState,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Snapshot> for Snapshot {
        fn from(value: &Snapshot) -> Self {
            value.clone()
        }
    }

    impl Snapshot {
        pub fn builder() -> builder::Snapshot {
            Default::default()
        }
    }

    ///Create-time parameters for a
    /// [`Snapshot`](crate::external_api::views::Snapshot)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Snapshot`](crate::external_api::views::Snapshot)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "disk",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "disk": {
    ///      "description": "The name of the disk to be snapshotted",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotCreate {
        pub description: String,
        ///The name of the disk to be snapshotted
        pub disk: Name,
        pub name: Name,
    }

    impl From<&SnapshotCreate> for SnapshotCreate {
        fn from(value: &SnapshotCreate) -> Self {
            value.clone()
        }
    }

    impl SnapshotCreate {
        pub fn builder() -> builder::SnapshotCreate {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Snapshot"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SnapshotResultsPage {
        ///list of items on this page of results
        pub items: Vec<Snapshot>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SnapshotResultsPage> for SnapshotResultsPage {
        fn from(value: &SnapshotResultsPage) -> Self {
            value.clone()
        }
    }

    impl SnapshotResultsPage {
        pub fn builder() -> builder::SnapshotResultsPage {
            Default::default()
        }
    }

    ///SnapshotState
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "creating",
    ///    "ready",
    ///    "faulted",
    ///    "destroyed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum SnapshotState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "ready")]
        Ready,
        #[serde(rename = "faulted")]
        Faulted,
        #[serde(rename = "destroyed")]
        Destroyed,
    }

    impl From<&SnapshotState> for SnapshotState {
        fn from(value: &SnapshotState) -> Self {
            value.clone()
        }
    }

    impl ToString for SnapshotState {
        fn to_string(&self) -> String {
            match *self {
                Self::Creating => "creating".to_string(),
                Self::Ready => "ready".to_string(),
                Self::Faulted => "faulted".to_string(),
                Self::Destroyed => "destroyed".to_string(),
            }
        }
    }

    impl std::str::FromStr for SnapshotState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "creating" => Ok(Self::Creating),
                "ready" => Ok(Self::Ready),
                "faulted" => Ok(Self::Faulted),
                "destroyed" => Ok(Self::Destroyed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SnapshotState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SnapshotState {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SnapshotState {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///SpoofLoginBody
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "username": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SpoofLoginBody {
        pub username: String,
    }

    impl From<&SpoofLoginBody> for SpoofLoginBody {
        fn from(value: &SpoofLoginBody) -> Self {
            value.clone()
        }
    }

    impl SpoofLoginBody {
        pub fn builder() -> builder::SpoofLoginBody {
            Default::default()
        }
    }

    ///Client view of a [`SshKey`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`SshKey`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "public_key",
    ///    "silo_user_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "public_key": {
    ///      "description": "SSH public key, e.g., `\"ssh-ed25519
    /// AAAAC3NzaC...\"`",
    ///      "type": "string"
    ///    },
    ///    "silo_user_id": {
    ///      "description": "The user to whom this key belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SshKey {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///SSH public key, e.g., `"ssh-ed25519 AAAAC3NzaC..."`
        pub public_key: String,
        ///The user to whom this key belongs
        pub silo_user_id: uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&SshKey> for SshKey {
        fn from(value: &SshKey) -> Self {
            value.clone()
        }
    }

    impl SshKey {
        pub fn builder() -> builder::SshKey {
            Default::default()
        }
    }

    ///Create-time parameters for an
    /// [`SshKey`](crate::external_api::views::SshKey)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an
    /// [`SshKey`](crate::external_api::views::SshKey)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name",
    ///    "public_key"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "public_key": {
    ///      "description": "SSH public key, e.g., `\"ssh-ed25519
    /// AAAAC3NzaC...\"`",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SshKeyCreate {
        pub description: String,
        pub name: Name,
        ///SSH public key, e.g., `"ssh-ed25519 AAAAC3NzaC..."`
        pub public_key: String,
    }

    impl From<&SshKeyCreate> for SshKeyCreate {
        fn from(value: &SshKeyCreate) -> Self {
            value.clone()
        }
    }

    impl SshKeyCreate {
        pub fn builder() -> builder::SshKeyCreate {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SshKey"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SshKeyResultsPage {
        ///list of items on this page of results
        pub items: Vec<SshKey>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SshKeyResultsPage> for SshKeyResultsPage {
        fn from(value: &SshKeyResultsPage) -> Self {
            value.clone()
        }
    }

    impl SshKeyResultsPage {
        pub fn builder() -> builder::SshKeyResultsPage {
            Default::default()
        }
    }

    ///SystemMetricName
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "virtual_disk_space_provisioned",
    ///    "cpus_provisioned",
    ///    "ram_provisioned"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum SystemMetricName {
        #[serde(rename = "virtual_disk_space_provisioned")]
        VirtualDiskSpaceProvisioned,
        #[serde(rename = "cpus_provisioned")]
        CpusProvisioned,
        #[serde(rename = "ram_provisioned")]
        RamProvisioned,
    }

    impl From<&SystemMetricName> for SystemMetricName {
        fn from(value: &SystemMetricName) -> Self {
            value.clone()
        }
    }

    impl ToString for SystemMetricName {
        fn to_string(&self) -> String {
            match *self {
                Self::VirtualDiskSpaceProvisioned => "virtual_disk_space_provisioned".to_string(),
                Self::CpusProvisioned => "cpus_provisioned".to_string(),
                Self::RamProvisioned => "ram_provisioned".to_string(),
            }
        }
    }

    impl std::str::FromStr for SystemMetricName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "virtual_disk_space_provisioned" => Ok(Self::VirtualDiskSpaceProvisioned),
                "cpus_provisioned" => Ok(Self::CpusProvisioned),
                "ram_provisioned" => Ok(Self::RamProvisioned),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SystemMetricName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SystemMetricName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SystemMetricName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Identity-related metadata that's included in "asset" public API objects
    /// (which generally have no name or description)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in \"asset\"
    /// public API objects (which generally have no name or description)",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "time_created",
    ///    "time_modified",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SystemUpdate {
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl From<&SystemUpdate> for SystemUpdate {
        fn from(value: &SystemUpdate) -> Self {
            value.clone()
        }
    }

    impl SystemUpdate {
        pub fn builder() -> builder::SystemUpdate {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SystemUpdate"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SystemUpdateResultsPage {
        ///list of items on this page of results
        pub items: Vec<SystemUpdate>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SystemUpdateResultsPage> for SystemUpdateResultsPage {
        fn from(value: &SystemUpdateResultsPage) -> Self {
            value.clone()
        }
    }

    impl SystemUpdateResultsPage {
        pub fn builder() -> builder::SystemUpdateResultsPage {
            Default::default()
        }
    }

    ///SystemUpdateStart
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SystemUpdateStart {
        pub version: SemverVersion,
    }

    impl From<&SystemUpdateStart> for SystemUpdateStart {
        fn from(value: &SystemUpdateStart) -> Self {
            value.clone()
        }
    }

    impl SystemUpdateStart {
        pub fn builder() -> builder::SystemUpdateStart {
            Default::default()
        }
    }

    ///SystemVersion
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "status",
    ///    "version_range"
    ///  ],
    ///  "properties": {
    ///    "status": {
    ///      "$ref": "#/components/schemas/UpdateStatus"
    ///    },
    ///    "version_range": {
    ///      "$ref": "#/components/schemas/VersionRange"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct SystemVersion {
        pub status: UpdateStatus,
        pub version_range: VersionRange,
    }

    impl From<&SystemVersion> for SystemVersion {
        fn from(value: &SystemVersion) -> Self {
            value.clone()
        }
    }

    impl SystemVersion {
        pub fn builder() -> builder::SystemVersion {
            Default::default()
        }
    }

    ///Names are constructed by concatenating the target and metric names with
    /// ':'. Target and metric names must be lowercase alphanumeric characters
    /// with '_' separating words.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "The name of a timeseries",
    ///  "description": "Names are constructed by concatenating the target and
    /// metric names with ':'. Target and metric names must be lowercase
    /// alphanumeric characters with '_' separating words.",
    ///  "type": "string",
    ///  "pattern":
    /// "(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*)"
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub struct TimeseriesName(String);
    impl std::ops::Deref for TimeseriesName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TimeseriesName> for String {
        fn from(value: TimeseriesName) -> Self {
            value.0
        }
    }

    impl From<&TimeseriesName> for TimeseriesName {
        fn from(value: &TimeseriesName) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for TimeseriesName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new(
                "(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*)",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err("doesn't match pattern \
                            \"(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*\
                            )(_([a-z0-9]+))*)\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for TimeseriesName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TimeseriesName {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TimeseriesName {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for TimeseriesName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The schema for a timeseries.
    ///
    ///This includes the name of the timeseries, as well as the datum type of
    /// its metric and the schema for each field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The schema for a timeseries.\n\nThis includes the name
    /// of the timeseries, as well as the datum type of its metric and the
    /// schema for each field.",
    ///  "type": "object",
    ///  "required": [
    ///    "created",
    ///    "datum_type",
    ///    "field_schema",
    ///    "timeseries_name"
    ///  ],
    ///  "properties": {
    ///    "created": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "datum_type": {
    ///      "$ref": "#/components/schemas/DatumType"
    ///    },
    ///    "field_schema": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/FieldSchema"
    ///      }
    ///    },
    ///    "timeseries_name": {
    ///      "$ref": "#/components/schemas/TimeseriesName"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct TimeseriesSchema {
        pub created: chrono::DateTime<chrono::offset::Utc>,
        pub datum_type: DatumType,
        pub field_schema: Vec<FieldSchema>,
        pub timeseries_name: TimeseriesName,
    }

    impl From<&TimeseriesSchema> for TimeseriesSchema {
        fn from(value: &TimeseriesSchema) -> Self {
            value.clone()
        }
    }

    impl TimeseriesSchema {
        pub fn builder() -> builder::TimeseriesSchema {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TimeseriesSchema"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct TimeseriesSchemaResultsPage {
        ///list of items on this page of results
        pub items: Vec<TimeseriesSchema>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&TimeseriesSchemaResultsPage> for TimeseriesSchemaResultsPage {
        fn from(value: &TimeseriesSchemaResultsPage) -> Self {
            value.clone()
        }
    }

    impl TimeseriesSchemaResultsPage {
        pub fn builder() -> builder::TimeseriesSchemaResultsPage {
            Default::default()
        }
    }

    ///Identity-related metadata that's included in "asset" public API objects
    /// (which generally have no name or description)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in \"asset\"
    /// public API objects (which generally have no name or description)",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "status",
    ///    "time_created",
    ///    "time_modified",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/UpdateStatus"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UpdateDeployment {
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        pub status: UpdateStatus,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl From<&UpdateDeployment> for UpdateDeployment {
        fn from(value: &UpdateDeployment) -> Self {
            value.clone()
        }
    }

    impl UpdateDeployment {
        pub fn builder() -> builder::UpdateDeployment {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UpdateDeployment"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UpdateDeploymentResultsPage {
        ///list of items on this page of results
        pub items: Vec<UpdateDeployment>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&UpdateDeploymentResultsPage> for UpdateDeploymentResultsPage {
        fn from(value: &UpdateDeploymentResultsPage) -> Self {
            value.clone()
        }
    }

    impl UpdateDeploymentResultsPage {
        pub fn builder() -> builder::UpdateDeploymentResultsPage {
            Default::default()
        }
    }

    ///UpdateStatus
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "status"
    ///      ],
    ///      "properties": {
    ///        "status": {
    ///          "type": "string",
    ///          "enum": [
    ///            "updating"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "status"
    ///      ],
    ///      "properties": {
    ///        "status": {
    ///          "type": "string",
    ///          "enum": [
    ///            "steady"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    #[serde(tag = "status")]
    pub enum UpdateStatus {
        #[serde(rename = "updating")]
        Updating,
        #[serde(rename = "steady")]
        Steady,
    }

    impl From<&UpdateStatus> for UpdateStatus {
        fn from(value: &UpdateStatus) -> Self {
            value.clone()
        }
    }

    impl ToString for UpdateStatus {
        fn to_string(&self) -> String {
            match *self {
                Self::Updating => "updating".to_string(),
                Self::Steady => "steady".to_string(),
            }
        }
    }

    impl std::str::FromStr for UpdateStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "updating" => Ok(Self::Updating),
                "steady" => Ok(Self::Steady),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for UpdateStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UpdateStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UpdateStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Identity-related metadata that's included in "asset" public API objects
    /// (which generally have no name or description)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in \"asset\"
    /// public API objects (which generally have no name or description)",
    ///  "type": "object",
    ///  "required": [
    ///    "component_type",
    ///    "device_id",
    ///    "id",
    ///    "status",
    ///    "system_version",
    ///    "time_created",
    ///    "time_modified",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "component_type": {
    ///      "$ref": "#/components/schemas/UpdateableComponentType"
    ///    },
    ///    "device_id": {
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/UpdateStatus"
    ///    },
    ///    "system_version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UpdateableComponent {
        pub component_type: UpdateableComponentType,
        pub device_id: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        pub status: UpdateStatus,
        pub system_version: SemverVersion,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl From<&UpdateableComponent> for UpdateableComponent {
        fn from(value: &UpdateableComponent) -> Self {
            value.clone()
        }
    }

    impl UpdateableComponent {
        pub fn builder() -> builder::UpdateableComponent {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UpdateableComponent"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UpdateableComponentResultsPage {
        ///list of items on this page of results
        pub items: Vec<UpdateableComponent>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&UpdateableComponentResultsPage> for UpdateableComponentResultsPage {
        fn from(value: &UpdateableComponentResultsPage) -> Self {
            value.clone()
        }
    }

    impl UpdateableComponentResultsPage {
        pub fn builder() -> builder::UpdateableComponentResultsPage {
            Default::default()
        }
    }

    ///UpdateableComponentType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bootloader_for_rot",
    ///    "bootloader_for_sp",
    ///    "bootloader_for_host_proc",
    ///    "hubris_for_psc_rot",
    ///    "hubris_for_psc_sp",
    ///    "hubris_for_sidecar_rot",
    ///    "hubris_for_sidecar_sp",
    ///    "hubris_for_gimlet_rot",
    ///    "hubris_for_gimlet_sp",
    ///    "helios_host_phase1",
    ///    "helios_host_phase2",
    ///    "host_omicron"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum UpdateableComponentType {
        #[serde(rename = "bootloader_for_rot")]
        BootloaderForRot,
        #[serde(rename = "bootloader_for_sp")]
        BootloaderForSp,
        #[serde(rename = "bootloader_for_host_proc")]
        BootloaderForHostProc,
        #[serde(rename = "hubris_for_psc_rot")]
        HubrisForPscRot,
        #[serde(rename = "hubris_for_psc_sp")]
        HubrisForPscSp,
        #[serde(rename = "hubris_for_sidecar_rot")]
        HubrisForSidecarRot,
        #[serde(rename = "hubris_for_sidecar_sp")]
        HubrisForSidecarSp,
        #[serde(rename = "hubris_for_gimlet_rot")]
        HubrisForGimletRot,
        #[serde(rename = "hubris_for_gimlet_sp")]
        HubrisForGimletSp,
        #[serde(rename = "helios_host_phase1")]
        HeliosHostPhase1,
        #[serde(rename = "helios_host_phase2")]
        HeliosHostPhase2,
        #[serde(rename = "host_omicron")]
        HostOmicron,
    }

    impl From<&UpdateableComponentType> for UpdateableComponentType {
        fn from(value: &UpdateableComponentType) -> Self {
            value.clone()
        }
    }

    impl ToString for UpdateableComponentType {
        fn to_string(&self) -> String {
            match *self {
                Self::BootloaderForRot => "bootloader_for_rot".to_string(),
                Self::BootloaderForSp => "bootloader_for_sp".to_string(),
                Self::BootloaderForHostProc => "bootloader_for_host_proc".to_string(),
                Self::HubrisForPscRot => "hubris_for_psc_rot".to_string(),
                Self::HubrisForPscSp => "hubris_for_psc_sp".to_string(),
                Self::HubrisForSidecarRot => "hubris_for_sidecar_rot".to_string(),
                Self::HubrisForSidecarSp => "hubris_for_sidecar_sp".to_string(),
                Self::HubrisForGimletRot => "hubris_for_gimlet_rot".to_string(),
                Self::HubrisForGimletSp => "hubris_for_gimlet_sp".to_string(),
                Self::HeliosHostPhase1 => "helios_host_phase1".to_string(),
                Self::HeliosHostPhase2 => "helios_host_phase2".to_string(),
                Self::HostOmicron => "host_omicron".to_string(),
            }
        }
    }

    impl std::str::FromStr for UpdateableComponentType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "bootloader_for_rot" => Ok(Self::BootloaderForRot),
                "bootloader_for_sp" => Ok(Self::BootloaderForSp),
                "bootloader_for_host_proc" => Ok(Self::BootloaderForHostProc),
                "hubris_for_psc_rot" => Ok(Self::HubrisForPscRot),
                "hubris_for_psc_sp" => Ok(Self::HubrisForPscSp),
                "hubris_for_sidecar_rot" => Ok(Self::HubrisForSidecarRot),
                "hubris_for_sidecar_sp" => Ok(Self::HubrisForSidecarSp),
                "hubris_for_gimlet_rot" => Ok(Self::HubrisForGimletRot),
                "hubris_for_gimlet_sp" => Ok(Self::HubrisForGimletSp),
                "helios_host_phase1" => Ok(Self::HeliosHostPhase1),
                "helios_host_phase2" => Ok(Self::HeliosHostPhase2),
                "host_omicron" => Ok(Self::HostOmicron),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for UpdateableComponentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UpdateableComponentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UpdateableComponentType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`User`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`User`]",
    ///  "type": "object",
    ///  "required": [
    ///    "display_name",
    ///    "id",
    ///    "silo_id"
    ///  ],
    ///  "properties": {
    ///    "display_name": {
    ///      "description": "Human-readable name that can identify the user",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "silo_id": {
    ///      "description": "Uuid of the silo to which this user belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct User {
        ///Human-readable name that can identify the user
        pub display_name: String,
        pub id: uuid::Uuid,
        ///Uuid of the silo to which this user belongs
        pub silo_id: uuid::Uuid,
    }

    impl From<&User> for User {
        fn from(value: &User) -> Self {
            value.clone()
        }
    }

    impl User {
        pub fn builder() -> builder::User {
            Default::default()
        }
    }

    ///Client view of a [`UserBuiltin`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`UserBuiltin`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UserBuiltin {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&UserBuiltin> for UserBuiltin {
        fn from(value: &UserBuiltin) -> Self {
            value.clone()
        }
    }

    impl UserBuiltin {
        pub fn builder() -> builder::UserBuiltin {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UserBuiltin"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UserBuiltinResultsPage {
        ///list of items on this page of results
        pub items: Vec<UserBuiltin>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&UserBuiltinResultsPage> for UserBuiltinResultsPage {
        fn from(value: &UserBuiltinResultsPage) -> Self {
            value.clone()
        }
    }

    impl UserBuiltinResultsPage {
        pub fn builder() -> builder::UserBuiltinResultsPage {
            Default::default()
        }
    }

    ///Create-time parameters for a [`User`](crate::external_api::views::User)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`User`](crate::external_api::views::User)",
    ///  "type": "object",
    ///  "required": [
    ///    "external_id",
    ///    "password"
    ///  ],
    ///  "properties": {
    ///    "external_id": {
    ///      "description": "username used to log in",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/UserId"
    ///        }
    ///      ]
    ///    },
    ///    "password": {
    ///      "description": "password used to log in",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/UserPassword"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UserCreate {
        ///username used to log in
        pub external_id: UserId,
        ///password used to log in
        pub password: UserPassword,
    }

    impl From<&UserCreate> for UserCreate {
        fn from(value: &UserCreate) -> Self {
            value.clone()
        }
    }

    impl UserCreate {
        pub fn builder() -> builder::UserCreate {
            Default::default()
        }
    }

    ///Names must begin with a lower case ASCII letter, be composed exclusively
    /// of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end
    /// with a '-'. Names cannot be a UUID though they may contain a UUID.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A name unique within the parent collection",
    ///  "description": "Names must begin with a lower case ASCII letter, be
    /// composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and
    /// '-', and may not end with a '-'. Names cannot be a UUID though they may
    /// contain a UUID.",
    ///  "type": "string",
    ///  "maxLength": 63,
    ///  "pattern":
    /// "^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*
    /// [a-zA-Z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub struct UserId(String);
    impl std::ops::Deref for UserId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<UserId> for String {
        fn from(value: UserId) -> Self {
            value.0
        }
    }

    impl From<&UserId> for UserId {
        fn from(value: &UserId) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for UserId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 63usize {
                return Err("longer than 63 characters".into());
            }
            if regress :: Regex :: new ("^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]$\"" . into ()) ; }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for UserId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UserId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UserId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for UserId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Parameters for setting a user's password
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameters for setting a user's password",
    ///  "oneOf": [
    ///    {
    ///      "description": "Sets the user's password to the provided value",
    ///      "type": "object",
    ///      "required": [
    ///        "details",
    ///        "user_password_value"
    ///      ],
    ///      "properties": {
    ///        "details": {
    ///          "$ref": "#/components/schemas/Password"
    ///        },
    ///        "user_password_value": {
    ///          "type": "string",
    ///          "enum": [
    ///            "password"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Invalidates any current password (disabling
    /// password authentication)",
    ///      "type": "object",
    ///      "required": [
    ///        "user_password_value"
    ///      ],
    ///      "properties": {
    ///        "user_password_value": {
    ///          "type": "string",
    ///          "enum": [
    ///            "invalid_password"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "user_password_value", content = "details")]
    pub enum UserPassword {
        ///Sets the user's password to the provided value
        #[serde(rename = "password")]
        Password(Password),
        #[serde(rename = "invalid_password")]
        InvalidPassword,
    }

    impl From<&UserPassword> for UserPassword {
        fn from(value: &UserPassword) -> Self {
            value.clone()
        }
    }

    impl From<Password> for UserPassword {
        fn from(value: Password) -> Self {
            Self::Password(value)
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/User"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UserResultsPage {
        ///list of items on this page of results
        pub items: Vec<User>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&UserResultsPage> for UserResultsPage {
        fn from(value: &UserResultsPage) -> Self {
            value.clone()
        }
    }

    impl UserResultsPage {
        pub fn builder() -> builder::UserResultsPage {
            Default::default()
        }
    }

    ///Credentials for local user login
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Credentials for local user login",
    ///  "type": "object",
    ///  "required": [
    ///    "password",
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "password": {
    ///      "$ref": "#/components/schemas/Password"
    ///    },
    ///    "username": {
    ///      "$ref": "#/components/schemas/UserId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct UsernamePasswordCredentials {
        pub password: Password,
        pub username: UserId,
    }

    impl From<&UsernamePasswordCredentials> for UsernamePasswordCredentials {
        fn from(value: &UsernamePasswordCredentials) -> Self {
            value.clone()
        }
    }

    impl UsernamePasswordCredentials {
        pub fn builder() -> builder::UsernamePasswordCredentials {
            Default::default()
        }
    }

    ///VersionRange
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "high",
    ///    "low"
    ///  ],
    ///  "properties": {
    ///    "high": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    },
    ///    "low": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VersionRange {
        pub high: SemverVersion,
        pub low: SemverVersion,
    }

    impl From<&VersionRange> for VersionRange {
        fn from(value: &VersionRange) -> Self {
            value.clone()
        }
    }

    impl VersionRange {
        pub fn builder() -> builder::VersionRange {
            Default::default()
        }
    }

    ///Client view of a [`Vpc`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Vpc`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "dns_name",
    ///    "id",
    ///    "ipv6_prefix",
    ///    "name",
    ///    "project_id",
    ///    "system_router_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "dns_name": {
    ///      "description": "The name used for the VPC in DNS.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ipv6_prefix": {
    ///      "description": "The unique local IPv6 address range for subnets in
    /// this VPC",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Net"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "description": "id for the project containing this VPC",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "system_router_id": {
    ///      "description": "id for the system router where subnet default
    /// routes are registered",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct Vpc {
        ///human-readable free-form text about a resource
        pub description: String,
        ///The name used for the VPC in DNS.
        pub dns_name: Name,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///The unique local IPv6 address range for subnets in this VPC
        pub ipv6_prefix: Ipv6Net,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///id for the project containing this VPC
        pub project_id: uuid::Uuid,
        ///id for the system router where subnet default routes are registered
        pub system_router_id: uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Vpc> for Vpc {
        fn from(value: &Vpc) -> Self {
            value.clone()
        }
    }

    impl Vpc {
        pub fn builder() -> builder::Vpc {
            Default::default()
        }
    }

    ///Create-time parameters for a [`Vpc`](crate::external_api::views::Vpc)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Vpc`](crate::external_api::views::Vpc)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "dns_name",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "dns_name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "ipv6_prefix": {
    ///      "description": "The IPv6 prefix for this VPC.\n\nAll IPv6 subnets
    /// created from this VPC must be taken from this range, which sould be a
    /// Unique Local Address in the range `fd00::/48`. The default VPC Subnet
    /// will have the first `/64` range from this prefix.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Net"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcCreate {
        pub description: String,
        pub dns_name: Name,
        ///The IPv6 prefix for this VPC.
        ///
        ///All IPv6 subnets created from this VPC must be taken from this
        /// range, which sould be a Unique Local Address in the range
        /// `fd00::/48`. The default VPC Subnet will have the first `/64` range
        /// from this prefix.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ipv6_prefix: Option<Ipv6Net>,
        pub name: Name,
    }

    impl From<&VpcCreate> for VpcCreate {
        fn from(value: &VpcCreate) -> Self {
            value.clone()
        }
    }

    impl VpcCreate {
        pub fn builder() -> builder::VpcCreate {
            Default::default()
        }
    }

    ///A single rule in a VPC firewall
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single rule in a VPC firewall",
    ///  "type": "object",
    ///  "required": [
    ///    "action",
    ///    "description",
    ///    "direction",
    ///    "filters",
    ///    "id",
    ///    "name",
    ///    "priority",
    ///    "status",
    ///    "targets",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "whether traffic matching the rule should be allowed
    /// or dropped",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleAction"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "direction": {
    ///      "description": "whether this rule is for incoming or outgoing
    /// traffic",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleDirection"
    ///        }
    ///      ]
    ///    },
    ///    "filters": {
    ///      "description": "reductions on the scope of the rule",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleFilter"
    ///        }
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "priority": {
    ///      "description": "the relative priority of this rule",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "status": {
    ///      "description": "whether this rule is in effect",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleStatus"
    ///        }
    ///      ]
    ///    },
    ///    "targets": {
    ///      "description": "list of sets of instances that the rule applies
    /// to",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleTarget"
    ///      }
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "the VPC to which this rule belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcFirewallRule {
        ///whether traffic matching the rule should be allowed or dropped
        pub action: VpcFirewallRuleAction,
        ///human-readable free-form text about a resource
        pub description: String,
        ///whether this rule is for incoming or outgoing traffic
        pub direction: VpcFirewallRuleDirection,
        ///reductions on the scope of the rule
        pub filters: VpcFirewallRuleFilter,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///the relative priority of this rule
        pub priority: u16,
        ///whether this rule is in effect
        pub status: VpcFirewallRuleStatus,
        ///list of sets of instances that the rule applies to
        pub targets: Vec<VpcFirewallRuleTarget>,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///the VPC to which this rule belongs
        pub vpc_id: uuid::Uuid,
    }

    impl From<&VpcFirewallRule> for VpcFirewallRule {
        fn from(value: &VpcFirewallRule) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRule {
        pub fn builder() -> builder::VpcFirewallRule {
            Default::default()
        }
    }

    ///VpcFirewallRuleAction
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "allow",
    ///    "deny"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum VpcFirewallRuleAction {
        #[serde(rename = "allow")]
        Allow,
        #[serde(rename = "deny")]
        Deny,
    }

    impl From<&VpcFirewallRuleAction> for VpcFirewallRuleAction {
        fn from(value: &VpcFirewallRuleAction) -> Self {
            value.clone()
        }
    }

    impl ToString for VpcFirewallRuleAction {
        fn to_string(&self) -> String {
            match *self {
                Self::Allow => "allow".to_string(),
                Self::Deny => "deny".to_string(),
            }
        }
    }

    impl std::str::FromStr for VpcFirewallRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "allow" => Ok(Self::Allow),
                "deny" => Ok(Self::Deny),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VpcFirewallRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VpcFirewallRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VpcFirewallRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///VpcFirewallRuleDirection
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "inbound",
    ///    "outbound"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum VpcFirewallRuleDirection {
        #[serde(rename = "inbound")]
        Inbound,
        #[serde(rename = "outbound")]
        Outbound,
    }

    impl From<&VpcFirewallRuleDirection> for VpcFirewallRuleDirection {
        fn from(value: &VpcFirewallRuleDirection) -> Self {
            value.clone()
        }
    }

    impl ToString for VpcFirewallRuleDirection {
        fn to_string(&self) -> String {
            match *self {
                Self::Inbound => "inbound".to_string(),
                Self::Outbound => "outbound".to_string(),
            }
        }
    }

    impl std::str::FromStr for VpcFirewallRuleDirection {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "inbound" => Ok(Self::Inbound),
                "outbound" => Ok(Self::Outbound),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VpcFirewallRuleDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VpcFirewallRuleDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VpcFirewallRuleDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Filter for a firewall rule. A given packet must match every field that
    /// is present for the rule to apply to it. A packet matches a field if any
    /// entry in that field matches the packet.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Filter for a firewall rule. A given packet must match
    /// every field that is present for the rule to apply to it. A packet
    /// matches a field if any entry in that field matches the packet.",
    ///  "type": "object",
    ///  "properties": {
    ///    "hosts": {
    ///      "description": "If present, the sources (if incoming) or
    /// destinations (if outgoing) this rule applies to.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleHostFilter"
    ///      }
    ///    },
    ///    "ports": {
    ///      "description": "If present, the destination ports this rule applies
    /// to.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/L4PortRange"
    ///      }
    ///    },
    ///    "protocols": {
    ///      "description": "If present, the networking protocols this rule
    /// applies to.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleProtocol"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcFirewallRuleFilter {
        ///If present, the sources (if incoming) or destinations (if outgoing)
        /// this rule applies to.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hosts: Option<Vec<VpcFirewallRuleHostFilter>>,
        ///If present, the destination ports this rule applies to.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ports: Option<Vec<L4PortRange>>,
        ///If present, the networking protocols this rule applies to.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub protocols: Option<Vec<VpcFirewallRuleProtocol>>,
    }

    impl From<&VpcFirewallRuleFilter> for VpcFirewallRuleFilter {
        fn from(value: &VpcFirewallRuleFilter) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRuleFilter {
        pub fn builder() -> builder::VpcFirewallRuleFilter {
            Default::default()
        }
    }

    ///The `VpcFirewallRuleHostFilter` is used to filter traffic on the basis
    /// of its source or destination host.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The `VpcFirewallRuleHostFilter` is used to filter
    /// traffic on the basis of its source or destination host.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The rule applies to traffic from/to all instances
    /// in the VPC",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to all instances
    /// in the VPC Subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to this specific
    /// instance",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to a specific IP
    /// address",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to a specific IP
    /// subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip_net"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleHostFilter {
        ///The rule applies to traffic from/to all instances in the VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///The rule applies to traffic from/to all instances in the VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        ///The rule applies to traffic from/to this specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        ///The rule applies to traffic from/to a specific IP address
        #[serde(rename = "ip")]
        Ip(std::net::IpAddr),
        ///The rule applies to traffic from/to a specific IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    impl From<&VpcFirewallRuleHostFilter> for VpcFirewallRuleHostFilter {
        fn from(value: &VpcFirewallRuleHostFilter) -> Self {
            value.clone()
        }
    }

    impl From<std::net::IpAddr> for VpcFirewallRuleHostFilter {
        fn from(value: std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    impl From<IpNet> for VpcFirewallRuleHostFilter {
        fn from(value: IpNet) -> Self {
            Self::IpNet(value)
        }
    }

    ///The protocols that may be specified in a firewall rule's filter
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The protocols that may be specified in a firewall
    /// rule's filter",
    ///  "type": "string",
    ///  "enum": [
    ///    "TCP",
    ///    "UDP",
    ///    "ICMP"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum VpcFirewallRuleProtocol {
        #[serde(rename = "TCP")]
        Tcp,
        #[serde(rename = "UDP")]
        Udp,
        #[serde(rename = "ICMP")]
        Icmp,
    }

    impl From<&VpcFirewallRuleProtocol> for VpcFirewallRuleProtocol {
        fn from(value: &VpcFirewallRuleProtocol) -> Self {
            value.clone()
        }
    }

    impl ToString for VpcFirewallRuleProtocol {
        fn to_string(&self) -> String {
            match *self {
                Self::Tcp => "TCP".to_string(),
                Self::Udp => "UDP".to_string(),
                Self::Icmp => "ICMP".to_string(),
            }
        }
    }

    impl std::str::FromStr for VpcFirewallRuleProtocol {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TCP" => Ok(Self::Tcp),
                "UDP" => Ok(Self::Udp),
                "ICMP" => Ok(Self::Icmp),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VpcFirewallRuleProtocol {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VpcFirewallRuleProtocol {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VpcFirewallRuleProtocol {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///VpcFirewallRuleStatus
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "disabled",
    ///    "enabled"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum VpcFirewallRuleStatus {
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "enabled")]
        Enabled,
    }

    impl From<&VpcFirewallRuleStatus> for VpcFirewallRuleStatus {
        fn from(value: &VpcFirewallRuleStatus) -> Self {
            value.clone()
        }
    }

    impl ToString for VpcFirewallRuleStatus {
        fn to_string(&self) -> String {
            match *self {
                Self::Disabled => "disabled".to_string(),
                Self::Enabled => "enabled".to_string(),
            }
        }
    }

    impl std::str::FromStr for VpcFirewallRuleStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "disabled" => Ok(Self::Disabled),
                "enabled" => Ok(Self::Enabled),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VpcFirewallRuleStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VpcFirewallRuleStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VpcFirewallRuleStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A `VpcFirewallRuleTarget` is used to specify the set of [`Instance`]s to
    /// which a firewall rule applies.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `VpcFirewallRuleTarget` is used to specify the set of
    /// [`Instance`]s to which a firewall rule applies.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The rule applies to all instances in the VPC",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to all instances in the VPC
    /// Subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to this specific instance",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to a specific IP address",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to a specific IP subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip_net"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleTarget {
        ///The rule applies to all instances in the VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///The rule applies to all instances in the VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        ///The rule applies to this specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        ///The rule applies to a specific IP address
        #[serde(rename = "ip")]
        Ip(std::net::IpAddr),
        ///The rule applies to a specific IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    impl From<&VpcFirewallRuleTarget> for VpcFirewallRuleTarget {
        fn from(value: &VpcFirewallRuleTarget) -> Self {
            value.clone()
        }
    }

    impl From<std::net::IpAddr> for VpcFirewallRuleTarget {
        fn from(value: std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    impl From<IpNet> for VpcFirewallRuleTarget {
        fn from(value: IpNet) -> Self {
            Self::IpNet(value)
        }
    }

    ///A single rule in a VPC firewall
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single rule in a VPC firewall",
    ///  "type": "object",
    ///  "required": [
    ///    "action",
    ///    "description",
    ///    "direction",
    ///    "filters",
    ///    "name",
    ///    "priority",
    ///    "status",
    ///    "targets"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "whether traffic matching the rule should be allowed
    /// or dropped",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleAction"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "direction": {
    ///      "description": "whether this rule is for incoming or outgoing
    /// traffic",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleDirection"
    ///        }
    ///      ]
    ///    },
    ///    "filters": {
    ///      "description": "reductions on the scope of the rule",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleFilter"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "name of the rule, unique to this VPC",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "priority": {
    ///      "description": "the relative priority of this rule",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "status": {
    ///      "description": "whether this rule is in effect",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleStatus"
    ///        }
    ///      ]
    ///    },
    ///    "targets": {
    ///      "description": "list of sets of instances that the rule applies
    /// to",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleTarget"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcFirewallRuleUpdate {
        ///whether traffic matching the rule should be allowed or dropped
        pub action: VpcFirewallRuleAction,
        ///human-readable free-form text about a resource
        pub description: String,
        ///whether this rule is for incoming or outgoing traffic
        pub direction: VpcFirewallRuleDirection,
        ///reductions on the scope of the rule
        pub filters: VpcFirewallRuleFilter,
        ///name of the rule, unique to this VPC
        pub name: Name,
        ///the relative priority of this rule
        pub priority: u16,
        ///whether this rule is in effect
        pub status: VpcFirewallRuleStatus,
        ///list of sets of instances that the rule applies to
        pub targets: Vec<VpcFirewallRuleTarget>,
    }

    impl From<&VpcFirewallRuleUpdate> for VpcFirewallRuleUpdate {
        fn from(value: &VpcFirewallRuleUpdate) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRuleUpdate {
        pub fn builder() -> builder::VpcFirewallRuleUpdate {
            Default::default()
        }
    }

    ///Updateable properties of a `Vpc`'s firewall Note that VpcFirewallRules
    /// are implicitly created along with a Vpc, so there is no explicit
    /// creation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a `Vpc`'s firewall Note that
    /// VpcFirewallRules are implicitly created along with a Vpc, so there is no
    /// explicit creation.",
    ///  "type": "object",
    ///  "required": [
    ///    "rules"
    ///  ],
    ///  "properties": {
    ///    "rules": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleUpdate"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcFirewallRuleUpdateParams {
        pub rules: Vec<VpcFirewallRuleUpdate>,
    }

    impl From<&VpcFirewallRuleUpdateParams> for VpcFirewallRuleUpdateParams {
        fn from(value: &VpcFirewallRuleUpdateParams) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRuleUpdateParams {
        pub fn builder() -> builder::VpcFirewallRuleUpdateParams {
            Default::default()
        }
    }

    ///Collection of a Vpc's firewall rules
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Collection of a Vpc's firewall rules",
    ///  "type": "object",
    ///  "required": [
    ///    "rules"
    ///  ],
    ///  "properties": {
    ///    "rules": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRule"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcFirewallRules {
        pub rules: Vec<VpcFirewallRule>,
    }

    impl From<&VpcFirewallRules> for VpcFirewallRules {
        fn from(value: &VpcFirewallRules) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRules {
        pub fn builder() -> builder::VpcFirewallRules {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Vpc"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcResultsPage {
        ///list of items on this page of results
        pub items: Vec<Vpc>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&VpcResultsPage> for VpcResultsPage {
        fn from(value: &VpcResultsPage) -> Self {
            value.clone()
        }
    }

    impl VpcResultsPage {
        pub fn builder() -> builder::VpcResultsPage {
            Default::default()
        }
    }

    ///A VPC router defines a series of rules that indicate where traffic
    /// should be sent depending on its destination.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A VPC router defines a series of rules that indicate
    /// where traffic should be sent depending on its destination.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "kind",
    ///    "name",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "kind": {
    ///      "$ref": "#/components/schemas/VpcRouterKind"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "The VPC to which the router belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcRouter {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        pub kind: VpcRouterKind,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///The VPC to which the router belongs.
        pub vpc_id: uuid::Uuid,
    }

    impl From<&VpcRouter> for VpcRouter {
        fn from(value: &VpcRouter) -> Self {
            value.clone()
        }
    }

    impl VpcRouter {
        pub fn builder() -> builder::VpcRouter {
            Default::default()
        }
    }

    ///Create-time parameters for a
    /// [`VpcRouter`](crate::external_api::views::VpcRouter)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`VpcRouter`](crate::external_api::views::VpcRouter)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcRouterCreate {
        pub description: String,
        pub name: Name,
    }

    impl From<&VpcRouterCreate> for VpcRouterCreate {
        fn from(value: &VpcRouterCreate) -> Self {
            value.clone()
        }
    }

    impl VpcRouterCreate {
        pub fn builder() -> builder::VpcRouterCreate {
            Default::default()
        }
    }

    ///VpcRouterKind
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "system",
    ///    "custom"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
    pub enum VpcRouterKind {
        #[serde(rename = "system")]
        System,
        #[serde(rename = "custom")]
        Custom,
    }

    impl From<&VpcRouterKind> for VpcRouterKind {
        fn from(value: &VpcRouterKind) -> Self {
            value.clone()
        }
    }

    impl ToString for VpcRouterKind {
        fn to_string(&self) -> String {
            match *self {
                Self::System => "system".to_string(),
                Self::Custom => "custom".to_string(),
            }
        }
    }

    impl std::str::FromStr for VpcRouterKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "system" => Ok(Self::System),
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VpcRouterKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VpcRouterKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VpcRouterKind {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcRouter"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcRouterResultsPage {
        ///list of items on this page of results
        pub items: Vec<VpcRouter>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&VpcRouterResultsPage> for VpcRouterResultsPage {
        fn from(value: &VpcRouterResultsPage) -> Self {
            value.clone()
        }
    }

    impl VpcRouterResultsPage {
        pub fn builder() -> builder::VpcRouterResultsPage {
            Default::default()
        }
    }

    ///Updateable properties of a
    /// [`VpcRouter`](crate::external_api::views::VpcRouter)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a
    /// [`VpcRouter`](crate::external_api::views::VpcRouter)",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcRouterUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&VpcRouterUpdate> for VpcRouterUpdate {
        fn from(value: &VpcRouterUpdate) -> Self {
            value.clone()
        }
    }

    impl VpcRouterUpdate {
        pub fn builder() -> builder::VpcRouterUpdate {
            Default::default()
        }
    }

    ///A VPC subnet represents a logical grouping for instances that allows
    /// network traffic between them, within a IPv4 subnetwork or optionall an
    /// IPv6 subnetwork.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A VPC subnet represents a logical grouping for
    /// instances that allows network traffic between them, within a IPv4
    /// subnetwork or optionall an IPv6 subnetwork.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "ipv4_block",
    ///    "ipv6_block",
    ///    "name",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ipv4_block": {
    ///      "description": "The IPv4 subnet CIDR block.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Net"
    ///        }
    ///      ]
    ///    },
    ///    "ipv6_block": {
    ///      "description": "The IPv6 subnet CIDR block.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Net"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "The VPC to which the subnet belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcSubnet {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///The IPv4 subnet CIDR block.
        pub ipv4_block: Ipv4Net,
        ///The IPv6 subnet CIDR block.
        pub ipv6_block: Ipv6Net,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///The VPC to which the subnet belongs.
        pub vpc_id: uuid::Uuid,
    }

    impl From<&VpcSubnet> for VpcSubnet {
        fn from(value: &VpcSubnet) -> Self {
            value.clone()
        }
    }

    impl VpcSubnet {
        pub fn builder() -> builder::VpcSubnet {
            Default::default()
        }
    }

    ///Create-time parameters for a
    /// [`VpcSubnet`](crate::external_api::views::VpcSubnet)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`VpcSubnet`](crate::external_api::views::VpcSubnet)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "ipv4_block",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "ipv4_block": {
    ///      "description": "The IPv4 address range for this subnet.\n\nIt must
    /// be allocated from an RFC 1918 private address range, and must not
    /// overlap with any other existing subnet in the VPC.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Net"
    ///        }
    ///      ]
    ///    },
    ///    "ipv6_block": {
    ///      "description": "The IPv6 address range for this subnet.\n\nIt must
    /// be allocated from the RFC 4193 Unique Local Address range, with the
    /// prefix equal to the parent VPC's prefix. A random `/64` block will be
    /// assigned if one is not provided. It must not overlap with any existing
    /// subnet in the VPC.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Net"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcSubnetCreate {
        pub description: String,
        ///The IPv4 address range for this subnet.
        ///
        ///It must be allocated from an RFC 1918 private address range, and
        /// must not overlap with any other existing subnet in the VPC.
        pub ipv4_block: Ipv4Net,
        ///The IPv6 address range for this subnet.
        ///
        ///It must be allocated from the RFC 4193 Unique Local Address range,
        /// with the prefix equal to the parent VPC's prefix. A random `/64`
        /// block will be assigned if one is not provided. It must not overlap
        /// with any existing subnet in the VPC.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ipv6_block: Option<Ipv6Net>,
        pub name: Name,
    }

    impl From<&VpcSubnetCreate> for VpcSubnetCreate {
        fn from(value: &VpcSubnetCreate) -> Self {
            value.clone()
        }
    }

    impl VpcSubnetCreate {
        pub fn builder() -> builder::VpcSubnetCreate {
            Default::default()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcSubnet"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcSubnetResultsPage {
        ///list of items on this page of results
        pub items: Vec<VpcSubnet>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&VpcSubnetResultsPage> for VpcSubnetResultsPage {
        fn from(value: &VpcSubnetResultsPage) -> Self {
            value.clone()
        }
    }

    impl VpcSubnetResultsPage {
        pub fn builder() -> builder::VpcSubnetResultsPage {
            Default::default()
        }
    }

    ///Updateable properties of a
    /// [`VpcSubnet`](crate::external_api::views::VpcSubnet)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a
    /// [`VpcSubnet`](crate::external_api::views::VpcSubnet)",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcSubnetUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&VpcSubnetUpdate> for VpcSubnetUpdate {
        fn from(value: &VpcSubnetUpdate) -> Self {
            value.clone()
        }
    }

    impl VpcSubnetUpdate {
        pub fn builder() -> builder::VpcSubnetUpdate {
            Default::default()
        }
    }

    ///Updateable properties of a [`Vpc`](crate::external_api::views::Vpc)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a
    /// [`Vpc`](crate::external_api::views::Vpc)",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "dns_name": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(Clone, Debug, Deserialize, Serialize)]
    pub struct VpcUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dns_name: Option<Name>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&VpcUpdate> for VpcUpdate {
        fn from(value: &VpcUpdate) -> Self {
            value.clone()
        }
    }

    impl VpcUpdate {
        pub fn builder() -> builder::VpcUpdate {
            Default::default()
        }
    }

    /// Types for composing complex structures.
    pub mod builder {
        #[derive(Clone, Debug)]
        pub struct Baseboard {
            part: Result<String, String>,
            revision: Result<i64, String>,
            serial: Result<String, String>,
        }

        impl Default for Baseboard {
            fn default() -> Self {
                Self {
                    part: Err("no value supplied for part".to_string()),
                    revision: Err("no value supplied for revision".to_string()),
                    serial: Err("no value supplied for serial".to_string()),
                }
            }
        }

        impl Baseboard {
            pub fn part<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.part = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for part: {}", e));
                self
            }
            pub fn revision<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.revision = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for revision: {}", e));
                self
            }
            pub fn serial<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.serial = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for serial: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Baseboard> for super::Baseboard {
            type Error = super::error::ConversionError;
            fn try_from(value: Baseboard) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    part: value.part?,
                    revision: value.revision?,
                    serial: value.serial?,
                })
            }
        }

        impl From<super::Baseboard> for Baseboard {
            fn from(value: super::Baseboard) -> Self {
                Self {
                    part: Ok(value.part),
                    revision: Ok(value.revision),
                    serial: Ok(value.serial),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Bindouble {
            count: Result<u64, String>,
            range: Result<super::BinRangedouble, String>,
        }

        impl Default for Bindouble {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Bindouble {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BinRangedouble>,
                T::Error: std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Bindouble> for super::Bindouble {
            type Error = super::error::ConversionError;
            fn try_from(value: Bindouble) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl From<super::Bindouble> for Bindouble {
            fn from(value: super::Bindouble) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Binint64 {
            count: Result<u64, String>,
            range: Result<super::BinRangeint64, String>,
        }

        impl Default for Binint64 {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Binint64 {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BinRangeint64>,
                T::Error: std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Binint64> for super::Binint64 {
            type Error = super::error::ConversionError;
            fn try_from(value: Binint64) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl From<super::Binint64> for Binint64 {
            fn from(value: super::Binint64) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Certificate {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            service: Result<super::ServiceUsingCertificate, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Certificate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    service: Err("no value supplied for service".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Certificate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn service<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ServiceUsingCertificate>,
                T::Error: std::fmt::Display,
            {
                self.service = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for service: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Certificate> for super::Certificate {
            type Error = super::error::ConversionError;
            fn try_from(value: Certificate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    service: value.service?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::Certificate> for Certificate {
            fn from(value: super::Certificate) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    service: Ok(value.service),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct CertificateCreate {
            cert: Result<Vec<u8>, String>,
            description: Result<String, String>,
            key: Result<Vec<u8>, String>,
            name: Result<super::Name, String>,
            service: Result<super::ServiceUsingCertificate, String>,
        }

        impl Default for CertificateCreate {
            fn default() -> Self {
                Self {
                    cert: Err("no value supplied for cert".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    key: Err("no value supplied for key".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    service: Err("no value supplied for service".to_string()),
                }
            }
        }

        impl CertificateCreate {
            pub fn cert<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<u8>>,
                T::Error: std::fmt::Display,
            {
                self.cert = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cert: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<u8>>,
                T::Error: std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn service<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ServiceUsingCertificate>,
                T::Error: std::fmt::Display,
            {
                self.service = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for service: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<CertificateCreate> for super::CertificateCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: CertificateCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cert: value.cert?,
                    description: value.description?,
                    key: value.key?,
                    name: value.name?,
                    service: value.service?,
                })
            }
        }

        impl From<super::CertificateCreate> for CertificateCreate {
            fn from(value: super::CertificateCreate) -> Self {
                Self {
                    cert: Ok(value.cert),
                    description: Ok(value.description),
                    key: Ok(value.key),
                    name: Ok(value.name),
                    service: Ok(value.service),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct CertificateResultsPage {
            items: Result<Vec<super::Certificate>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for CertificateResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl CertificateResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Certificate>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<CertificateResultsPage> for super::CertificateResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CertificateResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::CertificateResultsPage> for CertificateResultsPage {
            fn from(value: super::CertificateResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ComponentUpdate {
            component_type: Result<super::UpdateableComponentType, String>,
            id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            version: Result<super::SemverVersion, String>,
        }

        impl Default for ComponentUpdate {
            fn default() -> Self {
                Self {
                    component_type: Err("no value supplied for component_type".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl ComponentUpdate {
            pub fn component_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UpdateableComponentType>,
                T::Error: std::fmt::Display,
            {
                self.component_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for component_type: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ComponentUpdate> for super::ComponentUpdate {
            type Error = super::error::ConversionError;
            fn try_from(value: ComponentUpdate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    component_type: value.component_type?,
                    id: value.id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    version: value.version?,
                })
            }
        }

        impl From<super::ComponentUpdate> for ComponentUpdate {
            fn from(value: super::ComponentUpdate) -> Self {
                Self {
                    component_type: Ok(value.component_type),
                    id: Ok(value.id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ComponentUpdateResultsPage {
            items: Result<Vec<super::ComponentUpdate>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for ComponentUpdateResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ComponentUpdateResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ComponentUpdate>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ComponentUpdateResultsPage> for super::ComponentUpdateResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ComponentUpdateResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::ComponentUpdateResultsPage> for ComponentUpdateResultsPage {
            fn from(value: super::ComponentUpdateResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Cumulativedouble {
            start_time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            value: Result<f64, String>,
        }

        impl Default for Cumulativedouble {
            fn default() -> Self {
                Self {
                    start_time: Err("no value supplied for start_time".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }

        impl Cumulativedouble {
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<f64>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Cumulativedouble> for super::Cumulativedouble {
            type Error = super::error::ConversionError;
            fn try_from(value: Cumulativedouble) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    start_time: value.start_time?,
                    value: value.value?,
                })
            }
        }

        impl From<super::Cumulativedouble> for Cumulativedouble {
            fn from(value: super::Cumulativedouble) -> Self {
                Self {
                    start_time: Ok(value.start_time),
                    value: Ok(value.value),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Cumulativeint64 {
            start_time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            value: Result<i64, String>,
        }

        impl Default for Cumulativeint64 {
            fn default() -> Self {
                Self {
                    start_time: Err("no value supplied for start_time".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }

        impl Cumulativeint64 {
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Cumulativeint64> for super::Cumulativeint64 {
            type Error = super::error::ConversionError;
            fn try_from(value: Cumulativeint64) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    start_time: value.start_time?,
                    value: value.value?,
                })
            }
        }

        impl From<super::Cumulativeint64> for Cumulativeint64 {
            fn from(value: super::Cumulativeint64) -> Self {
                Self {
                    start_time: Ok(value.start_time),
                    value: Ok(value.value),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DerEncodedKeyPair {
            private_key: Result<String, String>,
            public_cert: Result<String, String>,
        }

        impl Default for DerEncodedKeyPair {
            fn default() -> Self {
                Self {
                    private_key: Err("no value supplied for private_key".to_string()),
                    public_cert: Err("no value supplied for public_cert".to_string()),
                }
            }
        }

        impl DerEncodedKeyPair {
            pub fn private_key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.private_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for private_key: {}", e));
                self
            }
            pub fn public_cert<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.public_cert = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_cert: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DerEncodedKeyPair> for super::DerEncodedKeyPair {
            type Error = super::error::ConversionError;
            fn try_from(value: DerEncodedKeyPair) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    private_key: value.private_key?,
                    public_cert: value.public_cert?,
                })
            }
        }

        impl From<super::DerEncodedKeyPair> for DerEncodedKeyPair {
            fn from(value: super::DerEncodedKeyPair) -> Self {
                Self {
                    private_key: Ok(value.private_key),
                    public_cert: Ok(value.public_cert),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DeviceAccessTokenRequest {
            client_id: Result<uuid::Uuid, String>,
            device_code: Result<String, String>,
            grant_type: Result<String, String>,
        }

        impl Default for DeviceAccessTokenRequest {
            fn default() -> Self {
                Self {
                    client_id: Err("no value supplied for client_id".to_string()),
                    device_code: Err("no value supplied for device_code".to_string()),
                    grant_type: Err("no value supplied for grant_type".to_string()),
                }
            }
        }

        impl DeviceAccessTokenRequest {
            pub fn client_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.client_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_id: {}", e));
                self
            }
            pub fn device_code<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.device_code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for device_code: {}", e));
                self
            }
            pub fn grant_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.grant_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for grant_type: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DeviceAccessTokenRequest> for super::DeviceAccessTokenRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DeviceAccessTokenRequest,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    client_id: value.client_id?,
                    device_code: value.device_code?,
                    grant_type: value.grant_type?,
                })
            }
        }

        impl From<super::DeviceAccessTokenRequest> for DeviceAccessTokenRequest {
            fn from(value: super::DeviceAccessTokenRequest) -> Self {
                Self {
                    client_id: Ok(value.client_id),
                    device_code: Ok(value.device_code),
                    grant_type: Ok(value.grant_type),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DeviceAuthRequest {
            client_id: Result<uuid::Uuid, String>,
        }

        impl Default for DeviceAuthRequest {
            fn default() -> Self {
                Self {
                    client_id: Err("no value supplied for client_id".to_string()),
                }
            }
        }

        impl DeviceAuthRequest {
            pub fn client_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.client_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DeviceAuthRequest> for super::DeviceAuthRequest {
            type Error = super::error::ConversionError;
            fn try_from(value: DeviceAuthRequest) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    client_id: value.client_id?,
                })
            }
        }

        impl From<super::DeviceAuthRequest> for DeviceAuthRequest {
            fn from(value: super::DeviceAuthRequest) -> Self {
                Self {
                    client_id: Ok(value.client_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DeviceAuthVerify {
            user_code: Result<String, String>,
        }

        impl Default for DeviceAuthVerify {
            fn default() -> Self {
                Self {
                    user_code: Err("no value supplied for user_code".to_string()),
                }
            }
        }

        impl DeviceAuthVerify {
            pub fn user_code<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.user_code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_code: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DeviceAuthVerify> for super::DeviceAuthVerify {
            type Error = super::error::ConversionError;
            fn try_from(value: DeviceAuthVerify) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    user_code: value.user_code?,
                })
            }
        }

        impl From<super::DeviceAuthVerify> for DeviceAuthVerify {
            fn from(value: super::DeviceAuthVerify) -> Self {
                Self {
                    user_code: Ok(value.user_code),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Disk {
            block_size: Result<super::ByteCount, String>,
            description: Result<String, String>,
            device_path: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            image_id: Result<Option<uuid::Uuid>, String>,
            name: Result<super::Name, String>,
            project_id: Result<uuid::Uuid, String>,
            size: Result<super::ByteCount, String>,
            snapshot_id: Result<Option<uuid::Uuid>, String>,
            state: Result<super::DiskState, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Disk {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    device_path: Err("no value supplied for device_path".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    image_id: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    size: Err("no value supplied for size".to_string()),
                    snapshot_id: Ok(Default::default()),
                    state: Err("no value supplied for state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Disk {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn device_path<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.device_path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for device_path: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn image_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<uuid::Uuid>>,
                T::Error: std::fmt::Display,
            {
                self.image_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for image_id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
            pub fn snapshot_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<uuid::Uuid>>,
                T::Error: std::fmt::Display,
            {
                self.snapshot_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for snapshot_id: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::DiskState>,
                T::Error: std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Disk> for super::Disk {
            type Error = super::error::ConversionError;
            fn try_from(value: Disk) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    device_path: value.device_path?,
                    id: value.id?,
                    image_id: value.image_id?,
                    name: value.name?,
                    project_id: value.project_id?,
                    size: value.size?,
                    snapshot_id: value.snapshot_id?,
                    state: value.state?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::Disk> for Disk {
            fn from(value: super::Disk) -> Self {
                Self {
                    block_size: Ok(value.block_size),
                    description: Ok(value.description),
                    device_path: Ok(value.device_path),
                    id: Ok(value.id),
                    image_id: Ok(value.image_id),
                    name: Ok(value.name),
                    project_id: Ok(value.project_id),
                    size: Ok(value.size),
                    snapshot_id: Ok(value.snapshot_id),
                    state: Ok(value.state),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DiskCreate {
            description: Result<String, String>,
            disk_source: Result<super::DiskSource, String>,
            name: Result<super::Name, String>,
            size: Result<super::ByteCount, String>,
        }

        impl Default for DiskCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    disk_source: Err("no value supplied for disk_source".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    size: Err("no value supplied for size".to_string()),
                }
            }
        }

        impl DiskCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disk_source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::DiskSource>,
                T::Error: std::fmt::Display,
            {
                self.disk_source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk_source: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DiskCreate> for super::DiskCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: DiskCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    disk_source: value.disk_source?,
                    name: value.name?,
                    size: value.size?,
                })
            }
        }

        impl From<super::DiskCreate> for DiskCreate {
            fn from(value: super::DiskCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    disk_source: Ok(value.disk_source),
                    name: Ok(value.name),
                    size: Ok(value.size),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DiskIdentifier {
            name: Result<super::Name, String>,
        }

        impl Default for DiskIdentifier {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl DiskIdentifier {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DiskIdentifier> for super::DiskIdentifier {
            type Error = super::error::ConversionError;
            fn try_from(value: DiskIdentifier) -> Result<Self, super::error::ConversionError> {
                Ok(Self { name: value.name? })
            }
        }

        impl From<super::DiskIdentifier> for DiskIdentifier {
            fn from(value: super::DiskIdentifier) -> Self {
                Self {
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DiskPath {
            disk: Result<super::NameOrId, String>,
        }

        impl Default for DiskPath {
            fn default() -> Self {
                Self {
                    disk: Err("no value supplied for disk".to_string()),
                }
            }
        }

        impl DiskPath {
            pub fn disk<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NameOrId>,
                T::Error: std::fmt::Display,
            {
                self.disk = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DiskPath> for super::DiskPath {
            type Error = super::error::ConversionError;
            fn try_from(value: DiskPath) -> Result<Self, super::error::ConversionError> {
                Ok(Self { disk: value.disk? })
            }
        }

        impl From<super::DiskPath> for DiskPath {
            fn from(value: super::DiskPath) -> Self {
                Self {
                    disk: Ok(value.disk),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DiskResultsPage {
            items: Result<Vec<super::Disk>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for DiskResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl DiskResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Disk>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DiskResultsPage> for super::DiskResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: DiskResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::DiskResultsPage> for DiskResultsPage {
            fn from(value: super::DiskResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Distribution {
            name: Result<super::Name, String>,
            version: Result<String, String>,
        }

        impl Default for Distribution {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl Distribution {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Distribution> for super::Distribution {
            type Error = super::error::ConversionError;
            fn try_from(value: Distribution) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    version: value.version?,
                })
            }
        }

        impl From<super::Distribution> for Distribution {
            fn from(value: super::Distribution) -> Self {
                Self {
                    name: Ok(value.name),
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Error {
            error_code: Result<Option<String>, String>,
            message: Result<String, String>,
            request_id: Result<String, String>,
        }

        impl Default for Error {
            fn default() -> Self {
                Self {
                    error_code: Ok(Default::default()),
                    message: Err("no value supplied for message".to_string()),
                    request_id: Err("no value supplied for request_id".to_string()),
                }
            }
        }

        impl Error {
            pub fn error_code<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.error_code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_code: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
            pub fn request_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.request_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for request_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Error> for super::Error {
            type Error = super::error::ConversionError;
            fn try_from(value: Error) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error_code: value.error_code?,
                    message: value.message?,
                    request_id: value.request_id?,
                })
            }
        }

        impl From<super::Error> for Error {
            fn from(value: super::Error) -> Self {
                Self {
                    error_code: Ok(value.error_code),
                    message: Ok(value.message),
                    request_id: Ok(value.request_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ExternalIp {
            ip: Result<std::net::IpAddr, String>,
            kind: Result<super::IpKind, String>,
        }

        impl Default for ExternalIp {
            fn default() -> Self {
                Self {
                    ip: Err("no value supplied for ip".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }

        impl ExternalIp {
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::IpAddr>,
                T::Error: std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IpKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ExternalIp> for super::ExternalIp {
            type Error = super::error::ConversionError;
            fn try_from(value: ExternalIp) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ip: value.ip?,
                    kind: value.kind?,
                })
            }
        }

        impl From<super::ExternalIp> for ExternalIp {
            fn from(value: super::ExternalIp) -> Self {
                Self {
                    ip: Ok(value.ip),
                    kind: Ok(value.kind),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ExternalIpResultsPage {
            items: Result<Vec<super::ExternalIp>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for ExternalIpResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ExternalIpResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ExternalIp>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ExternalIpResultsPage> for super::ExternalIpResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExternalIpResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::ExternalIpResultsPage> for ExternalIpResultsPage {
            fn from(value: super::ExternalIpResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FieldSchema {
            name: Result<String, String>,
            source: Result<super::FieldSource, String>,
            ty: Result<super::FieldType, String>,
        }

        impl Default for FieldSchema {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    source: Err("no value supplied for source".to_string()),
                    ty: Err("no value supplied for ty".to_string()),
                }
            }
        }

        impl FieldSchema {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::FieldSource>,
                T::Error: std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {}", e));
                self
            }
            pub fn ty<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::FieldType>,
                T::Error: std::fmt::Display,
            {
                self.ty = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ty: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FieldSchema> for super::FieldSchema {
            type Error = super::error::ConversionError;
            fn try_from(value: FieldSchema) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    source: value.source?,
                    ty: value.ty?,
                })
            }
        }

        impl From<super::FieldSchema> for FieldSchema {
            fn from(value: super::FieldSchema) -> Self {
                Self {
                    name: Ok(value.name),
                    source: Ok(value.source),
                    ty: Ok(value.ty),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FleetRolePolicy {
            role_assignments: Result<Vec<super::FleetRoleRoleAssignment>, String>,
        }

        impl Default for FleetRolePolicy {
            fn default() -> Self {
                Self {
                    role_assignments: Err("no value supplied for role_assignments".to_string()),
                }
            }
        }

        impl FleetRolePolicy {
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::FleetRoleRoleAssignment>>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for role_assignments: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<FleetRolePolicy> for super::FleetRolePolicy {
            type Error = super::error::ConversionError;
            fn try_from(value: FleetRolePolicy) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    role_assignments: value.role_assignments?,
                })
            }
        }

        impl From<super::FleetRolePolicy> for FleetRolePolicy {
            fn from(value: super::FleetRolePolicy) -> Self {
                Self {
                    role_assignments: Ok(value.role_assignments),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FleetRoleRoleAssignment {
            identity_id: Result<uuid::Uuid, String>,
            identity_type: Result<super::IdentityType, String>,
            role_name: Result<super::FleetRole, String>,
        }

        impl Default for FleetRoleRoleAssignment {
            fn default() -> Self {
                Self {
                    identity_id: Err("no value supplied for identity_id".to_string()),
                    identity_type: Err("no value supplied for identity_type".to_string()),
                    role_name: Err("no value supplied for role_name".to_string()),
                }
            }
        }

        impl FleetRoleRoleAssignment {
            pub fn identity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.identity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for identity_id: {}", e));
                self
            }
            pub fn identity_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdentityType>,
                T::Error: std::fmt::Display,
            {
                self.identity_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_type: {}", e)
                });
                self
            }
            pub fn role_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::FleetRole>,
                T::Error: std::fmt::Display,
            {
                self.role_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FleetRoleRoleAssignment> for super::FleetRoleRoleAssignment {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FleetRoleRoleAssignment,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    identity_id: value.identity_id?,
                    identity_type: value.identity_type?,
                    role_name: value.role_name?,
                })
            }
        }

        impl From<super::FleetRoleRoleAssignment> for FleetRoleRoleAssignment {
            fn from(value: super::FleetRoleRoleAssignment) -> Self {
                Self {
                    identity_id: Ok(value.identity_id),
                    identity_type: Ok(value.identity_type),
                    role_name: Ok(value.role_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct GlobalImage {
            block_size: Result<super::ByteCount, String>,
            description: Result<String, String>,
            digest: Result<Option<super::Digest>, String>,
            distribution: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            size: Result<super::ByteCount, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            url: Result<Option<String>, String>,
            version: Result<String, String>,
        }

        impl Default for GlobalImage {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    digest: Ok(Default::default()),
                    distribution: Err("no value supplied for distribution".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    size: Err("no value supplied for size".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    url: Ok(Default::default()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl GlobalImage {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn digest<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Digest>>,
                T::Error: std::fmt::Display,
            {
                self.digest = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for digest: {}", e));
                self
            }
            pub fn distribution<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.distribution = value.try_into().map_err(|e| {
                    format!("error converting supplied value for distribution: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<GlobalImage> for super::GlobalImage {
            type Error = super::error::ConversionError;
            fn try_from(value: GlobalImage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    digest: value.digest?,
                    distribution: value.distribution?,
                    id: value.id?,
                    name: value.name?,
                    size: value.size?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    url: value.url?,
                    version: value.version?,
                })
            }
        }

        impl From<super::GlobalImage> for GlobalImage {
            fn from(value: super::GlobalImage) -> Self {
                Self {
                    block_size: Ok(value.block_size),
                    description: Ok(value.description),
                    digest: Ok(value.digest),
                    distribution: Ok(value.distribution),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    size: Ok(value.size),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    url: Ok(value.url),
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct GlobalImageCreate {
            block_size: Result<super::BlockSize, String>,
            description: Result<String, String>,
            distribution: Result<super::Distribution, String>,
            name: Result<super::Name, String>,
            source: Result<super::ImageSource, String>,
        }

        impl Default for GlobalImageCreate {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    distribution: Err("no value supplied for distribution".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    source: Err("no value supplied for source".to_string()),
                }
            }
        }

        impl GlobalImageCreate {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BlockSize>,
                T::Error: std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn distribution<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Distribution>,
                T::Error: std::fmt::Display,
            {
                self.distribution = value.try_into().map_err(|e| {
                    format!("error converting supplied value for distribution: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ImageSource>,
                T::Error: std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<GlobalImageCreate> for super::GlobalImageCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: GlobalImageCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    distribution: value.distribution?,
                    name: value.name?,
                    source: value.source?,
                })
            }
        }

        impl From<super::GlobalImageCreate> for GlobalImageCreate {
            fn from(value: super::GlobalImageCreate) -> Self {
                Self {
                    block_size: Ok(value.block_size),
                    description: Ok(value.description),
                    distribution: Ok(value.distribution),
                    name: Ok(value.name),
                    source: Ok(value.source),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct GlobalImageResultsPage {
            items: Result<Vec<super::GlobalImage>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for GlobalImageResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl GlobalImageResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::GlobalImage>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<GlobalImageResultsPage> for super::GlobalImageResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GlobalImageResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::GlobalImageResultsPage> for GlobalImageResultsPage {
            fn from(value: super::GlobalImageResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Group {
            display_name: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            silo_id: Result<uuid::Uuid, String>,
        }

        impl Default for Group {
            fn default() -> Self {
                Self {
                    display_name: Err("no value supplied for display_name".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    silo_id: Err("no value supplied for silo_id".to_string()),
                }
            }
        }

        impl Group {
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.display_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn silo_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.silo_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Group> for super::Group {
            type Error = super::error::ConversionError;
            fn try_from(value: Group) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    display_name: value.display_name?,
                    id: value.id?,
                    silo_id: value.silo_id?,
                })
            }
        }

        impl From<super::Group> for Group {
            fn from(value: super::Group) -> Self {
                Self {
                    display_name: Ok(value.display_name),
                    id: Ok(value.id),
                    silo_id: Ok(value.silo_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct GroupResultsPage {
            items: Result<Vec<super::Group>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for GroupResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl GroupResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Group>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<GroupResultsPage> for super::GroupResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: GroupResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::GroupResultsPage> for GroupResultsPage {
            fn from(value: super::GroupResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramdouble {
            bins: Result<Vec<super::Bindouble>, String>,
            n_samples: Result<u64, String>,
            start_time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Histogramdouble {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                }
            }
        }

        impl Histogramdouble {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Bindouble>>,
                T::Error: std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Histogramdouble> for super::Histogramdouble {
            type Error = super::error::ConversionError;
            fn try_from(value: Histogramdouble) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    n_samples: value.n_samples?,
                    start_time: value.start_time?,
                })
            }
        }

        impl From<super::Histogramdouble> for Histogramdouble {
            fn from(value: super::Histogramdouble) -> Self {
                Self {
                    bins: Ok(value.bins),
                    n_samples: Ok(value.n_samples),
                    start_time: Ok(value.start_time),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramint64 {
            bins: Result<Vec<super::Binint64>, String>,
            n_samples: Result<u64, String>,
            start_time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Histogramint64 {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                }
            }
        }

        impl Histogramint64 {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Binint64>>,
                T::Error: std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Histogramint64> for super::Histogramint64 {
            type Error = super::error::ConversionError;
            fn try_from(value: Histogramint64) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    n_samples: value.n_samples?,
                    start_time: value.start_time?,
                })
            }
        }

        impl From<super::Histogramint64> for Histogramint64 {
            fn from(value: super::Histogramint64) -> Self {
                Self {
                    bins: Ok(value.bins),
                    n_samples: Ok(value.n_samples),
                    start_time: Ok(value.start_time),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IdentityProvider {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            provider_type: Result<super::IdentityProviderType, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for IdentityProvider {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    provider_type: Err("no value supplied for provider_type".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl IdentityProvider {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn provider_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdentityProviderType>,
                T::Error: std::fmt::Display,
            {
                self.provider_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for provider_type: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<IdentityProvider> for super::IdentityProvider {
            type Error = super::error::ConversionError;
            fn try_from(value: IdentityProvider) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    provider_type: value.provider_type?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::IdentityProvider> for IdentityProvider {
            fn from(value: super::IdentityProvider) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    provider_type: Ok(value.provider_type),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IdentityProviderResultsPage {
            items: Result<Vec<super::IdentityProvider>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for IdentityProviderResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl IdentityProviderResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::IdentityProvider>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<IdentityProviderResultsPage> for super::IdentityProviderResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IdentityProviderResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::IdentityProviderResultsPage> for IdentityProviderResultsPage {
            fn from(value: super::IdentityProviderResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Image {
            block_size: Result<super::ByteCount, String>,
            description: Result<String, String>,
            digest: Result<Option<super::Digest>, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            project_id: Result<uuid::Uuid, String>,
            size: Result<super::ByteCount, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            url: Result<Option<String>, String>,
            version: Result<Option<String>, String>,
        }

        impl Default for Image {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    digest: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    size: Err("no value supplied for size".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    url: Ok(Default::default()),
                    version: Ok(Default::default()),
                }
            }
        }

        impl Image {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn digest<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Digest>>,
                T::Error: std::fmt::Display,
            {
                self.digest = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for digest: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Image> for super::Image {
            type Error = super::error::ConversionError;
            fn try_from(value: Image) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    digest: value.digest?,
                    id: value.id?,
                    name: value.name?,
                    project_id: value.project_id?,
                    size: value.size?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    url: value.url?,
                    version: value.version?,
                })
            }
        }

        impl From<super::Image> for Image {
            fn from(value: super::Image) -> Self {
                Self {
                    block_size: Ok(value.block_size),
                    description: Ok(value.description),
                    digest: Ok(value.digest),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    project_id: Ok(value.project_id),
                    size: Ok(value.size),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    url: Ok(value.url),
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ImageCreate {
            block_size: Result<super::BlockSize, String>,
            description: Result<String, String>,
            name: Result<super::Name, String>,
            source: Result<super::ImageSource, String>,
        }

        impl Default for ImageCreate {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    source: Err("no value supplied for source".to_string()),
                }
            }
        }

        impl ImageCreate {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BlockSize>,
                T::Error: std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ImageSource>,
                T::Error: std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ImageCreate> for super::ImageCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: ImageCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    name: value.name?,
                    source: value.source?,
                })
            }
        }

        impl From<super::ImageCreate> for ImageCreate {
            fn from(value: super::ImageCreate) -> Self {
                Self {
                    block_size: Ok(value.block_size),
                    description: Ok(value.description),
                    name: Ok(value.name),
                    source: Ok(value.source),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ImageResultsPage {
            items: Result<Vec<super::Image>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for ImageResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ImageResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Image>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ImageResultsPage> for super::ImageResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: ImageResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::ImageResultsPage> for ImageResultsPage {
            fn from(value: super::ImageResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Instance {
            description: Result<String, String>,
            hostname: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            memory: Result<super::ByteCount, String>,
            name: Result<super::Name, String>,
            ncpus: Result<super::InstanceCpuCount, String>,
            project_id: Result<uuid::Uuid, String>,
            run_state: Result<super::InstanceState, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_run_state_updated: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Instance {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    hostname: Err("no value supplied for hostname".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    memory: Err("no value supplied for memory".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    ncpus: Err("no value supplied for ncpus".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    run_state: Err("no value supplied for run_state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    time_run_state_updated: Err(
                        "no value supplied for time_run_state_updated".to_string()
                    ),
                }
            }
        }

        impl Instance {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn hostname<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.hostname = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hostname: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn ncpus<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InstanceCpuCount>,
                T::Error: std::fmt::Display,
            {
                self.ncpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ncpus: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn run_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InstanceState>,
                T::Error: std::fmt::Display,
            {
                self.run_state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for run_state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn time_run_state_updated<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_run_state_updated = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for time_run_state_updated: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<Instance> for super::Instance {
            type Error = super::error::ConversionError;
            fn try_from(value: Instance) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    hostname: value.hostname?,
                    id: value.id?,
                    memory: value.memory?,
                    name: value.name?,
                    ncpus: value.ncpus?,
                    project_id: value.project_id?,
                    run_state: value.run_state?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    time_run_state_updated: value.time_run_state_updated?,
                })
            }
        }

        impl From<super::Instance> for Instance {
            fn from(value: super::Instance) -> Self {
                Self {
                    description: Ok(value.description),
                    hostname: Ok(value.hostname),
                    id: Ok(value.id),
                    memory: Ok(value.memory),
                    name: Ok(value.name),
                    ncpus: Ok(value.ncpus),
                    project_id: Ok(value.project_id),
                    run_state: Ok(value.run_state),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    time_run_state_updated: Ok(value.time_run_state_updated),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceCreate {
            description: Result<String, String>,
            disks: Result<Vec<super::InstanceDiskAttachment>, String>,
            external_ips: Result<Vec<super::ExternalIpCreate>, String>,
            hostname: Result<String, String>,
            memory: Result<super::ByteCount, String>,
            name: Result<super::Name, String>,
            ncpus: Result<super::InstanceCpuCount, String>,
            network_interfaces: Result<super::InstanceNetworkInterfaceAttachment, String>,
            start: Result<bool, String>,
            user_data: Result<String, String>,
        }

        impl Default for InstanceCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    disks: Ok(Default::default()),
                    external_ips: Ok(Default::default()),
                    hostname: Err("no value supplied for hostname".to_string()),
                    memory: Err("no value supplied for memory".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    ncpus: Err("no value supplied for ncpus".to_string()),
                    network_interfaces: Ok(super::defaults::instance_create_network_interfaces()),
                    start: Ok(super::defaults::default_bool::<true>()),
                    user_data: Ok(Default::default()),
                }
            }
        }

        impl InstanceCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disks<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::InstanceDiskAttachment>>,
                T::Error: std::fmt::Display,
            {
                self.disks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disks: {}", e));
                self
            }
            pub fn external_ips<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ExternalIpCreate>>,
                T::Error: std::fmt::Display,
            {
                self.external_ips = value.try_into().map_err(|e| {
                    format!("error converting supplied value for external_ips: {}", e)
                });
                self
            }
            pub fn hostname<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.hostname = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hostname: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn ncpus<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InstanceCpuCount>,
                T::Error: std::fmt::Display,
            {
                self.ncpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ncpus: {}", e));
                self
            }
            pub fn network_interfaces<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InstanceNetworkInterfaceAttachment>,
                T::Error: std::fmt::Display,
            {
                self.network_interfaces = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for network_interfaces: {}",
                        e
                    )
                });
                self
            }
            pub fn start<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.start = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start: {}", e));
                self
            }
            pub fn user_data<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.user_data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_data: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<InstanceCreate> for super::InstanceCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: InstanceCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    disks: value.disks?,
                    external_ips: value.external_ips?,
                    hostname: value.hostname?,
                    memory: value.memory?,
                    name: value.name?,
                    ncpus: value.ncpus?,
                    network_interfaces: value.network_interfaces?,
                    start: value.start?,
                    user_data: value.user_data?,
                })
            }
        }

        impl From<super::InstanceCreate> for InstanceCreate {
            fn from(value: super::InstanceCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    disks: Ok(value.disks),
                    external_ips: Ok(value.external_ips),
                    hostname: Ok(value.hostname),
                    memory: Ok(value.memory),
                    name: Ok(value.name),
                    ncpus: Ok(value.ncpus),
                    network_interfaces: Ok(value.network_interfaces),
                    start: Ok(value.start),
                    user_data: Ok(value.user_data),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceMigrate {
            dst_sled_id: Result<uuid::Uuid, String>,
        }

        impl Default for InstanceMigrate {
            fn default() -> Self {
                Self {
                    dst_sled_id: Err("no value supplied for dst_sled_id".to_string()),
                }
            }
        }

        impl InstanceMigrate {
            pub fn dst_sled_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.dst_sled_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dst_sled_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<InstanceMigrate> for super::InstanceMigrate {
            type Error = super::error::ConversionError;
            fn try_from(value: InstanceMigrate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    dst_sled_id: value.dst_sled_id?,
                })
            }
        }

        impl From<super::InstanceMigrate> for InstanceMigrate {
            fn from(value: super::InstanceMigrate) -> Self {
                Self {
                    dst_sled_id: Ok(value.dst_sled_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceResultsPage {
            items: Result<Vec<super::Instance>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for InstanceResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl InstanceResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Instance>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<InstanceResultsPage> for super::InstanceResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: InstanceResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::InstanceResultsPage> for InstanceResultsPage {
            fn from(value: super::InstanceResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceSerialConsoleData {
            data: Result<Vec<u8>, String>,
            last_byte_offset: Result<u64, String>,
        }

        impl Default for InstanceSerialConsoleData {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    last_byte_offset: Err("no value supplied for last_byte_offset".to_string()),
                }
            }
        }

        impl InstanceSerialConsoleData {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<u8>>,
                T::Error: std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn last_byte_offset<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.last_byte_offset = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for last_byte_offset: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<InstanceSerialConsoleData> for super::InstanceSerialConsoleData {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InstanceSerialConsoleData,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    last_byte_offset: value.last_byte_offset?,
                })
            }
        }

        impl From<super::InstanceSerialConsoleData> for InstanceSerialConsoleData {
            fn from(value: super::InstanceSerialConsoleData) -> Self {
                Self {
                    data: Ok(value.data),
                    last_byte_offset: Ok(value.last_byte_offset),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPool {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for IpPool {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl IpPool {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<IpPool> for super::IpPool {
            type Error = super::error::ConversionError;
            fn try_from(value: IpPool) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::IpPool> for IpPool {
            fn from(value: super::IpPool) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolCreate {
            description: Result<String, String>,
            name: Result<super::Name, String>,
        }

        impl Default for IpPoolCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl IpPoolCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<IpPoolCreate> for super::IpPoolCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: IpPoolCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl From<super::IpPoolCreate> for IpPoolCreate {
            fn from(value: super::IpPoolCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolRange {
            id: Result<uuid::Uuid, String>,
            range: Result<super::IpRange, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for IpPoolRange {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    range: Err("no value supplied for range".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                }
            }
        }

        impl IpPoolRange {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IpRange>,
                T::Error: std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<IpPoolRange> for super::IpPoolRange {
            type Error = super::error::ConversionError;
            fn try_from(value: IpPoolRange) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    range: value.range?,
                    time_created: value.time_created?,
                })
            }
        }

        impl From<super::IpPoolRange> for IpPoolRange {
            fn from(value: super::IpPoolRange) -> Self {
                Self {
                    id: Ok(value.id),
                    range: Ok(value.range),
                    time_created: Ok(value.time_created),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolRangeResultsPage {
            items: Result<Vec<super::IpPoolRange>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for IpPoolRangeResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl IpPoolRangeResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::IpPoolRange>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<IpPoolRangeResultsPage> for super::IpPoolRangeResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPoolRangeResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::IpPoolRangeResultsPage> for IpPoolRangeResultsPage {
            fn from(value: super::IpPoolRangeResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolResultsPage {
            items: Result<Vec<super::IpPool>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for IpPoolResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl IpPoolResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::IpPool>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<IpPoolResultsPage> for super::IpPoolResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: IpPoolResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::IpPoolResultsPage> for IpPoolResultsPage {
            fn from(value: super::IpPoolResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for IpPoolUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl IpPoolUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<IpPoolUpdate> for super::IpPoolUpdate {
            type Error = super::error::ConversionError;
            fn try_from(value: IpPoolUpdate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl From<super::IpPoolUpdate> for IpPoolUpdate {
            fn from(value: super::IpPoolUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Ipv4Range {
            first: Result<std::net::Ipv4Addr, String>,
            last: Result<std::net::Ipv4Addr, String>,
        }

        impl Default for Ipv4Range {
            fn default() -> Self {
                Self {
                    first: Err("no value supplied for first".to_string()),
                    last: Err("no value supplied for last".to_string()),
                }
            }
        }

        impl Ipv4Range {
            pub fn first<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::Ipv4Addr>,
                T::Error: std::fmt::Display,
            {
                self.first = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for first: {}", e));
                self
            }
            pub fn last<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::Ipv4Addr>,
                T::Error: std::fmt::Display,
            {
                self.last = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Ipv4Range> for super::Ipv4Range {
            type Error = super::error::ConversionError;
            fn try_from(value: Ipv4Range) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first: value.first?,
                    last: value.last?,
                })
            }
        }

        impl From<super::Ipv4Range> for Ipv4Range {
            fn from(value: super::Ipv4Range) -> Self {
                Self {
                    first: Ok(value.first),
                    last: Ok(value.last),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Ipv6Range {
            first: Result<std::net::Ipv6Addr, String>,
            last: Result<std::net::Ipv6Addr, String>,
        }

        impl Default for Ipv6Range {
            fn default() -> Self {
                Self {
                    first: Err("no value supplied for first".to_string()),
                    last: Err("no value supplied for last".to_string()),
                }
            }
        }

        impl Ipv6Range {
            pub fn first<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::Ipv6Addr>,
                T::Error: std::fmt::Display,
            {
                self.first = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for first: {}", e));
                self
            }
            pub fn last<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::Ipv6Addr>,
                T::Error: std::fmt::Display,
            {
                self.last = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Ipv6Range> for super::Ipv6Range {
            type Error = super::error::ConversionError;
            fn try_from(value: Ipv6Range) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first: value.first?,
                    last: value.last?,
                })
            }
        }

        impl From<super::Ipv6Range> for Ipv6Range {
            fn from(value: super::Ipv6Range) -> Self {
                Self {
                    first: Ok(value.first),
                    last: Ok(value.last),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Measurement {
            datum: Result<super::Datum, String>,
            timestamp: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Measurement {
            fn default() -> Self {
                Self {
                    datum: Err("no value supplied for datum".to_string()),
                    timestamp: Err("no value supplied for timestamp".to_string()),
                }
            }
        }

        impl Measurement {
            pub fn datum<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Datum>,
                T::Error: std::fmt::Display,
            {
                self.datum = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for datum: {}", e));
                self
            }
            pub fn timestamp<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.timestamp = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for timestamp: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Measurement> for super::Measurement {
            type Error = super::error::ConversionError;
            fn try_from(value: Measurement) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    datum: value.datum?,
                    timestamp: value.timestamp?,
                })
            }
        }

        impl From<super::Measurement> for Measurement {
            fn from(value: super::Measurement) -> Self {
                Self {
                    datum: Ok(value.datum),
                    timestamp: Ok(value.timestamp),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct MeasurementResultsPage {
            items: Result<Vec<super::Measurement>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for MeasurementResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl MeasurementResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Measurement>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<MeasurementResultsPage> for super::MeasurementResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MeasurementResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::MeasurementResultsPage> for MeasurementResultsPage {
            fn from(value: super::MeasurementResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct NetworkInterface {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            instance_id: Result<uuid::Uuid, String>,
            ip: Result<std::net::IpAddr, String>,
            mac: Result<super::MacAddr, String>,
            name: Result<super::Name, String>,
            primary: Result<bool, String>,
            subnet_id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vpc_id: Result<uuid::Uuid, String>,
        }

        impl Default for NetworkInterface {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    instance_id: Err("no value supplied for instance_id".to_string()),
                    ip: Err("no value supplied for ip".to_string()),
                    mac: Err("no value supplied for mac".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    primary: Err("no value supplied for primary".to_string()),
                    subnet_id: Err("no value supplied for subnet_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl NetworkInterface {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn instance_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.instance_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for instance_id: {}", e));
                self
            }
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::IpAddr>,
                T::Error: std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn mac<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MacAddr>,
                T::Error: std::fmt::Display,
            {
                self.mac = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mac: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn primary<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.primary = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for primary: {}", e));
                self
            }
            pub fn subnet_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.subnet_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subnet_id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<NetworkInterface> for super::NetworkInterface {
            type Error = super::error::ConversionError;
            fn try_from(value: NetworkInterface) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    instance_id: value.instance_id?,
                    ip: value.ip?,
                    mac: value.mac?,
                    name: value.name?,
                    primary: value.primary?,
                    subnet_id: value.subnet_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        impl From<super::NetworkInterface> for NetworkInterface {
            fn from(value: super::NetworkInterface) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    instance_id: Ok(value.instance_id),
                    ip: Ok(value.ip),
                    mac: Ok(value.mac),
                    name: Ok(value.name),
                    primary: Ok(value.primary),
                    subnet_id: Ok(value.subnet_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vpc_id: Ok(value.vpc_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct NetworkInterfaceCreate {
            description: Result<String, String>,
            ip: Result<Option<std::net::IpAddr>, String>,
            name: Result<super::Name, String>,
            subnet_name: Result<super::Name, String>,
            vpc_name: Result<super::Name, String>,
        }

        impl Default for NetworkInterfaceCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    ip: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    subnet_name: Err("no value supplied for subnet_name".to_string()),
                    vpc_name: Err("no value supplied for vpc_name".to_string()),
                }
            }
        }

        impl NetworkInterfaceCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<std::net::IpAddr>>,
                T::Error: std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subnet_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.subnet_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subnet_name: {}", e));
                self
            }
            pub fn vpc_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.vpc_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<NetworkInterfaceCreate> for super::NetworkInterfaceCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NetworkInterfaceCreate,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    ip: value.ip?,
                    name: value.name?,
                    subnet_name: value.subnet_name?,
                    vpc_name: value.vpc_name?,
                })
            }
        }

        impl From<super::NetworkInterfaceCreate> for NetworkInterfaceCreate {
            fn from(value: super::NetworkInterfaceCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    ip: Ok(value.ip),
                    name: Ok(value.name),
                    subnet_name: Ok(value.subnet_name),
                    vpc_name: Ok(value.vpc_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct NetworkInterfaceResultsPage {
            items: Result<Vec<super::NetworkInterface>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for NetworkInterfaceResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl NetworkInterfaceResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NetworkInterface>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<NetworkInterfaceResultsPage> for super::NetworkInterfaceResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NetworkInterfaceResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::NetworkInterfaceResultsPage> for NetworkInterfaceResultsPage {
            fn from(value: super::NetworkInterfaceResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct NetworkInterfaceUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
            primary: Result<bool, String>,
        }

        impl Default for NetworkInterfaceUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                    primary: Ok(Default::default()),
                }
            }
        }

        impl NetworkInterfaceUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn primary<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.primary = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for primary: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<NetworkInterfaceUpdate> for super::NetworkInterfaceUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NetworkInterfaceUpdate,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                    primary: value.primary?,
                })
            }
        }

        impl From<super::NetworkInterfaceUpdate> for NetworkInterfaceUpdate {
            fn from(value: super::NetworkInterfaceUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                    primary: Ok(value.primary),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Organization {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Organization {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Organization {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Organization> for super::Organization {
            type Error = super::error::ConversionError;
            fn try_from(value: Organization) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::Organization> for Organization {
            fn from(value: super::Organization) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct OrganizationCreate {
            description: Result<String, String>,
            name: Result<super::Name, String>,
        }

        impl Default for OrganizationCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl OrganizationCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<OrganizationCreate> for super::OrganizationCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: OrganizationCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl From<super::OrganizationCreate> for OrganizationCreate {
            fn from(value: super::OrganizationCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct OrganizationResultsPage {
            items: Result<Vec<super::Organization>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for OrganizationResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl OrganizationResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Organization>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<OrganizationResultsPage> for super::OrganizationResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OrganizationResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::OrganizationResultsPage> for OrganizationResultsPage {
            fn from(value: super::OrganizationResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct OrganizationRolePolicy {
            role_assignments: Result<Vec<super::OrganizationRoleRoleAssignment>, String>,
        }

        impl Default for OrganizationRolePolicy {
            fn default() -> Self {
                Self {
                    role_assignments: Err("no value supplied for role_assignments".to_string()),
                }
            }
        }

        impl OrganizationRolePolicy {
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::OrganizationRoleRoleAssignment>>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for role_assignments: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<OrganizationRolePolicy> for super::OrganizationRolePolicy {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OrganizationRolePolicy,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    role_assignments: value.role_assignments?,
                })
            }
        }

        impl From<super::OrganizationRolePolicy> for OrganizationRolePolicy {
            fn from(value: super::OrganizationRolePolicy) -> Self {
                Self {
                    role_assignments: Ok(value.role_assignments),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct OrganizationRoleRoleAssignment {
            identity_id: Result<uuid::Uuid, String>,
            identity_type: Result<super::IdentityType, String>,
            role_name: Result<super::OrganizationRole, String>,
        }

        impl Default for OrganizationRoleRoleAssignment {
            fn default() -> Self {
                Self {
                    identity_id: Err("no value supplied for identity_id".to_string()),
                    identity_type: Err("no value supplied for identity_type".to_string()),
                    role_name: Err("no value supplied for role_name".to_string()),
                }
            }
        }

        impl OrganizationRoleRoleAssignment {
            pub fn identity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.identity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for identity_id: {}", e));
                self
            }
            pub fn identity_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdentityType>,
                T::Error: std::fmt::Display,
            {
                self.identity_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_type: {}", e)
                });
                self
            }
            pub fn role_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::OrganizationRole>,
                T::Error: std::fmt::Display,
            {
                self.role_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<OrganizationRoleRoleAssignment>
            for super::OrganizationRoleRoleAssignment
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OrganizationRoleRoleAssignment,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    identity_id: value.identity_id?,
                    identity_type: value.identity_type?,
                    role_name: value.role_name?,
                })
            }
        }

        impl From<super::OrganizationRoleRoleAssignment> for OrganizationRoleRoleAssignment {
            fn from(value: super::OrganizationRoleRoleAssignment) -> Self {
                Self {
                    identity_id: Ok(value.identity_id),
                    identity_type: Ok(value.identity_type),
                    role_name: Ok(value.role_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct OrganizationUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for OrganizationUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl OrganizationUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<OrganizationUpdate> for super::OrganizationUpdate {
            type Error = super::error::ConversionError;
            fn try_from(value: OrganizationUpdate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl From<super::OrganizationUpdate> for OrganizationUpdate {
            fn from(value: super::OrganizationUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct PhysicalDisk {
            disk_type: Result<super::PhysicalDiskType, String>,
            id: Result<uuid::Uuid, String>,
            model: Result<String, String>,
            serial: Result<String, String>,
            sled_id: Result<Option<uuid::Uuid>, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vendor: Result<String, String>,
        }

        impl Default for PhysicalDisk {
            fn default() -> Self {
                Self {
                    disk_type: Err("no value supplied for disk_type".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    model: Err("no value supplied for model".to_string()),
                    serial: Err("no value supplied for serial".to_string()),
                    sled_id: Ok(Default::default()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vendor: Err("no value supplied for vendor".to_string()),
                }
            }
        }

        impl PhysicalDisk {
            pub fn disk_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PhysicalDiskType>,
                T::Error: std::fmt::Display,
            {
                self.disk_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk_type: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn model<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.model = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for model: {}", e));
                self
            }
            pub fn serial<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.serial = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for serial: {}", e));
                self
            }
            pub fn sled_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<uuid::Uuid>>,
                T::Error: std::fmt::Display,
            {
                self.sled_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sled_id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vendor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.vendor = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vendor: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<PhysicalDisk> for super::PhysicalDisk {
            type Error = super::error::ConversionError;
            fn try_from(value: PhysicalDisk) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    disk_type: value.disk_type?,
                    id: value.id?,
                    model: value.model?,
                    serial: value.serial?,
                    sled_id: value.sled_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vendor: value.vendor?,
                })
            }
        }

        impl From<super::PhysicalDisk> for PhysicalDisk {
            fn from(value: super::PhysicalDisk) -> Self {
                Self {
                    disk_type: Ok(value.disk_type),
                    id: Ok(value.id),
                    model: Ok(value.model),
                    serial: Ok(value.serial),
                    sled_id: Ok(value.sled_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vendor: Ok(value.vendor),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct PhysicalDiskResultsPage {
            items: Result<Vec<super::PhysicalDisk>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for PhysicalDiskResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl PhysicalDiskResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::PhysicalDisk>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<PhysicalDiskResultsPage> for super::PhysicalDiskResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PhysicalDiskResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::PhysicalDiskResultsPage> for PhysicalDiskResultsPage {
            fn from(value: super::PhysicalDiskResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Project {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            organization_id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Project {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    organization_id: Err("no value supplied for organization_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Project {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn organization_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.organization_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for organization_id: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Project> for super::Project {
            type Error = super::error::ConversionError;
            fn try_from(value: Project) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    organization_id: value.organization_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::Project> for Project {
            fn from(value: super::Project) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    organization_id: Ok(value.organization_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProjectCreate {
            description: Result<String, String>,
            name: Result<super::Name, String>,
        }

        impl Default for ProjectCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl ProjectCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ProjectCreate> for super::ProjectCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: ProjectCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl From<super::ProjectCreate> for ProjectCreate {
            fn from(value: super::ProjectCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProjectResultsPage {
            items: Result<Vec<super::Project>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for ProjectResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ProjectResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Project>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ProjectResultsPage> for super::ProjectResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: ProjectResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::ProjectResultsPage> for ProjectResultsPage {
            fn from(value: super::ProjectResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProjectRolePolicy {
            role_assignments: Result<Vec<super::ProjectRoleRoleAssignment>, String>,
        }

        impl Default for ProjectRolePolicy {
            fn default() -> Self {
                Self {
                    role_assignments: Err("no value supplied for role_assignments".to_string()),
                }
            }
        }

        impl ProjectRolePolicy {
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ProjectRoleRoleAssignment>>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for role_assignments: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<ProjectRolePolicy> for super::ProjectRolePolicy {
            type Error = super::error::ConversionError;
            fn try_from(value: ProjectRolePolicy) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    role_assignments: value.role_assignments?,
                })
            }
        }

        impl From<super::ProjectRolePolicy> for ProjectRolePolicy {
            fn from(value: super::ProjectRolePolicy) -> Self {
                Self {
                    role_assignments: Ok(value.role_assignments),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProjectRoleRoleAssignment {
            identity_id: Result<uuid::Uuid, String>,
            identity_type: Result<super::IdentityType, String>,
            role_name: Result<super::ProjectRole, String>,
        }

        impl Default for ProjectRoleRoleAssignment {
            fn default() -> Self {
                Self {
                    identity_id: Err("no value supplied for identity_id".to_string()),
                    identity_type: Err("no value supplied for identity_type".to_string()),
                    role_name: Err("no value supplied for role_name".to_string()),
                }
            }
        }

        impl ProjectRoleRoleAssignment {
            pub fn identity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.identity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for identity_id: {}", e));
                self
            }
            pub fn identity_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdentityType>,
                T::Error: std::fmt::Display,
            {
                self.identity_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_type: {}", e)
                });
                self
            }
            pub fn role_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProjectRole>,
                T::Error: std::fmt::Display,
            {
                self.role_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ProjectRoleRoleAssignment> for super::ProjectRoleRoleAssignment {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProjectRoleRoleAssignment,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    identity_id: value.identity_id?,
                    identity_type: value.identity_type?,
                    role_name: value.role_name?,
                })
            }
        }

        impl From<super::ProjectRoleRoleAssignment> for ProjectRoleRoleAssignment {
            fn from(value: super::ProjectRoleRoleAssignment) -> Self {
                Self {
                    identity_id: Ok(value.identity_id),
                    identity_type: Ok(value.identity_type),
                    role_name: Ok(value.role_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProjectUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for ProjectUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl ProjectUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ProjectUpdate> for super::ProjectUpdate {
            type Error = super::error::ConversionError;
            fn try_from(value: ProjectUpdate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl From<super::ProjectUpdate> for ProjectUpdate {
            fn from(value: super::ProjectUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Rack {
            id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Rack {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Rack {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Rack> for super::Rack {
            type Error = super::error::ConversionError;
            fn try_from(value: Rack) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::Rack> for Rack {
            fn from(value: super::Rack) -> Self {
                Self {
                    id: Ok(value.id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RackResultsPage {
            items: Result<Vec<super::Rack>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for RackResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl RackResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Rack>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<RackResultsPage> for super::RackResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: RackResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::RackResultsPage> for RackResultsPage {
            fn from(value: super::RackResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Role {
            description: Result<String, String>,
            name: Result<super::RoleName, String>,
        }

        impl Default for Role {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl Role {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RoleName>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Role> for super::Role {
            type Error = super::error::ConversionError;
            fn try_from(value: Role) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl From<super::Role> for Role {
            fn from(value: super::Role) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RoleResultsPage {
            items: Result<Vec<super::Role>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for RoleResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl RoleResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Role>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<RoleResultsPage> for super::RoleResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: RoleResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::RoleResultsPage> for RoleResultsPage {
            fn from(value: super::RoleResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RouterRoute {
            description: Result<String, String>,
            destination: Result<super::RouteDestination, String>,
            id: Result<uuid::Uuid, String>,
            kind: Result<super::RouterRouteKind, String>,
            name: Result<super::Name, String>,
            target: Result<super::RouteTarget, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vpc_router_id: Result<uuid::Uuid, String>,
        }

        impl Default for RouterRoute {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    destination: Err("no value supplied for destination".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    target: Err("no value supplied for target".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_router_id: Err("no value supplied for vpc_router_id".to_string()),
                }
            }
        }

        impl RouterRoute {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn destination<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteDestination>,
                T::Error: std::fmt::Display,
            {
                self.destination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for destination: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouterRouteKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteTarget>,
                T::Error: std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_router_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.vpc_router_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for vpc_router_id: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<RouterRoute> for super::RouterRoute {
            type Error = super::error::ConversionError;
            fn try_from(value: RouterRoute) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    destination: value.destination?,
                    id: value.id?,
                    kind: value.kind?,
                    name: value.name?,
                    target: value.target?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_router_id: value.vpc_router_id?,
                })
            }
        }

        impl From<super::RouterRoute> for RouterRoute {
            fn from(value: super::RouterRoute) -> Self {
                Self {
                    description: Ok(value.description),
                    destination: Ok(value.destination),
                    id: Ok(value.id),
                    kind: Ok(value.kind),
                    name: Ok(value.name),
                    target: Ok(value.target),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vpc_router_id: Ok(value.vpc_router_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RouterRouteCreateParams {
            description: Result<String, String>,
            destination: Result<super::RouteDestination, String>,
            name: Result<super::Name, String>,
            target: Result<super::RouteTarget, String>,
        }

        impl Default for RouterRouteCreateParams {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    destination: Err("no value supplied for destination".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    target: Err("no value supplied for target".to_string()),
                }
            }
        }

        impl RouterRouteCreateParams {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn destination<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteDestination>,
                T::Error: std::fmt::Display,
            {
                self.destination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for destination: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteTarget>,
                T::Error: std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<RouterRouteCreateParams> for super::RouterRouteCreateParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RouterRouteCreateParams,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    destination: value.destination?,
                    name: value.name?,
                    target: value.target?,
                })
            }
        }

        impl From<super::RouterRouteCreateParams> for RouterRouteCreateParams {
            fn from(value: super::RouterRouteCreateParams) -> Self {
                Self {
                    description: Ok(value.description),
                    destination: Ok(value.destination),
                    name: Ok(value.name),
                    target: Ok(value.target),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RouterRouteResultsPage {
            items: Result<Vec<super::RouterRoute>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for RouterRouteResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl RouterRouteResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::RouterRoute>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<RouterRouteResultsPage> for super::RouterRouteResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RouterRouteResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::RouterRouteResultsPage> for RouterRouteResultsPage {
            fn from(value: super::RouterRouteResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RouterRouteUpdateParams {
            description: Result<Option<String>, String>,
            destination: Result<super::RouteDestination, String>,
            name: Result<Option<super::Name>, String>,
            target: Result<super::RouteTarget, String>,
        }

        impl Default for RouterRouteUpdateParams {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    destination: Err("no value supplied for destination".to_string()),
                    name: Ok(Default::default()),
                    target: Err("no value supplied for target".to_string()),
                }
            }
        }

        impl RouterRouteUpdateParams {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn destination<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteDestination>,
                T::Error: std::fmt::Display,
            {
                self.destination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for destination: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteTarget>,
                T::Error: std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<RouterRouteUpdateParams> for super::RouterRouteUpdateParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RouterRouteUpdateParams,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    destination: value.destination?,
                    name: value.name?,
                    target: value.target?,
                })
            }
        }

        impl From<super::RouterRouteUpdateParams> for RouterRouteUpdateParams {
            fn from(value: super::RouterRouteUpdateParams) -> Self {
                Self {
                    description: Ok(value.description),
                    destination: Ok(value.destination),
                    name: Ok(value.name),
                    target: Ok(value.target),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Saga {
            id: Result<uuid::Uuid, String>,
            state: Result<super::SagaState, String>,
        }

        impl Default for Saga {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    state: Err("no value supplied for state".to_string()),
                }
            }
        }

        impl Saga {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SagaState>,
                T::Error: std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Saga> for super::Saga {
            type Error = super::error::ConversionError;
            fn try_from(value: Saga) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    state: value.state?,
                })
            }
        }

        impl From<super::Saga> for Saga {
            fn from(value: super::Saga) -> Self {
                Self {
                    id: Ok(value.id),
                    state: Ok(value.state),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SagaResultsPage {
            items: Result<Vec<super::Saga>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SagaResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SagaResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Saga>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SagaResultsPage> for super::SagaResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: SagaResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::SagaResultsPage> for SagaResultsPage {
            fn from(value: super::SagaResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SamlIdentityProvider {
            acs_url: Result<String, String>,
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            idp_entity_id: Result<String, String>,
            name: Result<super::Name, String>,
            public_cert: Result<Option<String>, String>,
            slo_url: Result<String, String>,
            sp_client_id: Result<String, String>,
            technical_contact_email: Result<String, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for SamlIdentityProvider {
            fn default() -> Self {
                Self {
                    acs_url: Err("no value supplied for acs_url".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    idp_entity_id: Err("no value supplied for idp_entity_id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    public_cert: Ok(Default::default()),
                    slo_url: Err("no value supplied for slo_url".to_string()),
                    sp_client_id: Err("no value supplied for sp_client_id".to_string()),
                    technical_contact_email: Err(
                        "no value supplied for technical_contact_email".to_string()
                    ),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl SamlIdentityProvider {
            pub fn acs_url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.acs_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for acs_url: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn idp_entity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.idp_entity_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for idp_entity_id: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn public_cert<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.public_cert = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_cert: {}", e));
                self
            }
            pub fn slo_url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.slo_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for slo_url: {}", e));
                self
            }
            pub fn sp_client_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.sp_client_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sp_client_id: {}", e)
                });
                self
            }
            pub fn technical_contact_email<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.technical_contact_email = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for technical_contact_email: {}",
                        e
                    )
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<SamlIdentityProvider> for super::SamlIdentityProvider {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SamlIdentityProvider,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    acs_url: value.acs_url?,
                    description: value.description?,
                    id: value.id?,
                    idp_entity_id: value.idp_entity_id?,
                    name: value.name?,
                    public_cert: value.public_cert?,
                    slo_url: value.slo_url?,
                    sp_client_id: value.sp_client_id?,
                    technical_contact_email: value.technical_contact_email?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::SamlIdentityProvider> for SamlIdentityProvider {
            fn from(value: super::SamlIdentityProvider) -> Self {
                Self {
                    acs_url: Ok(value.acs_url),
                    description: Ok(value.description),
                    id: Ok(value.id),
                    idp_entity_id: Ok(value.idp_entity_id),
                    name: Ok(value.name),
                    public_cert: Ok(value.public_cert),
                    slo_url: Ok(value.slo_url),
                    sp_client_id: Ok(value.sp_client_id),
                    technical_contact_email: Ok(value.technical_contact_email),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SamlIdentityProviderCreate {
            acs_url: Result<String, String>,
            description: Result<String, String>,
            group_attribute_name: Result<Option<String>, String>,
            idp_entity_id: Result<String, String>,
            idp_metadata_source: Result<super::IdpMetadataSource, String>,
            name: Result<super::Name, String>,
            signing_keypair: Result<Option<super::DerEncodedKeyPair>, String>,
            slo_url: Result<String, String>,
            sp_client_id: Result<String, String>,
            technical_contact_email: Result<String, String>,
        }

        impl Default for SamlIdentityProviderCreate {
            fn default() -> Self {
                Self {
                    acs_url: Err("no value supplied for acs_url".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    group_attribute_name: Ok(Default::default()),
                    idp_entity_id: Err("no value supplied for idp_entity_id".to_string()),
                    idp_metadata_source: Err(
                        "no value supplied for idp_metadata_source".to_string()
                    ),
                    name: Err("no value supplied for name".to_string()),
                    signing_keypair: Ok(Default::default()),
                    slo_url: Err("no value supplied for slo_url".to_string()),
                    sp_client_id: Err("no value supplied for sp_client_id".to_string()),
                    technical_contact_email: Err(
                        "no value supplied for technical_contact_email".to_string()
                    ),
                }
            }
        }

        impl SamlIdentityProviderCreate {
            pub fn acs_url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.acs_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for acs_url: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn group_attribute_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.group_attribute_name = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for group_attribute_name: {}",
                        e
                    )
                });
                self
            }
            pub fn idp_entity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.idp_entity_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for idp_entity_id: {}", e)
                });
                self
            }
            pub fn idp_metadata_source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdpMetadataSource>,
                T::Error: std::fmt::Display,
            {
                self.idp_metadata_source = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for idp_metadata_source: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn signing_keypair<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::DerEncodedKeyPair>>,
                T::Error: std::fmt::Display,
            {
                self.signing_keypair = value.try_into().map_err(|e| {
                    format!("error converting supplied value for signing_keypair: {}", e)
                });
                self
            }
            pub fn slo_url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.slo_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for slo_url: {}", e));
                self
            }
            pub fn sp_client_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.sp_client_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sp_client_id: {}", e)
                });
                self
            }
            pub fn technical_contact_email<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.technical_contact_email = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for technical_contact_email: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<SamlIdentityProviderCreate> for super::SamlIdentityProviderCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SamlIdentityProviderCreate,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    acs_url: value.acs_url?,
                    description: value.description?,
                    group_attribute_name: value.group_attribute_name?,
                    idp_entity_id: value.idp_entity_id?,
                    idp_metadata_source: value.idp_metadata_source?,
                    name: value.name?,
                    signing_keypair: value.signing_keypair?,
                    slo_url: value.slo_url?,
                    sp_client_id: value.sp_client_id?,
                    technical_contact_email: value.technical_contact_email?,
                })
            }
        }

        impl From<super::SamlIdentityProviderCreate> for SamlIdentityProviderCreate {
            fn from(value: super::SamlIdentityProviderCreate) -> Self {
                Self {
                    acs_url: Ok(value.acs_url),
                    description: Ok(value.description),
                    group_attribute_name: Ok(value.group_attribute_name),
                    idp_entity_id: Ok(value.idp_entity_id),
                    idp_metadata_source: Ok(value.idp_metadata_source),
                    name: Ok(value.name),
                    signing_keypair: Ok(value.signing_keypair),
                    slo_url: Ok(value.slo_url),
                    sp_client_id: Ok(value.sp_client_id),
                    technical_contact_email: Ok(value.technical_contact_email),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Silo {
            description: Result<String, String>,
            discoverable: Result<bool, String>,
            id: Result<uuid::Uuid, String>,
            identity_mode: Result<super::SiloIdentityMode, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Silo {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    discoverable: Err("no value supplied for discoverable".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    identity_mode: Err("no value supplied for identity_mode".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Silo {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn discoverable<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.discoverable = value.try_into().map_err(|e| {
                    format!("error converting supplied value for discoverable: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn identity_mode<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SiloIdentityMode>,
                T::Error: std::fmt::Display,
            {
                self.identity_mode = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_mode: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Silo> for super::Silo {
            type Error = super::error::ConversionError;
            fn try_from(value: Silo) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    discoverable: value.discoverable?,
                    id: value.id?,
                    identity_mode: value.identity_mode?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::Silo> for Silo {
            fn from(value: super::Silo) -> Self {
                Self {
                    description: Ok(value.description),
                    discoverable: Ok(value.discoverable),
                    id: Ok(value.id),
                    identity_mode: Ok(value.identity_mode),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloCreate {
            admin_group_name: Result<Option<String>, String>,
            description: Result<String, String>,
            discoverable: Result<bool, String>,
            identity_mode: Result<super::SiloIdentityMode, String>,
            name: Result<super::Name, String>,
        }

        impl Default for SiloCreate {
            fn default() -> Self {
                Self {
                    admin_group_name: Ok(Default::default()),
                    description: Err("no value supplied for description".to_string()),
                    discoverable: Err("no value supplied for discoverable".to_string()),
                    identity_mode: Err("no value supplied for identity_mode".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl SiloCreate {
            pub fn admin_group_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.admin_group_name = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for admin_group_name: {}",
                        e
                    )
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn discoverable<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.discoverable = value.try_into().map_err(|e| {
                    format!("error converting supplied value for discoverable: {}", e)
                });
                self
            }
            pub fn identity_mode<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SiloIdentityMode>,
                T::Error: std::fmt::Display,
            {
                self.identity_mode = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_mode: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SiloCreate> for super::SiloCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: SiloCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    admin_group_name: value.admin_group_name?,
                    description: value.description?,
                    discoverable: value.discoverable?,
                    identity_mode: value.identity_mode?,
                    name: value.name?,
                })
            }
        }

        impl From<super::SiloCreate> for SiloCreate {
            fn from(value: super::SiloCreate) -> Self {
                Self {
                    admin_group_name: Ok(value.admin_group_name),
                    description: Ok(value.description),
                    discoverable: Ok(value.discoverable),
                    identity_mode: Ok(value.identity_mode),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloResultsPage {
            items: Result<Vec<super::Silo>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SiloResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SiloResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Silo>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SiloResultsPage> for super::SiloResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: SiloResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::SiloResultsPage> for SiloResultsPage {
            fn from(value: super::SiloResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloRolePolicy {
            role_assignments: Result<Vec<super::SiloRoleRoleAssignment>, String>,
        }

        impl Default for SiloRolePolicy {
            fn default() -> Self {
                Self {
                    role_assignments: Err("no value supplied for role_assignments".to_string()),
                }
            }
        }

        impl SiloRolePolicy {
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::SiloRoleRoleAssignment>>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for role_assignments: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<SiloRolePolicy> for super::SiloRolePolicy {
            type Error = super::error::ConversionError;
            fn try_from(value: SiloRolePolicy) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    role_assignments: value.role_assignments?,
                })
            }
        }

        impl From<super::SiloRolePolicy> for SiloRolePolicy {
            fn from(value: super::SiloRolePolicy) -> Self {
                Self {
                    role_assignments: Ok(value.role_assignments),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloRoleRoleAssignment {
            identity_id: Result<uuid::Uuid, String>,
            identity_type: Result<super::IdentityType, String>,
            role_name: Result<super::SiloRole, String>,
        }

        impl Default for SiloRoleRoleAssignment {
            fn default() -> Self {
                Self {
                    identity_id: Err("no value supplied for identity_id".to_string()),
                    identity_type: Err("no value supplied for identity_type".to_string()),
                    role_name: Err("no value supplied for role_name".to_string()),
                }
            }
        }

        impl SiloRoleRoleAssignment {
            pub fn identity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.identity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for identity_id: {}", e));
                self
            }
            pub fn identity_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdentityType>,
                T::Error: std::fmt::Display,
            {
                self.identity_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_type: {}", e)
                });
                self
            }
            pub fn role_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SiloRole>,
                T::Error: std::fmt::Display,
            {
                self.role_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SiloRoleRoleAssignment> for super::SiloRoleRoleAssignment {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloRoleRoleAssignment,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    identity_id: value.identity_id?,
                    identity_type: value.identity_type?,
                    role_name: value.role_name?,
                })
            }
        }

        impl From<super::SiloRoleRoleAssignment> for SiloRoleRoleAssignment {
            fn from(value: super::SiloRoleRoleAssignment) -> Self {
                Self {
                    identity_id: Ok(value.identity_id),
                    identity_type: Ok(value.identity_type),
                    role_name: Ok(value.role_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Sled {
            baseboard: Result<super::Baseboard, String>,
            id: Result<uuid::Uuid, String>,
            service_address: Result<String, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Sled {
            fn default() -> Self {
                Self {
                    baseboard: Err("no value supplied for baseboard".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    service_address: Err("no value supplied for service_address".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Sled {
            pub fn baseboard<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Baseboard>,
                T::Error: std::fmt::Display,
            {
                self.baseboard = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for baseboard: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn service_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.service_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for service_address: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Sled> for super::Sled {
            type Error = super::error::ConversionError;
            fn try_from(value: Sled) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    baseboard: value.baseboard?,
                    id: value.id?,
                    service_address: value.service_address?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::Sled> for Sled {
            fn from(value: super::Sled) -> Self {
                Self {
                    baseboard: Ok(value.baseboard),
                    id: Ok(value.id),
                    service_address: Ok(value.service_address),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SledResultsPage {
            items: Result<Vec<super::Sled>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SledResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SledResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Sled>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SledResultsPage> for super::SledResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: SledResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::SledResultsPage> for SledResultsPage {
            fn from(value: super::SledResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Snapshot {
            description: Result<String, String>,
            disk_id: Result<uuid::Uuid, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            project_id: Result<uuid::Uuid, String>,
            size: Result<super::ByteCount, String>,
            state: Result<super::SnapshotState, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Snapshot {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    disk_id: Err("no value supplied for disk_id".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    size: Err("no value supplied for size".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Snapshot {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disk_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.disk_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk_id: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SnapshotState>,
                T::Error: std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Snapshot> for super::Snapshot {
            type Error = super::error::ConversionError;
            fn try_from(value: Snapshot) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    disk_id: value.disk_id?,
                    id: value.id?,
                    name: value.name?,
                    project_id: value.project_id?,
                    size: value.size?,
                    state: value.state?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::Snapshot> for Snapshot {
            fn from(value: super::Snapshot) -> Self {
                Self {
                    description: Ok(value.description),
                    disk_id: Ok(value.disk_id),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    project_id: Ok(value.project_id),
                    size: Ok(value.size),
                    state: Ok(value.state),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SnapshotCreate {
            description: Result<String, String>,
            disk: Result<super::Name, String>,
            name: Result<super::Name, String>,
        }

        impl Default for SnapshotCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    disk: Err("no value supplied for disk".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl SnapshotCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disk<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.disk = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SnapshotCreate> for super::SnapshotCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: SnapshotCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    disk: value.disk?,
                    name: value.name?,
                })
            }
        }

        impl From<super::SnapshotCreate> for SnapshotCreate {
            fn from(value: super::SnapshotCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    disk: Ok(value.disk),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SnapshotResultsPage {
            items: Result<Vec<super::Snapshot>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SnapshotResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SnapshotResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Snapshot>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SnapshotResultsPage> for super::SnapshotResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: SnapshotResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::SnapshotResultsPage> for SnapshotResultsPage {
            fn from(value: super::SnapshotResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SpoofLoginBody {
            username: Result<String, String>,
        }

        impl Default for SpoofLoginBody {
            fn default() -> Self {
                Self {
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }

        impl SpoofLoginBody {
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SpoofLoginBody> for super::SpoofLoginBody {
            type Error = super::error::ConversionError;
            fn try_from(value: SpoofLoginBody) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    username: value.username?,
                })
            }
        }

        impl From<super::SpoofLoginBody> for SpoofLoginBody {
            fn from(value: super::SpoofLoginBody) -> Self {
                Self {
                    username: Ok(value.username),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SshKey {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            public_key: Result<String, String>,
            silo_user_id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for SshKey {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    public_key: Err("no value supplied for public_key".to_string()),
                    silo_user_id: Err("no value supplied for silo_user_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl SshKey {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
            pub fn silo_user_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.silo_user_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for silo_user_id: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<SshKey> for super::SshKey {
            type Error = super::error::ConversionError;
            fn try_from(value: SshKey) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    public_key: value.public_key?,
                    silo_user_id: value.silo_user_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::SshKey> for SshKey {
            fn from(value: super::SshKey) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    public_key: Ok(value.public_key),
                    silo_user_id: Ok(value.silo_user_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SshKeyCreate {
            description: Result<String, String>,
            name: Result<super::Name, String>,
            public_key: Result<String, String>,
        }

        impl Default for SshKeyCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    public_key: Err("no value supplied for public_key".to_string()),
                }
            }
        }

        impl SshKeyCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SshKeyCreate> for super::SshKeyCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: SshKeyCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                    public_key: value.public_key?,
                })
            }
        }

        impl From<super::SshKeyCreate> for SshKeyCreate {
            fn from(value: super::SshKeyCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                    public_key: Ok(value.public_key),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SshKeyResultsPage {
            items: Result<Vec<super::SshKey>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SshKeyResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SshKeyResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::SshKey>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SshKeyResultsPage> for super::SshKeyResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: SshKeyResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::SshKeyResultsPage> for SshKeyResultsPage {
            fn from(value: super::SshKeyResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SystemUpdate {
            id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            version: Result<super::SemverVersion, String>,
        }

        impl Default for SystemUpdate {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl SystemUpdate {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SystemUpdate> for super::SystemUpdate {
            type Error = super::error::ConversionError;
            fn try_from(value: SystemUpdate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    version: value.version?,
                })
            }
        }

        impl From<super::SystemUpdate> for SystemUpdate {
            fn from(value: super::SystemUpdate) -> Self {
                Self {
                    id: Ok(value.id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SystemUpdateResultsPage {
            items: Result<Vec<super::SystemUpdate>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SystemUpdateResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SystemUpdateResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::SystemUpdate>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SystemUpdateResultsPage> for super::SystemUpdateResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SystemUpdateResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::SystemUpdateResultsPage> for SystemUpdateResultsPage {
            fn from(value: super::SystemUpdateResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SystemUpdateStart {
            version: Result<super::SemverVersion, String>,
        }

        impl Default for SystemUpdateStart {
            fn default() -> Self {
                Self {
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl SystemUpdateStart {
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SystemUpdateStart> for super::SystemUpdateStart {
            type Error = super::error::ConversionError;
            fn try_from(value: SystemUpdateStart) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    version: value.version?,
                })
            }
        }

        impl From<super::SystemUpdateStart> for SystemUpdateStart {
            fn from(value: super::SystemUpdateStart) -> Self {
                Self {
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SystemVersion {
            status: Result<super::UpdateStatus, String>,
            version_range: Result<super::VersionRange, String>,
        }

        impl Default for SystemVersion {
            fn default() -> Self {
                Self {
                    status: Err("no value supplied for status".to_string()),
                    version_range: Err("no value supplied for version_range".to_string()),
                }
            }
        }

        impl SystemVersion {
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UpdateStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn version_range<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VersionRange>,
                T::Error: std::fmt::Display,
            {
                self.version_range = value.try_into().map_err(|e| {
                    format!("error converting supplied value for version_range: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<SystemVersion> for super::SystemVersion {
            type Error = super::error::ConversionError;
            fn try_from(value: SystemVersion) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    status: value.status?,
                    version_range: value.version_range?,
                })
            }
        }

        impl From<super::SystemVersion> for SystemVersion {
            fn from(value: super::SystemVersion) -> Self {
                Self {
                    status: Ok(value.status),
                    version_range: Ok(value.version_range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TimeseriesSchema {
            created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            datum_type: Result<super::DatumType, String>,
            field_schema: Result<Vec<super::FieldSchema>, String>,
            timeseries_name: Result<super::TimeseriesName, String>,
        }

        impl Default for TimeseriesSchema {
            fn default() -> Self {
                Self {
                    created: Err("no value supplied for created".to_string()),
                    datum_type: Err("no value supplied for datum_type".to_string()),
                    field_schema: Err("no value supplied for field_schema".to_string()),
                    timeseries_name: Err("no value supplied for timeseries_name".to_string()),
                }
            }
        }

        impl TimeseriesSchema {
            pub fn created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.created = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created: {}", e));
                self
            }
            pub fn datum_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::DatumType>,
                T::Error: std::fmt::Display,
            {
                self.datum_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for datum_type: {}", e));
                self
            }
            pub fn field_schema<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::FieldSchema>>,
                T::Error: std::fmt::Display,
            {
                self.field_schema = value.try_into().map_err(|e| {
                    format!("error converting supplied value for field_schema: {}", e)
                });
                self
            }
            pub fn timeseries_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::TimeseriesName>,
                T::Error: std::fmt::Display,
            {
                self.timeseries_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for timeseries_name: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<TimeseriesSchema> for super::TimeseriesSchema {
            type Error = super::error::ConversionError;
            fn try_from(value: TimeseriesSchema) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created: value.created?,
                    datum_type: value.datum_type?,
                    field_schema: value.field_schema?,
                    timeseries_name: value.timeseries_name?,
                })
            }
        }

        impl From<super::TimeseriesSchema> for TimeseriesSchema {
            fn from(value: super::TimeseriesSchema) -> Self {
                Self {
                    created: Ok(value.created),
                    datum_type: Ok(value.datum_type),
                    field_schema: Ok(value.field_schema),
                    timeseries_name: Ok(value.timeseries_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TimeseriesSchemaResultsPage {
            items: Result<Vec<super::TimeseriesSchema>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for TimeseriesSchemaResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl TimeseriesSchemaResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::TimeseriesSchema>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<TimeseriesSchemaResultsPage> for super::TimeseriesSchemaResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TimeseriesSchemaResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::TimeseriesSchemaResultsPage> for TimeseriesSchemaResultsPage {
            fn from(value: super::TimeseriesSchemaResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UpdateDeployment {
            id: Result<uuid::Uuid, String>,
            status: Result<super::UpdateStatus, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            version: Result<super::SemverVersion, String>,
        }

        impl Default for UpdateDeployment {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl UpdateDeployment {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UpdateStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UpdateDeployment> for super::UpdateDeployment {
            type Error = super::error::ConversionError;
            fn try_from(value: UpdateDeployment) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    status: value.status?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    version: value.version?,
                })
            }
        }

        impl From<super::UpdateDeployment> for UpdateDeployment {
            fn from(value: super::UpdateDeployment) -> Self {
                Self {
                    id: Ok(value.id),
                    status: Ok(value.status),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UpdateDeploymentResultsPage {
            items: Result<Vec<super::UpdateDeployment>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for UpdateDeploymentResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl UpdateDeploymentResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::UpdateDeployment>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UpdateDeploymentResultsPage> for super::UpdateDeploymentResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateDeploymentResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::UpdateDeploymentResultsPage> for UpdateDeploymentResultsPage {
            fn from(value: super::UpdateDeploymentResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UpdateableComponent {
            component_type: Result<super::UpdateableComponentType, String>,
            device_id: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            status: Result<super::UpdateStatus, String>,
            system_version: Result<super::SemverVersion, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            version: Result<super::SemverVersion, String>,
        }

        impl Default for UpdateableComponent {
            fn default() -> Self {
                Self {
                    component_type: Err("no value supplied for component_type".to_string()),
                    device_id: Err("no value supplied for device_id".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    system_version: Err("no value supplied for system_version".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl UpdateableComponent {
            pub fn component_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UpdateableComponentType>,
                T::Error: std::fmt::Display,
            {
                self.component_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for component_type: {}", e)
                });
                self
            }
            pub fn device_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.device_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for device_id: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UpdateStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn system_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.system_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for system_version: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UpdateableComponent> for super::UpdateableComponent {
            type Error = super::error::ConversionError;
            fn try_from(value: UpdateableComponent) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    component_type: value.component_type?,
                    device_id: value.device_id?,
                    id: value.id?,
                    status: value.status?,
                    system_version: value.system_version?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    version: value.version?,
                })
            }
        }

        impl From<super::UpdateableComponent> for UpdateableComponent {
            fn from(value: super::UpdateableComponent) -> Self {
                Self {
                    component_type: Ok(value.component_type),
                    device_id: Ok(value.device_id),
                    id: Ok(value.id),
                    status: Ok(value.status),
                    system_version: Ok(value.system_version),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UpdateableComponentResultsPage {
            items: Result<Vec<super::UpdateableComponent>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for UpdateableComponentResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl UpdateableComponentResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::UpdateableComponent>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UpdateableComponentResultsPage>
            for super::UpdateableComponentResultsPage
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateableComponentResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::UpdateableComponentResultsPage> for UpdateableComponentResultsPage {
            fn from(value: super::UpdateableComponentResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct User {
            display_name: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            silo_id: Result<uuid::Uuid, String>,
        }

        impl Default for User {
            fn default() -> Self {
                Self {
                    display_name: Err("no value supplied for display_name".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    silo_id: Err("no value supplied for silo_id".to_string()),
                }
            }
        }

        impl User {
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.display_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn silo_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.silo_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<User> for super::User {
            type Error = super::error::ConversionError;
            fn try_from(value: User) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    display_name: value.display_name?,
                    id: value.id?,
                    silo_id: value.silo_id?,
                })
            }
        }

        impl From<super::User> for User {
            fn from(value: super::User) -> Self {
                Self {
                    display_name: Ok(value.display_name),
                    id: Ok(value.id),
                    silo_id: Ok(value.silo_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UserBuiltin {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for UserBuiltin {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl UserBuiltin {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<UserBuiltin> for super::UserBuiltin {
            type Error = super::error::ConversionError;
            fn try_from(value: UserBuiltin) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::UserBuiltin> for UserBuiltin {
            fn from(value: super::UserBuiltin) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UserBuiltinResultsPage {
            items: Result<Vec<super::UserBuiltin>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for UserBuiltinResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl UserBuiltinResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::UserBuiltin>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UserBuiltinResultsPage> for super::UserBuiltinResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UserBuiltinResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::UserBuiltinResultsPage> for UserBuiltinResultsPage {
            fn from(value: super::UserBuiltinResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UserCreate {
            external_id: Result<super::UserId, String>,
            password: Result<super::UserPassword, String>,
        }

        impl Default for UserCreate {
            fn default() -> Self {
                Self {
                    external_id: Err("no value supplied for external_id".to_string()),
                    password: Err("no value supplied for password".to_string()),
                }
            }
        }

        impl UserCreate {
            pub fn external_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UserId>,
                T::Error: std::fmt::Display,
            {
                self.external_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for external_id: {}", e));
                self
            }
            pub fn password<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UserPassword>,
                T::Error: std::fmt::Display,
            {
                self.password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for password: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UserCreate> for super::UserCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: UserCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    external_id: value.external_id?,
                    password: value.password?,
                })
            }
        }

        impl From<super::UserCreate> for UserCreate {
            fn from(value: super::UserCreate) -> Self {
                Self {
                    external_id: Ok(value.external_id),
                    password: Ok(value.password),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UserResultsPage {
            items: Result<Vec<super::User>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for UserResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl UserResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::User>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UserResultsPage> for super::UserResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: UserResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::UserResultsPage> for UserResultsPage {
            fn from(value: super::UserResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UsernamePasswordCredentials {
            password: Result<super::Password, String>,
            username: Result<super::UserId, String>,
        }

        impl Default for UsernamePasswordCredentials {
            fn default() -> Self {
                Self {
                    password: Err("no value supplied for password".to_string()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }

        impl UsernamePasswordCredentials {
            pub fn password<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Password>,
                T::Error: std::fmt::Display,
            {
                self.password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for password: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UserId>,
                T::Error: std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UsernamePasswordCredentials> for super::UsernamePasswordCredentials {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UsernamePasswordCredentials,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    password: value.password?,
                    username: value.username?,
                })
            }
        }

        impl From<super::UsernamePasswordCredentials> for UsernamePasswordCredentials {
            fn from(value: super::UsernamePasswordCredentials) -> Self {
                Self {
                    password: Ok(value.password),
                    username: Ok(value.username),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VersionRange {
            high: Result<super::SemverVersion, String>,
            low: Result<super::SemverVersion, String>,
        }

        impl Default for VersionRange {
            fn default() -> Self {
                Self {
                    high: Err("no value supplied for high".to_string()),
                    low: Err("no value supplied for low".to_string()),
                }
            }
        }

        impl VersionRange {
            pub fn high<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.high = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for high: {}", e));
                self
            }
            pub fn low<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.low = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for low: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VersionRange> for super::VersionRange {
            type Error = super::error::ConversionError;
            fn try_from(value: VersionRange) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    high: value.high?,
                    low: value.low?,
                })
            }
        }

        impl From<super::VersionRange> for VersionRange {
            fn from(value: super::VersionRange) -> Self {
                Self {
                    high: Ok(value.high),
                    low: Ok(value.low),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Vpc {
            description: Result<String, String>,
            dns_name: Result<super::Name, String>,
            id: Result<uuid::Uuid, String>,
            ipv6_prefix: Result<super::Ipv6Net, String>,
            name: Result<super::Name, String>,
            project_id: Result<uuid::Uuid, String>,
            system_router_id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Vpc {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    dns_name: Err("no value supplied for dns_name".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    ipv6_prefix: Err("no value supplied for ipv6_prefix".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    system_router_id: Err("no value supplied for system_router_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Vpc {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn dns_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.dns_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dns_name: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn ipv6_prefix<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Ipv6Net>,
                T::Error: std::fmt::Display,
            {
                self.ipv6_prefix = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_prefix: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn system_router_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.system_router_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for system_router_id: {}",
                        e
                    )
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Vpc> for super::Vpc {
            type Error = super::error::ConversionError;
            fn try_from(value: Vpc) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    dns_name: value.dns_name?,
                    id: value.id?,
                    ipv6_prefix: value.ipv6_prefix?,
                    name: value.name?,
                    project_id: value.project_id?,
                    system_router_id: value.system_router_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl From<super::Vpc> for Vpc {
            fn from(value: super::Vpc) -> Self {
                Self {
                    description: Ok(value.description),
                    dns_name: Ok(value.dns_name),
                    id: Ok(value.id),
                    ipv6_prefix: Ok(value.ipv6_prefix),
                    name: Ok(value.name),
                    project_id: Ok(value.project_id),
                    system_router_id: Ok(value.system_router_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcCreate {
            description: Result<String, String>,
            dns_name: Result<super::Name, String>,
            ipv6_prefix: Result<Option<super::Ipv6Net>, String>,
            name: Result<super::Name, String>,
        }

        impl Default for VpcCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    dns_name: Err("no value supplied for dns_name".to_string()),
                    ipv6_prefix: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl VpcCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn dns_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.dns_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dns_name: {}", e));
                self
            }
            pub fn ipv6_prefix<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Ipv6Net>>,
                T::Error: std::fmt::Display,
            {
                self.ipv6_prefix = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_prefix: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcCreate> for super::VpcCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: VpcCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    dns_name: value.dns_name?,
                    ipv6_prefix: value.ipv6_prefix?,
                    name: value.name?,
                })
            }
        }

        impl From<super::VpcCreate> for VpcCreate {
            fn from(value: super::VpcCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    dns_name: Ok(value.dns_name),
                    ipv6_prefix: Ok(value.ipv6_prefix),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcFirewallRule {
            action: Result<super::VpcFirewallRuleAction, String>,
            description: Result<String, String>,
            direction: Result<super::VpcFirewallRuleDirection, String>,
            filters: Result<super::VpcFirewallRuleFilter, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            priority: Result<u16, String>,
            status: Result<super::VpcFirewallRuleStatus, String>,
            targets: Result<Vec<super::VpcFirewallRuleTarget>, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vpc_id: Result<uuid::Uuid, String>,
        }

        impl Default for VpcFirewallRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    direction: Err("no value supplied for direction".to_string()),
                    filters: Err("no value supplied for filters".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    targets: Err("no value supplied for targets".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl VpcFirewallRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleAction>,
                T::Error: std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn direction<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleDirection>,
                T::Error: std::fmt::Display,
            {
                self.direction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for direction: {}", e));
                self
            }
            pub fn filters<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleFilter>,
                T::Error: std::fmt::Display,
            {
                self.filters = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for filters: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u16>,
                T::Error: std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn targets<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcFirewallRuleTarget>>,
                T::Error: std::fmt::Display,
            {
                self.targets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for targets: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcFirewallRule> for super::VpcFirewallRule {
            type Error = super::error::ConversionError;
            fn try_from(value: VpcFirewallRule) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    description: value.description?,
                    direction: value.direction?,
                    filters: value.filters?,
                    id: value.id?,
                    name: value.name?,
                    priority: value.priority?,
                    status: value.status?,
                    targets: value.targets?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        impl From<super::VpcFirewallRule> for VpcFirewallRule {
            fn from(value: super::VpcFirewallRule) -> Self {
                Self {
                    action: Ok(value.action),
                    description: Ok(value.description),
                    direction: Ok(value.direction),
                    filters: Ok(value.filters),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    priority: Ok(value.priority),
                    status: Ok(value.status),
                    targets: Ok(value.targets),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vpc_id: Ok(value.vpc_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcFirewallRuleFilter {
            hosts: Result<Option<Vec<super::VpcFirewallRuleHostFilter>>, String>,
            ports: Result<Option<Vec<super::L4PortRange>>, String>,
            protocols: Result<Option<Vec<super::VpcFirewallRuleProtocol>>, String>,
        }

        impl Default for VpcFirewallRuleFilter {
            fn default() -> Self {
                Self {
                    hosts: Ok(Default::default()),
                    ports: Ok(Default::default()),
                    protocols: Ok(Default::default()),
                }
            }
        }

        impl VpcFirewallRuleFilter {
            pub fn hosts<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<Vec<super::VpcFirewallRuleHostFilter>>>,
                T::Error: std::fmt::Display,
            {
                self.hosts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hosts: {}", e));
                self
            }
            pub fn ports<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<Vec<super::L4PortRange>>>,
                T::Error: std::fmt::Display,
            {
                self.ports = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ports: {}", e));
                self
            }
            pub fn protocols<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<Vec<super::VpcFirewallRuleProtocol>>>,
                T::Error: std::fmt::Display,
            {
                self.protocols = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for protocols: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcFirewallRuleFilter> for super::VpcFirewallRuleFilter {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcFirewallRuleFilter,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    hosts: value.hosts?,
                    ports: value.ports?,
                    protocols: value.protocols?,
                })
            }
        }

        impl From<super::VpcFirewallRuleFilter> for VpcFirewallRuleFilter {
            fn from(value: super::VpcFirewallRuleFilter) -> Self {
                Self {
                    hosts: Ok(value.hosts),
                    ports: Ok(value.ports),
                    protocols: Ok(value.protocols),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcFirewallRuleUpdate {
            action: Result<super::VpcFirewallRuleAction, String>,
            description: Result<String, String>,
            direction: Result<super::VpcFirewallRuleDirection, String>,
            filters: Result<super::VpcFirewallRuleFilter, String>,
            name: Result<super::Name, String>,
            priority: Result<u16, String>,
            status: Result<super::VpcFirewallRuleStatus, String>,
            targets: Result<Vec<super::VpcFirewallRuleTarget>, String>,
        }

        impl Default for VpcFirewallRuleUpdate {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    direction: Err("no value supplied for direction".to_string()),
                    filters: Err("no value supplied for filters".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    targets: Err("no value supplied for targets".to_string()),
                }
            }
        }

        impl VpcFirewallRuleUpdate {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleAction>,
                T::Error: std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn direction<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleDirection>,
                T::Error: std::fmt::Display,
            {
                self.direction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for direction: {}", e));
                self
            }
            pub fn filters<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleFilter>,
                T::Error: std::fmt::Display,
            {
                self.filters = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for filters: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u16>,
                T::Error: std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn targets<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcFirewallRuleTarget>>,
                T::Error: std::fmt::Display,
            {
                self.targets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for targets: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcFirewallRuleUpdate> for super::VpcFirewallRuleUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcFirewallRuleUpdate,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    description: value.description?,
                    direction: value.direction?,
                    filters: value.filters?,
                    name: value.name?,
                    priority: value.priority?,
                    status: value.status?,
                    targets: value.targets?,
                })
            }
        }

        impl From<super::VpcFirewallRuleUpdate> for VpcFirewallRuleUpdate {
            fn from(value: super::VpcFirewallRuleUpdate) -> Self {
                Self {
                    action: Ok(value.action),
                    description: Ok(value.description),
                    direction: Ok(value.direction),
                    filters: Ok(value.filters),
                    name: Ok(value.name),
                    priority: Ok(value.priority),
                    status: Ok(value.status),
                    targets: Ok(value.targets),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcFirewallRuleUpdateParams {
            rules: Result<Vec<super::VpcFirewallRuleUpdate>, String>,
        }

        impl Default for VpcFirewallRuleUpdateParams {
            fn default() -> Self {
                Self {
                    rules: Err("no value supplied for rules".to_string()),
                }
            }
        }

        impl VpcFirewallRuleUpdateParams {
            pub fn rules<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcFirewallRuleUpdate>>,
                T::Error: std::fmt::Display,
            {
                self.rules = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rules: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcFirewallRuleUpdateParams> for super::VpcFirewallRuleUpdateParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcFirewallRuleUpdateParams,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    rules: value.rules?,
                })
            }
        }

        impl From<super::VpcFirewallRuleUpdateParams> for VpcFirewallRuleUpdateParams {
            fn from(value: super::VpcFirewallRuleUpdateParams) -> Self {
                Self {
                    rules: Ok(value.rules),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcFirewallRules {
            rules: Result<Vec<super::VpcFirewallRule>, String>,
        }

        impl Default for VpcFirewallRules {
            fn default() -> Self {
                Self {
                    rules: Err("no value supplied for rules".to_string()),
                }
            }
        }

        impl VpcFirewallRules {
            pub fn rules<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcFirewallRule>>,
                T::Error: std::fmt::Display,
            {
                self.rules = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rules: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcFirewallRules> for super::VpcFirewallRules {
            type Error = super::error::ConversionError;
            fn try_from(value: VpcFirewallRules) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    rules: value.rules?,
                })
            }
        }

        impl From<super::VpcFirewallRules> for VpcFirewallRules {
            fn from(value: super::VpcFirewallRules) -> Self {
                Self {
                    rules: Ok(value.rules),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcResultsPage {
            items: Result<Vec<super::Vpc>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for VpcResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl VpcResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Vpc>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcResultsPage> for super::VpcResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(value: VpcResultsPage) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::VpcResultsPage> for VpcResultsPage {
            fn from(value: super::VpcResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcRouter {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            kind: Result<super::VpcRouterKind, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vpc_id: Result<uuid::Uuid, String>,
        }

        impl Default for VpcRouter {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl VpcRouter {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcRouterKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcRouter> for super::VpcRouter {
            type Error = super::error::ConversionError;
            fn try_from(value: VpcRouter) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    kind: value.kind?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        impl From<super::VpcRouter> for VpcRouter {
            fn from(value: super::VpcRouter) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    kind: Ok(value.kind),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vpc_id: Ok(value.vpc_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcRouterCreate {
            description: Result<String, String>,
            name: Result<super::Name, String>,
        }

        impl Default for VpcRouterCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl VpcRouterCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcRouterCreate> for super::VpcRouterCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: VpcRouterCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl From<super::VpcRouterCreate> for VpcRouterCreate {
            fn from(value: super::VpcRouterCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcRouterResultsPage {
            items: Result<Vec<super::VpcRouter>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for VpcRouterResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl VpcRouterResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcRouter>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcRouterResultsPage> for super::VpcRouterResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcRouterResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::VpcRouterResultsPage> for VpcRouterResultsPage {
            fn from(value: super::VpcRouterResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcRouterUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for VpcRouterUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl VpcRouterUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcRouterUpdate> for super::VpcRouterUpdate {
            type Error = super::error::ConversionError;
            fn try_from(value: VpcRouterUpdate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl From<super::VpcRouterUpdate> for VpcRouterUpdate {
            fn from(value: super::VpcRouterUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcSubnet {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            ipv4_block: Result<super::Ipv4Net, String>,
            ipv6_block: Result<super::Ipv6Net, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vpc_id: Result<uuid::Uuid, String>,
        }

        impl Default for VpcSubnet {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    ipv4_block: Err("no value supplied for ipv4_block".to_string()),
                    ipv6_block: Err("no value supplied for ipv6_block".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl VpcSubnet {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn ipv4_block<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Ipv4Net>,
                T::Error: std::fmt::Display,
            {
                self.ipv4_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv4_block: {}", e));
                self
            }
            pub fn ipv6_block<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Ipv6Net>,
                T::Error: std::fmt::Display,
            {
                self.ipv6_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_block: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcSubnet> for super::VpcSubnet {
            type Error = super::error::ConversionError;
            fn try_from(value: VpcSubnet) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    ipv4_block: value.ipv4_block?,
                    ipv6_block: value.ipv6_block?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        impl From<super::VpcSubnet> for VpcSubnet {
            fn from(value: super::VpcSubnet) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    ipv4_block: Ok(value.ipv4_block),
                    ipv6_block: Ok(value.ipv6_block),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vpc_id: Ok(value.vpc_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcSubnetCreate {
            description: Result<String, String>,
            ipv4_block: Result<super::Ipv4Net, String>,
            ipv6_block: Result<Option<super::Ipv6Net>, String>,
            name: Result<super::Name, String>,
        }

        impl Default for VpcSubnetCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    ipv4_block: Err("no value supplied for ipv4_block".to_string()),
                    ipv6_block: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl VpcSubnetCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn ipv4_block<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Ipv4Net>,
                T::Error: std::fmt::Display,
            {
                self.ipv4_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv4_block: {}", e));
                self
            }
            pub fn ipv6_block<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Ipv6Net>>,
                T::Error: std::fmt::Display,
            {
                self.ipv6_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_block: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcSubnetCreate> for super::VpcSubnetCreate {
            type Error = super::error::ConversionError;
            fn try_from(value: VpcSubnetCreate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    ipv4_block: value.ipv4_block?,
                    ipv6_block: value.ipv6_block?,
                    name: value.name?,
                })
            }
        }

        impl From<super::VpcSubnetCreate> for VpcSubnetCreate {
            fn from(value: super::VpcSubnetCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    ipv4_block: Ok(value.ipv4_block),
                    ipv6_block: Ok(value.ipv6_block),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcSubnetResultsPage {
            items: Result<Vec<super::VpcSubnet>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for VpcSubnetResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl VpcSubnetResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcSubnet>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcSubnetResultsPage> for super::VpcSubnetResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcSubnetResultsPage,
            ) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl From<super::VpcSubnetResultsPage> for VpcSubnetResultsPage {
            fn from(value: super::VpcSubnetResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcSubnetUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for VpcSubnetUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl VpcSubnetUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcSubnetUpdate> for super::VpcSubnetUpdate {
            type Error = super::error::ConversionError;
            fn try_from(value: VpcSubnetUpdate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl From<super::VpcSubnetUpdate> for VpcSubnetUpdate {
            fn from(value: super::VpcSubnetUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcUpdate {
            description: Result<Option<String>, String>,
            dns_name: Result<Option<super::Name>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for VpcUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    dns_name: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl VpcUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn dns_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.dns_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dns_name: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcUpdate> for super::VpcUpdate {
            type Error = super::error::ConversionError;
            fn try_from(value: VpcUpdate) -> Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    dns_name: value.dns_name?,
                    name: value.name?,
                })
            }
        }

        impl From<super::VpcUpdate> for VpcUpdate {
            fn from(value: super::VpcUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    dns_name: Ok(value.dns_name),
                    name: Ok(value.name),
                }
            }
        }
    }

    /// Generation of default values for serde.
    pub mod defaults {
        pub(super) fn default_bool<const V: bool>() -> bool {
            V
        }

        pub(super) fn instance_create_network_interfaces(
        ) -> super::InstanceNetworkInterfaceAttachment {
            super::InstanceNetworkInterfaceAttachment::Default
        }
    }
}

#[derive(Clone, Debug)]
///Client for Oxide Region API
///
///API for interacting with the Oxide control plane
///
///Version: 0.0.1
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }

    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }

    /// Get the base URL to which requests are made.
    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }

    /// Get the internal `reqwest::Client` used to make requests.
    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }

    /// Get the version of this API.
    ///
    /// This string is pulled directly from the source OpenAPI
    /// document and may be in any format the API selects.
    pub fn api_version(&self) -> &'static str {
        "0.0.1"
    }
}

///Virtual disks are used to store instance-local data which includes the
/// operating system.
pub trait ClientDisksExt {
    ///Fetch a disk by id
    ///
    ///Use `GET /v1/disks/{disk}` instead
    ///
    ///Sends a `GET` request to `/by-id/disks/{id}`
    ///
    ///```ignore
    /// let response = client.disk_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_view_by_id(&self) -> builder::DiskViewById;
    ///List disks
    ///
    ///Use `GET /v1/disks` instead
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/disks`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.disk_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_list(&self) -> builder::DiskList;
    ///Use `POST /v1/disks` instead
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/disks`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///```ignore
    /// let response = client.disk_create()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_create(&self) -> builder::DiskCreate;
    ///Fetch a disk
    ///
    ///Use `GET /v1/disks/{disk}` instead
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}`
    ///
    ///```ignore
    /// let response = client.disk_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .disk_name(disk_name)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_view(&self) -> builder::DiskView;
    ///Use `DELETE /v1/disks/{disk}` instead
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}`
    ///
    ///```ignore
    /// let response = client.disk_delete()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .disk_name(disk_name)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_delete(&self) -> builder::DiskDelete;
    ///Fetch disk metrics
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}/metrics/{metric_name}`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `disk_name`
    /// - `metric_name`
    /// - `end_time`: An exclusive end time of metrics.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `start_time`: An inclusive start time of metrics.
    ///```ignore
    /// let response = client.disk_metrics_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .disk_name(disk_name)
    ///    .metric_name(metric_name)
    ///    .end_time(end_time)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .start_time(start_time)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_metrics_list(&self) -> builder::DiskMetricsList;
    ///List disks
    ///
    ///Sends a `GET` request to `/v1/disks`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`
    /// - `sort_by`
    ///```ignore
    /// let response = client.disk_list_v1()
    ///    .limit(limit)
    ///    .organization(organization)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_list_v1(&self) -> builder::DiskListV1;
    ///Create a disk
    ///
    ///Sends a `POST` request to `/v1/disks`
    ///
    ///```ignore
    /// let response = client.disk_create_v1()
    ///    .organization(organization)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_create_v1(&self) -> builder::DiskCreateV1;
    ///Fetch a disk
    ///
    ///Sends a `GET` request to `/v1/disks/{disk}`
    ///
    ///```ignore
    /// let response = client.disk_view_v1()
    ///    .disk(disk)
    ///    .organization(organization)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_view_v1(&self) -> builder::DiskViewV1;
    ///Delete a disk
    ///
    ///Sends a `DELETE` request to `/v1/disks/{disk}`
    ///
    ///```ignore
    /// let response = client.disk_delete_v1()
    ///    .disk(disk)
    ///    .organization(organization)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_delete_v1(&self) -> builder::DiskDeleteV1;
}

impl ClientDisksExt for Client {
    fn disk_view_by_id(&self) -> builder::DiskViewById {
        builder::DiskViewById::new(self)
    }

    fn disk_list(&self) -> builder::DiskList {
        builder::DiskList::new(self)
    }

    fn disk_create(&self) -> builder::DiskCreate {
        builder::DiskCreate::new(self)
    }

    fn disk_view(&self) -> builder::DiskView {
        builder::DiskView::new(self)
    }

    fn disk_delete(&self) -> builder::DiskDelete {
        builder::DiskDelete::new(self)
    }

    fn disk_metrics_list(&self) -> builder::DiskMetricsList {
        builder::DiskMetricsList::new(self)
    }

    fn disk_list_v1(&self) -> builder::DiskListV1 {
        builder::DiskListV1::new(self)
    }

    fn disk_create_v1(&self) -> builder::DiskCreateV1 {
        builder::DiskCreateV1::new(self)
    }

    fn disk_view_v1(&self) -> builder::DiskViewV1 {
        builder::DiskViewV1::new(self)
    }

    fn disk_delete_v1(&self) -> builder::DiskDeleteV1 {
        builder::DiskDeleteV1::new(self)
    }
}

///TODO operations that will not ship to customers
pub trait ClientHiddenExt {
    ///Start an OAuth 2.0 Device Authorization Grant
    ///
    ///This endpoint is designed to be accessed from an *unauthenticated* API
    /// client. It generates and records a `device_code` and `user_code` which
    /// must be verified and confirmed prior to a token being granted.
    ///
    ///Sends a `POST` request to `/device/auth`
    ///
    ///```ignore
    /// let response = client.device_auth_request()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn device_auth_request(&self) -> builder::DeviceAuthRequest;
    ///Confirm an OAuth 2.0 Device Authorization Grant
    ///
    ///This endpoint is designed to be accessed by the user agent (browser),
    /// not the client requesting the token. So we do not actually return the
    /// token here; it will be returned in response to the poll on
    /// `/device/token`.
    ///
    ///Sends a `POST` request to `/device/confirm`
    ///
    ///```ignore
    /// let response = client.device_auth_confirm()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn device_auth_confirm(&self) -> builder::DeviceAuthConfirm;
    ///Request a device access token
    ///
    ///This endpoint should be polled by the client until the user code is
    /// verified and the grant is confirmed.
    ///
    ///Sends a `POST` request to `/device/token`
    ///
    ///```ignore
    /// let response = client.device_access_token()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn device_access_token(&self) -> builder::DeviceAccessToken;
    ///Sends a `POST` request to `/login`
    ///
    ///```ignore
    /// let response = client.login_spoof()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn login_spoof(&self) -> builder::LoginSpoof;
    ///Sends a `POST` request to `/logout`
    ///
    ///```ignore
    /// let response = client.logout()
    ///    .send()
    ///    .await;
    /// ```
    fn logout(&self) -> builder::Logout;
    ///Fetch the user associated with the current session
    ///
    ///Sends a `GET` request to `/session/me`
    ///
    ///```ignore
    /// let response = client.session_me()
    ///    .send()
    ///    .await;
    /// ```
    fn session_me(&self) -> builder::SessionMe;
    ///Fetch the silogroups the current user belongs to
    ///
    ///Sends a `GET` request to `/session/me/groups`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.session_me_groups()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn session_me_groups(&self) -> builder::SessionMeGroups;
}

impl ClientHiddenExt for Client {
    fn device_auth_request(&self) -> builder::DeviceAuthRequest {
        builder::DeviceAuthRequest::new(self)
    }

    fn device_auth_confirm(&self) -> builder::DeviceAuthConfirm {
        builder::DeviceAuthConfirm::new(self)
    }

    fn device_access_token(&self) -> builder::DeviceAccessToken {
        builder::DeviceAccessToken::new(self)
    }

    fn login_spoof(&self) -> builder::LoginSpoof {
        builder::LoginSpoof::new(self)
    }

    fn logout(&self) -> builder::Logout {
        builder::Logout::new(self)
    }

    fn session_me(&self) -> builder::SessionMe {
        builder::SessionMe::new(self)
    }

    fn session_me_groups(&self) -> builder::SessionMeGroups {
        builder::SessionMeGroups::new(self)
    }
}

///Images are read-only Virtual Disks that may be used to boot Virtual Machines
pub trait ClientImagesExt {
    ///Fetch an image by id
    ///
    ///Sends a `GET` request to `/by-id/images/{id}`
    ///
    ///```ignore
    /// let response = client.image_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn image_view_by_id(&self) -> builder::ImageViewById;
    ///List images
    ///
    ///List images in a project. The images are returned sorted by creation
    /// date, with the most recent images appearing first.
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/images`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.image_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn image_list(&self) -> builder::ImageList;
    ///Create an image
    ///
    ///Create a new image in a project.
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/images`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///```ignore
    /// let response = client.image_create()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn image_create(&self) -> builder::ImageCreate;
    ///Fetch an image
    ///
    ///Fetch the details for a specific image in a project.
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/images/
    /// {image_name}`
    ///
    ///```ignore
    /// let response = client.image_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .image_name(image_name)
    ///    .send()
    ///    .await;
    /// ```
    fn image_view(&self) -> builder::ImageView;
    ///Delete an image
    ///
    ///Permanently delete an image from a project. This operation cannot be
    /// undone. Any instances in the project using the image will continue to
    /// run, however new instances can not be created with this image.
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/images/
    /// {image_name}`
    ///
    ///```ignore
    /// let response = client.image_delete()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .image_name(image_name)
    ///    .send()
    ///    .await;
    /// ```
    fn image_delete(&self) -> builder::ImageDelete;
}

impl ClientImagesExt for Client {
    fn image_view_by_id(&self) -> builder::ImageViewById {
        builder::ImageViewById::new(self)
    }

    fn image_list(&self) -> builder::ImageList {
        builder::ImageList::new(self)
    }

    fn image_create(&self) -> builder::ImageCreate {
        builder::ImageCreate::new(self)
    }

    fn image_view(&self) -> builder::ImageView {
        builder::ImageView::new(self)
    }

    fn image_delete(&self) -> builder::ImageDelete {
        builder::ImageDelete::new(self)
    }
}

///Virtual machine instances are the basic unit of computation. These
/// operations are used for provisioning, controlling, and destroying instances.
pub trait ClientInstancesExt {
    ///Fetch an instance by id
    ///
    ///Sends a `GET` request to `/by-id/instances/{id}`
    ///
    ///```ignore
    /// let response = client.instance_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_view_by_id(&self) -> builder::InstanceViewById;
    ///Fetch a network interface by id
    ///
    ///Sends a `GET` request to `/by-id/network-interfaces/{id}`
    ///
    ///```ignore
    /// let response = client.instance_network_interface_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interface_view_by_id(&self) -> builder::InstanceNetworkInterfaceViewById;
    ///List instances
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.instance_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_list(&self) -> builder::InstanceList;
    ///Create an instance
    ///
    ///Use `POST /v1/instances` instead
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///```ignore
    /// let response = client.instance_create()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_create(&self) -> builder::InstanceCreate;
    ///Fetch an instance
    ///
    ///Use `GET /v1/instances/{instance}` instead
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}`
    ///
    ///```ignore
    /// let response = client.instance_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_view(&self) -> builder::InstanceView;
    ///Delete an instance
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}`
    ///
    ///```ignore
    /// let response = client.instance_delete()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_delete(&self) -> builder::InstanceDelete;
    ///List an instance's disks
    ///
    ///Use `GET /v1/instances/{instance}/disks` instead
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.instance_disk_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disk_list(&self) -> builder::InstanceDiskList;
    ///Attach a disk to an instance
    ///
    ///Use `POST /v1/instances/{instance}/disks/attach` instead
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks/attach`
    ///
    ///```ignore
    /// let response = client.instance_disk_attach()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disk_attach(&self) -> builder::InstanceDiskAttach;
    ///Detach a disk from an instance
    ///
    ///Use `POST /v1/disks/{disk}/detach` instead
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks/detach`
    ///
    ///```ignore
    /// let response = client.instance_disk_detach()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disk_detach(&self) -> builder::InstanceDiskDetach;
    ///List external IP addresses
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/external-ips`
    ///
    ///```ignore
    /// let response = client.instance_external_ip_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_external_ip_list(&self) -> builder::InstanceExternalIpList;
    ///Migrate an instance
    ///
    ///Use `POST /v1/instances/{instance}/migrate` instead
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/migrate`
    ///
    ///```ignore
    /// let response = client.instance_migrate()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_migrate(&self) -> builder::InstanceMigrate;
    ///List network interfaces
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.instance_network_interface_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interface_list(&self) -> builder::InstanceNetworkInterfaceList;
    ///Create a network interface
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces`
    ///
    ///```ignore
    /// let response = client.instance_network_interface_create()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interface_create(&self) -> builder::InstanceNetworkInterfaceCreate;
    ///Fetch a network interface
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces/{interface_name}`
    ///
    ///```ignore
    /// let response = client.instance_network_interface_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .interface_name(interface_name)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interface_view(&self) -> builder::InstanceNetworkInterfaceView;
    ///Update a network interface
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces/{interface_name}`
    ///
    ///```ignore
    /// let response = client.instance_network_interface_update()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .interface_name(interface_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interface_update(&self) -> builder::InstanceNetworkInterfaceUpdate;
    ///Delete a network interface
    ///
    ///Note that the primary interface for an instance cannot be deleted if
    /// there are any secondary interfaces. A new primary interface must be
    /// designated first. The primary interface can be deleted if there are no
    /// secondary interfaces.
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces/{interface_name}`
    ///
    ///```ignore
    /// let response = client.instance_network_interface_delete()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .interface_name(interface_name)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interface_delete(&self) -> builder::InstanceNetworkInterfaceDelete;
    ///Reboot an instance
    ///
    ///Use `POST /v1/instances/{instance}/reboot` instead
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/reboot`
    ///
    ///```ignore
    /// let response = client.instance_reboot()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_reboot(&self) -> builder::InstanceReboot;
    ///Fetch an instance's serial console
    ///
    ///Use `GET /v1/instances/{instance}/serial-console` instead
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/serial-console`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `from_start`: Character index in the serial buffer from which to read,
    ///   counting the bytes output since instance start. If this is not
    ///   provided, `most_recent` must be provided, and if this *is* provided,
    ///   `most_recent` must *not* be provided.
    /// - `max_bytes`: Maximum number of bytes of buffered serial console
    ///   contents to return. If the requested range runs to the end of the
    ///   available buffer, the data returned will be shorter than `max_bytes`.
    /// - `most_recent`: Character index in the serial buffer from which to
    ///   read, counting *backward* from the most recently buffered data
    ///   retrieved from the instance. (See note on `from_start` about mutual
    ///   exclusivity)
    ///```ignore
    /// let response = client.instance_serial_console()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .from_start(from_start)
    ///    .max_bytes(max_bytes)
    ///    .most_recent(most_recent)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_serial_console(&self) -> builder::InstanceSerialConsole;
    ///Connect to an instance's serial console
    ///
    ///Use `GET /v1/instances/{instance}/serial-console/stream` instead
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/serial-console/stream`
    ///
    ///```ignore
    /// let response = client.instance_serial_console_stream()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_serial_console_stream(&self) -> builder::InstanceSerialConsoleStream;
    ///Boot an instance
    ///
    ///Use `POST /v1/instances/{instance}/start` instead
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/start`
    ///
    ///```ignore
    /// let response = client.instance_start()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_start(&self) -> builder::InstanceStart;
    ///Halt an instance
    ///
    ///Use `POST /v1/instances/{instance}/stop` instead
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/stop`
    ///
    ///```ignore
    /// let response = client.instance_stop()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_stop(&self) -> builder::InstanceStop;
    ///List instances
    ///
    ///Sends a `GET` request to `/v1/instances`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`
    /// - `sort_by`
    ///```ignore
    /// let response = client.instance_list_v1()
    ///    .limit(limit)
    ///    .organization(organization)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_list_v1(&self) -> builder::InstanceListV1;
    ///Create an instance
    ///
    ///Sends a `POST` request to `/v1/instances`
    ///
    ///```ignore
    /// let response = client.instance_create_v1()
    ///    .organization(organization)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_create_v1(&self) -> builder::InstanceCreateV1;
    ///Fetch an instance
    ///
    ///Sends a `GET` request to `/v1/instances/{instance}`
    ///
    ///```ignore
    /// let response = client.instance_view_v1()
    ///    .instance(instance)
    ///    .organization(organization)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_view_v1(&self) -> builder::InstanceViewV1;
    ///Delete an instance
    ///
    ///Sends a `DELETE` request to `/v1/instances/{instance}`
    ///
    ///```ignore
    /// let response = client.instance_delete_v1()
    ///    .instance(instance)
    ///    .organization(organization)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_delete_v1(&self) -> builder::InstanceDeleteV1;
    ///List an instance's disks
    ///
    ///Sends a `GET` request to `/v1/instances/{instance}/disks`
    ///
    ///Arguments:
    /// - `instance`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`
    /// - `sort_by`
    ///```ignore
    /// let response = client.instance_disk_list_v1()
    ///    .instance(instance)
    ///    .limit(limit)
    ///    .organization(organization)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disk_list_v1(&self) -> builder::InstanceDiskListV1;
    ///Attach a disk to an instance
    ///
    ///Sends a `POST` request to `/v1/instances/{instance}/disks/attach`
    ///
    ///```ignore
    /// let response = client.instance_disk_attach_v1()
    ///    .instance(instance)
    ///    .organization(organization)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disk_attach_v1(&self) -> builder::InstanceDiskAttachV1;
    ///Detach a disk from an instance
    ///
    ///Sends a `POST` request to `/v1/instances/{instance}/disks/detach`
    ///
    ///```ignore
    /// let response = client.instance_disk_detach_v1()
    ///    .instance(instance)
    ///    .organization(organization)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disk_detach_v1(&self) -> builder::InstanceDiskDetachV1;
    ///Migrate an instance
    ///
    ///Sends a `POST` request to `/v1/instances/{instance}/migrate`
    ///
    ///```ignore
    /// let response = client.instance_migrate_v1()
    ///    .instance(instance)
    ///    .organization(organization)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_migrate_v1(&self) -> builder::InstanceMigrateV1;
    ///Reboot an instance
    ///
    ///Sends a `POST` request to `/v1/instances/{instance}/reboot`
    ///
    ///```ignore
    /// let response = client.instance_reboot_v1()
    ///    .instance(instance)
    ///    .organization(organization)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_reboot_v1(&self) -> builder::InstanceRebootV1;
    ///Fetch an instance's serial console
    ///
    ///Sends a `GET` request to `/v1/instances/{instance}/serial-console`
    ///
    ///Arguments:
    /// - `instance`
    /// - `from_start`: Character index in the serial buffer from which to read,
    ///   counting the bytes output since instance start. If this is not
    ///   provided, `most_recent` must be provided, and if this *is* provided,
    ///   `most_recent` must *not* be provided.
    /// - `max_bytes`: Maximum number of bytes of buffered serial console
    ///   contents to return. If the requested range runs to the end of the
    ///   available buffer, the data returned will be shorter than `max_bytes`.
    /// - `most_recent`: Character index in the serial buffer from which to
    ///   read, counting *backward* from the most recently buffered data
    ///   retrieved from the instance. (See note on `from_start` about mutual
    ///   exclusivity)
    /// - `organization`
    /// - `project`
    ///```ignore
    /// let response = client.instance_serial_console_v1()
    ///    .instance(instance)
    ///    .from_start(from_start)
    ///    .max_bytes(max_bytes)
    ///    .most_recent(most_recent)
    ///    .organization(organization)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_serial_console_v1(&self) -> builder::InstanceSerialConsoleV1;
    ///Stream an instance's serial console
    ///
    ///Sends a `GET` request to
    /// `/v1/instances/{instance}/serial-console/stream`
    ///
    ///```ignore
    /// let response = client.instance_serial_console_stream_v1()
    ///    .instance(instance)
    ///    .organization(organization)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_serial_console_stream_v1(&self) -> builder::InstanceSerialConsoleStreamV1;
    ///Boot an instance
    ///
    ///Sends a `POST` request to `/v1/instances/{instance}/start`
    ///
    ///```ignore
    /// let response = client.instance_start_v1()
    ///    .instance(instance)
    ///    .organization(organization)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_start_v1(&self) -> builder::InstanceStartV1;
    ///Stop an instance
    ///
    ///Sends a `POST` request to `/v1/instances/{instance}/stop`
    ///
    ///```ignore
    /// let response = client.instance_stop_v1()
    ///    .instance(instance)
    ///    .organization(organization)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_stop_v1(&self) -> builder::InstanceStopV1;
}

impl ClientInstancesExt for Client {
    fn instance_view_by_id(&self) -> builder::InstanceViewById {
        builder::InstanceViewById::new(self)
    }

    fn instance_network_interface_view_by_id(&self) -> builder::InstanceNetworkInterfaceViewById {
        builder::InstanceNetworkInterfaceViewById::new(self)
    }

    fn instance_list(&self) -> builder::InstanceList {
        builder::InstanceList::new(self)
    }

    fn instance_create(&self) -> builder::InstanceCreate {
        builder::InstanceCreate::new(self)
    }

    fn instance_view(&self) -> builder::InstanceView {
        builder::InstanceView::new(self)
    }

    fn instance_delete(&self) -> builder::InstanceDelete {
        builder::InstanceDelete::new(self)
    }

    fn instance_disk_list(&self) -> builder::InstanceDiskList {
        builder::InstanceDiskList::new(self)
    }

    fn instance_disk_attach(&self) -> builder::InstanceDiskAttach {
        builder::InstanceDiskAttach::new(self)
    }

    fn instance_disk_detach(&self) -> builder::InstanceDiskDetach {
        builder::InstanceDiskDetach::new(self)
    }

    fn instance_external_ip_list(&self) -> builder::InstanceExternalIpList {
        builder::InstanceExternalIpList::new(self)
    }

    fn instance_migrate(&self) -> builder::InstanceMigrate {
        builder::InstanceMigrate::new(self)
    }

    fn instance_network_interface_list(&self) -> builder::InstanceNetworkInterfaceList {
        builder::InstanceNetworkInterfaceList::new(self)
    }

    fn instance_network_interface_create(&self) -> builder::InstanceNetworkInterfaceCreate {
        builder::InstanceNetworkInterfaceCreate::new(self)
    }

    fn instance_network_interface_view(&self) -> builder::InstanceNetworkInterfaceView {
        builder::InstanceNetworkInterfaceView::new(self)
    }

    fn instance_network_interface_update(&self) -> builder::InstanceNetworkInterfaceUpdate {
        builder::InstanceNetworkInterfaceUpdate::new(self)
    }

    fn instance_network_interface_delete(&self) -> builder::InstanceNetworkInterfaceDelete {
        builder::InstanceNetworkInterfaceDelete::new(self)
    }

    fn instance_reboot(&self) -> builder::InstanceReboot {
        builder::InstanceReboot::new(self)
    }

    fn instance_serial_console(&self) -> builder::InstanceSerialConsole {
        builder::InstanceSerialConsole::new(self)
    }

    fn instance_serial_console_stream(&self) -> builder::InstanceSerialConsoleStream {
        builder::InstanceSerialConsoleStream::new(self)
    }

    fn instance_start(&self) -> builder::InstanceStart {
        builder::InstanceStart::new(self)
    }

    fn instance_stop(&self) -> builder::InstanceStop {
        builder::InstanceStop::new(self)
    }

    fn instance_list_v1(&self) -> builder::InstanceListV1 {
        builder::InstanceListV1::new(self)
    }

    fn instance_create_v1(&self) -> builder::InstanceCreateV1 {
        builder::InstanceCreateV1::new(self)
    }

    fn instance_view_v1(&self) -> builder::InstanceViewV1 {
        builder::InstanceViewV1::new(self)
    }

    fn instance_delete_v1(&self) -> builder::InstanceDeleteV1 {
        builder::InstanceDeleteV1::new(self)
    }

    fn instance_disk_list_v1(&self) -> builder::InstanceDiskListV1 {
        builder::InstanceDiskListV1::new(self)
    }

    fn instance_disk_attach_v1(&self) -> builder::InstanceDiskAttachV1 {
        builder::InstanceDiskAttachV1::new(self)
    }

    fn instance_disk_detach_v1(&self) -> builder::InstanceDiskDetachV1 {
        builder::InstanceDiskDetachV1::new(self)
    }

    fn instance_migrate_v1(&self) -> builder::InstanceMigrateV1 {
        builder::InstanceMigrateV1::new(self)
    }

    fn instance_reboot_v1(&self) -> builder::InstanceRebootV1 {
        builder::InstanceRebootV1::new(self)
    }

    fn instance_serial_console_v1(&self) -> builder::InstanceSerialConsoleV1 {
        builder::InstanceSerialConsoleV1::new(self)
    }

    fn instance_serial_console_stream_v1(&self) -> builder::InstanceSerialConsoleStreamV1 {
        builder::InstanceSerialConsoleStreamV1::new(self)
    }

    fn instance_start_v1(&self) -> builder::InstanceStartV1 {
        builder::InstanceStartV1::new(self)
    }

    fn instance_stop_v1(&self) -> builder::InstanceStopV1 {
        builder::InstanceStopV1::new(self)
    }
}

///Authentication endpoints
pub trait ClientLoginExt {
    ///Authenticate a user (i.e., log in) via username and password
    ///
    ///Sends a `POST` request to `/login/{silo_name}/local`
    ///
    ///```ignore
    /// let response = client.login_local()
    ///    .silo_name(silo_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn login_local(&self) -> builder::LoginLocal;
    ///Prompt user login
    ///
    ///Either display a page asking a user for their credentials, or redirect
    /// them to their identity provider.
    ///
    ///Sends a `GET` request to `/login/{silo_name}/saml/{provider_name}`
    ///
    ///```ignore
    /// let response = client.login_saml_begin()
    ///    .silo_name(silo_name)
    ///    .provider_name(provider_name)
    ///    .send()
    ///    .await;
    /// ```
    fn login_saml_begin(&self) -> builder::LoginSamlBegin;
    ///Authenticate a user (i.e., log in) via SAML
    ///
    ///Sends a `POST` request to `/login/{silo_name}/saml/{provider_name}`
    ///
    ///```ignore
    /// let response = client.login_saml()
    ///    .silo_name(silo_name)
    ///    .provider_name(provider_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn login_saml(&self) -> builder::LoginSaml;
}

impl ClientLoginExt for Client {
    fn login_local(&self) -> builder::LoginLocal {
        builder::LoginLocal::new(self)
    }

    fn login_saml_begin(&self) -> builder::LoginSamlBegin {
        builder::LoginSamlBegin::new(self)
    }

    fn login_saml(&self) -> builder::LoginSaml {
        builder::LoginSaml::new(self)
    }
}

///Metrics provide insight into the operation of the Oxide deployment. These
/// include telemetry on hardware and software components that can be used to
/// understand the current state as well as to diagnose issues.
pub trait ClientMetricsExt {
    ///List timeseries schema
    ///
    ///Sends a `GET` request to `/timeseries/schema`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    ///```ignore
    /// let response = client.timeseries_schema_get()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn timeseries_schema_get(&self) -> builder::TimeseriesSchemaGet;
}

impl ClientMetricsExt for Client {
    fn timeseries_schema_get(&self) -> builder::TimeseriesSchemaGet {
        builder::TimeseriesSchemaGet::new(self)
    }
}

///Organizations represent a subset of users and projects in an Oxide
/// deployment.
pub trait ClientOrganizationsExt {
    ///Fetch an organization by id
    ///
    ///Use `GET /v1/organizations/{organization}` instead
    ///
    ///Sends a `GET` request to `/by-id/organizations/{id}`
    ///
    ///```ignore
    /// let response = client.organization_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_view_by_id(&self) -> builder::OrganizationViewById;
    ///List organizations
    ///
    ///Use `GET /v1/organizations` instead
    ///
    ///Sends a `GET` request to `/organizations`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.organization_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_list(&self) -> builder::OrganizationList;
    ///Create an organization
    ///
    ///Use `POST /v1/organizations` instead
    ///
    ///Sends a `POST` request to `/organizations`
    ///
    ///```ignore
    /// let response = client.organization_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_create(&self) -> builder::OrganizationCreate;
    ///Fetch an organization
    ///
    ///Use `GET /v1/organizations/{organization}` instead
    ///
    ///Sends a `GET` request to `/organizations/{organization_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    ///```ignore
    /// let response = client.organization_view()
    ///    .organization_name(organization_name)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_view(&self) -> builder::OrganizationView;
    ///Update an organization
    ///
    ///Use `PUT /v1/organizations/{organization}` instead
    ///
    ///Sends a `PUT` request to `/organizations/{organization_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    ///```ignore
    /// let response = client.organization_update()
    ///    .organization_name(organization_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_update(&self) -> builder::OrganizationUpdate;
    ///Delete an organization
    ///
    ///Use `DELETE /v1/organizations/{organization}` instead
    ///
    ///Sends a `DELETE` request to `/organizations/{organization_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    ///```ignore
    /// let response = client.organization_delete()
    ///    .organization_name(organization_name)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_delete(&self) -> builder::OrganizationDelete;
    ///Fetch an organization's IAM policy
    ///
    ///Use `GET /v1/organizations/{organization}/policy` instead
    ///
    ///Sends a `GET` request to `/organizations/{organization_name}/policy`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    ///```ignore
    /// let response = client.organization_policy_view()
    ///    .organization_name(organization_name)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_policy_view(&self) -> builder::OrganizationPolicyView;
    ///Update an organization's IAM policy
    ///
    ///Use `PUT /v1/organizations/{organization}/policy` instead
    ///
    ///Sends a `PUT` request to `/organizations/{organization_name}/policy`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    ///```ignore
    /// let response = client.organization_policy_update()
    ///    .organization_name(organization_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_policy_update(&self) -> builder::OrganizationPolicyUpdate;
    ///List organizations
    ///
    ///Sends a `GET` request to `/v1/organizations`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.organization_list_v1()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_list_v1(&self) -> builder::OrganizationListV1;
    ///Create an organization
    ///
    ///Sends a `POST` request to `/v1/organizations`
    ///
    ///```ignore
    /// let response = client.organization_create_v1()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_create_v1(&self) -> builder::OrganizationCreateV1;
    ///Fetch an organization
    ///
    ///Sends a `GET` request to `/v1/organizations/{organization}`
    ///
    ///```ignore
    /// let response = client.organization_view_v1()
    ///    .organization(organization)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_view_v1(&self) -> builder::OrganizationViewV1;
    ///Update an organization
    ///
    ///Sends a `PUT` request to `/v1/organizations/{organization}`
    ///
    ///```ignore
    /// let response = client.organization_update_v1()
    ///    .organization(organization)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_update_v1(&self) -> builder::OrganizationUpdateV1;
    ///Delete an organization
    ///
    ///Sends a `DELETE` request to `/v1/organizations/{organization}`
    ///
    ///```ignore
    /// let response = client.organization_delete_v1()
    ///    .organization(organization)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_delete_v1(&self) -> builder::OrganizationDeleteV1;
    ///Fetch an organization's IAM policy
    ///
    ///Sends a `GET` request to `/v1/organizations/{organization}/policy`
    ///
    ///```ignore
    /// let response = client.organization_policy_view_v1()
    ///    .organization(organization)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_policy_view_v1(&self) -> builder::OrganizationPolicyViewV1;
    ///Update an organization's IAM policy
    ///
    ///Sends a `PUT` request to `/v1/organizations/{organization}/policy`
    ///
    ///```ignore
    /// let response = client.organization_policy_update_v1()
    ///    .organization(organization)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_policy_update_v1(&self) -> builder::OrganizationPolicyUpdateV1;
}

impl ClientOrganizationsExt for Client {
    fn organization_view_by_id(&self) -> builder::OrganizationViewById {
        builder::OrganizationViewById::new(self)
    }

    fn organization_list(&self) -> builder::OrganizationList {
        builder::OrganizationList::new(self)
    }

    fn organization_create(&self) -> builder::OrganizationCreate {
        builder::OrganizationCreate::new(self)
    }

    fn organization_view(&self) -> builder::OrganizationView {
        builder::OrganizationView::new(self)
    }

    fn organization_update(&self) -> builder::OrganizationUpdate {
        builder::OrganizationUpdate::new(self)
    }

    fn organization_delete(&self) -> builder::OrganizationDelete {
        builder::OrganizationDelete::new(self)
    }

    fn organization_policy_view(&self) -> builder::OrganizationPolicyView {
        builder::OrganizationPolicyView::new(self)
    }

    fn organization_policy_update(&self) -> builder::OrganizationPolicyUpdate {
        builder::OrganizationPolicyUpdate::new(self)
    }

    fn organization_list_v1(&self) -> builder::OrganizationListV1 {
        builder::OrganizationListV1::new(self)
    }

    fn organization_create_v1(&self) -> builder::OrganizationCreateV1 {
        builder::OrganizationCreateV1::new(self)
    }

    fn organization_view_v1(&self) -> builder::OrganizationViewV1 {
        builder::OrganizationViewV1::new(self)
    }

    fn organization_update_v1(&self) -> builder::OrganizationUpdateV1 {
        builder::OrganizationUpdateV1::new(self)
    }

    fn organization_delete_v1(&self) -> builder::OrganizationDeleteV1 {
        builder::OrganizationDeleteV1::new(self)
    }

    fn organization_policy_view_v1(&self) -> builder::OrganizationPolicyViewV1 {
        builder::OrganizationPolicyViewV1::new(self)
    }

    fn organization_policy_update_v1(&self) -> builder::OrganizationPolicyUpdateV1 {
        builder::OrganizationPolicyUpdateV1::new(self)
    }
}

///System-wide IAM policy
pub trait ClientPolicyExt {
    ///Fetch the top-level IAM policy
    ///
    ///Sends a `GET` request to `/system/policy`
    ///
    ///```ignore
    /// let response = client.system_policy_view()
    ///    .send()
    ///    .await;
    /// ```
    fn system_policy_view(&self) -> builder::SystemPolicyView;
    ///Update the top-level IAM policy
    ///
    ///Sends a `PUT` request to `/system/policy`
    ///
    ///```ignore
    /// let response = client.system_policy_update()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn system_policy_update(&self) -> builder::SystemPolicyUpdate;
}

impl ClientPolicyExt for Client {
    fn system_policy_view(&self) -> builder::SystemPolicyView {
        builder::SystemPolicyView::new(self)
    }

    fn system_policy_update(&self) -> builder::SystemPolicyUpdate {
        builder::SystemPolicyUpdate::new(self)
    }
}

///Projects are a grouping of associated resources such as instances and disks
/// within an organization for purposes of billing and access control.
pub trait ClientProjectsExt {
    ///Fetch a project by id
    ///
    ///Use `GET /v1/projects/{project}` instead
    ///
    ///Sends a `GET` request to `/by-id/projects/{id}`
    ///
    ///```ignore
    /// let response = client.project_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn project_view_by_id(&self) -> builder::ProjectViewById;
    ///List projects
    ///
    ///Use `GET /v1/projects` instead
    ///
    ///Sends a `GET` request to `/organizations/{organization_name}/projects`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.project_list()
    ///    .organization_name(organization_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn project_list(&self) -> builder::ProjectList;
    ///Create a project
    ///
    ///Use `POST /v1/projects` instead
    ///
    ///Sends a `POST` request to `/organizations/{organization_name}/projects`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    ///```ignore
    /// let response = client.project_create()
    ///    .organization_name(organization_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_create(&self) -> builder::ProjectCreate;
    ///Fetch a project
    ///
    ///Use `GET /v1/projects/{project}` instead
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    ///```ignore
    /// let response = client.project_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_view(&self) -> builder::ProjectView;
    ///Update a project
    ///
    ///Use `PUT /v1/projects/{project}` instead
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///```ignore
    /// let response = client.project_update()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_update(&self) -> builder::ProjectUpdate;
    ///Delete a project
    ///
    ///Use `DELETE /v1/projects/{project}` instead
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    ///```ignore
    /// let response = client.project_delete()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_delete(&self) -> builder::ProjectDelete;
    ///Fetch a project's IAM policy
    ///
    ///Use `GET /v1/projects/{project}/policy` instead
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/policy`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    ///```ignore
    /// let response = client.project_policy_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_policy_view(&self) -> builder::ProjectPolicyView;
    ///Update a project's IAM policy
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/policy`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///```ignore
    /// let response = client.project_policy_update()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_policy_update(&self) -> builder::ProjectPolicyUpdate;
    ///List projects
    ///
    ///Sends a `GET` request to `/v1/projects`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.project_list_v1()
    ///    .limit(limit)
    ///    .organization(organization)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn project_list_v1(&self) -> builder::ProjectListV1;
    ///Create a project
    ///
    ///Sends a `POST` request to `/v1/projects`
    ///
    ///```ignore
    /// let response = client.project_create_v1()
    ///    .organization(organization)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_create_v1(&self) -> builder::ProjectCreateV1;
    ///Fetch a project
    ///
    ///Sends a `GET` request to `/v1/projects/{project}`
    ///
    ///```ignore
    /// let response = client.project_view_v1()
    ///    .project(project)
    ///    .organization(organization)
    ///    .send()
    ///    .await;
    /// ```
    fn project_view_v1(&self) -> builder::ProjectViewV1;
    ///Update a project
    ///
    ///Sends a `PUT` request to `/v1/projects/{project}`
    ///
    ///```ignore
    /// let response = client.project_update_v1()
    ///    .project(project)
    ///    .organization(organization)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_update_v1(&self) -> builder::ProjectUpdateV1;
    ///Delete a project
    ///
    ///Sends a `DELETE` request to `/v1/projects/{project}`
    ///
    ///```ignore
    /// let response = client.project_delete_v1()
    ///    .project(project)
    ///    .organization(organization)
    ///    .send()
    ///    .await;
    /// ```
    fn project_delete_v1(&self) -> builder::ProjectDeleteV1;
    ///Fetch a project's IAM policy
    ///
    ///Sends a `GET` request to `/v1/projects/{project}/policy`
    ///
    ///```ignore
    /// let response = client.project_policy_view_v1()
    ///    .project(project)
    ///    .organization(organization)
    ///    .send()
    ///    .await;
    /// ```
    fn project_policy_view_v1(&self) -> builder::ProjectPolicyViewV1;
    ///Update a project's IAM policy
    ///
    ///Sends a `PUT` request to `/v1/projects/{project}/policy`
    ///
    ///```ignore
    /// let response = client.project_policy_update_v1()
    ///    .project(project)
    ///    .organization(organization)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_policy_update_v1(&self) -> builder::ProjectPolicyUpdateV1;
}

impl ClientProjectsExt for Client {
    fn project_view_by_id(&self) -> builder::ProjectViewById {
        builder::ProjectViewById::new(self)
    }

    fn project_list(&self) -> builder::ProjectList {
        builder::ProjectList::new(self)
    }

    fn project_create(&self) -> builder::ProjectCreate {
        builder::ProjectCreate::new(self)
    }

    fn project_view(&self) -> builder::ProjectView {
        builder::ProjectView::new(self)
    }

    fn project_update(&self) -> builder::ProjectUpdate {
        builder::ProjectUpdate::new(self)
    }

    fn project_delete(&self) -> builder::ProjectDelete {
        builder::ProjectDelete::new(self)
    }

    fn project_policy_view(&self) -> builder::ProjectPolicyView {
        builder::ProjectPolicyView::new(self)
    }

    fn project_policy_update(&self) -> builder::ProjectPolicyUpdate {
        builder::ProjectPolicyUpdate::new(self)
    }

    fn project_list_v1(&self) -> builder::ProjectListV1 {
        builder::ProjectListV1::new(self)
    }

    fn project_create_v1(&self) -> builder::ProjectCreateV1 {
        builder::ProjectCreateV1::new(self)
    }

    fn project_view_v1(&self) -> builder::ProjectViewV1 {
        builder::ProjectViewV1::new(self)
    }

    fn project_update_v1(&self) -> builder::ProjectUpdateV1 {
        builder::ProjectUpdateV1::new(self)
    }

    fn project_delete_v1(&self) -> builder::ProjectDeleteV1 {
        builder::ProjectDeleteV1::new(self)
    }

    fn project_policy_view_v1(&self) -> builder::ProjectPolicyViewV1 {
        builder::ProjectPolicyViewV1::new(self)
    }

    fn project_policy_update_v1(&self) -> builder::ProjectPolicyUpdateV1 {
        builder::ProjectPolicyUpdateV1::new(self)
    }
}

///Roles are a component of Identity and Access Management (IAM) that allow a
/// user or agent account access to additional permissions.
pub trait ClientRolesExt {
    ///List built-in roles
    ///
    ///Sends a `GET` request to `/roles`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    ///```ignore
    /// let response = client.role_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn role_list(&self) -> builder::RoleList;
    ///Fetch a built-in role
    ///
    ///Sends a `GET` request to `/roles/{role_name}`
    ///
    ///Arguments:
    /// - `role_name`: The built-in role's unique name.
    ///```ignore
    /// let response = client.role_view()
    ///    .role_name(role_name)
    ///    .send()
    ///    .await;
    /// ```
    fn role_view(&self) -> builder::RoleView;
}

impl ClientRolesExt for Client {
    fn role_list(&self) -> builder::RoleList {
        builder::RoleList::new(self)
    }

    fn role_view(&self) -> builder::RoleView {
        builder::RoleView::new(self)
    }
}

///Information pertaining to the current session.
pub trait ClientSessionExt {
    ///List SSH public keys
    ///
    ///Lists SSH public keys for the currently authenticated user.
    ///
    ///Sends a `GET` request to `/session/me/sshkeys`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.session_sshkey_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn session_sshkey_list(&self) -> builder::SessionSshkeyList;
    ///Create an SSH public key
    ///
    ///Create an SSH public key for the currently authenticated user.
    ///
    ///Sends a `POST` request to `/session/me/sshkeys`
    ///
    ///```ignore
    /// let response = client.session_sshkey_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn session_sshkey_create(&self) -> builder::SessionSshkeyCreate;
    ///Fetch an SSH public key
    ///
    ///Fetch an SSH public key associated with the currently authenticated
    /// user.
    ///
    ///Sends a `GET` request to `/session/me/sshkeys/{ssh_key_name}`
    ///
    ///```ignore
    /// let response = client.session_sshkey_view()
    ///    .ssh_key_name(ssh_key_name)
    ///    .send()
    ///    .await;
    /// ```
    fn session_sshkey_view(&self) -> builder::SessionSshkeyView;
    ///Delete an SSH public key
    ///
    ///Delete an SSH public key associated with the currently authenticated
    /// user.
    ///
    ///Sends a `DELETE` request to `/session/me/sshkeys/{ssh_key_name}`
    ///
    ///```ignore
    /// let response = client.session_sshkey_delete()
    ///    .ssh_key_name(ssh_key_name)
    ///    .send()
    ///    .await;
    /// ```
    fn session_sshkey_delete(&self) -> builder::SessionSshkeyDelete;
}

impl ClientSessionExt for Client {
    fn session_sshkey_list(&self) -> builder::SessionSshkeyList {
        builder::SessionSshkeyList::new(self)
    }

    fn session_sshkey_create(&self) -> builder::SessionSshkeyCreate {
        builder::SessionSshkeyCreate::new(self)
    }

    fn session_sshkey_view(&self) -> builder::SessionSshkeyView {
        builder::SessionSshkeyView::new(self)
    }

    fn session_sshkey_delete(&self) -> builder::SessionSshkeyDelete {
        builder::SessionSshkeyDelete::new(self)
    }
}

///Silos represent a logical partition of users and resources.
pub trait ClientSilosExt {
    ///List groups
    ///
    ///Sends a `GET` request to `/groups`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.group_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn group_list(&self) -> builder::GroupList;
    ///Fetch the current silo's IAM policy
    ///
    ///Sends a `GET` request to `/policy`
    ///
    ///```ignore
    /// let response = client.policy_view()
    ///    .send()
    ///    .await;
    /// ```
    fn policy_view(&self) -> builder::PolicyView;
    ///Update the current silo's IAM policy
    ///
    ///Sends a `PUT` request to `/policy`
    ///
    ///```ignore
    /// let response = client.policy_update()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn policy_update(&self) -> builder::PolicyUpdate;
    ///List users
    ///
    ///Sends a `GET` request to `/users`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.user_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn user_list(&self) -> builder::UserList;
}

impl ClientSilosExt for Client {
    fn group_list(&self) -> builder::GroupList {
        builder::GroupList::new(self)
    }

    fn policy_view(&self) -> builder::PolicyView {
        builder::PolicyView::new(self)
    }

    fn policy_update(&self) -> builder::PolicyUpdate {
        builder::PolicyUpdate::new(self)
    }

    fn user_list(&self) -> builder::UserList {
        builder::UserList::new(self)
    }
}

///Snapshots of Virtual Disks at a particular point in time.
pub trait ClientSnapshotsExt {
    ///Fetch a snapshot by id
    ///
    ///Sends a `GET` request to `/by-id/snapshots/{id}`
    ///
    ///```ignore
    /// let response = client.snapshot_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn snapshot_view_by_id(&self) -> builder::SnapshotViewById;
    ///List snapshots
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/snapshots`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.snapshot_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn snapshot_list(&self) -> builder::SnapshotList;
    ///Create a snapshot
    ///
    ///Creates a point-in-time snapshot from a disk.
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/snapshots`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///```ignore
    /// let response = client.snapshot_create()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn snapshot_create(&self) -> builder::SnapshotCreate;
    ///Fetch a snapshot
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/snapshots/
    /// {snapshot_name}`
    ///
    ///```ignore
    /// let response = client.snapshot_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .snapshot_name(snapshot_name)
    ///    .send()
    ///    .await;
    /// ```
    fn snapshot_view(&self) -> builder::SnapshotView;
    ///Delete a snapshot
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/snapshots/
    /// {snapshot_name}`
    ///
    ///```ignore
    /// let response = client.snapshot_delete()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .snapshot_name(snapshot_name)
    ///    .send()
    ///    .await;
    /// ```
    fn snapshot_delete(&self) -> builder::SnapshotDelete;
}

impl ClientSnapshotsExt for Client {
    fn snapshot_view_by_id(&self) -> builder::SnapshotViewById {
        builder::SnapshotViewById::new(self)
    }

    fn snapshot_list(&self) -> builder::SnapshotList {
        builder::SnapshotList::new(self)
    }

    fn snapshot_create(&self) -> builder::SnapshotCreate {
        builder::SnapshotCreate::new(self)
    }

    fn snapshot_view(&self) -> builder::SnapshotView {
        builder::SnapshotView::new(self)
    }

    fn snapshot_delete(&self) -> builder::SnapshotDelete {
        builder::SnapshotDelete::new(self)
    }
}

///Internal system information
pub trait ClientSystemExt {
    ///Fetch a system-wide image by id
    ///
    ///Sends a `GET` request to `/system/by-id/images/{id}`
    ///
    ///```ignore
    /// let response = client.system_image_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn system_image_view_by_id(&self) -> builder::SystemImageViewById;
    ///Fetch an IP pool by id
    ///
    ///Sends a `GET` request to `/system/by-id/ip-pools/{id}`
    ///
    ///```ignore
    /// let response = client.ip_pool_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_view_by_id(&self) -> builder::IpPoolViewById;
    ///Fetch a silo by id
    ///
    ///Sends a `GET` request to `/system/by-id/silos/{id}`
    ///
    ///```ignore
    /// let response = client.silo_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_view_by_id(&self) -> builder::SiloViewById;
    ///List system-wide certificates
    ///
    ///Returns a list of all the system-wide certificates. System-wide
    /// certificates are returned sorted by creation date, with the most recent
    /// certificates appearing first.
    ///
    ///Sends a `GET` request to `/system/certificates`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.certificate_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn certificate_list(&self) -> builder::CertificateList;
    ///Create a new system-wide x.509 certificate
    ///
    ///This certificate is automatically used by the Oxide Control plane to
    /// serve external connections.
    ///
    ///Sends a `POST` request to `/system/certificates`
    ///
    ///```ignore
    /// let response = client.certificate_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn certificate_create(&self) -> builder::CertificateCreate;
    ///Fetch a certificate
    ///
    ///Returns the details of a specific certificate
    ///
    ///Sends a `GET` request to `/system/certificates/{certificate}`
    ///
    ///```ignore
    /// let response = client.certificate_view()
    ///    .certificate(certificate)
    ///    .send()
    ///    .await;
    /// ```
    fn certificate_view(&self) -> builder::CertificateView;
    ///Delete a certificate
    ///
    ///Permanently delete a certificate. This operation cannot be undone.
    ///
    ///Sends a `DELETE` request to `/system/certificates/{certificate}`
    ///
    ///```ignore
    /// let response = client.certificate_delete()
    ///    .certificate(certificate)
    ///    .send()
    ///    .await;
    /// ```
    fn certificate_delete(&self) -> builder::CertificateDelete;
    ///List physical disks
    ///
    ///Sends a `GET` request to `/system/hardware/disks`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.physical_disk_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn physical_disk_list(&self) -> builder::PhysicalDiskList;
    ///List racks
    ///
    ///Sends a `GET` request to `/system/hardware/racks`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.rack_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn rack_list(&self) -> builder::RackList;
    ///Fetch a rack
    ///
    ///Sends a `GET` request to `/system/hardware/racks/{rack_id}`
    ///
    ///Arguments:
    /// - `rack_id`: The rack's unique ID.
    ///```ignore
    /// let response = client.rack_view()
    ///    .rack_id(rack_id)
    ///    .send()
    ///    .await;
    /// ```
    fn rack_view(&self) -> builder::RackView;
    ///List sleds
    ///
    ///Sends a `GET` request to `/system/hardware/sleds`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.sled_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn sled_list(&self) -> builder::SledList;
    ///Fetch a sled
    ///
    ///Sends a `GET` request to `/system/hardware/sleds/{sled_id}`
    ///
    ///Arguments:
    /// - `sled_id`: The sled's unique ID.
    ///```ignore
    /// let response = client.sled_view()
    ///    .sled_id(sled_id)
    ///    .send()
    ///    .await;
    /// ```
    fn sled_view(&self) -> builder::SledView;
    ///List physical disks attached to sleds
    ///
    ///Sends a `GET` request to `/system/hardware/sleds/{sled_id}/disks`
    ///
    ///Arguments:
    /// - `sled_id`: The sled's unique ID.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.sled_physical_disk_list()
    ///    .sled_id(sled_id)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn sled_physical_disk_list(&self) -> builder::SledPhysicalDiskList;
    ///List system-wide images
    ///
    ///Returns a list of all the system-wide images. System-wide images are
    /// returned sorted by creation date, with the most recent images appearing
    /// first.
    ///
    ///Sends a `GET` request to `/system/images`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.system_image_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn system_image_list(&self) -> builder::SystemImageList;
    ///Create a system-wide image
    ///
    ///Create a new system-wide image. This image can then be used by any user
    /// in any silo as a base for instances.
    ///
    ///Sends a `POST` request to `/system/images`
    ///
    ///```ignore
    /// let response = client.system_image_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn system_image_create(&self) -> builder::SystemImageCreate;
    ///Fetch a system-wide image
    ///
    ///Returns the details of a specific system-wide image.
    ///
    ///Sends a `GET` request to `/system/images/{image_name}`
    ///
    ///```ignore
    /// let response = client.system_image_view()
    ///    .image_name(image_name)
    ///    .send()
    ///    .await;
    /// ```
    fn system_image_view(&self) -> builder::SystemImageView;
    ///Delete a system-wide image
    ///
    ///Permanently delete a system-wide image. This operation cannot be undone.
    /// Any instances using the system-wide image will continue to run, however
    /// new instances can not be created with this image.
    ///
    ///Sends a `DELETE` request to `/system/images/{image_name}`
    ///
    ///```ignore
    /// let response = client.system_image_delete()
    ///    .image_name(image_name)
    ///    .send()
    ///    .await;
    /// ```
    fn system_image_delete(&self) -> builder::SystemImageDelete;
    ///List IP pools
    ///
    ///Sends a `GET` request to `/system/ip-pools`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.ip_pool_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_list(&self) -> builder::IpPoolList;
    ///Create an IP pool
    ///
    ///Sends a `POST` request to `/system/ip-pools`
    ///
    ///```ignore
    /// let response = client.ip_pool_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_create(&self) -> builder::IpPoolCreate;
    ///Fetch an IP pool
    ///
    ///Sends a `GET` request to `/system/ip-pools/{pool_name}`
    ///
    ///```ignore
    /// let response = client.ip_pool_view()
    ///    .pool_name(pool_name)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_view(&self) -> builder::IpPoolView;
    ///Update an IP Pool
    ///
    ///Sends a `PUT` request to `/system/ip-pools/{pool_name}`
    ///
    ///```ignore
    /// let response = client.ip_pool_update()
    ///    .pool_name(pool_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_update(&self) -> builder::IpPoolUpdate;
    ///Delete an IP Pool
    ///
    ///Sends a `DELETE` request to `/system/ip-pools/{pool_name}`
    ///
    ///```ignore
    /// let response = client.ip_pool_delete()
    ///    .pool_name(pool_name)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_delete(&self) -> builder::IpPoolDelete;
    ///List ranges for an IP pool
    ///
    ///Ranges are ordered by their first address.
    ///
    ///Sends a `GET` request to `/system/ip-pools/{pool_name}/ranges`
    ///
    ///Arguments:
    /// - `pool_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    ///```ignore
    /// let response = client.ip_pool_range_list()
    ///    .pool_name(pool_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_range_list(&self) -> builder::IpPoolRangeList;
    ///Add a range to an IP pool
    ///
    ///Sends a `POST` request to `/system/ip-pools/{pool_name}/ranges/add`
    ///
    ///```ignore
    /// let response = client.ip_pool_range_add()
    ///    .pool_name(pool_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_range_add(&self) -> builder::IpPoolRangeAdd;
    ///Remove a range from an IP pool
    ///
    ///Sends a `POST` request to `/system/ip-pools/{pool_name}/ranges/remove`
    ///
    ///```ignore
    /// let response = client.ip_pool_range_remove()
    ///    .pool_name(pool_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_range_remove(&self) -> builder::IpPoolRangeRemove;
    ///Fetch the IP pool used for Oxide services
    ///
    ///Sends a `GET` request to `/system/ip-pools-service`
    ///
    ///```ignore
    /// let response = client.ip_pool_service_view()
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_service_view(&self) -> builder::IpPoolServiceView;
    ///List ranges for the IP pool used for Oxide services
    ///
    ///Ranges are ordered by their first address.
    ///
    ///Sends a `GET` request to `/system/ip-pools-service/ranges`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    ///```ignore
    /// let response = client.ip_pool_service_range_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_service_range_list(&self) -> builder::IpPoolServiceRangeList;
    ///Add a range to an IP pool used for Oxide services
    ///
    ///Sends a `POST` request to `/system/ip-pools-service/ranges/add`
    ///
    ///```ignore
    /// let response = client.ip_pool_service_range_add()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_service_range_add(&self) -> builder::IpPoolServiceRangeAdd;
    ///Remove a range from an IP pool used for Oxide services
    ///
    ///Sends a `POST` request to `/system/ip-pools-service/ranges/remove`
    ///
    ///```ignore
    /// let response = client.ip_pool_service_range_remove()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_service_range_remove(&self) -> builder::IpPoolServiceRangeRemove;
    ///Access metrics data
    ///
    ///Sends a `GET` request to `/system/metrics/{metric_name}`
    ///
    ///Arguments:
    /// - `metric_name`
    /// - `end_time`: An exclusive end time of metrics.
    /// - `id`: The UUID of the container being queried
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `start_time`: An inclusive start time of metrics.
    ///```ignore
    /// let response = client.system_metric()
    ///    .metric_name(metric_name)
    ///    .end_time(end_time)
    ///    .id(id)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .start_time(start_time)
    ///    .send()
    ///    .await;
    /// ```
    fn system_metric(&self) -> builder::SystemMetric;
    ///List sagas
    ///
    ///Sends a `GET` request to `/system/sagas`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.saga_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn saga_list(&self) -> builder::SagaList;
    ///Fetch a saga
    ///
    ///Sends a `GET` request to `/system/sagas/{saga_id}`
    ///
    ///```ignore
    /// let response = client.saga_view()
    ///    .saga_id(saga_id)
    ///    .send()
    ///    .await;
    /// ```
    fn saga_view(&self) -> builder::SagaView;
    ///List silos
    ///
    ///Lists silos that are discoverable based on the current permissions.
    ///
    ///Sends a `GET` request to `/system/silos`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.silo_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_list(&self) -> builder::SiloList;
    ///Create a silo
    ///
    ///Sends a `POST` request to `/system/silos`
    ///
    ///```ignore
    /// let response = client.silo_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_create(&self) -> builder::SiloCreate;
    ///Fetch a silo
    ///
    ///Fetch a silo by name.
    ///
    ///Sends a `GET` request to `/system/silos/{silo_name}`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    ///```ignore
    /// let response = client.silo_view()
    ///    .silo_name(silo_name)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_view(&self) -> builder::SiloView;
    ///Delete a silo
    ///
    ///Delete a silo by name.
    ///
    ///Sends a `DELETE` request to `/system/silos/{silo_name}`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    ///```ignore
    /// let response = client.silo_delete()
    ///    .silo_name(silo_name)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_delete(&self) -> builder::SiloDelete;
    ///List a silo's IDPs
    ///
    ///Sends a `GET` request to `/system/silos/{silo_name}/identity-providers`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.silo_identity_provider_list()
    ///    .silo_name(silo_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_identity_provider_list(&self) -> builder::SiloIdentityProviderList;
    ///Create a user
    ///
    ///Users can only be created in Silos with `provision_type` == `Fixed`.
    /// Otherwise, Silo users are just-in-time (JIT) provisioned when a user
    /// first logs in using an external Identity Provider.
    ///
    ///Sends a `POST` request to
    /// `/system/silos/{silo_name}/identity-providers/local/users`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `body`
    ///```ignore
    /// let response = client.local_idp_user_create()
    ///    .silo_name(silo_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn local_idp_user_create(&self) -> builder::LocalIdpUserCreate;
    ///Delete a user
    ///
    ///Sends a `DELETE` request to
    /// `/system/silos/{silo_name}/identity-providers/local/users/{user_id}`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `user_id`: The user's internal id
    ///```ignore
    /// let response = client.local_idp_user_delete()
    ///    .silo_name(silo_name)
    ///    .user_id(user_id)
    ///    .send()
    ///    .await;
    /// ```
    fn local_idp_user_delete(&self) -> builder::LocalIdpUserDelete;
    ///Set or invalidate a user's password
    ///
    ///Passwords can only be updated for users in Silos with identity mode
    /// `LocalOnly`.
    ///
    ///Sends a `POST` request to
    /// `/system/silos/{silo_name}/identity-providers/local/users/{user_id}/
    /// set-password`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `user_id`: The user's internal id
    /// - `body`
    ///```ignore
    /// let response = client.local_idp_user_set_password()
    ///    .silo_name(silo_name)
    ///    .user_id(user_id)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn local_idp_user_set_password(&self) -> builder::LocalIdpUserSetPassword;
    ///Create a SAML IDP
    ///
    ///Sends a `POST` request to
    /// `/system/silos/{silo_name}/identity-providers/saml`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `body`
    ///```ignore
    /// let response = client.saml_identity_provider_create()
    ///    .silo_name(silo_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn saml_identity_provider_create(&self) -> builder::SamlIdentityProviderCreate;
    ///Fetch a SAML IDP
    ///
    ///Sends a `GET` request to
    /// `/system/silos/{silo_name}/identity-providers/saml/{provider_name}`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `provider_name`: The SAML identity provider's name
    ///```ignore
    /// let response = client.saml_identity_provider_view()
    ///    .silo_name(silo_name)
    ///    .provider_name(provider_name)
    ///    .send()
    ///    .await;
    /// ```
    fn saml_identity_provider_view(&self) -> builder::SamlIdentityProviderView;
    ///Fetch a silo's IAM policy
    ///
    ///Sends a `GET` request to `/system/silos/{silo_name}/policy`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    ///```ignore
    /// let response = client.silo_policy_view()
    ///    .silo_name(silo_name)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_policy_view(&self) -> builder::SiloPolicyView;
    ///Update a silo's IAM policy
    ///
    ///Sends a `PUT` request to `/system/silos/{silo_name}/policy`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `body`
    ///```ignore
    /// let response = client.silo_policy_update()
    ///    .silo_name(silo_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_policy_update(&self) -> builder::SiloPolicyUpdate;
    ///List users in a silo
    ///
    ///Sends a `GET` request to `/system/silos/{silo_name}/users/all`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.silo_users_list()
    ///    .silo_name(silo_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_users_list(&self) -> builder::SiloUsersList;
    ///Fetch a user
    ///
    ///Sends a `GET` request to `/system/silos/{silo_name}/users/id/{user_id}`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `user_id`: The user's internal id
    ///```ignore
    /// let response = client.silo_user_view()
    ///    .silo_name(silo_name)
    ///    .user_id(user_id)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_user_view(&self) -> builder::SiloUserView;
    ///List built-in users
    ///
    ///Sends a `GET` request to `/system/user`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.system_user_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn system_user_list(&self) -> builder::SystemUserList;
    ///Fetch a built-in user
    ///
    ///Sends a `GET` request to `/system/user/{user_name}`
    ///
    ///Arguments:
    /// - `user_name`: The built-in user's unique name.
    ///```ignore
    /// let response = client.system_user_view()
    ///    .user_name(user_name)
    ///    .send()
    ///    .await;
    /// ```
    fn system_user_view(&self) -> builder::SystemUserView;
    ///View version and update status of component tree
    ///
    ///Sends a `GET` request to `/v1/system/update/components`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.system_component_version_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn system_component_version_list(&self) -> builder::SystemComponentVersionList;
    ///List all update deployments
    ///
    ///Sends a `GET` request to `/v1/system/update/deployments`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.update_deployments_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn update_deployments_list(&self) -> builder::UpdateDeploymentsList;
    ///Fetch a system update deployment
    ///
    ///Sends a `GET` request to `/v1/system/update/deployments/{id}`
    ///
    ///```ignore
    /// let response = client.update_deployment_view()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn update_deployment_view(&self) -> builder::UpdateDeploymentView;
    ///Refresh update data
    ///
    ///Sends a `POST` request to `/v1/system/update/refresh`
    ///
    ///```ignore
    /// let response = client.system_update_refresh()
    ///    .send()
    ///    .await;
    /// ```
    fn system_update_refresh(&self) -> builder::SystemUpdateRefresh;
    ///Start system update
    ///
    ///Sends a `POST` request to `/v1/system/update/start`
    ///
    ///```ignore
    /// let response = client.system_update_start()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn system_update_start(&self) -> builder::SystemUpdateStart;
    ///Stop system update
    ///
    ///If there is no update in progress, do nothing.
    ///
    ///Sends a `POST` request to `/v1/system/update/stop`
    ///
    ///```ignore
    /// let response = client.system_update_stop()
    ///    .send()
    ///    .await;
    /// ```
    fn system_update_stop(&self) -> builder::SystemUpdateStop;
    ///List all updates
    ///
    ///Sends a `GET` request to `/v1/system/update/updates`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.system_update_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn system_update_list(&self) -> builder::SystemUpdateList;
    ///View system update
    ///
    ///Sends a `GET` request to `/v1/system/update/updates/{version}`
    ///
    ///```ignore
    /// let response = client.system_update_view()
    ///    .version(version)
    ///    .send()
    ///    .await;
    /// ```
    fn system_update_view(&self) -> builder::SystemUpdateView;
    ///View system update component tree
    ///
    ///Sends a `GET` request to
    /// `/v1/system/update/updates/{version}/components`
    ///
    ///```ignore
    /// let response = client.system_update_components_list()
    ///    .version(version)
    ///    .send()
    ///    .await;
    /// ```
    fn system_update_components_list(&self) -> builder::SystemUpdateComponentsList;
    ///View system version and update status
    ///
    ///Sends a `GET` request to `/v1/system/update/version`
    ///
    ///```ignore
    /// let response = client.system_version()
    ///    .send()
    ///    .await;
    /// ```
    fn system_version(&self) -> builder::SystemVersion;
}

impl ClientSystemExt for Client {
    fn system_image_view_by_id(&self) -> builder::SystemImageViewById {
        builder::SystemImageViewById::new(self)
    }

    fn ip_pool_view_by_id(&self) -> builder::IpPoolViewById {
        builder::IpPoolViewById::new(self)
    }

    fn silo_view_by_id(&self) -> builder::SiloViewById {
        builder::SiloViewById::new(self)
    }

    fn certificate_list(&self) -> builder::CertificateList {
        builder::CertificateList::new(self)
    }

    fn certificate_create(&self) -> builder::CertificateCreate {
        builder::CertificateCreate::new(self)
    }

    fn certificate_view(&self) -> builder::CertificateView {
        builder::CertificateView::new(self)
    }

    fn certificate_delete(&self) -> builder::CertificateDelete {
        builder::CertificateDelete::new(self)
    }

    fn physical_disk_list(&self) -> builder::PhysicalDiskList {
        builder::PhysicalDiskList::new(self)
    }

    fn rack_list(&self) -> builder::RackList {
        builder::RackList::new(self)
    }

    fn rack_view(&self) -> builder::RackView {
        builder::RackView::new(self)
    }

    fn sled_list(&self) -> builder::SledList {
        builder::SledList::new(self)
    }

    fn sled_view(&self) -> builder::SledView {
        builder::SledView::new(self)
    }

    fn sled_physical_disk_list(&self) -> builder::SledPhysicalDiskList {
        builder::SledPhysicalDiskList::new(self)
    }

    fn system_image_list(&self) -> builder::SystemImageList {
        builder::SystemImageList::new(self)
    }

    fn system_image_create(&self) -> builder::SystemImageCreate {
        builder::SystemImageCreate::new(self)
    }

    fn system_image_view(&self) -> builder::SystemImageView {
        builder::SystemImageView::new(self)
    }

    fn system_image_delete(&self) -> builder::SystemImageDelete {
        builder::SystemImageDelete::new(self)
    }

    fn ip_pool_list(&self) -> builder::IpPoolList {
        builder::IpPoolList::new(self)
    }

    fn ip_pool_create(&self) -> builder::IpPoolCreate {
        builder::IpPoolCreate::new(self)
    }

    fn ip_pool_view(&self) -> builder::IpPoolView {
        builder::IpPoolView::new(self)
    }

    fn ip_pool_update(&self) -> builder::IpPoolUpdate {
        builder::IpPoolUpdate::new(self)
    }

    fn ip_pool_delete(&self) -> builder::IpPoolDelete {
        builder::IpPoolDelete::new(self)
    }

    fn ip_pool_range_list(&self) -> builder::IpPoolRangeList {
        builder::IpPoolRangeList::new(self)
    }

    fn ip_pool_range_add(&self) -> builder::IpPoolRangeAdd {
        builder::IpPoolRangeAdd::new(self)
    }

    fn ip_pool_range_remove(&self) -> builder::IpPoolRangeRemove {
        builder::IpPoolRangeRemove::new(self)
    }

    fn ip_pool_service_view(&self) -> builder::IpPoolServiceView {
        builder::IpPoolServiceView::new(self)
    }

    fn ip_pool_service_range_list(&self) -> builder::IpPoolServiceRangeList {
        builder::IpPoolServiceRangeList::new(self)
    }

    fn ip_pool_service_range_add(&self) -> builder::IpPoolServiceRangeAdd {
        builder::IpPoolServiceRangeAdd::new(self)
    }

    fn ip_pool_service_range_remove(&self) -> builder::IpPoolServiceRangeRemove {
        builder::IpPoolServiceRangeRemove::new(self)
    }

    fn system_metric(&self) -> builder::SystemMetric {
        builder::SystemMetric::new(self)
    }

    fn saga_list(&self) -> builder::SagaList {
        builder::SagaList::new(self)
    }

    fn saga_view(&self) -> builder::SagaView {
        builder::SagaView::new(self)
    }

    fn silo_list(&self) -> builder::SiloList {
        builder::SiloList::new(self)
    }

    fn silo_create(&self) -> builder::SiloCreate {
        builder::SiloCreate::new(self)
    }

    fn silo_view(&self) -> builder::SiloView {
        builder::SiloView::new(self)
    }

    fn silo_delete(&self) -> builder::SiloDelete {
        builder::SiloDelete::new(self)
    }

    fn silo_identity_provider_list(&self) -> builder::SiloIdentityProviderList {
        builder::SiloIdentityProviderList::new(self)
    }

    fn local_idp_user_create(&self) -> builder::LocalIdpUserCreate {
        builder::LocalIdpUserCreate::new(self)
    }

    fn local_idp_user_delete(&self) -> builder::LocalIdpUserDelete {
        builder::LocalIdpUserDelete::new(self)
    }

    fn local_idp_user_set_password(&self) -> builder::LocalIdpUserSetPassword {
        builder::LocalIdpUserSetPassword::new(self)
    }

    fn saml_identity_provider_create(&self) -> builder::SamlIdentityProviderCreate {
        builder::SamlIdentityProviderCreate::new(self)
    }

    fn saml_identity_provider_view(&self) -> builder::SamlIdentityProviderView {
        builder::SamlIdentityProviderView::new(self)
    }

    fn silo_policy_view(&self) -> builder::SiloPolicyView {
        builder::SiloPolicyView::new(self)
    }

    fn silo_policy_update(&self) -> builder::SiloPolicyUpdate {
        builder::SiloPolicyUpdate::new(self)
    }

    fn silo_users_list(&self) -> builder::SiloUsersList {
        builder::SiloUsersList::new(self)
    }

    fn silo_user_view(&self) -> builder::SiloUserView {
        builder::SiloUserView::new(self)
    }

    fn system_user_list(&self) -> builder::SystemUserList {
        builder::SystemUserList::new(self)
    }

    fn system_user_view(&self) -> builder::SystemUserView {
        builder::SystemUserView::new(self)
    }

    fn system_component_version_list(&self) -> builder::SystemComponentVersionList {
        builder::SystemComponentVersionList::new(self)
    }

    fn update_deployments_list(&self) -> builder::UpdateDeploymentsList {
        builder::UpdateDeploymentsList::new(self)
    }

    fn update_deployment_view(&self) -> builder::UpdateDeploymentView {
        builder::UpdateDeploymentView::new(self)
    }

    fn system_update_refresh(&self) -> builder::SystemUpdateRefresh {
        builder::SystemUpdateRefresh::new(self)
    }

    fn system_update_start(&self) -> builder::SystemUpdateStart {
        builder::SystemUpdateStart::new(self)
    }

    fn system_update_stop(&self) -> builder::SystemUpdateStop {
        builder::SystemUpdateStop::new(self)
    }

    fn system_update_list(&self) -> builder::SystemUpdateList {
        builder::SystemUpdateList::new(self)
    }

    fn system_update_view(&self) -> builder::SystemUpdateView {
        builder::SystemUpdateView::new(self)
    }

    fn system_update_components_list(&self) -> builder::SystemUpdateComponentsList {
        builder::SystemUpdateComponentsList::new(self)
    }

    fn system_version(&self) -> builder::SystemVersion {
        builder::SystemVersion::new(self)
    }
}

///A Virtual Private Cloud (VPC) is an isolated network environment that should
/// probaby be moved into a more generic networking tag
pub trait ClientVpcsExt {
    ///Fetch a route by id
    ///
    ///Sends a `GET` request to `/by-id/vpc-router-routes/{id}`
    ///
    ///```ignore
    /// let response = client.vpc_router_route_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_route_view_by_id(&self) -> builder::VpcRouterRouteViewById;
    ///Get a router by id
    ///
    ///Sends a `GET` request to `/by-id/vpc-routers/{id}`
    ///
    ///```ignore
    /// let response = client.vpc_router_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_view_by_id(&self) -> builder::VpcRouterViewById;
    ///Fetch a subnet by id
    ///
    ///Sends a `GET` request to `/by-id/vpc-subnets/{id}`
    ///
    ///```ignore
    /// let response = client.vpc_subnet_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_view_by_id(&self) -> builder::VpcSubnetViewById;
    ///Fetch a VPC
    ///
    ///Sends a `GET` request to `/by-id/vpcs/{id}`
    ///
    ///```ignore
    /// let response = client.vpc_view_by_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_view_by_id(&self) -> builder::VpcViewById;
    ///List VPCs
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.vpc_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_list(&self) -> builder::VpcList;
    ///Create a VPC
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///```ignore
    /// let response = client.vpc_create()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_create(&self) -> builder::VpcCreate;
    ///Fetch a VPC
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}`
    ///
    ///```ignore
    /// let response = client.vpc_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_view(&self) -> builder::VpcView;
    ///Update a VPC
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}`
    ///
    ///```ignore
    /// let response = client.vpc_update()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_update(&self) -> builder::VpcUpdate;
    ///Delete a VPC
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}`
    ///
    ///```ignore
    /// let response = client.vpc_delete()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_delete(&self) -> builder::VpcDelete;
    ///List firewall rules
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/firewall/rules`
    ///
    ///```ignore
    /// let response = client.vpc_firewall_rules_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_firewall_rules_view(&self) -> builder::VpcFirewallRulesView;
    ///Replace firewall rules
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/firewall/rules`
    ///
    ///```ignore
    /// let response = client.vpc_firewall_rules_update()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_firewall_rules_update(&self) -> builder::VpcFirewallRulesUpdate;
    ///List routers
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.vpc_router_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_list(&self) -> builder::VpcRouterList;
    ///Create a router
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers`
    ///
    ///```ignore
    /// let response = client.vpc_router_create()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_create(&self) -> builder::VpcRouterCreate;
    ///Get a router
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}`
    ///
    ///```ignore
    /// let response = client.vpc_router_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_view(&self) -> builder::VpcRouterView;
    ///Update a router
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}`
    ///
    ///```ignore
    /// let response = client.vpc_router_update()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_update(&self) -> builder::VpcRouterUpdate;
    ///Delete a router
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}`
    ///
    ///```ignore
    /// let response = client.vpc_router_delete()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_delete(&self) -> builder::VpcRouterDelete;
    ///List routes
    ///
    ///List the routes associated with a router in a particular VPC.
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `router_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.vpc_router_route_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_route_list(&self) -> builder::VpcRouterRouteList;
    ///Create a router
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes`
    ///
    ///```ignore
    /// let response = client.vpc_router_route_create()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_route_create(&self) -> builder::VpcRouterRouteCreate;
    ///Fetch a route
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}`
    ///
    ///```ignore
    /// let response = client.vpc_router_route_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .route_name(route_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_route_view(&self) -> builder::VpcRouterRouteView;
    ///Update a route
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}`
    ///
    ///```ignore
    /// let response = client.vpc_router_route_update()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .route_name(route_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_route_update(&self) -> builder::VpcRouterRouteUpdate;
    ///Delete a route
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}`
    ///
    ///```ignore
    /// let response = client.vpc_router_route_delete()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .route_name(route_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_route_delete(&self) -> builder::VpcRouterRouteDelete;
    ///List subnets
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.vpc_subnet_list()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_list(&self) -> builder::VpcSubnetList;
    ///Create a subnet
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets`
    ///
    ///```ignore
    /// let response = client.vpc_subnet_create()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_create(&self) -> builder::VpcSubnetCreate;
    ///Fetch a subnet
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}`
    ///
    ///```ignore
    /// let response = client.vpc_subnet_view()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .subnet_name(subnet_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_view(&self) -> builder::VpcSubnetView;
    ///Update a subnet
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}`
    ///
    ///```ignore
    /// let response = client.vpc_subnet_update()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .subnet_name(subnet_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_update(&self) -> builder::VpcSubnetUpdate;
    ///Delete a subnet
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}`
    ///
    ///```ignore
    /// let response = client.vpc_subnet_delete()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .subnet_name(subnet_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_delete(&self) -> builder::VpcSubnetDelete;
    ///List network interfaces
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}/network-interfaces`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `subnet_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    ///```ignore
    /// let response = client.vpc_subnet_list_network_interfaces()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .subnet_name(subnet_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_list_network_interfaces(&self) -> builder::VpcSubnetListNetworkInterfaces;
}

impl ClientVpcsExt for Client {
    fn vpc_router_route_view_by_id(&self) -> builder::VpcRouterRouteViewById {
        builder::VpcRouterRouteViewById::new(self)
    }

    fn vpc_router_view_by_id(&self) -> builder::VpcRouterViewById {
        builder::VpcRouterViewById::new(self)
    }

    fn vpc_subnet_view_by_id(&self) -> builder::VpcSubnetViewById {
        builder::VpcSubnetViewById::new(self)
    }

    fn vpc_view_by_id(&self) -> builder::VpcViewById {
        builder::VpcViewById::new(self)
    }

    fn vpc_list(&self) -> builder::VpcList {
        builder::VpcList::new(self)
    }

    fn vpc_create(&self) -> builder::VpcCreate {
        builder::VpcCreate::new(self)
    }

    fn vpc_view(&self) -> builder::VpcView {
        builder::VpcView::new(self)
    }

    fn vpc_update(&self) -> builder::VpcUpdate {
        builder::VpcUpdate::new(self)
    }

    fn vpc_delete(&self) -> builder::VpcDelete {
        builder::VpcDelete::new(self)
    }

    fn vpc_firewall_rules_view(&self) -> builder::VpcFirewallRulesView {
        builder::VpcFirewallRulesView::new(self)
    }

    fn vpc_firewall_rules_update(&self) -> builder::VpcFirewallRulesUpdate {
        builder::VpcFirewallRulesUpdate::new(self)
    }

    fn vpc_router_list(&self) -> builder::VpcRouterList {
        builder::VpcRouterList::new(self)
    }

    fn vpc_router_create(&self) -> builder::VpcRouterCreate {
        builder::VpcRouterCreate::new(self)
    }

    fn vpc_router_view(&self) -> builder::VpcRouterView {
        builder::VpcRouterView::new(self)
    }

    fn vpc_router_update(&self) -> builder::VpcRouterUpdate {
        builder::VpcRouterUpdate::new(self)
    }

    fn vpc_router_delete(&self) -> builder::VpcRouterDelete {
        builder::VpcRouterDelete::new(self)
    }

    fn vpc_router_route_list(&self) -> builder::VpcRouterRouteList {
        builder::VpcRouterRouteList::new(self)
    }

    fn vpc_router_route_create(&self) -> builder::VpcRouterRouteCreate {
        builder::VpcRouterRouteCreate::new(self)
    }

    fn vpc_router_route_view(&self) -> builder::VpcRouterRouteView {
        builder::VpcRouterRouteView::new(self)
    }

    fn vpc_router_route_update(&self) -> builder::VpcRouterRouteUpdate {
        builder::VpcRouterRouteUpdate::new(self)
    }

    fn vpc_router_route_delete(&self) -> builder::VpcRouterRouteDelete {
        builder::VpcRouterRouteDelete::new(self)
    }

    fn vpc_subnet_list(&self) -> builder::VpcSubnetList {
        builder::VpcSubnetList::new(self)
    }

    fn vpc_subnet_create(&self) -> builder::VpcSubnetCreate {
        builder::VpcSubnetCreate::new(self)
    }

    fn vpc_subnet_view(&self) -> builder::VpcSubnetView {
        builder::VpcSubnetView::new(self)
    }

    fn vpc_subnet_update(&self) -> builder::VpcSubnetUpdate {
        builder::VpcSubnetUpdate::new(self)
    }

    fn vpc_subnet_delete(&self) -> builder::VpcSubnetDelete {
        builder::VpcSubnetDelete::new(self)
    }

    fn vpc_subnet_list_network_interfaces(&self) -> builder::VpcSubnetListNetworkInterfaces {
        builder::VpcSubnetListNetworkInterfaces::new(self)
    }
}

/// Types for composing operation parameters.
#[allow(clippy::all)]
pub mod builder {
    use super::types;
    #[allow(unused_imports)]
    use super::{
        encode_path, ByteStream, Error, HeaderMap, HeaderValue, RequestBuilderExt, ResponseValue,
    };
    ///Builder for [`ClientDisksExt::disk_view_by_id`]
    ///
    ///[`ClientDisksExt::disk_view_by_id`]: super::ClientDisksExt::disk_view_by_id
    #[derive(Debug, Clone)]
    pub struct DiskViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> DiskViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/by-id/disks/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/disks/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientImagesExt::image_view_by_id`]
    ///
    ///[`ClientImagesExt::image_view_by_id`]: super::ClientImagesExt::image_view_by_id
    #[derive(Debug, Clone)]
    pub struct ImageViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> ImageViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/by-id/images/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/images/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_view_by_id`]
    ///
    ///[`ClientInstancesExt::instance_view_by_id`]: super::ClientInstancesExt::instance_view_by_id
    #[derive(Debug, Clone)]
    pub struct InstanceViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> InstanceViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/by-id/instances/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/instances/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for
    /// [`ClientInstancesExt::instance_network_interface_view_by_id`]
    ///
    ///[`ClientInstancesExt::instance_network_interface_view_by_id`]: super::ClientInstancesExt::instance_network_interface_view_by_id
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> InstanceNetworkInterfaceViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/by-id/network-interfaces/{id}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/network-interfaces/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_view_by_id`]
    ///
    ///[`ClientOrganizationsExt::organization_view_by_id`]: super::ClientOrganizationsExt::organization_view_by_id
    #[derive(Debug, Clone)]
    pub struct OrganizationViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> OrganizationViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/by-id/organizations/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/organizations/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_view_by_id`]
    ///
    ///[`ClientProjectsExt::project_view_by_id`]: super::ClientProjectsExt::project_view_by_id
    #[derive(Debug, Clone)]
    pub struct ProjectViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> ProjectViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/by-id/projects/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/projects/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSnapshotsExt::snapshot_view_by_id`]
    ///
    ///[`ClientSnapshotsExt::snapshot_view_by_id`]: super::ClientSnapshotsExt::snapshot_view_by_id
    #[derive(Debug, Clone)]
    pub struct SnapshotViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> SnapshotViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/by-id/snapshots/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/snapshots/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_route_view_by_id`]
    ///
    ///[`ClientVpcsExt::vpc_router_route_view_by_id`]: super::ClientVpcsExt::vpc_router_route_view_by_id
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> VpcRouterRouteViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/by-id/vpc-router-routes/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/vpc-router-routes/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_view_by_id`]
    ///
    ///[`ClientVpcsExt::vpc_router_view_by_id`]: super::ClientVpcsExt::vpc_router_view_by_id
    #[derive(Debug, Clone)]
    pub struct VpcRouterViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> VpcRouterViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/by-id/vpc-routers/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/vpc-routers/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_subnet_view_by_id`]
    ///
    ///[`ClientVpcsExt::vpc_subnet_view_by_id`]: super::ClientVpcsExt::vpc_subnet_view_by_id
    #[derive(Debug, Clone)]
    pub struct VpcSubnetViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> VpcSubnetViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/by-id/vpc-subnets/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/vpc-subnets/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_view_by_id`]
    ///
    ///[`ClientVpcsExt::vpc_view_by_id`]: super::ClientVpcsExt::vpc_view_by_id
    #[derive(Debug, Clone)]
    pub struct VpcViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> VpcViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/by-id/vpcs/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/vpcs/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientHiddenExt::device_auth_request`]
    ///
    ///[`ClientHiddenExt::device_auth_request`]: super::ClientHiddenExt::device_auth_request
    #[derive(Debug, Clone)]
    pub struct DeviceAuthRequest<'a> {
        client: &'a super::Client,
        body: Result<types::builder::DeviceAuthRequest, String>,
    }

    impl<'a> DeviceAuthRequest<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::DeviceAuthRequest::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeviceAuthRequest>,
            <V as std::convert::TryInto<types::DeviceAuthRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DeviceAuthRequest` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::DeviceAuthRequest,
            ) -> types::builder::DeviceAuthRequest,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/device/auth`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::DeviceAuthRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/device/auth", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client.client.post(url).form_urlencoded(&body)?.build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    ///Builder for [`ClientHiddenExt::device_auth_confirm`]
    ///
    ///[`ClientHiddenExt::device_auth_confirm`]: super::ClientHiddenExt::device_auth_confirm
    #[derive(Debug, Clone)]
    pub struct DeviceAuthConfirm<'a> {
        client: &'a super::Client,
        body: Result<types::builder::DeviceAuthVerify, String>,
    }

    impl<'a> DeviceAuthConfirm<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::DeviceAuthVerify::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeviceAuthVerify>,
            <V as std::convert::TryInto<types::DeviceAuthVerify>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DeviceAuthVerify` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::DeviceAuthVerify,
            ) -> types::builder::DeviceAuthVerify,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/device/confirm`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::DeviceAuthVerify::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/device/confirm", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientHiddenExt::device_access_token`]
    ///
    ///[`ClientHiddenExt::device_access_token`]: super::ClientHiddenExt::device_access_token
    #[derive(Debug, Clone)]
    pub struct DeviceAccessToken<'a> {
        client: &'a super::Client,
        body: Result<types::builder::DeviceAccessTokenRequest, String>,
    }

    impl<'a> DeviceAccessToken<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::DeviceAccessTokenRequest::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeviceAccessTokenRequest>,
            <V as std::convert::TryInto<types::DeviceAccessTokenRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `DeviceAccessTokenRequest` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::DeviceAccessTokenRequest,
            ) -> types::builder::DeviceAccessTokenRequest,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/device/token`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::DeviceAccessTokenRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/device/token", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client.client.post(url).form_urlencoded(&body)?.build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    ///Builder for [`ClientSilosExt::group_list`]
    ///
    ///[`ClientSilosExt::group_list`]: super::ClientSilosExt::group_list
    #[derive(Debug, Clone)]
    pub struct GroupList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> GroupList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/groups`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/groups", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/groups`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Group, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientHiddenExt::login_spoof`]
    ///
    ///[`ClientHiddenExt::login_spoof`]: super::ClientHiddenExt::login_spoof
    #[derive(Debug, Clone)]
    pub struct LoginSpoof<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SpoofLoginBody, String>,
    }

    impl<'a> LoginSpoof<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::SpoofLoginBody::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SpoofLoginBody>,
            <V as std::convert::TryInto<types::SpoofLoginBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SpoofLoginBody` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SpoofLoginBody) -> types::builder::SpoofLoginBody,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/login`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SpoofLoginBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/login", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientLoginExt::login_local`]
    ///
    ///[`ClientLoginExt::login_local`]: super::ClientLoginExt::login_local
    #[derive(Debug, Clone)]
    pub struct LoginLocal<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        body: Result<types::builder::UsernamePasswordCredentials, String>,
    }

    impl<'a> LoginLocal<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                body: Ok(types::builder::UsernamePasswordCredentials::default()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UsernamePasswordCredentials>,
            <V as std::convert::TryInto<types::UsernamePasswordCredentials>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UsernamePasswordCredentials` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::UsernamePasswordCredentials,
            ) -> types::builder::UsernamePasswordCredentials,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/login/{silo_name}/local`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UsernamePasswordCredentials::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/login/{}/local",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientLoginExt::login_saml_begin`]
    ///
    ///[`ClientLoginExt::login_saml_begin`]: super::ClientLoginExt::login_saml_begin
    #[derive(Debug, Clone)]
    pub struct LoginSamlBegin<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        provider_name: Result<types::Name, String>,
    }

    impl<'a> LoginSamlBegin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                provider_name: Err("provider_name was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn provider_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.provider_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for provider_name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/login/{silo_name}/saml/{provider_name}`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                provider_name,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let provider_name = provider_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/login/{}/saml/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&provider_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientLoginExt::login_saml`]
    ///
    ///[`ClientLoginExt::login_saml`]: super::ClientLoginExt::login_saml
    #[derive(Debug)]
    pub struct LoginSaml<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        provider_name: Result<types::Name, String>,
        body: Result<reqwest::Body, String>,
    }

    impl<'a> LoginSaml<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                provider_name: Err("provider_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn provider_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.provider_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for provider_name failed".to_string());
            self
        }

        pub fn body<B>(mut self, value: B) -> Self
        where
            B: std::convert::TryInto<reqwest::Body>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `reqwest::Body` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/login/{silo_name}/saml/{provider_name}`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                provider_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let provider_name = provider_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/login/{}/saml/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&provider_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::CONTENT_TYPE,
                    reqwest::header::HeaderValue::from_static("application/octet-stream"),
                )
                .body(body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientHiddenExt::logout`]
    ///
    ///[`ClientHiddenExt::logout`]: super::ClientHiddenExt::logout
    #[derive(Debug, Clone)]
    pub struct Logout<'a> {
        client: &'a super::Client,
    }

    impl<'a> Logout<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `POST` request to `/logout`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/logout", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_list`]
    ///
    ///[`ClientOrganizationsExt::organization_list`]: super::ClientOrganizationsExt::organization_list
    #[derive(Debug, Clone)]
    pub struct OrganizationList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> OrganizationList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/organizations`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/organizations", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/organizations`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Organization, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_create`]
    ///
    ///[`ClientOrganizationsExt::organization_create`]: super::ClientOrganizationsExt::organization_create
    #[derive(Debug, Clone)]
    pub struct OrganizationCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::OrganizationCreate, String>,
    }

    impl<'a> OrganizationCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::OrganizationCreate::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationCreate>,
            <V as std::convert::TryInto<types::OrganizationCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `OrganizationCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::OrganizationCreate,
            ) -> types::builder::OrganizationCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/organizations`
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::OrganizationCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/organizations", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_view`]
    ///
    ///[`ClientOrganizationsExt::organization_view`]: super::ClientOrganizationsExt::organization_view
    #[derive(Debug, Clone)]
    pub struct OrganizationView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
    }

    impl<'a> OrganizationView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/organizations/{organization_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_update`]
    ///
    ///[`ClientOrganizationsExt::organization_update`]: super::ClientOrganizationsExt::organization_update
    #[derive(Debug, Clone)]
    pub struct OrganizationUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        body: Result<types::builder::OrganizationUpdate, String>,
    }

    impl<'a> OrganizationUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                body: Ok(types::builder::OrganizationUpdate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationUpdate>,
            <V as std::convert::TryInto<types::OrganizationUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `OrganizationUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::OrganizationUpdate,
            ) -> types::builder::OrganizationUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/organizations/{organization_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::OrganizationUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_delete`]
    ///
    ///[`ClientOrganizationsExt::organization_delete`]: super::ClientOrganizationsExt::organization_delete
    #[derive(Debug, Clone)]
    pub struct OrganizationDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
    }

    impl<'a> OrganizationDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/organizations/{organization_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_policy_view`]
    ///
    ///[`ClientOrganizationsExt::organization_policy_view`]: super::ClientOrganizationsExt::organization_policy_view
    #[derive(Debug, Clone)]
    pub struct OrganizationPolicyView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
    }

    impl<'a> OrganizationPolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/organizations/{organization_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_policy_update`]
    ///
    ///[`ClientOrganizationsExt::organization_policy_update`]: super::ClientOrganizationsExt::organization_policy_update
    #[derive(Debug, Clone)]
    pub struct OrganizationPolicyUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        body: Result<types::builder::OrganizationRolePolicy, String>,
    }

    impl<'a> OrganizationPolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                body: Ok(types::builder::OrganizationRolePolicy::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationRolePolicy>,
            <V as std::convert::TryInto<types::OrganizationRolePolicy>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `OrganizationRolePolicy` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::OrganizationRolePolicy,
            ) -> types::builder::OrganizationRolePolicy,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/organizations/{organization_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::OrganizationRolePolicy::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_list`]
    ///
    ///[`ClientProjectsExt::project_list`]: super::ClientProjectsExt::project_list
    #[derive(Debug, Clone)]
    pub struct ProjectList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> ProjectList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Project, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientProjectsExt::project_create`]
    ///
    ///[`ClientProjectsExt::project_create`]: super::ClientProjectsExt::project_create
    #[derive(Debug, Clone)]
    pub struct ProjectCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        body: Result<types::builder::ProjectCreate, String>,
    }

    impl<'a> ProjectCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                body: Ok(types::builder::ProjectCreate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectCreate>,
            <V as std::convert::TryInto<types::ProjectCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ProjectCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ProjectCreate) -> types::builder::ProjectCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ProjectCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_view`]
    ///
    ///[`ClientProjectsExt::project_view`]: super::ClientProjectsExt::project_view
    #[derive(Debug, Clone)]
    pub struct ProjectView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
    }

    impl<'a> ProjectView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_update`]
    ///
    ///[`ClientProjectsExt::project_update`]: super::ClientProjectsExt::project_update
    #[derive(Debug, Clone)]
    pub struct ProjectUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::builder::ProjectUpdate, String>,
    }

    impl<'a> ProjectUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Ok(types::builder::ProjectUpdate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectUpdate>,
            <V as std::convert::TryInto<types::ProjectUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ProjectUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ProjectUpdate) -> types::builder::ProjectUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ProjectUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_delete`]
    ///
    ///[`ClientProjectsExt::project_delete`]: super::ClientProjectsExt::project_delete
    #[derive(Debug, Clone)]
    pub struct ProjectDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
    }

    impl<'a> ProjectDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientDisksExt::disk_list`]
    ///
    ///[`ClientDisksExt::disk_list`]: super::ClientDisksExt::disk_list
    #[derive(Debug, Clone)]
    pub struct DiskList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> DiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/disks",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientDisksExt::disk_create`]
    ///
    ///[`ClientDisksExt::disk_create`]: super::ClientDisksExt::disk_create
    #[derive(Debug, Clone)]
    pub struct DiskCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::builder::DiskCreate, String>,
    }

    impl<'a> DiskCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Ok(types::builder::DiskCreate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskCreate>,
            <V as std::convert::TryInto<types::DiskCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DiskCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::DiskCreate) -> types::builder::DiskCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/disks`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::DiskCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/disks",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientDisksExt::disk_view`]
    ///
    ///[`ClientDisksExt::disk_view`]: super::ClientDisksExt::disk_view
    #[derive(Debug, Clone)]
    pub struct DiskView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        disk_name: Result<types::Name, String>,
    }

    impl<'a> DiskView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                disk_name: Err("disk_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn disk_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.disk_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for disk_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/disks/
        /// {disk_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                disk_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let disk_name = disk_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/disks/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&disk_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientDisksExt::disk_delete`]
    ///
    ///[`ClientDisksExt::disk_delete`]: super::ClientDisksExt::disk_delete
    #[derive(Debug, Clone)]
    pub struct DiskDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        disk_name: Result<types::Name, String>,
    }

    impl<'a> DiskDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                disk_name: Err("disk_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn disk_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.disk_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for disk_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/disks/
        /// {disk_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                disk_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let disk_name = disk_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/disks/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&disk_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientDisksExt::disk_metrics_list`]
    ///
    ///[`ClientDisksExt::disk_metrics_list`]: super::ClientDisksExt::disk_metrics_list
    #[derive(Debug, Clone)]
    pub struct DiskMetricsList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        disk_name: Result<types::Name, String>,
        metric_name: Result<types::DiskMetricName, String>,
        end_time: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        start_time: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
    }

    impl<'a> DiskMetricsList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                disk_name: Err("disk_name was not initialized".to_string()),
                metric_name: Err("metric_name was not initialized".to_string()),
                end_time: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
                start_time: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn disk_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.disk_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for disk_name failed".to_string());
            self
        }

        pub fn metric_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskMetricName>,
        {
            self.metric_name = value
                .try_into()
                .map_err(|_| "conversion to `DiskMetricName` for metric_name failed".to_string());
            self
        }

        pub fn end_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
        {
            self.end_time = value.try_into().map(Some).map_err(|_| {
                "conversion to `chrono :: DateTime < chrono :: offset :: Utc >` for end_time failed"
                    .to_string()
            });
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn start_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
        {
            self.start_time = value.try_into().map(Some).map_err(|_| {
                "conversion to `chrono :: DateTime < chrono :: offset :: Utc >` for start_time \
                 failed"
                    .to_string()
            });
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/disks/
        /// {disk_name}/metrics/{metric_name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                disk_name,
                metric_name,
                end_time,
                limit,
                page_token,
                start_time,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let disk_name = disk_name.map_err(Error::InvalidRequest)?;
            let metric_name = metric_name.map_err(Error::InvalidRequest)?;
            let end_time = end_time.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let start_time = start_time.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/disks/{}/metrics/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&disk_name.to_string()),
                encode_path(&metric_name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &end_time {
                query.push(("end_time", v.to_string()));
            }
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &start_time {
                query.push(("start_time", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/disks/
        /// {disk_name}/metrics/{metric_name}`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Measurement, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                end_time: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
                start_time: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientImagesExt::image_list`]
    ///
    ///[`ClientImagesExt::image_list`]: super::ClientImagesExt::image_list
    #[derive(Debug, Clone)]
    pub struct ImageList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> ImageList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/images`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ImageResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/images",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/images`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Image, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientImagesExt::image_create`]
    ///
    ///[`ClientImagesExt::image_create`]: super::ClientImagesExt::image_create
    #[derive(Debug, Clone)]
    pub struct ImageCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::builder::ImageCreate, String>,
    }

    impl<'a> ImageCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Ok(types::builder::ImageCreate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ImageCreate>,
            <V as std::convert::TryInto<types::ImageCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ImageCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ImageCreate) -> types::builder::ImageCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/images`
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ImageCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/images",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientImagesExt::image_view`]
    ///
    ///[`ClientImagesExt::image_view`]: super::ClientImagesExt::image_view
    #[derive(Debug, Clone)]
    pub struct ImageView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        image_name: Result<types::Name, String>,
    }

    impl<'a> ImageView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                image_name: Err("image_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn image_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.image_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for image_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/images/
        /// {image_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                image_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let image_name = image_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/images/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&image_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientImagesExt::image_delete`]
    ///
    ///[`ClientImagesExt::image_delete`]: super::ClientImagesExt::image_delete
    #[derive(Debug, Clone)]
    pub struct ImageDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        image_name: Result<types::Name, String>,
    }

    impl<'a> ImageDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                image_name: Err("image_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn image_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.image_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for image_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/images/
        /// {image_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                image_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let image_name = image_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/images/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&image_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_list`]
    ///
    ///[`ClientInstancesExt::instance_list`]: super::ClientInstancesExt::instance_list
    #[derive(Debug, Clone)]
    pub struct InstanceList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> InstanceList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Instance, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientInstancesExt::instance_create`]
    ///
    ///[`ClientInstancesExt::instance_create`]: super::ClientInstancesExt::instance_create
    #[derive(Debug, Clone)]
    pub struct InstanceCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::builder::InstanceCreate, String>,
    }

    impl<'a> InstanceCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Ok(types::builder::InstanceCreate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceCreate>,
            <V as std::convert::TryInto<types::InstanceCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `InstanceCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::InstanceCreate) -> types::builder::InstanceCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::InstanceCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_view`]
    ///
    ///[`ClientInstancesExt::instance_view`]: super::ClientInstancesExt::instance_view
    #[derive(Debug, Clone)]
    pub struct InstanceView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_delete`]
    ///
    ///[`ClientInstancesExt::instance_delete`]: super::ClientInstancesExt::instance_delete
    #[derive(Debug, Clone)]
    pub struct InstanceDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_disk_list`]
    ///
    ///[`ClientInstancesExt::instance_disk_list`]: super::ClientInstancesExt::instance_disk_list
    #[derive(Debug, Clone)]
    pub struct InstanceDiskList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> InstanceDiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/disks",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientInstancesExt::instance_disk_attach`]
    ///
    ///[`ClientInstancesExt::instance_disk_attach`]: super::ClientInstancesExt::instance_disk_attach
    #[derive(Debug, Clone)]
    pub struct InstanceDiskAttach<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        body: Result<types::builder::DiskIdentifier, String>,
    }

    impl<'a> InstanceDiskAttach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                body: Ok(types::builder::DiskIdentifier::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskIdentifier>,
            <V as std::convert::TryInto<types::DiskIdentifier>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DiskIdentifier` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::DiskIdentifier) -> types::builder::DiskIdentifier,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/disks/attach`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::DiskIdentifier::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/disks/attach",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_disk_detach`]
    ///
    ///[`ClientInstancesExt::instance_disk_detach`]: super::ClientInstancesExt::instance_disk_detach
    #[derive(Debug, Clone)]
    pub struct InstanceDiskDetach<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        body: Result<types::builder::DiskIdentifier, String>,
    }

    impl<'a> InstanceDiskDetach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                body: Ok(types::builder::DiskIdentifier::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskIdentifier>,
            <V as std::convert::TryInto<types::DiskIdentifier>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DiskIdentifier` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::DiskIdentifier) -> types::builder::DiskIdentifier,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/disks/detach`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::DiskIdentifier::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/disks/detach",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_external_ip_list`]
    ///
    ///[`ClientInstancesExt::instance_external_ip_list`]: super::ClientInstancesExt::instance_external_ip_list
    #[derive(Debug, Clone)]
    pub struct InstanceExternalIpList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceExternalIpList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/external-ips`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ExternalIpResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/external-ips",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_migrate`]
    ///
    ///[`ClientInstancesExt::instance_migrate`]: super::ClientInstancesExt::instance_migrate
    #[derive(Debug, Clone)]
    pub struct InstanceMigrate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        body: Result<types::builder::InstanceMigrate, String>,
    }

    impl<'a> InstanceMigrate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                body: Ok(types::builder::InstanceMigrate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceMigrate>,
            <V as std::convert::TryInto<types::InstanceMigrate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `InstanceMigrate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::InstanceMigrate) -> types::builder::InstanceMigrate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/migrate`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::InstanceMigrate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/migrate",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_network_interface_list`]
    ///
    ///[`ClientInstancesExt::instance_network_interface_list`]: super::ClientInstancesExt::instance_network_interface_list
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> InstanceNetworkInterfaceList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/network-interfaces`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterfaceResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/network-interfaces`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::NetworkInterface, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientInstancesExt::instance_network_interface_create`]
    ///
    ///[`ClientInstancesExt::instance_network_interface_create`]: super::ClientInstancesExt::instance_network_interface_create
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        body: Result<types::builder::NetworkInterfaceCreate, String>,
    }

    impl<'a> InstanceNetworkInterfaceCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                body: Ok(types::builder::NetworkInterfaceCreate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NetworkInterfaceCreate>,
            <V as std::convert::TryInto<types::NetworkInterfaceCreate>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `NetworkInterfaceCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::NetworkInterfaceCreate,
            ) -> types::builder::NetworkInterfaceCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/network-interfaces`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::NetworkInterfaceCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_network_interface_view`]
    ///
    ///[`ClientInstancesExt::instance_network_interface_view`]: super::ClientInstancesExt::instance_network_interface_view
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        interface_name: Result<types::Name, String>,
    }

    impl<'a> InstanceNetworkInterfaceView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                interface_name: Err("interface_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn interface_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.interface_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for interface_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/network-interfaces/{interface_name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                interface_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let interface_name = interface_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
                encode_path(&interface_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_network_interface_update`]
    ///
    ///[`ClientInstancesExt::instance_network_interface_update`]: super::ClientInstancesExt::instance_network_interface_update
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        interface_name: Result<types::Name, String>,
        body: Result<types::builder::NetworkInterfaceUpdate, String>,
    }

    impl<'a> InstanceNetworkInterfaceUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                interface_name: Err("interface_name was not initialized".to_string()),
                body: Ok(types::builder::NetworkInterfaceUpdate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn interface_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.interface_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for interface_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NetworkInterfaceUpdate>,
            <V as std::convert::TryInto<types::NetworkInterfaceUpdate>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `NetworkInterfaceUpdate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::NetworkInterfaceUpdate,
            ) -> types::builder::NetworkInterfaceUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/network-interfaces/{interface_name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                interface_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let interface_name = interface_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::NetworkInterfaceUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
                encode_path(&interface_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_network_interface_delete`]
    ///
    ///[`ClientInstancesExt::instance_network_interface_delete`]: super::ClientInstancesExt::instance_network_interface_delete
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        interface_name: Result<types::Name, String>,
    }

    impl<'a> InstanceNetworkInterfaceDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                interface_name: Err("interface_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn interface_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.interface_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for interface_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/network-interfaces/{interface_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                interface_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let interface_name = interface_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
                encode_path(&interface_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_reboot`]
    ///
    ///[`ClientInstancesExt::instance_reboot`]: super::ClientInstancesExt::instance_reboot
    #[derive(Debug, Clone)]
    pub struct InstanceReboot<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceReboot<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/reboot`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/reboot",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_serial_console`]
    ///
    ///[`ClientInstancesExt::instance_serial_console`]: super::ClientInstancesExt::instance_serial_console
    #[derive(Debug, Clone)]
    pub struct InstanceSerialConsole<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        from_start: Result<Option<u64>, String>,
        max_bytes: Result<Option<u64>, String>,
        most_recent: Result<Option<u64>, String>,
    }

    impl<'a> InstanceSerialConsole<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                from_start: Ok(None),
                max_bytes: Ok(None),
                most_recent: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn from_start<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.from_start = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for from_start failed".to_string());
            self
        }

        pub fn max_bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.max_bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for max_bytes failed".to_string());
            self
        }

        pub fn most_recent<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.most_recent = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for most_recent failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/serial-console`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceSerialConsoleData>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                from_start,
                max_bytes,
                most_recent,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let from_start = from_start.map_err(Error::InvalidRequest)?;
            let max_bytes = max_bytes.map_err(Error::InvalidRequest)?;
            let most_recent = most_recent.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/serial-console",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &from_start {
                query.push(("from_start", v.to_string()));
            }
            if let Some(v) = &max_bytes {
                query.push(("max_bytes", v.to_string()));
            }
            if let Some(v) = &most_recent {
                query.push(("most_recent", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_serial_console_stream`]
    ///
    ///[`ClientInstancesExt::instance_serial_console_stream`]: super::ClientInstancesExt::instance_serial_console_stream
    #[derive(Debug, Clone)]
    pub struct InstanceSerialConsoleStream<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceSerialConsoleStream<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/serial-console/stream`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<reqwest::Upgraded>, Error<reqwest::Upgraded>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/serial-console/stream",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(reqwest::header::CONNECTION, "Upgrade")
                .header(reqwest::header::UPGRADE, "websocket")
                .header(reqwest::header::SEC_WEBSOCKET_VERSION, "13")
                .header(
                    reqwest::header::SEC_WEBSOCKET_KEY,
                    base64::Engine::encode(
                        &base64::engine::general_purpose::STANDARD,
                        rand::random::<[u8; 16]>(),
                    ),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                101u16 => ResponseValue::upgrade(response).await,
                200..=299 => ResponseValue::upgrade(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_start`]
    ///
    ///[`ClientInstancesExt::instance_start`]: super::ClientInstancesExt::instance_start
    #[derive(Debug, Clone)]
    pub struct InstanceStart<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceStart<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/start`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/start",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_stop`]
    ///
    ///[`ClientInstancesExt::instance_stop`]: super::ClientInstancesExt::instance_stop
    #[derive(Debug, Clone)]
    pub struct InstanceStop<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceStop<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/stop`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/stop",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_policy_view`]
    ///
    ///[`ClientProjectsExt::project_policy_view`]: super::ClientProjectsExt::project_policy_view
    #[derive(Debug, Clone)]
    pub struct ProjectPolicyView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
    }

    impl<'a> ProjectPolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_policy_update`]
    ///
    ///[`ClientProjectsExt::project_policy_update`]: super::ClientProjectsExt::project_policy_update
    #[derive(Debug, Clone)]
    pub struct ProjectPolicyUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::builder::ProjectRolePolicy, String>,
    }

    impl<'a> ProjectPolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Ok(types::builder::ProjectRolePolicy::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectRolePolicy>,
            <V as std::convert::TryInto<types::ProjectRolePolicy>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ProjectRolePolicy` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ProjectRolePolicy,
            ) -> types::builder::ProjectRolePolicy,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ProjectRolePolicy::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSnapshotsExt::snapshot_list`]
    ///
    ///[`ClientSnapshotsExt::snapshot_list`]: super::ClientSnapshotsExt::snapshot_list
    #[derive(Debug, Clone)]
    pub struct SnapshotList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> SnapshotList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// snapshots`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SnapshotResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// snapshots`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Snapshot, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSnapshotsExt::snapshot_create`]
    ///
    ///[`ClientSnapshotsExt::snapshot_create`]: super::ClientSnapshotsExt::snapshot_create
    #[derive(Debug, Clone)]
    pub struct SnapshotCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::builder::SnapshotCreate, String>,
    }

    impl<'a> SnapshotCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Ok(types::builder::SnapshotCreate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreate>,
            <V as std::convert::TryInto<types::SnapshotCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SnapshotCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SnapshotCreate) -> types::builder::SnapshotCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// snapshots`
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SnapshotCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSnapshotsExt::snapshot_view`]
    ///
    ///[`ClientSnapshotsExt::snapshot_view`]: super::ClientSnapshotsExt::snapshot_view
    #[derive(Debug, Clone)]
    pub struct SnapshotView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        snapshot_name: Result<types::Name, String>,
    }

    impl<'a> SnapshotView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                snapshot_name: Err("snapshot_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn snapshot_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.snapshot_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for snapshot_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// snapshots/{snapshot_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                snapshot_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let snapshot_name = snapshot_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&snapshot_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSnapshotsExt::snapshot_delete`]
    ///
    ///[`ClientSnapshotsExt::snapshot_delete`]: super::ClientSnapshotsExt::snapshot_delete
    #[derive(Debug, Clone)]
    pub struct SnapshotDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        snapshot_name: Result<types::Name, String>,
    }

    impl<'a> SnapshotDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                snapshot_name: Err("snapshot_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn snapshot_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.snapshot_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for snapshot_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// snapshots/{snapshot_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                snapshot_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let snapshot_name = snapshot_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&snapshot_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_list`]
    ///
    ///[`ClientVpcsExt::vpc_list`]: super::ClientVpcsExt::vpc_list
    #[derive(Debug, Clone)]
    pub struct VpcList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> VpcList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Vpc, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_create`]
    ///
    ///[`ClientVpcsExt::vpc_create`]: super::ClientVpcsExt::vpc_create
    #[derive(Debug, Clone)]
    pub struct VpcCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::builder::VpcCreate, String>,
    }

    impl<'a> VpcCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Ok(types::builder::VpcCreate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcCreate>,
            <V as std::convert::TryInto<types::VpcCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcCreate) -> types::builder::VpcCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs`
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_view`]
    ///
    ///[`ClientVpcsExt::vpc_view`]: super::ClientVpcsExt::vpc_view
    #[derive(Debug, Clone)]
    pub struct VpcView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
    }

    impl<'a> VpcView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_update`]
    ///
    ///[`ClientVpcsExt::vpc_update`]: super::ClientVpcsExt::vpc_update
    #[derive(Debug, Clone)]
    pub struct VpcUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        body: Result<types::builder::VpcUpdate, String>,
    }

    impl<'a> VpcUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                body: Ok(types::builder::VpcUpdate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcUpdate>,
            <V as std::convert::TryInto<types::VpcUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcUpdate) -> types::builder::VpcUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_delete`]
    ///
    ///[`ClientVpcsExt::vpc_delete`]: super::ClientVpcsExt::vpc_delete
    #[derive(Debug, Clone)]
    pub struct VpcDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
    }

    impl<'a> VpcDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_firewall_rules_view`]
    ///
    ///[`ClientVpcsExt::vpc_firewall_rules_view`]: super::ClientVpcsExt::vpc_firewall_rules_view
    #[derive(Debug, Clone)]
    pub struct VpcFirewallRulesView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
    }

    impl<'a> VpcFirewallRulesView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/firewall/rules`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_firewall_rules_update`]
    ///
    ///[`ClientVpcsExt::vpc_firewall_rules_update`]: super::ClientVpcsExt::vpc_firewall_rules_update
    #[derive(Debug, Clone)]
    pub struct VpcFirewallRulesUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        body: Result<types::builder::VpcFirewallRuleUpdateParams, String>,
    }

    impl<'a> VpcFirewallRulesUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                body: Ok(types::builder::VpcFirewallRuleUpdateParams::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcFirewallRuleUpdateParams>,
            <V as std::convert::TryInto<types::VpcFirewallRuleUpdateParams>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `VpcFirewallRuleUpdateParams` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::VpcFirewallRuleUpdateParams,
            ) -> types::builder::VpcFirewallRuleUpdateParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/firewall/rules`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::VpcFirewallRuleUpdateParams::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_list`]
    ///
    ///[`ClientVpcsExt::vpc_router_list`]: super::ClientVpcsExt::vpc_router_list
    #[derive(Debug, Clone)]
    pub struct VpcRouterList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> VpcRouterList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcRouterResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::VpcRouter, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_create`]
    ///
    ///[`ClientVpcsExt::vpc_router_create`]: super::ClientVpcsExt::vpc_router_create
    #[derive(Debug, Clone)]
    pub struct VpcRouterCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        body: Result<types::builder::VpcRouterCreate, String>,
    }

    impl<'a> VpcRouterCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                body: Ok(types::builder::VpcRouterCreate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcRouterCreate>,
            <V as std::convert::TryInto<types::VpcRouterCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcRouterCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcRouterCreate) -> types::builder::VpcRouterCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers`
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcRouterCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_view`]
    ///
    ///[`ClientVpcsExt::vpc_router_view`]: super::ClientVpcsExt::vpc_router_view
    #[derive(Debug, Clone)]
    pub struct VpcRouterView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
    }

    impl<'a> VpcRouterView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_update`]
    ///
    ///[`ClientVpcsExt::vpc_router_update`]: super::ClientVpcsExt::vpc_router_update
    #[derive(Debug, Clone)]
    pub struct VpcRouterUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        body: Result<types::builder::VpcRouterUpdate, String>,
    }

    impl<'a> VpcRouterUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                body: Ok(types::builder::VpcRouterUpdate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcRouterUpdate>,
            <V as std::convert::TryInto<types::VpcRouterUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcRouterUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcRouterUpdate) -> types::builder::VpcRouterUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcRouterUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_delete`]
    ///
    ///[`ClientVpcsExt::vpc_router_delete`]: super::ClientVpcsExt::vpc_router_delete
    #[derive(Debug, Clone)]
    pub struct VpcRouterDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
    }

    impl<'a> VpcRouterDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_route_list`]
    ///
    ///[`ClientVpcsExt::vpc_router_route_list`]: super::ClientVpcsExt::vpc_router_route_list
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> VpcRouterRouteList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RouterRouteResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::RouterRoute, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_route_create`]
    ///
    ///[`ClientVpcsExt::vpc_router_route_create`]: super::ClientVpcsExt::vpc_router_route_create
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        body: Result<types::builder::RouterRouteCreateParams, String>,
    }

    impl<'a> VpcRouterRouteCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                body: Ok(types::builder::RouterRouteCreateParams::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RouterRouteCreateParams>,
            <V as std::convert::TryInto<types::RouterRouteCreateParams>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `RouterRouteCreateParams` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::RouterRouteCreateParams,
            ) -> types::builder::RouterRouteCreateParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes`
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::RouterRouteCreateParams::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_route_view`]
    ///
    ///[`ClientVpcsExt::vpc_router_route_view`]: super::ClientVpcsExt::vpc_router_route_view
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        route_name: Result<types::Name, String>,
    }

    impl<'a> VpcRouterRouteView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                route_name: Err("route_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn route_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.route_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for route_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes/{route_name}`
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let route_name = route_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
                encode_path(&route_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_route_update`]
    ///
    ///[`ClientVpcsExt::vpc_router_route_update`]: super::ClientVpcsExt::vpc_router_route_update
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        route_name: Result<types::Name, String>,
        body: Result<types::builder::RouterRouteUpdateParams, String>,
    }

    impl<'a> VpcRouterRouteUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                route_name: Err("route_name was not initialized".to_string()),
                body: Ok(types::builder::RouterRouteUpdateParams::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn route_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.route_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for route_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RouterRouteUpdateParams>,
            <V as std::convert::TryInto<types::RouterRouteUpdateParams>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `RouterRouteUpdateParams` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::RouterRouteUpdateParams,
            ) -> types::builder::RouterRouteUpdateParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes/{route_name}`
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let route_name = route_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::RouterRouteUpdateParams::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
                encode_path(&route_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_router_route_delete`]
    ///
    ///[`ClientVpcsExt::vpc_router_route_delete`]: super::ClientVpcsExt::vpc_router_route_delete
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        route_name: Result<types::Name, String>,
    }

    impl<'a> VpcRouterRouteDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                route_name: Err("route_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn route_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.route_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for route_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes/{route_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let route_name = route_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
                encode_path(&route_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_subnet_list`]
    ///
    ///[`ClientVpcsExt::vpc_subnet_list`]: super::ClientVpcsExt::vpc_subnet_list
    #[derive(Debug, Clone)]
    pub struct VpcSubnetList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> VpcSubnetList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcSubnetResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::VpcSubnet, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_subnet_create`]
    ///
    ///[`ClientVpcsExt::vpc_subnet_create`]: super::ClientVpcsExt::vpc_subnet_create
    #[derive(Debug, Clone)]
    pub struct VpcSubnetCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        body: Result<types::builder::VpcSubnetCreate, String>,
    }

    impl<'a> VpcSubnetCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                body: Ok(types::builder::VpcSubnetCreate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcSubnetCreate>,
            <V as std::convert::TryInto<types::VpcSubnetCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcSubnetCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcSubnetCreate) -> types::builder::VpcSubnetCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets`
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcSubnetCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_subnet_view`]
    ///
    ///[`ClientVpcsExt::vpc_subnet_view`]: super::ClientVpcsExt::vpc_subnet_view
    #[derive(Debug, Clone)]
    pub struct VpcSubnetView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        subnet_name: Result<types::Name, String>,
    }

    impl<'a> VpcSubnetView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                subnet_name: Err("subnet_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn subnet_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.subnet_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for subnet_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets/{subnet_name}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let subnet_name = subnet_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_subnet_update`]
    ///
    ///[`ClientVpcsExt::vpc_subnet_update`]: super::ClientVpcsExt::vpc_subnet_update
    #[derive(Debug, Clone)]
    pub struct VpcSubnetUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        subnet_name: Result<types::Name, String>,
        body: Result<types::builder::VpcSubnetUpdate, String>,
    }

    impl<'a> VpcSubnetUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                subnet_name: Err("subnet_name was not initialized".to_string()),
                body: Ok(types::builder::VpcSubnetUpdate::default()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn subnet_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.subnet_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for subnet_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcSubnetUpdate>,
            <V as std::convert::TryInto<types::VpcSubnetUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcSubnetUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcSubnetUpdate) -> types::builder::VpcSubnetUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets/{subnet_name}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let subnet_name = subnet_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcSubnetUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_subnet_delete`]
    ///
    ///[`ClientVpcsExt::vpc_subnet_delete`]: super::ClientVpcsExt::vpc_subnet_delete
    #[derive(Debug, Clone)]
    pub struct VpcSubnetDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        subnet_name: Result<types::Name, String>,
    }

    impl<'a> VpcSubnetDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                subnet_name: Err("subnet_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn subnet_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.subnet_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for subnet_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets/{subnet_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let subnet_name = subnet_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::vpc_subnet_list_network_interfaces`]
    ///
    ///[`ClientVpcsExt::vpc_subnet_list_network_interfaces`]: super::ClientVpcsExt::vpc_subnet_list_network_interfaces
    #[derive(Debug, Clone)]
    pub struct VpcSubnetListNetworkInterfaces<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        subnet_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> VpcSubnetListNetworkInterfaces<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                subnet_name: Err("subnet_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn subnet_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.subnet_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for subnet_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets/{subnet_name}/network-interfaces`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterfaceResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let subnet_name = subnet_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}/network-interfaces",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets/{subnet_name}/network-interfaces`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::NetworkInterface, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSilosExt::policy_view`]
    ///
    ///[`ClientSilosExt::policy_view`]: super::ClientSilosExt::policy_view
    #[derive(Debug, Clone)]
    pub struct PolicyView<'a> {
        client: &'a super::Client,
    }

    impl<'a> PolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/policy", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSilosExt::policy_update`]
    ///
    ///[`ClientSilosExt::policy_update`]: super::ClientSilosExt::policy_update
    #[derive(Debug, Clone)]
    pub struct PolicyUpdate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SiloRolePolicy, String>,
    }

    impl<'a> PolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::SiloRolePolicy::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloRolePolicy>,
            <V as std::convert::TryInto<types::SiloRolePolicy>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SiloRolePolicy` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SiloRolePolicy) -> types::builder::SiloRolePolicy,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SiloRolePolicy::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/policy", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientRolesExt::role_list`]
    ///
    ///[`ClientRolesExt::role_list`]: super::ClientRolesExt::role_list
    #[derive(Debug, Clone)]
    pub struct RoleList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
    }

    impl<'a> RoleList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        ///Sends a `GET` request to `/roles`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RoleResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/roles", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/roles`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Role, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientRolesExt::role_view`]
    ///
    ///[`ClientRolesExt::role_view`]: super::ClientRolesExt::role_view
    #[derive(Debug, Clone)]
    pub struct RoleView<'a> {
        client: &'a super::Client,
        role_name: Result<String, String>,
    }

    impl<'a> RoleView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                role_name: Err("role_name was not initialized".to_string()),
            }
        }

        pub fn role_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.role_name = value
                .try_into()
                .map_err(|_| "conversion to `String` for role_name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/roles/{role_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Role>, Error<types::Error>> {
            let Self { client, role_name } = self;
            let role_name = role_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/roles/{}",
                client.baseurl,
                encode_path(&role_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientHiddenExt::session_me`]
    ///
    ///[`ClientHiddenExt::session_me`]: super::ClientHiddenExt::session_me
    #[derive(Debug, Clone)]
    pub struct SessionMe<'a> {
        client: &'a super::Client,
    }

    impl<'a> SessionMe<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/session/me`
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/session/me", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientHiddenExt::session_me_groups`]
    ///
    ///[`ClientHiddenExt::session_me_groups`]: super::ClientHiddenExt::session_me_groups
    #[derive(Debug, Clone)]
    pub struct SessionMeGroups<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SessionMeGroups<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/session/me/groups`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/session/me/groups", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/session/me/groups`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Group, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSessionExt::session_sshkey_list`]
    ///
    ///[`ClientSessionExt::session_sshkey_list`]: super::ClientSessionExt::session_sshkey_list
    #[derive(Debug, Clone)]
    pub struct SessionSshkeyList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> SessionSshkeyList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/session/me/sshkeys`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SshKeyResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/session/me/sshkeys", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/session/me/sshkeys`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SshKey, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSessionExt::session_sshkey_create`]
    ///
    ///[`ClientSessionExt::session_sshkey_create`]: super::ClientSessionExt::session_sshkey_create
    #[derive(Debug, Clone)]
    pub struct SessionSshkeyCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SshKeyCreate, String>,
    }

    impl<'a> SessionSshkeyCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::SshKeyCreate::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SshKeyCreate>,
            <V as std::convert::TryInto<types::SshKeyCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SshKeyCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SshKeyCreate) -> types::builder::SshKeyCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/session/me/sshkeys`
        pub async fn send(self) -> Result<ResponseValue<types::SshKey>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SshKeyCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/session/me/sshkeys", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSessionExt::session_sshkey_view`]
    ///
    ///[`ClientSessionExt::session_sshkey_view`]: super::ClientSessionExt::session_sshkey_view
    #[derive(Debug, Clone)]
    pub struct SessionSshkeyView<'a> {
        client: &'a super::Client,
        ssh_key_name: Result<types::Name, String>,
    }

    impl<'a> SessionSshkeyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                ssh_key_name: Err("ssh_key_name was not initialized".to_string()),
            }
        }

        pub fn ssh_key_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.ssh_key_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for ssh_key_name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/session/me/sshkeys/{ssh_key_name}`
        pub async fn send(self) -> Result<ResponseValue<types::SshKey>, Error<types::Error>> {
            let Self {
                client,
                ssh_key_name,
            } = self;
            let ssh_key_name = ssh_key_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/session/me/sshkeys/{}",
                client.baseurl,
                encode_path(&ssh_key_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSessionExt::session_sshkey_delete`]
    ///
    ///[`ClientSessionExt::session_sshkey_delete`]: super::ClientSessionExt::session_sshkey_delete
    #[derive(Debug, Clone)]
    pub struct SessionSshkeyDelete<'a> {
        client: &'a super::Client,
        ssh_key_name: Result<types::Name, String>,
    }

    impl<'a> SessionSshkeyDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                ssh_key_name: Err("ssh_key_name was not initialized".to_string()),
            }
        }

        pub fn ssh_key_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.ssh_key_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for ssh_key_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/session/me/sshkeys/{ssh_key_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                ssh_key_name,
            } = self;
            let ssh_key_name = ssh_key_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/session/me/sshkeys/{}",
                client.baseurl,
                encode_path(&ssh_key_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_image_view_by_id`]
    ///
    ///[`ClientSystemExt::system_image_view_by_id`]: super::ClientSystemExt::system_image_view_by_id
    #[derive(Debug, Clone)]
    pub struct SystemImageViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> SystemImageViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/by-id/images/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::GlobalImage>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/by-id/images/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_view_by_id`]
    ///
    ///[`ClientSystemExt::ip_pool_view_by_id`]: super::ClientSystemExt::ip_pool_view_by_id
    #[derive(Debug, Clone)]
    pub struct IpPoolViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> IpPoolViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/by-id/ip-pools/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/by-id/ip-pools/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::silo_view_by_id`]
    ///
    ///[`ClientSystemExt::silo_view_by_id`]: super::ClientSystemExt::silo_view_by_id
    #[derive(Debug, Clone)]
    pub struct SiloViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> SiloViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/by-id/silos/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/by-id/silos/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::certificate_list`]
    ///
    ///[`ClientSystemExt::certificate_list`]: super::ClientSystemExt::certificate_list
    #[derive(Debug, Clone)]
    pub struct CertificateList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> CertificateList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/certificates`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CertificateResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/certificates", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/certificates`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Certificate, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::certificate_create`]
    ///
    ///[`ClientSystemExt::certificate_create`]: super::ClientSystemExt::certificate_create
    #[derive(Debug, Clone)]
    pub struct CertificateCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CertificateCreate, String>,
    }

    impl<'a> CertificateCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::CertificateCreate::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CertificateCreate>,
            <V as std::convert::TryInto<types::CertificateCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CertificateCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CertificateCreate,
            ) -> types::builder::CertificateCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/system/certificates`
        pub async fn send(self) -> Result<ResponseValue<types::Certificate>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CertificateCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/certificates", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::certificate_view`]
    ///
    ///[`ClientSystemExt::certificate_view`]: super::ClientSystemExt::certificate_view
    #[derive(Debug, Clone)]
    pub struct CertificateView<'a> {
        client: &'a super::Client,
        certificate: Result<types::NameOrId, String>,
    }

    impl<'a> CertificateView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                certificate: Err("certificate was not initialized".to_string()),
            }
        }

        pub fn certificate<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.certificate = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for certificate failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/certificates/{certificate}`
        pub async fn send(self) -> Result<ResponseValue<types::Certificate>, Error<types::Error>> {
            let Self {
                client,
                certificate,
            } = self;
            let certificate = certificate.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/certificates/{}",
                client.baseurl,
                encode_path(&certificate.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::certificate_delete`]
    ///
    ///[`ClientSystemExt::certificate_delete`]: super::ClientSystemExt::certificate_delete
    #[derive(Debug, Clone)]
    pub struct CertificateDelete<'a> {
        client: &'a super::Client,
        certificate: Result<types::NameOrId, String>,
    }

    impl<'a> CertificateDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                certificate: Err("certificate was not initialized".to_string()),
            }
        }

        pub fn certificate<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.certificate = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for certificate failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/system/certificates/{certificate}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                certificate,
            } = self;
            let certificate = certificate.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/certificates/{}",
                client.baseurl,
                encode_path(&certificate.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::physical_disk_list`]
    ///
    ///[`ClientSystemExt::physical_disk_list`]: super::ClientSystemExt::physical_disk_list
    #[derive(Debug, Clone)]
    pub struct PhysicalDiskList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> PhysicalDiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/hardware/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PhysicalDiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/hardware/disks", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/hardware/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::PhysicalDisk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::rack_list`]
    ///
    ///[`ClientSystemExt::rack_list`]: super::ClientSystemExt::rack_list
    #[derive(Debug, Clone)]
    pub struct RackList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> RackList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/hardware/racks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RackResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/hardware/racks", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/hardware/racks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Rack, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::rack_view`]
    ///
    ///[`ClientSystemExt::rack_view`]: super::ClientSystemExt::rack_view
    #[derive(Debug, Clone)]
    pub struct RackView<'a> {
        client: &'a super::Client,
        rack_id: Result<uuid::Uuid, String>,
    }

    impl<'a> RackView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                rack_id: Err("rack_id was not initialized".to_string()),
            }
        }

        pub fn rack_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.rack_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for rack_id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/hardware/racks/{rack_id}`
        pub async fn send(self) -> Result<ResponseValue<types::Rack>, Error<types::Error>> {
            let Self { client, rack_id } = self;
            let rack_id = rack_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/hardware/racks/{}",
                client.baseurl,
                encode_path(&rack_id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::sled_list`]
    ///
    ///[`ClientSystemExt::sled_list`]: super::ClientSystemExt::sled_list
    #[derive(Debug, Clone)]
    pub struct SledList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SledList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/hardware/sleds`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SledResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/hardware/sleds", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/hardware/sleds`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Sled, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::sled_view`]
    ///
    ///[`ClientSystemExt::sled_view`]: super::ClientSystemExt::sled_view
    #[derive(Debug, Clone)]
    pub struct SledView<'a> {
        client: &'a super::Client,
        sled_id: Result<uuid::Uuid, String>,
    }

    impl<'a> SledView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                sled_id: Err("sled_id was not initialized".to_string()),
            }
        }

        pub fn sled_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.sled_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for sled_id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/hardware/sleds/{sled_id}`
        pub async fn send(self) -> Result<ResponseValue<types::Sled>, Error<types::Error>> {
            let Self { client, sled_id } = self;
            let sled_id = sled_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/hardware/sleds/{}",
                client.baseurl,
                encode_path(&sled_id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::sled_physical_disk_list`]
    ///
    ///[`ClientSystemExt::sled_physical_disk_list`]: super::ClientSystemExt::sled_physical_disk_list
    #[derive(Debug, Clone)]
    pub struct SledPhysicalDiskList<'a> {
        client: &'a super::Client,
        sled_id: Result<uuid::Uuid, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SledPhysicalDiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                sled_id: Err("sled_id was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn sled_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.sled_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for sled_id failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/hardware/sleds/{sled_id}/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PhysicalDiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                sled_id,
                limit,
                page_token,
                sort_by,
            } = self;
            let sled_id = sled_id.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/hardware/sleds/{}/disks",
                client.baseurl,
                encode_path(&sled_id.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/hardware/sleds/{sled_id}/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::PhysicalDisk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::system_image_list`]
    ///
    ///[`ClientSystemExt::system_image_list`]: super::ClientSystemExt::system_image_list
    #[derive(Debug, Clone)]
    pub struct SystemImageList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> SystemImageList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/images`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GlobalImageResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/images", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/images`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::GlobalImage, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::system_image_create`]
    ///
    ///[`ClientSystemExt::system_image_create`]: super::ClientSystemExt::system_image_create
    #[derive(Debug, Clone)]
    pub struct SystemImageCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::GlobalImageCreate, String>,
    }

    impl<'a> SystemImageCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::GlobalImageCreate::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GlobalImageCreate>,
            <V as std::convert::TryInto<types::GlobalImageCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `GlobalImageCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::GlobalImageCreate,
            ) -> types::builder::GlobalImageCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/system/images`
        pub async fn send(self) -> Result<ResponseValue<types::GlobalImage>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::GlobalImageCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/images", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_image_view`]
    ///
    ///[`ClientSystemExt::system_image_view`]: super::ClientSystemExt::system_image_view
    #[derive(Debug, Clone)]
    pub struct SystemImageView<'a> {
        client: &'a super::Client,
        image_name: Result<types::Name, String>,
    }

    impl<'a> SystemImageView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                image_name: Err("image_name was not initialized".to_string()),
            }
        }

        pub fn image_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.image_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for image_name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/images/{image_name}`
        pub async fn send(self) -> Result<ResponseValue<types::GlobalImage>, Error<types::Error>> {
            let Self { client, image_name } = self;
            let image_name = image_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/images/{}",
                client.baseurl,
                encode_path(&image_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_image_delete`]
    ///
    ///[`ClientSystemExt::system_image_delete`]: super::ClientSystemExt::system_image_delete
    #[derive(Debug, Clone)]
    pub struct SystemImageDelete<'a> {
        client: &'a super::Client,
        image_name: Result<types::Name, String>,
    }

    impl<'a> SystemImageDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                image_name: Err("image_name was not initialized".to_string()),
            }
        }

        pub fn image_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.image_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for image_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/system/images/{image_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, image_name } = self;
            let image_name = image_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/images/{}",
                client.baseurl,
                encode_path(&image_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_list`]
    ///
    ///[`ClientSystemExt::ip_pool_list`]: super::ClientSystemExt::ip_pool_list
    #[derive(Debug, Clone)]
    pub struct IpPoolList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> IpPoolList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/ip-pools`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/ip-pools", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/ip-pools`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPool, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_create`]
    ///
    ///[`ClientSystemExt::ip_pool_create`]: super::ClientSystemExt::ip_pool_create
    #[derive(Debug, Clone)]
    pub struct IpPoolCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::IpPoolCreate, String>,
    }

    impl<'a> IpPoolCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::IpPoolCreate::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpPoolCreate>,
            <V as std::convert::TryInto<types::IpPoolCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `IpPoolCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::IpPoolCreate) -> types::builder::IpPoolCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/system/ip-pools`
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::IpPoolCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/ip-pools", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_view`]
    ///
    ///[`ClientSystemExt::ip_pool_view`]: super::ClientSystemExt::ip_pool_view
    #[derive(Debug, Clone)]
    pub struct IpPoolView<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
    }

    impl<'a> IpPoolView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool_name: Err("pool_name was not initialized".to_string()),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/ip-pools/{pool_name}`
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, pool_name } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_update`]
    ///
    ///[`ClientSystemExt::ip_pool_update`]: super::ClientSystemExt::ip_pool_update
    #[derive(Debug, Clone)]
    pub struct IpPoolUpdate<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
        body: Result<types::builder::IpPoolUpdate, String>,
    }

    impl<'a> IpPoolUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool_name: Err("pool_name was not initialized".to_string()),
                body: Ok(types::builder::IpPoolUpdate::default()),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpPoolUpdate>,
            <V as std::convert::TryInto<types::IpPoolUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `IpPoolUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::IpPoolUpdate) -> types::builder::IpPoolUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/system/ip-pools/{pool_name}`
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self {
                client,
                pool_name,
                body,
            } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::IpPoolUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_delete`]
    ///
    ///[`ClientSystemExt::ip_pool_delete`]: super::ClientSystemExt::ip_pool_delete
    #[derive(Debug, Clone)]
    pub struct IpPoolDelete<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
    }

    impl<'a> IpPoolDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool_name: Err("pool_name was not initialized".to_string()),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/system/ip-pools/{pool_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, pool_name } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_range_list`]
    ///
    ///[`ClientSystemExt::ip_pool_range_list`]: super::ClientSystemExt::ip_pool_range_list
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeList<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
    }

    impl<'a> IpPoolRangeList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool_name: Err("pool_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/ip-pools/{pool_name}/ranges`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolRangeResultsPage>, Error<types::Error>> {
            let Self {
                client,
                pool_name,
                limit,
                page_token,
            } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}/ranges",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/ip-pools/{pool_name}/ranges`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPoolRange, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_range_add`]
    ///
    ///[`ClientSystemExt::ip_pool_range_add`]: super::ClientSystemExt::ip_pool_range_add
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeAdd<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolRangeAdd<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool_name: Err("pool_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/system/ip-pools/{pool_name}/ranges/add`
        pub async fn send(self) -> Result<ResponseValue<types::IpPoolRange>, Error<types::Error>> {
            let Self {
                client,
                pool_name,
                body,
            } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}/ranges/add",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_range_remove`]
    ///
    ///[`ClientSystemExt::ip_pool_range_remove`]: super::ClientSystemExt::ip_pool_range_remove
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeRemove<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolRangeRemove<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool_name: Err("pool_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to
        /// `/system/ip-pools/{pool_name}/ranges/remove`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                pool_name,
                body,
            } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}/ranges/remove",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_service_view`]
    ///
    ///[`ClientSystemExt::ip_pool_service_view`]: super::ClientSystemExt::ip_pool_service_view
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceView<'a> {
        client: &'a super::Client,
    }

    impl<'a> IpPoolServiceView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/system/ip-pools-service`
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/system/ip-pools-service", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_service_range_list`]
    ///
    ///[`ClientSystemExt::ip_pool_service_range_list`]: super::ClientSystemExt::ip_pool_service_range_list
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
    }

    impl<'a> IpPoolServiceRangeList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/ip-pools-service/ranges`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolRangeResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/ip-pools-service/ranges", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/ip-pools-service/ranges`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPoolRange, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_service_range_add`]
    ///
    ///[`ClientSystemExt::ip_pool_service_range_add`]: super::ClientSystemExt::ip_pool_service_range_add
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeAdd<'a> {
        client: &'a super::Client,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolServiceRangeAdd<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/system/ip-pools-service/ranges/add`
        pub async fn send(self) -> Result<ResponseValue<types::IpPoolRange>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/ip-pools-service/ranges/add", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::ip_pool_service_range_remove`]
    ///
    ///[`ClientSystemExt::ip_pool_service_range_remove`]: super::ClientSystemExt::ip_pool_service_range_remove
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeRemove<'a> {
        client: &'a super::Client,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolServiceRangeRemove<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/system/ip-pools-service/ranges/remove`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/ip-pools-service/ranges/remove", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_metric`]
    ///
    ///[`ClientSystemExt::system_metric`]: super::ClientSystemExt::system_metric
    #[derive(Debug, Clone)]
    pub struct SystemMetric<'a> {
        client: &'a super::Client,
        metric_name: Result<types::SystemMetricName, String>,
        end_time: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
        id: Result<uuid::Uuid, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        start_time: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
    }

    impl<'a> SystemMetric<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                metric_name: Err("metric_name was not initialized".to_string()),
                end_time: Ok(None),
                id: Err("id was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                start_time: Ok(None),
            }
        }

        pub fn metric_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SystemMetricName>,
        {
            self.metric_name = value
                .try_into()
                .map_err(|_| "conversion to `SystemMetricName` for metric_name failed".to_string());
            self
        }

        pub fn end_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
        {
            self.end_time = value.try_into().map(Some).map_err(|_| {
                "conversion to `chrono :: DateTime < chrono :: offset :: Utc >` for end_time failed"
                    .to_string()
            });
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn start_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
        {
            self.start_time = value.try_into().map(Some).map_err(|_| {
                "conversion to `chrono :: DateTime < chrono :: offset :: Utc >` for start_time \
                 failed"
                    .to_string()
            });
            self
        }

        ///Sends a `GET` request to `/system/metrics/{metric_name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::Error>> {
            let Self {
                client,
                metric_name,
                end_time,
                id,
                limit,
                page_token,
                start_time,
            } = self;
            let metric_name = metric_name.map_err(Error::InvalidRequest)?;
            let end_time = end_time.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let start_time = start_time.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/metrics/{}",
                client.baseurl,
                encode_path(&metric_name.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &end_time {
                query.push(("end_time", v.to_string()));
            }
            query.push(("id", id.to_string()));
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &start_time {
                query.push(("start_time", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientPolicyExt::system_policy_view`]
    ///
    ///[`ClientPolicyExt::system_policy_view`]: super::ClientPolicyExt::system_policy_view
    #[derive(Debug, Clone)]
    pub struct SystemPolicyView<'a> {
        client: &'a super::Client,
    }

    impl<'a> SystemPolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/system/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/system/policy", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientPolicyExt::system_policy_update`]
    ///
    ///[`ClientPolicyExt::system_policy_update`]: super::ClientPolicyExt::system_policy_update
    #[derive(Debug, Clone)]
    pub struct SystemPolicyUpdate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::FleetRolePolicy, String>,
    }

    impl<'a> SystemPolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::FleetRolePolicy::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FleetRolePolicy>,
            <V as std::convert::TryInto<types::FleetRolePolicy>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `FleetRolePolicy` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::FleetRolePolicy) -> types::builder::FleetRolePolicy,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/system/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::FleetRolePolicy::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/policy", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::saga_list`]
    ///
    ///[`ClientSystemExt::saga_list`]: super::ClientSystemExt::saga_list
    #[derive(Debug, Clone)]
    pub struct SagaList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SagaList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/sagas`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SagaResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/sagas", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/sagas`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Saga, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::saga_view`]
    ///
    ///[`ClientSystemExt::saga_view`]: super::ClientSystemExt::saga_view
    #[derive(Debug, Clone)]
    pub struct SagaView<'a> {
        client: &'a super::Client,
        saga_id: Result<uuid::Uuid, String>,
    }

    impl<'a> SagaView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                saga_id: Err("saga_id was not initialized".to_string()),
            }
        }

        pub fn saga_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.saga_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for saga_id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/sagas/{saga_id}`
        pub async fn send(self) -> Result<ResponseValue<types::Saga>, Error<types::Error>> {
            let Self { client, saga_id } = self;
            let saga_id = saga_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/sagas/{}",
                client.baseurl,
                encode_path(&saga_id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::silo_list`]
    ///
    ///[`ClientSystemExt::silo_list`]: super::ClientSystemExt::silo_list
    #[derive(Debug, Clone)]
    pub struct SiloList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> SiloList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/silos`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/silos", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/silos`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Silo, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::silo_create`]
    ///
    ///[`ClientSystemExt::silo_create`]: super::ClientSystemExt::silo_create
    #[derive(Debug, Clone)]
    pub struct SiloCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SiloCreate, String>,
    }

    impl<'a> SiloCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::SiloCreate::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloCreate>,
            <V as std::convert::TryInto<types::SiloCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SiloCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SiloCreate) -> types::builder::SiloCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/system/silos`
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SiloCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/silos", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::silo_view`]
    ///
    ///[`ClientSystemExt::silo_view`]: super::ClientSystemExt::silo_view
    #[derive(Debug, Clone)]
    pub struct SiloView<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
    }

    impl<'a> SiloView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/silos/{silo_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, silo_name } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::silo_delete`]
    ///
    ///[`ClientSystemExt::silo_delete`]: super::ClientSystemExt::silo_delete
    #[derive(Debug, Clone)]
    pub struct SiloDelete<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
    }

    impl<'a> SiloDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/system/silos/{silo_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, silo_name } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::silo_identity_provider_list`]
    ///
    ///[`ClientSystemExt::silo_identity_provider_list`]: super::ClientSystemExt::silo_identity_provider_list
    #[derive(Debug, Clone)]
    pub struct SiloIdentityProviderList<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> SiloIdentityProviderList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/system/silos/{silo_name}/identity-providers`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IdentityProviderResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                silo_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/system/silos/{silo_name}/identity-providers`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IdentityProvider, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::local_idp_user_create`]
    ///
    ///[`ClientSystemExt::local_idp_user_create`]: super::ClientSystemExt::local_idp_user_create
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserCreate<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        body: Result<types::builder::UserCreate, String>,
    }

    impl<'a> LocalIdpUserCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                body: Ok(types::builder::UserCreate::default()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UserCreate>,
            <V as std::convert::TryInto<types::UserCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UserCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::UserCreate) -> types::builder::UserCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/system/silos/{silo_name}/identity-providers/local/users`
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UserCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers/local/users",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::local_idp_user_delete`]
    ///
    ///[`ClientSystemExt::local_idp_user_delete`]: super::ClientSystemExt::local_idp_user_delete
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserDelete<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        user_id: Result<uuid::Uuid, String>,
    }

    impl<'a> LocalIdpUserDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                user_id: Err("user_id was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for user_id failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/system/silos/{silo_name}/identity-providers/local/users/{user_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                user_id,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers/local/users/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&user_id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::local_idp_user_set_password`]
    ///
    ///[`ClientSystemExt::local_idp_user_set_password`]: super::ClientSystemExt::local_idp_user_set_password
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserSetPassword<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        user_id: Result<uuid::Uuid, String>,
        body: Result<types::UserPassword, String>,
    }

    impl<'a> LocalIdpUserSetPassword<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                user_id: Err("user_id was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for user_id failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UserPassword>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `UserPassword` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to
        /// `/system/silos/{silo_name}/identity-providers/local/users/{user_id}/
        /// set-password`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                user_id,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers/local/users/{}/set-password",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&user_id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::saml_identity_provider_create`]
    ///
    ///[`ClientSystemExt::saml_identity_provider_create`]: super::ClientSystemExt::saml_identity_provider_create
    #[derive(Debug, Clone)]
    pub struct SamlIdentityProviderCreate<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        body: Result<types::builder::SamlIdentityProviderCreate, String>,
    }

    impl<'a> SamlIdentityProviderCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                body: Ok(types::builder::SamlIdentityProviderCreate::default()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SamlIdentityProviderCreate>,
            <V as std::convert::TryInto<types::SamlIdentityProviderCreate>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SamlIdentityProviderCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SamlIdentityProviderCreate,
            ) -> types::builder::SamlIdentityProviderCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to
        /// `/system/silos/{silo_name}/identity-providers/saml`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SamlIdentityProvider>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::SamlIdentityProviderCreate::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers/saml",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::saml_identity_provider_view`]
    ///
    ///[`ClientSystemExt::saml_identity_provider_view`]: super::ClientSystemExt::saml_identity_provider_view
    #[derive(Debug, Clone)]
    pub struct SamlIdentityProviderView<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        provider_name: Result<types::Name, String>,
    }

    impl<'a> SamlIdentityProviderView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                provider_name: Err("provider_name was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn provider_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.provider_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for provider_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/system/silos/{silo_name}/identity-providers/saml/{provider_name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SamlIdentityProvider>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                provider_name,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let provider_name = provider_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers/saml/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&provider_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::silo_policy_view`]
    ///
    ///[`ClientSystemExt::silo_policy_view`]: super::ClientSystemExt::silo_policy_view
    #[derive(Debug, Clone)]
    pub struct SiloPolicyView<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
    }

    impl<'a> SiloPolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/silos/{silo_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client, silo_name } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/policy",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::silo_policy_update`]
    ///
    ///[`ClientSystemExt::silo_policy_update`]: super::ClientSystemExt::silo_policy_update
    #[derive(Debug, Clone)]
    pub struct SiloPolicyUpdate<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        body: Result<types::builder::SiloRolePolicy, String>,
    }

    impl<'a> SiloPolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                body: Ok(types::builder::SiloRolePolicy::default()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloRolePolicy>,
            <V as std::convert::TryInto<types::SiloRolePolicy>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SiloRolePolicy` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SiloRolePolicy) -> types::builder::SiloRolePolicy,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/system/silos/{silo_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SiloRolePolicy::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/policy",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::silo_users_list`]
    ///
    ///[`ClientSystemExt::silo_users_list`]: super::ClientSystemExt::silo_users_list
    #[derive(Debug, Clone)]
    pub struct SiloUsersList<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SiloUsersList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/silos/{silo_name}/users/all`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/users/all",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/silos/{silo_name}/users/all`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::User, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::silo_user_view`]
    ///
    ///[`ClientSystemExt::silo_user_view`]: super::ClientSystemExt::silo_user_view
    #[derive(Debug, Clone)]
    pub struct SiloUserView<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        user_id: Result<uuid::Uuid, String>,
    }

    impl<'a> SiloUserView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                user_id: Err("user_id was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for user_id failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/system/silos/{silo_name}/users/id/{user_id}`
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                user_id,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/users/id/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&user_id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_user_list`]
    ///
    ///[`ClientSystemExt::system_user_list`]: super::ClientSystemExt::system_user_list
    #[derive(Debug, Clone)]
    pub struct SystemUserList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> SystemUserList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/user`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserBuiltinResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/user", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/system/user`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::UserBuiltin, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::system_user_view`]
    ///
    ///[`ClientSystemExt::system_user_view`]: super::ClientSystemExt::system_user_view
    #[derive(Debug, Clone)]
    pub struct SystemUserView<'a> {
        client: &'a super::Client,
        user_name: Result<types::Name, String>,
    }

    impl<'a> SystemUserView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user_name: Err("user_name was not initialized".to_string()),
            }
        }

        pub fn user_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.user_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for user_name failed".to_string());
            self
        }

        ///Sends a `GET` request to `/system/user/{user_name}`
        pub async fn send(self) -> Result<ResponseValue<types::UserBuiltin>, Error<types::Error>> {
            let Self { client, user_name } = self;
            let user_name = user_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/user/{}",
                client.baseurl,
                encode_path(&user_name.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientMetricsExt::timeseries_schema_get`]
    ///
    ///[`ClientMetricsExt::timeseries_schema_get`]: super::ClientMetricsExt::timeseries_schema_get
    #[derive(Debug, Clone)]
    pub struct TimeseriesSchemaGet<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
    }

    impl<'a> TimeseriesSchemaGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        ///Sends a `GET` request to `/timeseries/schema`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TimeseriesSchemaResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/timeseries/schema", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/timeseries/schema`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::TimeseriesSchema, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSilosExt::user_list`]
    ///
    ///[`ClientSilosExt::user_list`]: super::ClientSilosExt::user_list
    #[derive(Debug, Clone)]
    pub struct UserList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> UserList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/users`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/users", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/users`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::User, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientDisksExt::disk_list_v1`]
    ///
    ///[`ClientDisksExt::disk_list_v1`]: super::ClientDisksExt::disk_list_v1
    #[derive(Debug, Clone)]
    pub struct DiskListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> DiskListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/disks", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/v1/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientDisksExt::disk_create_v1`]
    ///
    ///[`ClientDisksExt::disk_create_v1`]: super::ClientDisksExt::disk_create_v1
    #[derive(Debug, Clone)]
    pub struct DiskCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::DiskCreate, String>,
    }

    impl<'a> DiskCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization: Ok(None),
                project: Err("project was not initialized".to_string()),
                body: Ok(types::builder::DiskCreate::default()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskCreate>,
            <V as std::convert::TryInto<types::DiskCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DiskCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::DiskCreate) -> types::builder::DiskCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/v1/disks`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::DiskCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/disks", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            query.push(("project", project.to_string()));
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientDisksExt::disk_view_v1`]
    ///
    ///[`ClientDisksExt::disk_view_v1`]: super::ClientDisksExt::disk_view_v1
    #[derive(Debug, Clone)]
    pub struct DiskViewV1<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> DiskViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                disk: Err("disk was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/disks/{disk}`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                disk,
                organization,
                project,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}",
                client.baseurl,
                encode_path(&disk.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientDisksExt::disk_delete_v1`]
    ///
    ///[`ClientDisksExt::disk_delete_v1`]: super::ClientDisksExt::disk_delete_v1
    #[derive(Debug, Clone)]
    pub struct DiskDeleteV1<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> DiskDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                disk: Err("disk was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/v1/disks/{disk}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                disk,
                organization,
                project,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}",
                client.baseurl,
                encode_path(&disk.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_list_v1`]
    ///
    ///[`ClientInstancesExt::instance_list_v1`]: super::ClientInstancesExt::instance_list_v1
    #[derive(Debug, Clone)]
    pub struct InstanceListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> InstanceListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/instances`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/instances", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/v1/instances`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Instance, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientInstancesExt::instance_create_v1`]
    ///
    ///[`ClientInstancesExt::instance_create_v1`]: super::ClientInstancesExt::instance_create_v1
    #[derive(Debug, Clone)]
    pub struct InstanceCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::InstanceCreate, String>,
    }

    impl<'a> InstanceCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization: Ok(None),
                project: Err("project was not initialized".to_string()),
                body: Ok(types::builder::InstanceCreate::default()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceCreate>,
            <V as std::convert::TryInto<types::InstanceCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `InstanceCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::InstanceCreate) -> types::builder::InstanceCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/v1/instances`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::InstanceCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/instances", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            query.push(("project", project.to_string()));
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_view_v1`]
    ///
    ///[`ClientInstancesExt::instance_view_v1`]: super::ClientInstancesExt::instance_view_v1
    #[derive(Debug, Clone)]
    pub struct InstanceViewV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/instances/{instance}`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_delete_v1`]
    ///
    ///[`ClientInstancesExt::instance_delete_v1`]: super::ClientInstancesExt::instance_delete_v1
    #[derive(Debug, Clone)]
    pub struct InstanceDeleteV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/v1/instances/{instance}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_disk_list_v1`]
    ///
    ///[`ClientInstancesExt::instance_disk_list_v1`]: super::ClientInstancesExt::instance_disk_list_v1
    #[derive(Debug, Clone)]
    pub struct InstanceDiskListV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> InstanceDiskListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/instances/{instance}/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                instance,
                limit,
                organization,
                page_token,
                project,
                sort_by,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/disks",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/v1/instances/{instance}/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientInstancesExt::instance_disk_attach_v1`]
    ///
    ///[`ClientInstancesExt::instance_disk_attach_v1`]: super::ClientInstancesExt::instance_disk_attach_v1
    #[derive(Debug, Clone)]
    pub struct InstanceDiskAttachV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::DiskPath, String>,
    }

    impl<'a> InstanceDiskAttachV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                body: Ok(types::builder::DiskPath::default()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskPath>,
            <V as std::convert::TryInto<types::DiskPath>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DiskPath` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::DiskPath) -> types::builder::DiskPath,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/v1/instances/{instance}/disks/attach`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::DiskPath::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/disks/attach",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_disk_detach_v1`]
    ///
    ///[`ClientInstancesExt::instance_disk_detach_v1`]: super::ClientInstancesExt::instance_disk_detach_v1
    #[derive(Debug, Clone)]
    pub struct InstanceDiskDetachV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::DiskPath, String>,
    }

    impl<'a> InstanceDiskDetachV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                body: Ok(types::builder::DiskPath::default()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskPath>,
            <V as std::convert::TryInto<types::DiskPath>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DiskPath` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::DiskPath) -> types::builder::DiskPath,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/v1/instances/{instance}/disks/detach`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::DiskPath::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/disks/detach",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_migrate_v1`]
    ///
    ///[`ClientInstancesExt::instance_migrate_v1`]: super::ClientInstancesExt::instance_migrate_v1
    #[derive(Debug, Clone)]
    pub struct InstanceMigrateV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::InstanceMigrate, String>,
    }

    impl<'a> InstanceMigrateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                body: Ok(types::builder::InstanceMigrate::default()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceMigrate>,
            <V as std::convert::TryInto<types::InstanceMigrate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `InstanceMigrate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::InstanceMigrate) -> types::builder::InstanceMigrate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/v1/instances/{instance}/migrate`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::InstanceMigrate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/migrate",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_reboot_v1`]
    ///
    ///[`ClientInstancesExt::instance_reboot_v1`]: super::ClientInstancesExt::instance_reboot_v1
    #[derive(Debug, Clone)]
    pub struct InstanceRebootV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceRebootV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        ///Sends a `POST` request to `/v1/instances/{instance}/reboot`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/reboot",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_serial_console_v1`]
    ///
    ///[`ClientInstancesExt::instance_serial_console_v1`]: super::ClientInstancesExt::instance_serial_console_v1
    #[derive(Debug, Clone)]
    pub struct InstanceSerialConsoleV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        from_start: Result<Option<u64>, String>,
        max_bytes: Result<Option<u64>, String>,
        most_recent: Result<Option<u64>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceSerialConsoleV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                from_start: Ok(None),
                max_bytes: Ok(None),
                most_recent: Ok(None),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn from_start<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.from_start = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for from_start failed".to_string());
            self
        }

        pub fn max_bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.max_bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for max_bytes failed".to_string());
            self
        }

        pub fn most_recent<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.most_recent = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for most_recent failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/instances/{instance}/serial-console`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceSerialConsoleData>, Error<types::Error>> {
            let Self {
                client,
                instance,
                from_start,
                max_bytes,
                most_recent,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let from_start = from_start.map_err(Error::InvalidRequest)?;
            let max_bytes = max_bytes.map_err(Error::InvalidRequest)?;
            let most_recent = most_recent.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/serial-console",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &from_start {
                query.push(("from_start", v.to_string()));
            }
            if let Some(v) = &max_bytes {
                query.push(("max_bytes", v.to_string()));
            }
            if let Some(v) = &most_recent {
                query.push(("most_recent", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_serial_console_stream_v1`]
    ///
    ///[`ClientInstancesExt::instance_serial_console_stream_v1`]: super::ClientInstancesExt::instance_serial_console_stream_v1
    #[derive(Debug, Clone)]
    pub struct InstanceSerialConsoleStreamV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceSerialConsoleStreamV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/v1/instances/{instance}/serial-console/stream`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<reqwest::Upgraded>, Error<reqwest::Upgraded>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/serial-console/stream",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .query(&query)
                .header(reqwest::header::CONNECTION, "Upgrade")
                .header(reqwest::header::UPGRADE, "websocket")
                .header(reqwest::header::SEC_WEBSOCKET_VERSION, "13")
                .header(
                    reqwest::header::SEC_WEBSOCKET_KEY,
                    base64::Engine::encode(
                        &base64::engine::general_purpose::STANDARD,
                        rand::random::<[u8; 16]>(),
                    ),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                101u16 => ResponseValue::upgrade(response).await,
                200..=299 => ResponseValue::upgrade(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_start_v1`]
    ///
    ///[`ClientInstancesExt::instance_start_v1`]: super::ClientInstancesExt::instance_start_v1
    #[derive(Debug, Clone)]
    pub struct InstanceStartV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceStartV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        ///Sends a `POST` request to `/v1/instances/{instance}/start`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/start",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_stop_v1`]
    ///
    ///[`ClientInstancesExt::instance_stop_v1`]: super::ClientInstancesExt::instance_stop_v1
    #[derive(Debug, Clone)]
    pub struct InstanceStopV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceStopV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        ///Sends a `POST` request to `/v1/instances/{instance}/stop`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/stop",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_list_v1`]
    ///
    ///[`ClientOrganizationsExt::organization_list_v1`]: super::ClientOrganizationsExt::organization_list_v1
    #[derive(Debug, Clone)]
    pub struct OrganizationListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> OrganizationListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/organizations`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/organizations", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/v1/organizations`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Organization, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_create_v1`]
    ///
    ///[`ClientOrganizationsExt::organization_create_v1`]: super::ClientOrganizationsExt::organization_create_v1
    #[derive(Debug, Clone)]
    pub struct OrganizationCreateV1<'a> {
        client: &'a super::Client,
        body: Result<types::builder::OrganizationCreate, String>,
    }

    impl<'a> OrganizationCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::OrganizationCreate::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationCreate>,
            <V as std::convert::TryInto<types::OrganizationCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `OrganizationCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::OrganizationCreate,
            ) -> types::builder::OrganizationCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/v1/organizations`
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::OrganizationCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/organizations", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_view_v1`]
    ///
    ///[`ClientOrganizationsExt::organization_view_v1`]: super::ClientOrganizationsExt::organization_view_v1
    #[derive(Debug, Clone)]
    pub struct OrganizationViewV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
    }

    impl<'a> OrganizationViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization: Err("organization was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/organizations/{organization}`
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self {
                client,
                organization,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/organizations/{}",
                client.baseurl,
                encode_path(&organization.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_update_v1`]
    ///
    ///[`ClientOrganizationsExt::organization_update_v1`]: super::ClientOrganizationsExt::organization_update_v1
    #[derive(Debug, Clone)]
    pub struct OrganizationUpdateV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
        body: Result<types::builder::OrganizationUpdate, String>,
    }

    impl<'a> OrganizationUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization: Err("organization was not initialized".to_string()),
                body: Ok(types::builder::OrganizationUpdate::default()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationUpdate>,
            <V as std::convert::TryInto<types::OrganizationUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `OrganizationUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::OrganizationUpdate,
            ) -> types::builder::OrganizationUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/v1/organizations/{organization}`
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self {
                client,
                organization,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::OrganizationUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/organizations/{}",
                client.baseurl,
                encode_path(&organization.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_delete_v1`]
    ///
    ///[`ClientOrganizationsExt::organization_delete_v1`]: super::ClientOrganizationsExt::organization_delete_v1
    #[derive(Debug, Clone)]
    pub struct OrganizationDeleteV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
    }

    impl<'a> OrganizationDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization: Err("organization was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/v1/organizations/{organization}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/organizations/{}",
                client.baseurl,
                encode_path(&organization.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_policy_view_v1`]
    ///
    ///[`ClientOrganizationsExt::organization_policy_view_v1`]: super::ClientOrganizationsExt::organization_policy_view_v1
    #[derive(Debug, Clone)]
    pub struct OrganizationPolicyViewV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
    }

    impl<'a> OrganizationPolicyViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization: Err("organization was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/organizations/{organization}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/organizations/{}/policy",
                client.baseurl,
                encode_path(&organization.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_policy_update_v1`]
    ///
    ///[`ClientOrganizationsExt::organization_policy_update_v1`]: super::ClientOrganizationsExt::organization_policy_update_v1
    #[derive(Debug, Clone)]
    pub struct OrganizationPolicyUpdateV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
        body: Result<types::builder::OrganizationRolePolicy, String>,
    }

    impl<'a> OrganizationPolicyUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization: Err("organization was not initialized".to_string()),
                body: Ok(types::builder::OrganizationRolePolicy::default()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationRolePolicy>,
            <V as std::convert::TryInto<types::OrganizationRolePolicy>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `OrganizationRolePolicy` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::OrganizationRolePolicy,
            ) -> types::builder::OrganizationRolePolicy,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/v1/organizations/{organization}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::OrganizationRolePolicy::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/organizations/{}/policy",
                client.baseurl,
                encode_path(&organization.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_list_v1`]
    ///
    ///[`ClientProjectsExt::project_list_v1`]: super::ClientProjectsExt::project_list_v1
    #[derive(Debug, Clone)]
    pub struct ProjectListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> ProjectListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/projects`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/projects", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/v1/projects`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Project, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientProjectsExt::project_create_v1`]
    ///
    ///[`ClientProjectsExt::project_create_v1`]: super::ClientProjectsExt::project_create_v1
    #[derive(Debug, Clone)]
    pub struct ProjectCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
        body: Result<types::builder::ProjectCreate, String>,
    }

    impl<'a> ProjectCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                organization: Err("organization was not initialized".to_string()),
                body: Ok(types::builder::ProjectCreate::default()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectCreate>,
            <V as std::convert::TryInto<types::ProjectCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ProjectCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ProjectCreate) -> types::builder::ProjectCreate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/v1/projects`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                organization,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ProjectCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/projects", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            query.push(("organization", organization.to_string()));
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_view_v1`]
    ///
    ///[`ClientProjectsExt::project_view_v1`]: super::ClientProjectsExt::project_view_v1
    #[derive(Debug, Clone)]
    pub struct ProjectViewV1<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> ProjectViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                organization: Ok(None),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/projects/{project}`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                project,
                organization,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_update_v1`]
    ///
    ///[`ClientProjectsExt::project_update_v1`]: super::ClientProjectsExt::project_update_v1
    #[derive(Debug, Clone)]
    pub struct ProjectUpdateV1<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::ProjectUpdate, String>,
    }

    impl<'a> ProjectUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                organization: Ok(None),
                body: Ok(types::builder::ProjectUpdate::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectUpdate>,
            <V as std::convert::TryInto<types::ProjectUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ProjectUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ProjectUpdate) -> types::builder::ProjectUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/v1/projects/{project}`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                project,
                organization,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ProjectUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_delete_v1`]
    ///
    ///[`ClientProjectsExt::project_delete_v1`]: super::ClientProjectsExt::project_delete_v1
    #[derive(Debug, Clone)]
    pub struct ProjectDeleteV1<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> ProjectDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                organization: Ok(None),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/v1/projects/{project}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                project,
                organization,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_policy_view_v1`]
    ///
    ///[`ClientProjectsExt::project_policy_view_v1`]: super::ClientProjectsExt::project_policy_view_v1
    #[derive(Debug, Clone)]
    pub struct ProjectPolicyViewV1<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> ProjectPolicyViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                organization: Ok(None),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/projects/{project}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                project,
                organization,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}/policy",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::project_policy_update_v1`]
    ///
    ///[`ClientProjectsExt::project_policy_update_v1`]: super::ClientProjectsExt::project_policy_update_v1
    #[derive(Debug, Clone)]
    pub struct ProjectPolicyUpdateV1<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::ProjectRolePolicy, String>,
    }

    impl<'a> ProjectPolicyUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                organization: Ok(None),
                body: Ok(types::builder::ProjectRolePolicy::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectRolePolicy>,
            <V as std::convert::TryInto<types::ProjectRolePolicy>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ProjectRolePolicy` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ProjectRolePolicy,
            ) -> types::builder::ProjectRolePolicy,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/v1/projects/{project}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                project,
                organization,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ProjectRolePolicy::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}/policy",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_component_version_list`]
    ///
    ///[`ClientSystemExt::system_component_version_list`]: super::ClientSystemExt::system_component_version_list
    #[derive(Debug, Clone)]
    pub struct SystemComponentVersionList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SystemComponentVersionList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/system/update/components`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UpdateableComponentResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/update/components", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/v1/system/update/components`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::UpdateableComponent, Error<types::Error>>>
               + Unpin
               + 'a {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::update_deployments_list`]
    ///
    ///[`ClientSystemExt::update_deployments_list`]: super::ClientSystemExt::update_deployments_list
    #[derive(Debug, Clone)]
    pub struct UpdateDeploymentsList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> UpdateDeploymentsList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/system/update/deployments`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UpdateDeploymentResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/update/deployments", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/v1/system/update/deployments`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::UpdateDeployment, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::update_deployment_view`]
    ///
    ///[`ClientSystemExt::update_deployment_view`]: super::ClientSystemExt::update_deployment_view
    #[derive(Debug, Clone)]
    pub struct UpdateDeploymentView<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> UpdateDeploymentView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/system/update/deployments/{id}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UpdateDeployment>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/update/deployments/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_update_refresh`]
    ///
    ///[`ClientSystemExt::system_update_refresh`]: super::ClientSystemExt::system_update_refresh
    #[derive(Debug, Clone)]
    pub struct SystemUpdateRefresh<'a> {
        client: &'a super::Client,
    }

    impl<'a> SystemUpdateRefresh<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `POST` request to `/v1/system/update/refresh`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/update/refresh", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_update_start`]
    ///
    ///[`ClientSystemExt::system_update_start`]: super::ClientSystemExt::system_update_start
    #[derive(Debug, Clone)]
    pub struct SystemUpdateStart<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SystemUpdateStart, String>,
    }

    impl<'a> SystemUpdateStart<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(types::builder::SystemUpdateStart::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SystemUpdateStart>,
            <V as std::convert::TryInto<types::SystemUpdateStart>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SystemUpdateStart` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SystemUpdateStart,
            ) -> types::builder::SystemUpdateStart,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/v1/system/update/start`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UpdateDeployment>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SystemUpdateStart::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/update/start", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_update_stop`]
    ///
    ///[`ClientSystemExt::system_update_stop`]: super::ClientSystemExt::system_update_stop
    #[derive(Debug, Clone)]
    pub struct SystemUpdateStop<'a> {
        client: &'a super::Client,
    }

    impl<'a> SystemUpdateStop<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `POST` request to `/v1/system/update/stop`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/update/stop", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_update_list`]
    ///
    ///[`ClientSystemExt::system_update_list`]: super::ClientSystemExt::system_update_list
    #[derive(Debug, Clone)]
    pub struct SystemUpdateList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SystemUpdateList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/system/update/updates`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SystemUpdateResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/update/updates", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/v1/system/update/updates`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SystemUpdate, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let limit = self
                .limit
                .clone()
                .ok()
                .flatten()
                .and_then(|x| std::num::NonZeroUsize::try_from(x).ok())
                .map(std::num::NonZeroUsize::get)
                .unwrap_or(usize::MAX);
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .take(limit)
                .boxed()
        }
    }

    ///Builder for [`ClientSystemExt::system_update_view`]
    ///
    ///[`ClientSystemExt::system_update_view`]: super::ClientSystemExt::system_update_view
    #[derive(Debug, Clone)]
    pub struct SystemUpdateView<'a> {
        client: &'a super::Client,
        version: Result<types::SemverVersion, String>,
    }

    impl<'a> SystemUpdateView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                version: Err("version was not initialized".to_string()),
            }
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SemverVersion>,
        {
            self.version = value
                .try_into()
                .map_err(|_| "conversion to `SemverVersion` for version failed".to_string());
            self
        }

        ///Sends a `GET` request to `/v1/system/update/updates/{version}`
        pub async fn send(self) -> Result<ResponseValue<types::SystemUpdate>, Error<types::Error>> {
            let Self { client, version } = self;
            let version = version.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/update/updates/{}",
                client.baseurl,
                encode_path(&version.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_update_components_list`]
    ///
    ///[`ClientSystemExt::system_update_components_list`]: super::ClientSystemExt::system_update_components_list
    #[derive(Debug, Clone)]
    pub struct SystemUpdateComponentsList<'a> {
        client: &'a super::Client,
        version: Result<types::SemverVersion, String>,
    }

    impl<'a> SystemUpdateComponentsList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                version: Err("version was not initialized".to_string()),
            }
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SemverVersion>,
        {
            self.version = value
                .try_into()
                .map_err(|_| "conversion to `SemverVersion` for version failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/v1/system/update/updates/{version}/components`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ComponentUpdateResultsPage>, Error<types::Error>> {
            let Self { client, version } = self;
            let version = version.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/update/updates/{}/components",
                client.baseurl,
                encode_path(&version.to_string()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSystemExt::system_version`]
    ///
    ///[`ClientSystemExt::system_version`]: super::ClientSystemExt::system_version
    #[derive(Debug, Clone)]
    pub struct SystemVersion<'a> {
        client: &'a super::Client,
    }

    impl<'a> SystemVersion<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        ///Sends a `GET` request to `/v1/system/update/version`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SystemVersion>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/update/version", client.baseurl,);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}

/// Items consumers will typically use such as the Client and
/// extension traits.
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
    pub use super::ClientDisksExt;
    pub use super::ClientHiddenExt;
    pub use super::ClientImagesExt;
    pub use super::ClientInstancesExt;
    pub use super::ClientLoginExt;
    pub use super::ClientMetricsExt;
    pub use super::ClientOrganizationsExt;
    pub use super::ClientPolicyExt;
    pub use super::ClientProjectsExt;
    pub use super::ClientRolesExt;
    pub use super::ClientSessionExt;
    pub use super::ClientSilosExt;
    pub use super::ClientSnapshotsExt;
    pub use super::ClientSystemExt;
    pub use super::ClientVpcsExt;
}
