use anyhow::Result;
mod progenitor_support {
    use percent_encoding::{utf8_percent_encode, AsciiSet, CONTROLS};
    #[allow(dead_code)]
    const PATH_SET: &AsciiSet = &CONTROLS
        .add(b' ')
        .add(b'"')
        .add(b'#')
        .add(b'<')
        .add(b'>')
        .add(b'?')
        .add(b'`')
        .add(b'{')
        .add(b'}');
    #[allow(dead_code)]
    pub(crate) fn encode_path(pc: &str) -> String {
        utf8_percent_encode(pc, PATH_SET).to_string()
    }
}

pub mod types {
    use schemars::JsonSchema;
    use serde::{Deserialize, Serialize};
    #[doc = "A count of bytes, typically used either for memory or storage capacity\n\nThe maximum supported byte count is [`i64::MAX`].  This makes it somewhat inconvenient to define constructors: a u32 constructor can be infallible, but an i64 constructor can fail (if the value is negative) and a u64 constructor can fail (if the value is larger than i64::MAX).  We provide all of these for consumers' convenience."]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct ByteCount(pub u64);
    impl std::ops::Deref for ByteCount {
        type Target = u64;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "The type of an individual datum of a metric."]
    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum DatumType {
        Bool,
        I64,
        F64,
        String,
        Bytes,
        CumulativeI64,
        CumulativeF64,
        HistogramI64,
        HistogramF64,
    }

    impl ToString for DatumType {
        fn to_string(&self) -> String {
            match self {
                DatumType::Bool => "Bool".to_string(),
                DatumType::I64 => "I64".to_string(),
                DatumType::F64 => "F64".to_string(),
                DatumType::String => "String".to_string(),
                DatumType::Bytes => "Bytes".to_string(),
                DatumType::CumulativeI64 => "CumulativeI64".to_string(),
                DatumType::CumulativeF64 => "CumulativeF64".to_string(),
                DatumType::HistogramI64 => "HistogramI64".to_string(),
                DatumType::HistogramF64 => "HistogramF64".to_string(),
            }
        }
    }

    #[doc = "Client view of an [`Disk`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Disk {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[serde(rename = "devicePath")]
        pub device_path: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub name: Name,
        #[serde(rename = "projectId")]
        pub project_id: uuid::Uuid,
        pub size: ByteCount,
        #[serde(
            rename = "snapshotId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub snapshot_id: Option<uuid::Uuid>,
        pub state: DiskState,
        #[doc = "timestamp when this resource was created"]
        #[serde(rename = "timeCreated")]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        #[serde(rename = "timeModified")]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "Create-time parameters for a [`Disk`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct DiskCreate {
        pub description: String,
        pub name: Name,
        pub size: ByteCount,
        #[doc = "id for snapshot from which the Disk should be created, if any"]
        #[serde(
            rename = "snapshotId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub snapshot_id: Option<uuid::Uuid>,
    }

    #[doc = "Parameters for the [`Disk`] to be attached or detached to an instance"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct DiskIdentifier {
        pub disk: Name,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct DiskResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Disk>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    #[serde(tag = "state", content = "instance")]
    pub enum DiskState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "detached")]
        Detached,
        #[serde(rename = "attaching")]
        Attaching(uuid::Uuid),
        #[serde(rename = "attached")]
        Attached(uuid::Uuid),
        #[serde(rename = "detaching")]
        Detaching(uuid::Uuid),
        #[serde(rename = "destroyed")]
        Destroyed,
        #[serde(rename = "faulted")]
        Faulted,
    }

    #[doc = "The name and type information for a field of a timeseries schema."]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct FieldSchema {
        pub name: String,
        pub source: FieldSource,
        pub ty: FieldType,
    }

    #[doc = "The source from which a field is derived, the target or metric."]
    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum FieldSource {
        Target,
        Metric,
    }

    impl ToString for FieldSource {
        fn to_string(&self) -> String {
            match self {
                FieldSource::Target => "Target".to_string(),
                FieldSource::Metric => "Metric".to_string(),
            }
        }
    }

    #[doc = "The `FieldType` identifies the data type of a target or metric field."]
    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum FieldType {
        String,
        I64,
        IpAddr,
        Uuid,
        Bool,
    }

    impl ToString for FieldType {
        fn to_string(&self) -> String {
            match self {
                FieldType::String => "String".to_string(),
                FieldType::I64 => "I64".to_string(),
                FieldType::IpAddr => "IpAddr".to_string(),
                FieldType::Uuid => "Uuid".to_string(),
                FieldType::Bool => "Bool".to_string(),
            }
        }
    }

    #[doc = "Supported set of sort modes for scanning by id only.\n\nCurrently, we only support scanning in ascending order."]
    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum IdSortMode {
        #[serde(rename = "id-ascending")]
        IdAscending,
    }

    impl ToString for IdSortMode {
        fn to_string(&self) -> String {
            match self {
                IdSortMode::IdAscending => "id-ascending".to_string(),
            }
        }
    }

    #[doc = "Identity-related metadata that's included in nearly all public API objects"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct IdentityMetadata {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        #[serde(rename = "timeCreated")]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        #[serde(rename = "timeModified")]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "Client view of an [`Instance`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Instance {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "RFC1035-compliant hostname for the Instance."]
        pub hostname: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub memory: ByteCount,
        pub name: Name,
        pub ncpus: InstanceCpuCount,
        #[doc = "id for the project containing this Instance"]
        #[serde(rename = "projectId")]
        pub project_id: uuid::Uuid,
        #[serde(rename = "runState")]
        pub run_state: InstanceState,
        #[doc = "timestamp when this resource was created"]
        #[serde(rename = "timeCreated")]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        #[serde(rename = "timeModified")]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[serde(rename = "timeRunStateUpdated")]
        pub time_run_state_updated: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "The number of CPUs in an Instance"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct InstanceCpuCount(pub u16);
    impl std::ops::Deref for InstanceCpuCount {
        type Target = u16;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "Create-time parameters for an [`Instance`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct InstanceCreate {
        pub description: String,
        pub hostname: String,
        pub memory: ByteCount,
        pub name: Name,
        pub ncpus: InstanceCpuCount,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct InstanceResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Instance>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Running state of an Instance (primarily: booted or stopped)\n\nThis typically reflects whether it's starting, running, stopping, or stopped, but also includes states related to the Instance's lifecycle"]
    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum InstanceState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "starting")]
        Starting,
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "stopping")]
        Stopping,
        #[serde(rename = "stopped")]
        Stopped,
        #[serde(rename = "rebooting")]
        Rebooting,
        #[serde(rename = "repairing")]
        Repairing,
        #[serde(rename = "failed")]
        Failed,
        #[serde(rename = "destroyed")]
        Destroyed,
    }

    impl ToString for InstanceState {
        fn to_string(&self) -> String {
            match self {
                InstanceState::Creating => "creating".to_string(),
                InstanceState::Starting => "starting".to_string(),
                InstanceState::Running => "running".to_string(),
                InstanceState::Stopping => "stopping".to_string(),
                InstanceState::Stopped => "stopped".to_string(),
                InstanceState::Rebooting => "rebooting".to_string(),
                InstanceState::Repairing => "repairing".to_string(),
                InstanceState::Failed => "failed".to_string(),
                InstanceState::Destroyed => "destroyed".to_string(),
            }
        }
    }

    #[doc = "An IPv4 subnet, including prefix and subnet mask"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Ipv4Net(pub String);
    impl std::ops::Deref for Ipv4Net {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "An IPv6 subnet, including prefix and subnet mask"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Ipv6Net(pub String);
    impl std::ops::Deref for Ipv6Net {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "An inclusive-inclusive range of IP ports. The second port may be omitted to represent a single port"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct L4PortRange(pub String);
    impl std::ops::Deref for L4PortRange {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct LoginParams {
        pub username: String,
    }

    #[doc = "A Media Access Control address, in EUI-48 format"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct MacAddr(pub String);
    impl std::ops::Deref for MacAddr {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'."]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Name(pub String);
    impl std::ops::Deref for Name {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "Supported set of sort modes for scanning by name or id"]
    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum NameOrIdSortMode {
        #[serde(rename = "name-ascending")]
        NameAscending,
        #[serde(rename = "name-descending")]
        NameDescending,
        #[serde(rename = "id-ascending")]
        IdAscending,
    }

    impl ToString for NameOrIdSortMode {
        fn to_string(&self) -> String {
            match self {
                NameOrIdSortMode::NameAscending => "name-ascending".to_string(),
                NameOrIdSortMode::NameDescending => "name-descending".to_string(),
                NameOrIdSortMode::IdAscending => "id-ascending".to_string(),
            }
        }
    }

    #[doc = "Supported set of sort modes for scanning by name only\n\nCurrently, we only support scanning in ascending order."]
    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum NameSortMode {
        #[serde(rename = "name-ascending")]
        NameAscending,
    }

    impl ToString for NameSortMode {
        fn to_string(&self) -> String {
            match self {
                NameSortMode::NameAscending => "name-ascending".to_string(),
            }
        }
    }

    #[doc = "A `NetworkInterface` represents a virtual network interface device."]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct NetworkInterface {
        pub identity: IdentityMetadata,
        #[doc = "The Instance to which the interface belongs."]
        pub instance_id: uuid::Uuid,
        #[doc = "The IP address assigned to this interface."]
        pub ip: String,
        pub mac: MacAddr,
        #[doc = "The subnet to which the interface belongs."]
        pub subnet_id: uuid::Uuid,
        #[doc = "The VPC to which the interface belongs."]
        pub vpc_id: uuid::Uuid,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct NetworkInterfaceResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<NetworkInterface>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Client view of an [`Organization`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Organization {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        #[serde(rename = "timeCreated")]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        #[serde(rename = "timeModified")]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "Create-time parameters for an [`Organization`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct OrganizationCreate {
        pub description: String,
        pub name: Name,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct OrganizationResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Organization>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Updateable properties of an [`Organization`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct OrganizationUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    #[doc = "Client view of a [`Project`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Project {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub name: Name,
        #[serde(rename = "organizationId")]
        pub organization_id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        #[serde(rename = "timeCreated")]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        #[serde(rename = "timeModified")]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "Create-time parameters for a [`Project`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct ProjectCreate {
        pub description: String,
        pub name: Name,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct ProjectResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Project>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Updateable properties of a [`Project`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct ProjectUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    #[doc = "Client view of an [`Rack`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Rack {
        pub identity: IdentityMetadata,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct RackResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Rack>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Client view of a [`Role`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Role {
        pub description: String,
        pub name: RoleName,
    }

    #[doc = "Role names consist of two string components separated by dot (\".\")."]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct RoleName(pub String);
    impl std::ops::Deref for RoleName {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct RoleResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Role>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteDestination {
        #[serde(rename = "ip")]
        Ip(String),
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[serde(rename = "subnet")]
        Subnet(Name),
    }

    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteTarget {
        #[serde(rename = "ip")]
        Ip(String),
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[serde(rename = "subnet")]
        Subnet(Name),
        #[serde(rename = "instance")]
        Instance(Name),
        #[serde(rename = "internetGateway")]
        InternetGateway(Name),
    }

    #[doc = "A route defines a rule that governs where traffic should be sent based on its destination."]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct RouterRoute {
        pub destination: RouteDestination,
        pub identity: IdentityMetadata,
        pub kind: RouterRouteKind,
        #[doc = "The VPC Router to which the route belongs."]
        pub router_id: uuid::Uuid,
        pub target: RouteTarget,
    }

    #[doc = "Create-time parameters for a [`RouterRoute`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct RouterRouteCreateParams {
        pub description: String,
        pub destination: RouteDestination,
        pub name: Name,
        pub target: RouteTarget,
    }

    #[doc = "The classification of a [`RouterRoute`] as defined by the system. The kind determines certain attributes such as if the route is modifiable and describes how or where the route was created.\n\nSee [RFD-21](https://rfd.shared.oxide.computer/rfd/0021#concept-router) for more context"]
    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum RouterRouteKind {
        Default,
        VpcSubnet,
        VpcPeering,
        Custom,
    }

    impl ToString for RouterRouteKind {
        fn to_string(&self) -> String {
            match self {
                RouterRouteKind::Default => "Default".to_string(),
                RouterRouteKind::VpcSubnet => "VpcSubnet".to_string(),
                RouterRouteKind::VpcPeering => "VpcPeering".to_string(),
                RouterRouteKind::Custom => "Custom".to_string(),
            }
        }
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct RouterRouteResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<RouterRoute>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Updateable properties of a [`RouterRoute`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct RouterRouteUpdateParams {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        pub destination: RouteDestination,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
        pub target: RouteTarget,
    }

    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Saga {
        pub id: uuid::Uuid,
        pub state: SagaState,
    }

    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    #[serde(tag = "error")]
    pub enum SagaErrorInfo {
        #[serde(rename = "actionFailed")]
        ActionFailed { source_error: serde_json::Value },
        #[serde(rename = "deserializeFailed")]
        DeserializeFailed { message: String },
        #[serde(rename = "injectedError")]
        InjectedError,
        #[serde(rename = "serializeFailed")]
        SerializeFailed { message: String },
        #[serde(rename = "subsagaCreateFailed")]
        SubsagaCreateFailed { message: String },
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct SagaResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Saga>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    #[serde(tag = "state")]
    pub enum SagaState {
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "succeeded")]
        Succeeded,
        #[serde(rename = "failed")]
        Failed {
            error_info: SagaErrorInfo,
            error_node_name: String,
        },
    }

    #[doc = "Client view of an [`Sled`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Sled {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub name: Name,
        #[serde(rename = "serviceAddress")]
        pub service_address: String,
        #[doc = "timestamp when this resource was created"]
        #[serde(rename = "timeCreated")]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        #[serde(rename = "timeModified")]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct SledResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Sled>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Names are constructed by concatenating the target and metric names with ':'. Target and metric names must be lowercase alphanumeric characters with '_' separating words."]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct TimeseriesName(pub String);
    impl std::ops::Deref for TimeseriesName {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "The schema for a timeseries.\n\nThis includes the name of the timeseries, as well as the datum type of its metric and the schema for each field."]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct TimeseriesSchema {
        pub created: chrono::DateTime<chrono::offset::Utc>,
        pub datum_type: DatumType,
        pub field_schema: Vec<FieldSchema>,
        pub timeseries_name: TimeseriesName,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct TimeseriesSchemaResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<TimeseriesSchema>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Client view of a [`User`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct User {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        #[serde(rename = "timeCreated")]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        #[serde(rename = "timeModified")]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct UserResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<User>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Client view of a [`Vpc`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct Vpc {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[serde(rename = "dnsName")]
        pub dns_name: Name,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub name: Name,
        #[doc = "id for the project containing this VPC"]
        #[serde(rename = "projectId")]
        pub project_id: uuid::Uuid,
        #[doc = "id for the system router where subnet default routes are registered"]
        #[serde(rename = "systemRouterId")]
        pub system_router_id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        #[serde(rename = "timeCreated")]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        #[serde(rename = "timeModified")]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "Create-time parameters for a [`Vpc`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcCreate {
        pub description: String,
        #[serde(rename = "dnsName")]
        pub dns_name: Name,
        pub name: Name,
    }

    #[doc = "A single rule in a VPC firewall"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcFirewallRule {
        pub action: VpcFirewallRuleAction,
        pub direction: VpcFirewallRuleDirection,
        pub filters: VpcFirewallRuleFilter,
        pub identity: IdentityMetadata,
        #[doc = "the relative priority of this rule"]
        pub priority: u16,
        pub status: VpcFirewallRuleStatus,
        #[doc = "list of sets of instances that the rule applies to"]
        pub targets: Vec<VpcFirewallRuleTarget>,
    }

    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum VpcFirewallRuleAction {
        #[serde(rename = "allow")]
        Allow,
        #[serde(rename = "deny")]
        Deny,
    }

    impl ToString for VpcFirewallRuleAction {
        fn to_string(&self) -> String {
            match self {
                VpcFirewallRuleAction::Allow => "allow".to_string(),
                VpcFirewallRuleAction::Deny => "deny".to_string(),
            }
        }
    }

    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum VpcFirewallRuleDirection {
        #[serde(rename = "inbound")]
        Inbound,
        #[serde(rename = "outbound")]
        Outbound,
    }

    impl ToString for VpcFirewallRuleDirection {
        fn to_string(&self) -> String {
            match self {
                VpcFirewallRuleDirection::Inbound => "inbound".to_string(),
                VpcFirewallRuleDirection::Outbound => "outbound".to_string(),
            }
        }
    }

    #[doc = "Filter for a firewall rule. A given packet must match every field that is present for the rule to apply to it. A packet matches a field if any entry in that field matches the packet."]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcFirewallRuleFilter {
        #[doc = "If present, the sources (if incoming) or destinations (if outgoing) this rule applies to."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hosts: Option<Vec<VpcFirewallRuleHostFilter>>,
        #[doc = "If present, the destination ports this rule applies to."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ports: Option<Vec<L4PortRange>>,
        #[doc = "If present, the networking protocols this rule applies to."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub protocols: Option<Vec<VpcFirewallRuleProtocol>>,
    }

    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleHostFilter {
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[serde(rename = "subnet")]
        Subnet(Name),
        #[serde(rename = "instance")]
        Instance(Name),
        #[serde(rename = "ip")]
        Ip(String),
        #[serde(rename = "internetGateway")]
        InternetGateway(Name),
    }

    #[doc = "The protocols that may be specified in a firewall rule's filter"]
    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum VpcFirewallRuleProtocol {
        #[serde(rename = "TCP")]
        Tcp,
        #[serde(rename = "UDP")]
        Udp,
        #[serde(rename = "ICMP")]
        Icmp,
    }

    impl ToString for VpcFirewallRuleProtocol {
        fn to_string(&self) -> String {
            match self {
                VpcFirewallRuleProtocol::Tcp => "TCP".to_string(),
                VpcFirewallRuleProtocol::Udp => "UDP".to_string(),
                VpcFirewallRuleProtocol::Icmp => "ICMP".to_string(),
            }
        }
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcFirewallRuleResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<VpcFirewallRule>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum VpcFirewallRuleStatus {
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "enabled")]
        Enabled,
    }

    impl ToString for VpcFirewallRuleStatus {
        fn to_string(&self) -> String {
            match self {
                VpcFirewallRuleStatus::Disabled => "disabled".to_string(),
                VpcFirewallRuleStatus::Enabled => "enabled".to_string(),
            }
        }
    }

    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleTarget {
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[serde(rename = "subnet")]
        Subnet(Name),
        #[serde(rename = "instance")]
        Instance(Name),
    }

    #[doc = "A single rule in a VPC firewall"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcFirewallRuleUpdate {
        pub action: VpcFirewallRuleAction,
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        pub direction: VpcFirewallRuleDirection,
        pub filters: VpcFirewallRuleFilter,
        #[doc = "the relative priority of this rule"]
        pub priority: u16,
        pub status: VpcFirewallRuleStatus,
        #[doc = "list of sets of instances that the rule applies to"]
        pub targets: Vec<VpcFirewallRuleTarget>,
    }

    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcFirewallRuleUpdateParams(
        pub std::collections::HashMap<String, VpcFirewallRuleUpdate>,
    );
    impl std::ops::Deref for VpcFirewallRuleUpdateParams {
        type Target = std::collections::HashMap<String, VpcFirewallRuleUpdate>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcFirewallRuleUpdateResult(pub std::collections::HashMap<String, VpcFirewallRule>);
    impl std::ops::Deref for VpcFirewallRuleUpdateResult {
        type Target = std::collections::HashMap<String, VpcFirewallRule>;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Vpc>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "A VPC router defines a series of rules that indicate where traffic should be sent depending on its destination."]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcRouter {
        pub identity: IdentityMetadata,
        pub kind: VpcRouterKind,
        #[doc = "The VPC to which the router belongs."]
        pub vpc_id: uuid::Uuid,
    }

    #[doc = "Create-time parameters for a [`VpcRouter`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcRouterCreate {
        pub description: String,
        pub name: Name,
    }

    #[derive(
        Serialize, Deserialize, JsonSchema, Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash,
    )]
    pub enum VpcRouterKind {
        #[serde(rename = "system")]
        System,
        #[serde(rename = "custom")]
        Custom,
    }

    impl ToString for VpcRouterKind {
        fn to_string(&self) -> String {
            match self {
                VpcRouterKind::System => "system".to_string(),
                VpcRouterKind::Custom => "custom".to_string(),
            }
        }
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcRouterResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<VpcRouter>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Updateable properties of a [`VpcRouter`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcRouterUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    #[doc = "A VPC subnet represents a logical grouping for instances that allows network traffic between them, within a IPv4 subnetwork or optionall an IPv6 subnetwork."]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcSubnet {
        pub identity: IdentityMetadata,
        #[serde(
            rename = "ipv4_block",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ipv_4_block: Option<Ipv4Net>,
        #[serde(
            rename = "ipv6_block",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ipv_6_block: Option<Ipv6Net>,
        #[doc = "The VPC to which the subnet belongs."]
        pub vpc_id: uuid::Uuid,
    }

    #[doc = "Create-time parameters for a [`VpcSubnet`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcSubnetCreate {
        pub description: String,
        #[serde(rename = "ipv4Block", default, skip_serializing_if = "Option::is_none")]
        pub ipv_4_block: Option<Ipv4Net>,
        #[serde(rename = "ipv6Block", default, skip_serializing_if = "Option::is_none")]
        pub ipv_6_block: Option<Ipv6Net>,
        pub name: Name,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcSubnetResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<VpcSubnet>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Updateable properties of a [`VpcSubnet`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcSubnetUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(rename = "ipv4Block", default, skip_serializing_if = "Option::is_none")]
        pub ipv_4_block: Option<Ipv4Net>,
        #[serde(rename = "ipv6Block", default, skip_serializing_if = "Option::is_none")]
        pub ipv_6_block: Option<Ipv6Net>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    #[doc = "Updateable properties of a [`Vpc`]"]
    #[derive(Serialize, Deserialize, JsonSchema, Debug, Clone)]
    pub struct VpcUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(rename = "dnsName", default, skip_serializing_if = "Option::is_none")]
        pub dns_name: Option<Name>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }
}

#[derive(Clone)]
pub struct Client {
    baseurl: String,
    client: reqwest::Client,
}

impl Client {
    pub fn new(baseurl: &str) -> Self {
        let dur = std::time::Duration::from_secs(15);
        let client = reqwest::ClientBuilder::new()
            .connect_timeout(dur)
            .timeout(dur)
            .build()
            .unwrap();
        Self::new_with_client(baseurl, client)
    }

    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }

    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }

    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }

    #[doc = "List racks in the system.\n\nhardware_racks_get: GET /hardware/racks"]
    pub async fn hardware_racks_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<types::RackResultsPage> {
        let url = format!("{}/hardware/racks", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List racks in the system.\n\nreturns a Stream<Item = Rack> by making successive calls to hardware_racks_get"]
    pub fn hardware_racks_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Rack>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.hardware_racks_get(limit, None, sort_by)
            .map_ok(move |page| {
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.hardware_racks_get(None, state.as_deref(), None)
                            .map_ok(|page| {
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Fetch information about a particular rack.\n\nhardware_racks_get_rack: GET /hardware/racks/{rack_id}"]
    pub async fn hardware_racks_get_rack<'a>(
        &'a self,
        rack_id: &'a uuid::Uuid,
    ) -> Result<types::Rack> {
        let url = format!(
            "{}/hardware/racks/{}",
            self.baseurl,
            progenitor_support::encode_path(&rack_id.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List sleds in the system.\n\nhardware_sleds_get: GET /hardware/sleds"]
    pub async fn hardware_sleds_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<types::SledResultsPage> {
        let url = format!("{}/hardware/sleds", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List sleds in the system.\n\nreturns a Stream<Item = Sled> by making successive calls to hardware_sleds_get"]
    pub fn hardware_sleds_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Sled>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.hardware_sleds_get(limit, None, sort_by)
            .map_ok(move |page| {
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.hardware_sleds_get(None, state.as_deref(), None)
                            .map_ok(|page| {
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Fetch information about a sled in the system.\n\nhardware_sleds_get_sled: GET /hardware/sleds/{sled_id}"]
    pub async fn hardware_sleds_get_sled<'a>(
        &'a self,
        sled_id: &'a uuid::Uuid,
    ) -> Result<types::Sled> {
        let url = format!(
            "{}/hardware/sleds/{}",
            self.baseurl,
            progenitor_support::encode_path(&sled_id.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "spoof_login: POST /login"]
    pub async fn spoof_login<'a>(
        &'a self,
        body: &'a types::LoginParams,
    ) -> Result<reqwest::Response> {
        let url = format!("{}/login", self.baseurl,);
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "logout: POST /logout"]
    pub async fn logout<'a>(&'a self) -> Result<reqwest::Response> {
        let url = format!("{}/logout", self.baseurl,);
        let request = self.client.post(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "List all organizations.\n\norganizations_get: GET /organizations"]
    pub async fn organizations_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<types::OrganizationResultsPage> {
        let url = format!("{}/organizations", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List all organizations.\n\nreturns a Stream<Item = Organization> by making successive calls to organizations_get"]
    pub fn organizations_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Organization>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.organizations_get(limit, None, sort_by)
            .map_ok(move |page| {
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.organizations_get(None, state.as_deref(), None)
                            .map_ok(|page| {
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Create a new organization.\n\norganizations_post: POST /organizations"]
    pub async fn organizations_post<'a>(
        &'a self,
        body: &'a types::OrganizationCreate,
    ) -> Result<types::Organization> {
        let url = format!("{}/organizations", self.baseurl,);
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Fetch a specific organization\n\norganizations_get_organization: GET /organizations/{organization_name}"]
    pub async fn organizations_get_organization<'a>(
        &'a self,
        organization_name: &'a types::Name,
    ) -> Result<types::Organization> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Update a specific organization.\n * TODO-correctness: Is it valid for PUT to accept application/json that's a subset of what the resource actually represents?  If not, is that a problem? (HTTP may require that this be idempotent.)  If so, can we get around that having this be a slightly different content-type (e.g., \"application/json-patch\")?  We should see what other APIs do.\n\norganizations_put_organization: PUT /organizations/{organization_name}"]
    pub async fn organizations_put_organization<'a>(
        &'a self,
        organization_name: &'a types::Name,
        body: &'a types::OrganizationUpdate,
    ) -> Result<types::Organization> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Delete a specific organization.\n\norganizations_delete_organization: DELETE /organizations/{organization_name}"]
    pub async fn organizations_delete_organization<'a>(
        &'a self,
        organization_name: &'a types::Name,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "List all projects.\n\norganization_projects_get: GET /organizations/{organization_name}/projects"]
    pub async fn organization_projects_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<types::ProjectResultsPage> {
        let url = format!(
            "{}/organizations/{}/projects",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List all projects.\n\nreturns a Stream<Item = Project> by making successive calls to organization_projects_get"]
    pub fn organization_projects_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Project>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.organization_projects_get(organization_name, limit, None, sort_by)
            .map_ok(move |page| {
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.organization_projects_get(
                            organization_name,
                            None,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            Some((
                                futures::stream::iter(page.items.into_iter().map(Ok)),
                                page.next_page,
                            ))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Create a new project.\n\norganization_projects_post: POST /organizations/{organization_name}/projects"]
    pub async fn organization_projects_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        body: &'a types::ProjectCreate,
    ) -> Result<types::Project> {
        let url = format!(
            "{}/organizations/{}/projects",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Fetch a specific project\n\norganization_projects_get_project: GET /organizations/{organization_name}/projects/{project_name}"]
    pub async fn organization_projects_get_project<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
    ) -> Result<types::Project> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Update a specific project.\n * TODO-correctness: Is it valid for PUT to accept application/json that's a subset of what the resource actually represents?  If not, is that a problem? (HTTP may require that this be idempotent.)  If so, can we get around that having this be a slightly different content-type (e.g., \"application/json-patch\")?  We should see what other APIs do.\n\norganization_projects_put_project: PUT /organizations/{organization_name}/projects/{project_name}"]
    pub async fn organization_projects_put_project<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::ProjectUpdate,
    ) -> Result<types::Project> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Delete a specific project.\n\norganization_projects_delete_project: DELETE /organizations/{organization_name}/projects/{project_name}"]
    pub async fn organization_projects_delete_project<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "List disks in a project.\n\nproject_disks_get: GET /organizations/{organization_name}/projects/{project_name}/disks"]
    pub async fn project_disks_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<types::DiskResultsPage> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List disks in a project.\n\nreturns a Stream<Item = Disk> by making successive calls to project_disks_get"]
    pub fn project_disks_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.project_disks_get(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.project_disks_get(
                            organization_name,
                            project_name,
                            None,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            Some((
                                futures::stream::iter(page.items.into_iter().map(Ok)),
                                page.next_page,
                            ))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Create a disk in a project.\n * TODO-correctness See note about instance create.  This should be async.\n\nproject_disks_post: POST /organizations/{organization_name}/projects/{project_name}/disks"]
    pub async fn project_disks_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::DiskCreate,
    ) -> Result<types::Disk> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Fetch a single disk in a project.\n\nproject_disks_get_disk: GET /organizations/{organization_name}/projects/{project_name}/disks/{disk_name}"]
    pub async fn project_disks_get_disk<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
    ) -> Result<types::Disk> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&disk_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Delete a disk from a project.\n\nproject_disks_delete_disk: DELETE /organizations/{organization_name}/projects/{project_name}/disks/{disk_name}"]
    pub async fn project_disks_delete_disk<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&disk_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "List instances in a project.\n\nproject_instances_get: GET /organizations/{organization_name}/projects/{project_name}/instances"]
    pub async fn project_instances_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<types::InstanceResultsPage> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List instances in a project.\n\nreturns a Stream<Item = Instance> by making successive calls to project_instances_get"]
    pub fn project_instances_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Instance>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.project_instances_get(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.project_instances_get(
                            organization_name,
                            project_name,
                            None,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            Some((
                                futures::stream::iter(page.items.into_iter().map(Ok)),
                                page.next_page,
                            ))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Create an instance in a project.\n * TODO-correctness This is supposed to be async.  Is that right?  We can create the instance immediately -- it's just not booted yet.  Maybe the boot operation is what's a separate operation_id.  What about the response code (201 Created vs 202 Accepted)?  Is that orthogonal?  Things can return a useful response, including an operation id, with either response code.  Maybe a \"reboot\" operation would return a 202 Accepted because there's no actual resource created?\n\nproject_instances_post: POST /organizations/{organization_name}/projects/{project_name}/instances"]
    pub async fn project_instances_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::InstanceCreate,
    ) -> Result<types::Instance> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Get an instance in a project.\n\nproject_instances_get_instance: GET /organizations/{organization_name}/projects/{project_name}/instances/{instance_name}"]
    pub async fn project_instances_get_instance<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<types::Instance> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&instance_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Delete an instance from a project.\n\nproject_instances_delete_instance: DELETE /organizations/{organization_name}/projects/{project_name}/instances/{instance_name}"]
    pub async fn project_instances_delete_instance<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&instance_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "List disks attached to this instance.\n\ninstance_disks_get: GET /organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks"]
    pub async fn instance_disks_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<types::DiskResultsPage> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&instance_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List disks attached to this instance.\n\nreturns a Stream<Item = Disk> by making successive calls to instance_disks_get"]
    pub fn instance_disks_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_disks_get(
            organization_name,
            project_name,
            instance_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.instance_disks_get(
                        organization_name,
                        project_name,
                        instance_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "instance_disks_attach: POST /organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks/attach"]
    pub async fn instance_disks_attach<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::DiskIdentifier,
    ) -> Result<types::Disk> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks/attach",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "instance_disks_detach: POST /organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks/detach"]
    pub async fn instance_disks_detach<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::DiskIdentifier,
    ) -> Result<types::Disk> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks/detach",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Reboot an instance.\n\nproject_instances_instance_reboot: POST /organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/reboot"]
    pub async fn project_instances_instance_reboot<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<types::Instance> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/reboot",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Boot an instance.\n\nproject_instances_instance_start: POST /organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/start"]
    pub async fn project_instances_instance_start<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<types::Instance> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/start",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Halt an instance.\n\nproject_instances_instance_stop: POST /organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/stop"]
    pub async fn project_instances_instance_stop<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<types::Instance> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/stop",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List VPCs in a project.\n\nproject_vpcs_get: GET /organizations/{organization_name}/projects/{project_name}/vpcs"]
    pub async fn project_vpcs_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<types::VpcResultsPage> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List VPCs in a project.\n\nreturns a Stream<Item = Vpc> by making successive calls to project_vpcs_get"]
    pub fn project_vpcs_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Vpc>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.project_vpcs_get(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.project_vpcs_get(
                            organization_name,
                            project_name,
                            None,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            Some((
                                futures::stream::iter(page.items.into_iter().map(Ok)),
                                page.next_page,
                            ))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Create a VPC in a project.\n\nproject_vpcs_post: POST /organizations/{organization_name}/projects/{project_name}/vpcs"]
    pub async fn project_vpcs_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::VpcCreate,
    ) -> Result<types::Vpc> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Get a VPC in a project.\n\nproject_vpcs_get_vpc: GET /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}"]
    pub async fn project_vpcs_get_vpc<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
    ) -> Result<types::Vpc> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Update a VPC.\n\nproject_vpcs_put_vpc: PUT /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}"]
    pub async fn project_vpcs_put_vpc<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcUpdate,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "Delete a vpc from a project.\n\nproject_vpcs_delete_vpc: DELETE /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}"]
    pub async fn project_vpcs_delete_vpc<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "List firewall rules for a VPC.\n\nvpc_firewall_rules_get: GET /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/firewall/rules"]
    pub async fn vpc_firewall_rules_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<types::VpcFirewallRuleResultsPage> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List firewall rules for a VPC.\n\nreturns a Stream<Item = VpcFirewallRule> by making successive calls to vpc_firewall_rules_get"]
    pub fn vpc_firewall_rules_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::VpcFirewallRule>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_firewall_rules_get(
            organization_name,
            project_name,
            vpc_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_firewall_rules_get(
                        organization_name,
                        project_name,
                        vpc_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "Replace the firewall rules for a VPC\n\nvpc_firewall_rules_put: PUT /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/firewall/rules"]
    pub async fn vpc_firewall_rules_put<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcFirewallRuleUpdateParams,
    ) -> Result<types::VpcFirewallRuleUpdateResult> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List VPC Custom and System Routers\n\nvpc_routers_get: GET /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers"]
    pub async fn vpc_routers_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<types::VpcRouterResultsPage> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List VPC Custom and System Routers\n\nreturns a Stream<Item = VpcRouter> by making successive calls to vpc_routers_get"]
    pub fn vpc_routers_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::VpcRouter>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_routers_get(
            organization_name,
            project_name,
            vpc_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_routers_get(
                        organization_name,
                        project_name,
                        vpc_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "Create a VPC Router\n\nvpc_routers_post: POST /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers"]
    pub async fn vpc_routers_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcRouterCreate,
    ) -> Result<types::VpcRouter> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Get a VPC Router\n\nvpc_routers_get_router: GET /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}"]
    pub async fn vpc_routers_get_router<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
    ) -> Result<types::VpcRouter> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&router_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Update a VPC Router\n\nvpc_routers_put_router: PUT /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}"]
    pub async fn vpc_routers_put_router<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        body: &'a types::VpcRouterUpdate,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&router_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "Delete a router from its VPC\n\nvpc_routers_delete_router: DELETE /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}"]
    pub async fn vpc_routers_delete_router<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&router_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "List a Router's routes\n\nrouters_routes_get: GET /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes"]
    pub async fn routers_routes_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<types::RouterRouteResultsPage> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&router_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List a Router's routes\n\nreturns a Stream<Item = RouterRoute> by making successive calls to routers_routes_get"]
    pub fn routers_routes_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::RouterRoute>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.routers_routes_get(
            organization_name,
            project_name,
            vpc_name,
            router_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.routers_routes_get(
                        organization_name,
                        project_name,
                        vpc_name,
                        router_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "Create a VPC Router\n\nrouters_routes_post: POST /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes"]
    pub async fn routers_routes_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        body: &'a types::RouterRouteCreateParams,
    ) -> Result<types::RouterRoute> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&router_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Get a VPC Router route\n\nrouters_routes_get_route: GET /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}"]
    pub async fn routers_routes_get_route<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
    ) -> Result<types::RouterRoute> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&router_name.to_string()),
            progenitor_support::encode_path(&route_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Update a Router route\n\nrouters_routes_put_route: PUT /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}"]
    pub async fn routers_routes_put_route<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
        body: &'a types::RouterRouteUpdateParams,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&router_name.to_string()),
            progenitor_support::encode_path(&route_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "Delete a route from its router\n\nrouters_routes_delete_route: DELETE /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}"]
    pub async fn routers_routes_delete_route<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&router_name.to_string()),
            progenitor_support::encode_path(&route_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "List subnets in a VPC.\n\nvpc_subnets_get: GET /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets"]
    pub async fn vpc_subnets_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<types::VpcSubnetResultsPage> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List subnets in a VPC.\n\nreturns a Stream<Item = VpcSubnet> by making successive calls to vpc_subnets_get"]
    pub fn vpc_subnets_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::VpcSubnet>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_subnets_get(
            organization_name,
            project_name,
            vpc_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_subnets_get(
                        organization_name,
                        project_name,
                        vpc_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "Create a subnet in a VPC.\n\nvpc_subnets_post: POST /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets"]
    pub async fn vpc_subnets_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcSubnetCreate,
    ) -> Result<types::VpcSubnet> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Get subnet in a VPC.\n\nvpc_subnets_get_subnet: GET /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}"]
    pub async fn vpc_subnets_get_subnet<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
    ) -> Result<types::VpcSubnet> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&subnet_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "Update a VPC Subnet.\n\nvpc_subnets_put_subnet: PUT /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}"]
    pub async fn vpc_subnets_put_subnet<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        body: &'a types::VpcSubnetUpdate,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&subnet_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "Delete a subnet from a VPC.\n\nvpc_subnets_delete_subnet: DELETE /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}"]
    pub async fn vpc_subnets_delete_subnet<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
    ) -> Result<reqwest::Response> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&subnet_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res)
    }

    #[doc = "List IP addresses on a VPC subnet.\n\nsubnets_ips_get: GET /organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}/ips"]
    pub async fn subnets_ips_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<types::NetworkInterfaceResultsPage> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}/ips",
            self.baseurl,
            progenitor_support::encode_path(&organization_name.to_string()),
            progenitor_support::encode_path(&project_name.to_string()),
            progenitor_support::encode_path(&vpc_name.to_string()),
            progenitor_support::encode_path(&subnet_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List IP addresses on a VPC subnet.\n\nreturns a Stream<Item = NetworkInterface> by making successive calls to subnets_ips_get"]
    pub fn subnets_ips_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::NetworkInterface>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.subnets_ips_get(
            organization_name,
            project_name,
            vpc_name,
            subnet_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.subnets_ips_get(
                        organization_name,
                        project_name,
                        vpc_name,
                        subnet_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "List the built-in roles\n\nroles_get: GET /roles"]
    pub async fn roles_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<types::RoleResultsPage> {
        let url = format!("{}/roles", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List the built-in roles\n\nreturns a Stream<Item = Role> by making successive calls to roles_get"]
    pub fn roles_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
    ) -> impl futures::Stream<Item = Result<types::Role>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.roles_get(limit, None)
            .map_ok(move |page| {
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.roles_get(None, state.as_deref())
                            .map_ok(|page| {
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Fetch a specific built-in role\n\nroles_get_role: GET /roles/{role_name}"]
    pub async fn roles_get_role<'a>(&'a self, role_name: &'a str) -> Result<types::Role> {
        let url = format!(
            "{}/roles/{}",
            self.baseurl,
            progenitor_support::encode_path(&role_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List all sagas (for debugging)\n\nsagas_get: GET /sagas"]
    pub async fn sagas_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<types::SagaResultsPage> {
        let url = format!("{}/sagas", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List all sagas (for debugging)\n\nreturns a Stream<Item = Saga> by making successive calls to sagas_get"]
    pub fn sagas_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Saga>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.sagas_get(limit, None, sort_by)
            .map_ok(move |page| {
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.sagas_get(None, state.as_deref(), None)
                            .map_ok(|page| {
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Fetch information about a single saga (for debugging)\n\nsagas_get_saga: GET /sagas/{saga_id}"]
    pub async fn sagas_get_saga<'a>(&'a self, saga_id: &'a uuid::Uuid) -> Result<types::Saga> {
        let url = format!(
            "{}/sagas/{}",
            self.baseurl,
            progenitor_support::encode_path(&saga_id.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List all timeseries schema\n\ntimeseries_schema_get: GET /timeseries/schema"]
    pub async fn timeseries_schema_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<types::TimeseriesSchemaResultsPage> {
        let url = format!("{}/timeseries/schema", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List all timeseries schema\n\nreturns a Stream<Item = TimeseriesSchema> by making successive calls to timeseries_schema_get"]
    pub fn timeseries_schema_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
    ) -> impl futures::Stream<Item = Result<types::TimeseriesSchema>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.timeseries_schema_get(limit, None)
            .map_ok(move |page| {
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.timeseries_schema_get(None, state.as_deref())
                            .map_ok(|page| {
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "List the built-in system users\n\nusers_get: GET /users"]
    pub async fn users_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<types::UserResultsPage> {
        let url = format!("{}/users", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }

    #[doc = "List the built-in system users\n\nreturns a Stream<Item = User> by making successive calls to users_get"]
    pub fn users_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::User>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.users_get(limit, None, sort_by)
            .map_ok(move |page| {
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.users_get(None, state.as_deref(), None)
                            .map_ok(|page| {
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Fetch a specific built-in system user\n\nusers_get_user: GET /users/{user_name}"]
    pub async fn users_get_user<'a>(&'a self, user_name: &'a types::Name) -> Result<types::User> {
        let url = format!(
            "{}/users/{}",
            self.baseurl,
            progenitor_support::encode_path(&user_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let res = result?.error_for_status()?;
        Ok(res.json().await?)
    }
}
