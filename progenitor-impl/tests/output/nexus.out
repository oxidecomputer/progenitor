pub use progenitor_client::{ByteStream, Error, ResponseValue};
pub mod types {
    use serde::{Deserialize, Serialize};
    #[doc = "A count of bytes, typically used either for memory or storage capacity\n\nThe maximum supported byte count is [`i64::MAX`].  This makes it somewhat inconvenient to define constructors: a u32 constructor can be infallible, but an i64 constructor can fail (if the value is negative) and a u64 constructor can fail (if the value is larger than i64::MAX).  We provide all of these for consumers' convenience."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ByteCount(pub u64);
    impl std::ops::Deref for ByteCount {
        type Target = u64;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "The type of an individual datum of a metric."]
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum DatumType {
        Bool,
        I64,
        F64,
        String,
        Bytes,
        CumulativeI64,
        CumulativeF64,
        HistogramI64,
        HistogramF64,
    }

    impl ToString for DatumType {
        fn to_string(&self) -> String {
            match *self {
                DatumType::Bool => "Bool".to_string(),
                DatumType::I64 => "I64".to_string(),
                DatumType::F64 => "F64".to_string(),
                DatumType::String => "String".to_string(),
                DatumType::Bytes => "Bytes".to_string(),
                DatumType::CumulativeI64 => "CumulativeI64".to_string(),
                DatumType::CumulativeF64 => "CumulativeF64".to_string(),
                DatumType::HistogramI64 => "HistogramI64".to_string(),
                DatumType::HistogramF64 => "HistogramF64".to_string(),
            }
        }
    }

    #[doc = "Client view of an [`Disk`]"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Disk {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        pub device_path: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        pub project_id: uuid::Uuid,
        pub size: ByteCount,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snapshot_id: Option<uuid::Uuid>,
        pub state: DiskState,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "Create-time parameters for a [`Disk`](omicron_common::api::external::Disk)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct DiskCreate {
        pub description: String,
        pub name: Name,
        #[doc = "size of the Disk"]
        pub size: ByteCount,
        #[doc = "id for snapshot from which the Disk should be created, if any"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snapshot_id: Option<uuid::Uuid>,
    }

    #[doc = "Parameters for the [`Disk`](omicron_common::api::external::Disk) to be attached or detached to an instance"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct DiskIdentifier {
        pub disk: Name,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct DiskResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Disk>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "State of a Disk (primarily: attached or not)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "state", content = "instance")]
    pub enum DiskState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "detached")]
        Detached,
        #[doc = "Disk is being attached to the given Instance"]
        #[serde(rename = "attaching")]
        Attaching(uuid::Uuid),
        #[doc = "Disk is attached to the given Instance"]
        #[serde(rename = "attached")]
        Attached(uuid::Uuid),
        #[doc = "Disk is being detached from the given Instance"]
        #[serde(rename = "detaching")]
        Detaching(uuid::Uuid),
        #[serde(rename = "destroyed")]
        Destroyed,
        #[serde(rename = "faulted")]
        Faulted,
    }

    #[doc = "Error information from a response."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Error {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_code: Option<String>,
        pub message: String,
        pub request_id: String,
    }

    #[doc = "The name and type information for a field of a timeseries schema."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct FieldSchema {
        pub name: String,
        pub source: FieldSource,
        pub ty: FieldType,
    }

    #[doc = "The source from which a field is derived, the target or metric."]
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum FieldSource {
        Target,
        Metric,
    }

    impl ToString for FieldSource {
        fn to_string(&self) -> String {
            match *self {
                FieldSource::Target => "Target".to_string(),
                FieldSource::Metric => "Metric".to_string(),
            }
        }
    }

    #[doc = "The `FieldType` identifies the data type of a target or metric field."]
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum FieldType {
        String,
        I64,
        IpAddr,
        Uuid,
        Bool,
    }

    impl ToString for FieldType {
        fn to_string(&self) -> String {
            match *self {
                FieldType::String => "String".to_string(),
                FieldType::I64 => "I64".to_string(),
                FieldType::IpAddr => "IpAddr".to_string(),
                FieldType::Uuid => "Uuid".to_string(),
                FieldType::Bool => "Bool".to_string(),
            }
        }
    }

    #[doc = "Supported set of sort modes for scanning by id only.\n\nCurrently, we only support scanning in ascending order."]
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum IdSortMode {
        #[serde(rename = "id-ascending")]
        IdAscending,
    }

    impl ToString for IdSortMode {
        fn to_string(&self) -> String {
            match *self {
                IdSortMode::IdAscending => "id-ascending".to_string(),
            }
        }
    }

    #[doc = "Client view of an [`Instance`]"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Instance {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "RFC1035-compliant hostname for the Instance."]
        pub hostname: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "memory allocated for this Instance"]
        pub memory: ByteCount,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "number of CPUs allocated for this Instance"]
        pub ncpus: InstanceCpuCount,
        #[doc = "id for the project containing this Instance"]
        pub project_id: uuid::Uuid,
        pub run_state: InstanceState,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub time_run_state_updated: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "The number of CPUs in an Instance"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct InstanceCpuCount(pub u16);
    impl std::ops::Deref for InstanceCpuCount {
        type Target = u16;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "Create-time parameters for an [`Instance`](omicron_common::api::external::Instance)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct InstanceCreate {
        pub description: String,
        pub hostname: String,
        pub memory: ByteCount,
        pub name: Name,
        pub ncpus: InstanceCpuCount,
        #[doc = "The network interfaces to be created for this instance."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub network_interfaces: Option<InstanceNetworkInterfaceAttachment>,
    }

    #[doc = "Migration parameters for an [`Instance`](omicron_common::api::external::Instance)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct InstanceMigrate {
        pub dst_sled_uuid: uuid::Uuid,
    }

    #[doc = "Describes an attachment of a `NetworkInterface` to an `Instance`, at the time the instance is created."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type", content = "params")]
    pub enum InstanceNetworkInterfaceAttachment {
        #[doc = "Create one or more `NetworkInterface`s for the `Instance`"]
        Create(InstanceNetworkInterfaceCreate),
        Default,
        None,
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct InstanceNetworkInterfaceCreate {
        pub params: Vec<NetworkInterfaceCreate>,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct InstanceResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Instance>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Running state of an Instance (primarily: booted or stopped)\n\nThis typically reflects whether it's starting, running, stopping, or stopped, but also includes states related to the Instance's lifecycle"]
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum InstanceState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "starting")]
        Starting,
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "stopping")]
        Stopping,
        #[serde(rename = "stopped")]
        Stopped,
        #[serde(rename = "rebooting")]
        Rebooting,
        #[serde(rename = "migrating")]
        Migrating,
        #[serde(rename = "repairing")]
        Repairing,
        #[serde(rename = "failed")]
        Failed,
        #[serde(rename = "destroyed")]
        Destroyed,
    }

    impl ToString for InstanceState {
        fn to_string(&self) -> String {
            match *self {
                InstanceState::Creating => "creating".to_string(),
                InstanceState::Starting => "starting".to_string(),
                InstanceState::Running => "running".to_string(),
                InstanceState::Stopping => "stopping".to_string(),
                InstanceState::Stopped => "stopped".to_string(),
                InstanceState::Rebooting => "rebooting".to_string(),
                InstanceState::Migrating => "migrating".to_string(),
                InstanceState::Repairing => "repairing".to_string(),
                InstanceState::Failed => "failed".to_string(),
                InstanceState::Destroyed => "destroyed".to_string(),
            }
        }
    }

    #[doc = "An `IpNet` represents an IP network, either IPv4 or IPv6."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub enum IpNet {
        V4(Ipv4Net),
        V6(Ipv6Net),
    }

    #[doc = "An IPv4 subnet, including prefix and subnet mask"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Ipv4Net(pub String);
    impl std::ops::Deref for Ipv4Net {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "An IPv6 subnet, including prefix and subnet mask"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Ipv6Net(pub String);
    impl std::ops::Deref for Ipv6Net {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "An inclusive-inclusive range of IP ports. The second port may be omitted to represent a single port"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct L4PortRange(pub String);
    impl std::ops::Deref for L4PortRange {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct LoginParams {
        pub username: String,
    }

    #[doc = "A Media Access Control address, in EUI-48 format"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct MacAddr(pub String);
    impl std::ops::Deref for MacAddr {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Name(pub String);
    impl std::ops::Deref for Name {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "Supported set of sort modes for scanning by name or id"]
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum NameOrIdSortMode {
        #[serde(rename = "name-ascending")]
        NameAscending,
        #[serde(rename = "name-descending")]
        NameDescending,
        #[serde(rename = "id-ascending")]
        IdAscending,
    }

    impl ToString for NameOrIdSortMode {
        fn to_string(&self) -> String {
            match *self {
                NameOrIdSortMode::NameAscending => "name-ascending".to_string(),
                NameOrIdSortMode::NameDescending => "name-descending".to_string(),
                NameOrIdSortMode::IdAscending => "id-ascending".to_string(),
            }
        }
    }

    #[doc = "Supported set of sort modes for scanning by name only\n\nCurrently, we only support scanning in ascending order."]
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum NameSortMode {
        #[serde(rename = "name-ascending")]
        NameAscending,
    }

    impl ToString for NameSortMode {
        fn to_string(&self) -> String {
            match *self {
                NameSortMode::NameAscending => "name-ascending".to_string(),
            }
        }
    }

    #[doc = "A `NetworkInterface` represents a virtual network interface device."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct NetworkInterface {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "The Instance to which the interface belongs."]
        pub instance_id: uuid::Uuid,
        #[doc = "The IP address assigned to this interface."]
        pub ip: String,
        #[doc = "The MAC address assigned to this interface."]
        pub mac: MacAddr,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "The subnet to which the interface belongs."]
        pub subnet_id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "The VPC to which the interface belongs."]
        pub vpc_id: uuid::Uuid,
    }

    #[doc = "Create-time parameters for a [`NetworkInterface`](omicron_common::api::external::NetworkInterface)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct NetworkInterfaceCreate {
        pub description: String,
        #[doc = "The IP address for the interface. One will be auto-assigned if not provided."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ip: Option<String>,
        pub name: Name,
        #[doc = "The VPC Subnet in which to create the interface."]
        pub subnet_name: Name,
        #[doc = "The VPC in which to create the interface."]
        pub vpc_name: Name,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct NetworkInterfaceResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<NetworkInterface>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Client view of an [`Organization`]"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Organization {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "Create-time parameters for an [`Organization`](crate::external_api::views::Organization)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct OrganizationCreate {
        pub description: String,
        pub name: Name,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct OrganizationResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Organization>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Updateable properties of an [`Organization`](crate::external_api::views::Organization)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct OrganizationUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    #[doc = "Client view of a [`Project`]"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Project {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        pub organization_id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "Create-time parameters for a [`Project`](crate::external_api::views::Project)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ProjectCreate {
        pub description: String,
        pub name: Name,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ProjectResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Project>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Updateable properties of a [`Project`](crate::external_api::views::Project)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ProjectUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    #[doc = "Client view of an [`Rack`]"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Rack {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RackResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Rack>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Client view of a [`Role`]"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Role {
        pub description: String,
        pub name: RoleName,
    }

    #[doc = "Role names consist of two string components separated by dot (\".\")."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RoleName(pub String);
    impl std::ops::Deref for RoleName {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RoleResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Role>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "A `RouteDestination` is used to match traffic with a routing rule, on the destination of that traffic.\n\nWhen traffic is to be sent to a destination that is within a given `RouteDestination`, the corresponding [`RouterRoute`] applies, and traffic will be forward to the [`RouteTarget`] for that rule."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteDestination {
        #[doc = "Route applies to traffic destined for a specific IP address"]
        #[serde(rename = "ip")]
        Ip(String),
        #[doc = "Route applies to traffic destined for a specific IP subnet"]
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
        #[doc = "Route applies to traffic destined for the given VPC."]
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[doc = "Route applies to traffic"]
        #[serde(rename = "subnet")]
        Subnet(Name),
    }

    #[doc = "A `RouteTarget` describes the possible locations that traffic matching a route destination can be sent."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteTarget {
        #[doc = "Forward traffic to a particular IP address."]
        #[serde(rename = "ip")]
        Ip(String),
        #[doc = "Forward traffic to a VPC"]
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[doc = "Forward traffic to a VPC Subnet"]
        #[serde(rename = "subnet")]
        Subnet(Name),
        #[doc = "Forward traffic to a specific instance"]
        #[serde(rename = "instance")]
        Instance(Name),
        #[doc = "Forward traffic to an internet gateway"]
        #[serde(rename = "internet_gateway")]
        InternetGateway(Name),
    }

    #[doc = "A route defines a rule that governs where traffic should be sent based on its destination."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RouterRoute {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        pub destination: RouteDestination,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "Describes the kind of router. Set at creation. `read-only`"]
        pub kind: RouterRouteKind,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "The VPC Router to which the route belongs."]
        pub router_id: uuid::Uuid,
        pub target: RouteTarget,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "Create-time parameters for a [`RouterRoute`]"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RouterRouteCreateParams {
        pub description: String,
        pub destination: RouteDestination,
        pub name: Name,
        pub target: RouteTarget,
    }

    #[doc = "The classification of a [`RouterRoute`] as defined by the system. The kind determines certain attributes such as if the route is modifiable and describes how or where the route was created.\n\nSee [RFD-21](https://rfd.shared.oxide.computer/rfd/0021#concept-router) for more context"]
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum RouterRouteKind {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "vpc_subnet")]
        VpcSubnet,
        #[serde(rename = "vpc_peering")]
        VpcPeering,
        #[serde(rename = "custom")]
        Custom,
    }

    impl ToString for RouterRouteKind {
        fn to_string(&self) -> String {
            match *self {
                RouterRouteKind::Default => "default".to_string(),
                RouterRouteKind::VpcSubnet => "vpc_subnet".to_string(),
                RouterRouteKind::VpcPeering => "vpc_peering".to_string(),
                RouterRouteKind::Custom => "custom".to_string(),
            }
        }
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RouterRouteResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<RouterRoute>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Updateable properties of a [`RouterRoute`]"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RouterRouteUpdateParams {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        pub destination: RouteDestination,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
        pub target: RouteTarget,
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Saga {
        pub id: uuid::Uuid,
        pub state: SagaState,
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "error")]
    pub enum SagaErrorInfo {
        #[serde(rename = "action_failed")]
        ActionFailed { source_error: serde_json::Value },
        #[serde(rename = "deserialize_failed")]
        DeserializeFailed { message: String },
        #[serde(rename = "injected_error")]
        InjectedError,
        #[serde(rename = "serialize_failed")]
        SerializeFailed { message: String },
        #[serde(rename = "subsaga_create_failed")]
        SubsagaCreateFailed { message: String },
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SagaResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Saga>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "state")]
    pub enum SagaState {
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "succeeded")]
        Succeeded,
        #[serde(rename = "failed")]
        Failed {
            error_info: SagaErrorInfo,
            error_node_name: String,
        },
    }

    #[doc = "Client view of currently authed user."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SessionUser {
        pub id: uuid::Uuid,
    }

    #[doc = "Client view of an [`Sled`]"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Sled {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        pub service_address: String,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SledResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Sled>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Client view of a Snapshot"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Snapshot {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        pub disk_id: uuid::Uuid,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        pub project_id: uuid::Uuid,
        pub size: ByteCount,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "Create-time parameters for a [`Snapshot`](omicron_common::api::external::Snapshot)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SnapshotCreate {
        pub description: String,
        #[doc = "The name of the disk to be snapshotted"]
        pub disk: Name,
        pub name: Name,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SnapshotResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Snapshot>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Names are constructed by concatenating the target and metric names with ':'. Target and metric names must be lowercase alphanumeric characters with '_' separating words."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct TimeseriesName(pub String);
    impl std::ops::Deref for TimeseriesName {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[doc = "The schema for a timeseries.\n\nThis includes the name of the timeseries, as well as the datum type of its metric and the schema for each field."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct TimeseriesSchema {
        pub created: chrono::DateTime<chrono::offset::Utc>,
        pub datum_type: DatumType,
        pub field_schema: Vec<FieldSchema>,
        pub timeseries_name: TimeseriesName,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct TimeseriesSchemaResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<TimeseriesSchema>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Client view of a [`User`]"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct User {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct UserResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<User>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Client view of a [`Vpc`]"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Vpc {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "The name used for the VPC in DNS."]
        pub dns_name: Name,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "The unique local IPv6 address range for subnets in this VPC"]
        pub ipv6_prefix: Ipv6Net,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "id for the project containing this VPC"]
        pub project_id: uuid::Uuid,
        #[doc = "id for the system router where subnet default routes are registered"]
        pub system_router_id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    #[doc = "Create-time parameters for a [`Vpc`](crate::external_api::views::Vpc)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcCreate {
        pub description: String,
        pub dns_name: Name,
        #[doc = "The IPv6 prefix for this VPC.\n\nAll IPv6 subnets created from this VPC must be taken from this range, which sould be a Unique Local Address in the range `fd00::/48`. The default VPC Subnet will have the first `/64` range from this prefix."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ipv6_prefix: Option<Ipv6Net>,
        pub name: Name,
    }

    #[doc = "A single rule in a VPC firewall"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcFirewallRule {
        #[doc = "whether traffic matching the rule should be allowed or dropped"]
        pub action: VpcFirewallRuleAction,
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "whether this rule is for incoming or outgoing traffic"]
        pub direction: VpcFirewallRuleDirection,
        #[doc = "reductions on the scope of the rule"]
        pub filters: VpcFirewallRuleFilter,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "the relative priority of this rule"]
        pub priority: u16,
        #[doc = "whether this rule is in effect"]
        pub status: VpcFirewallRuleStatus,
        #[doc = "list of sets of instances that the rule applies to"]
        pub targets: Vec<VpcFirewallRuleTarget>,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "the VPC to which this rule belongs"]
        pub vpc_id: uuid::Uuid,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum VpcFirewallRuleAction {
        #[serde(rename = "allow")]
        Allow,
        #[serde(rename = "deny")]
        Deny,
    }

    impl ToString for VpcFirewallRuleAction {
        fn to_string(&self) -> String {
            match *self {
                VpcFirewallRuleAction::Allow => "allow".to_string(),
                VpcFirewallRuleAction::Deny => "deny".to_string(),
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum VpcFirewallRuleDirection {
        #[serde(rename = "inbound")]
        Inbound,
        #[serde(rename = "outbound")]
        Outbound,
    }

    impl ToString for VpcFirewallRuleDirection {
        fn to_string(&self) -> String {
            match *self {
                VpcFirewallRuleDirection::Inbound => "inbound".to_string(),
                VpcFirewallRuleDirection::Outbound => "outbound".to_string(),
            }
        }
    }

    #[doc = "Filter for a firewall rule. A given packet must match every field that is present for the rule to apply to it. A packet matches a field if any entry in that field matches the packet."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcFirewallRuleFilter {
        #[doc = "If present, the sources (if incoming) or destinations (if outgoing) this rule applies to."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hosts: Option<Vec<VpcFirewallRuleHostFilter>>,
        #[doc = "If present, the destination ports this rule applies to."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ports: Option<Vec<L4PortRange>>,
        #[doc = "If present, the networking protocols this rule applies to."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub protocols: Option<Vec<VpcFirewallRuleProtocol>>,
    }

    #[doc = "The `VpcFirewallRuleHostFilter` is used to filter traffic on the basis of its source or destination host."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleHostFilter {
        #[doc = "The rule applies to traffic from/to all instances in the VPC"]
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[doc = "The rule applies to traffic from/to all instances in the VPC Subnet"]
        #[serde(rename = "subnet")]
        Subnet(Name),
        #[doc = "The rule applies to traffic from/to this specific instance"]
        #[serde(rename = "instance")]
        Instance(Name),
        #[doc = "The rule applies to traffic from/to a specific IP address"]
        #[serde(rename = "ip")]
        Ip(String),
        #[doc = "The rule applies to traffic from/to a specific IP subnet"]
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    #[doc = "The protocols that may be specified in a firewall rule's filter"]
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum VpcFirewallRuleProtocol {
        #[serde(rename = "TCP")]
        Tcp,
        #[serde(rename = "UDP")]
        Udp,
        #[serde(rename = "ICMP")]
        Icmp,
    }

    impl ToString for VpcFirewallRuleProtocol {
        fn to_string(&self) -> String {
            match *self {
                VpcFirewallRuleProtocol::Tcp => "TCP".to_string(),
                VpcFirewallRuleProtocol::Udp => "UDP".to_string(),
                VpcFirewallRuleProtocol::Icmp => "ICMP".to_string(),
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum VpcFirewallRuleStatus {
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "enabled")]
        Enabled,
    }

    impl ToString for VpcFirewallRuleStatus {
        fn to_string(&self) -> String {
            match *self {
                VpcFirewallRuleStatus::Disabled => "disabled".to_string(),
                VpcFirewallRuleStatus::Enabled => "enabled".to_string(),
            }
        }
    }

    #[doc = "A `VpcFirewallRuleTarget` is used to specify the set of [`Instance`]s to which a firewall rule applies."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleTarget {
        #[doc = "The rule applies to all instances in the VPC"]
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[doc = "The rule applies to all instances in the VPC Subnet"]
        #[serde(rename = "subnet")]
        Subnet(Name),
        #[doc = "The rule applies to this specific instance"]
        #[serde(rename = "instance")]
        Instance(Name),
        #[doc = "The rule applies to a specific IP address"]
        #[serde(rename = "ip")]
        Ip(String),
        #[doc = "The rule applies to a specific IP subnet"]
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    #[doc = "A single rule in a VPC firewall"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcFirewallRuleUpdate {
        #[doc = "whether traffic matching the rule should be allowed or dropped"]
        pub action: VpcFirewallRuleAction,
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "whether this rule is for incoming or outgoing traffic"]
        pub direction: VpcFirewallRuleDirection,
        #[doc = "reductions on the scope of the rule"]
        pub filters: VpcFirewallRuleFilter,
        #[doc = "name of the rule, unique to this VPC"]
        pub name: Name,
        #[doc = "the relative priority of this rule"]
        pub priority: u16,
        #[doc = "whether this rule is in effect"]
        pub status: VpcFirewallRuleStatus,
        #[doc = "list of sets of instances that the rule applies to"]
        pub targets: Vec<VpcFirewallRuleTarget>,
    }

    #[doc = "Updateable properties of a `Vpc`'s firewall Note that VpcFirewallRules are implicitly created along with a Vpc, so there is no explicit creation."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcFirewallRuleUpdateParams {
        pub rules: Vec<VpcFirewallRuleUpdate>,
    }

    #[doc = "Collection of a [`Vpc`]'s firewall rules"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcFirewallRules {
        pub rules: Vec<VpcFirewallRule>,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Vpc>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "A VPC router defines a series of rules that indicate where traffic should be sent depending on its destination."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcRouter {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub kind: VpcRouterKind,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "The VPC to which the router belongs."]
        pub vpc_id: uuid::Uuid,
    }

    #[doc = "Create-time parameters for a [`VpcRouter`](crate::external_api::views::VpcRouter)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcRouterCreate {
        pub description: String,
        pub name: Name,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum VpcRouterKind {
        #[serde(rename = "system")]
        System,
        #[serde(rename = "custom")]
        Custom,
    }

    impl ToString for VpcRouterKind {
        fn to_string(&self) -> String {
            match *self {
                VpcRouterKind::System => "system".to_string(),
                VpcRouterKind::Custom => "custom".to_string(),
            }
        }
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcRouterResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<VpcRouter>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Updateable properties of a [`VpcRouter`](crate::external_api::views::VpcRouter)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcRouterUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    #[doc = "A VPC subnet represents a logical grouping for instances that allows network traffic between them, within a IPv4 subnetwork or optionall an IPv6 subnetwork."]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcSubnet {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "The IPv4 subnet CIDR block."]
        pub ipv4_block: Ipv4Net,
        #[doc = "The IPv6 subnet CIDR block."]
        pub ipv6_block: Ipv6Net,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "The VPC to which the subnet belongs."]
        pub vpc_id: uuid::Uuid,
    }

    #[doc = "Create-time parameters for a [`VpcSubnet`](crate::external_api::views::VpcSubnet)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcSubnetCreate {
        pub description: String,
        #[doc = "The IPv4 address range for this subnet.\n\nIt must be allocated from an RFC 1918 private address range, and must not overlap with any other existing subnet in the VPC."]
        pub ipv4_block: Ipv4Net,
        #[doc = "The IPv6 address range for this subnet.\n\nIt must be allocated from the RFC 4193 Unique Local Address range, with the prefix equal to the parent VPC's prefix. A random `/64` block will be assigned if one is not provided. It must not overlap with any existing subnet in the VPC."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ipv6_block: Option<Ipv6Net>,
        pub name: Name,
    }

    #[doc = "A single page of results"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcSubnetResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<VpcSubnet>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[doc = "Updateable properties of a [`VpcSubnet`](crate::external_api::views::VpcSubnet)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcSubnetUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ipv4_block: Option<Ipv4Net>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ipv6_block: Option<Ipv6Net>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    #[doc = "Updateable properties of a [`Vpc`](crate::external_api::views::Vpc)"]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dns_name: Option<Name>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }
}

#[derive(Clone)]
pub struct Client {
    baseurl: String,
    client: reqwest::Client,
}

impl Client {
    pub fn new(baseurl: &str) -> Self {
        let dur = std::time::Duration::from_secs(15);
        let client = reqwest::ClientBuilder::new()
            .connect_timeout(dur)
            .timeout(dur)
            .build()
            .unwrap();
        Self::new_with_client(baseurl, client)
    }

    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }

    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }

    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }

    #[doc = "List racks in the system\n\nSends a `GET` request to `/hardware/racks`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn hardware_racks_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::RackResultsPage>, Error<types::Error>> {
        let url = format!("{}/hardware/racks", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List racks in the system as a Stream\n\nSends repeated `GET` requests to `/hardware/racks` until there are no more results.\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn hardware_racks_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Rack, Error<types::Error>>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.hardware_racks_get(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.hardware_racks_get(None, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Fetch information about a particular rack\n\nSends a `GET` request to `/hardware/racks/{rack_id}`\n\nArguments:\n- `rack_id`: The rack's unique ID.\n"]
    pub async fn hardware_racks_get_rack<'a>(
        &'a self,
        rack_id: &'a uuid::Uuid,
    ) -> Result<ResponseValue<types::Rack>, Error<types::Error>> {
        let url = format!(
            "{}/hardware/racks/{}",
            self.baseurl,
            progenitor_client::encode_path(&rack_id.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List sleds in the system\n\nSends a `GET` request to `/hardware/sleds`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn hardware_sleds_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::SledResultsPage>, Error<types::Error>> {
        let url = format!("{}/hardware/sleds", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List sleds in the system as a Stream\n\nSends repeated `GET` requests to `/hardware/sleds` until there are no more results.\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn hardware_sleds_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Sled, Error<types::Error>>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.hardware_sleds_get(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.hardware_sleds_get(None, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Fetch information about a sled in the system\n\nSends a `GET` request to `/hardware/sleds/{sled_id}`\n\nArguments:\n- `sled_id`: The sled's unique ID.\n"]
    pub async fn hardware_sleds_get_sled<'a>(
        &'a self,
        sled_id: &'a uuid::Uuid,
    ) -> Result<ResponseValue<types::Sled>, Error<types::Error>> {
        let url = format!(
            "{}/hardware/sleds/{}",
            self.baseurl,
            progenitor_client::encode_path(&sled_id.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Sends a `POST` request to `/login`"]
    pub async fn spoof_login<'a>(
        &'a self,
        body: &'a types::LoginParams,
    ) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
        let url = format!("{}/login", self.baseurl,);
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
        }
    }

    #[doc = "Sends a `POST` request to `/logout`"]
    pub async fn logout<'a>(&'a self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
        let url = format!("{}/logout", self.baseurl,);
        let request = self.client.post(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
        }
    }

    #[doc = "List all organizations\n\nSends a `GET` request to `/organizations`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn organizations_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::OrganizationResultsPage>, Error<types::Error>> {
        let url = format!("{}/organizations", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List all organizations as a Stream\n\nSends repeated `GET` requests to `/organizations` until there are no more results.\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn organizations_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Organization, Error<types::Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.organizations_get(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.organizations_get(None, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Create a new organization\n\nSends a `POST` request to `/organizations`"]
    pub async fn organizations_post<'a>(
        &'a self,
        body: &'a types::OrganizationCreate,
    ) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
        let url = format!("{}/organizations", self.baseurl,);
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Fetch a specific organization\n\nSends a `GET` request to `/organizations/{organization_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n"]
    pub async fn organizations_get_organization<'a>(
        &'a self,
        organization_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Update a specific organization\n\nSends a `PUT` request to `/organizations/{organization_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `body`\n"]
    pub async fn organizations_put_organization<'a>(
        &'a self,
        organization_name: &'a types::Name,
        body: &'a types::OrganizationUpdate,
    ) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Delete a specific organization\n\nSends a `DELETE` request to `/organizations/{organization_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n"]
    pub async fn organizations_delete_organization<'a>(
        &'a self,
        organization_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List all projects\n\nSends a `GET` request to `/organizations/{organization_name}/projects`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn organization_projects_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::ProjectResultsPage>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List all projects as a Stream\n\nSends repeated `GET` requests to `/organizations/{organization_name}/projects` until there are no more results.\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn organization_projects_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Project, Error<types::Error>>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.organization_projects_get(organization_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.organization_projects_get(
                            organization_name,
                            None,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((
                                futures::stream::iter(page.items.into_iter().map(Ok)),
                                page.next_page,
                            ))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Create a new project\n\nSends a `POST` request to `/organizations/{organization_name}/projects`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `body`\n"]
    pub async fn organization_projects_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        body: &'a types::ProjectCreate,
    ) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Fetch a specific project\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n"]
    pub async fn organization_projects_get_project<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Update a specific project\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n"]
    pub async fn organization_projects_put_project<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::ProjectUpdate,
    ) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Delete a specific project\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n"]
    pub async fn organization_projects_delete_project<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List disks in a project\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/disks`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn project_disks_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List disks in a project as a Stream\n\nSends repeated `GET` requests to `/organizations/{organization_name}/projects/{project_name}/disks` until there are no more results.\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn project_disks_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.project_disks_get(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.project_disks_get(
                            organization_name,
                            project_name,
                            None,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((
                                futures::stream::iter(page.items.into_iter().map(Ok)),
                                page.next_page,
                            ))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Create a disk in a project\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/disks`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n"]
    pub async fn project_disks_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::DiskCreate,
    ) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Fetch a single disk in a project\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/disks/{disk_name}`"]
    pub async fn project_disks_get_disk<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&disk_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Delete a disk from a project\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/disks/{disk_name}`"]
    pub async fn project_disks_delete_disk<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&disk_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List instances in a project\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn project_instances_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::InstanceResultsPage>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List instances in a project as a Stream\n\nSends repeated `GET` requests to `/organizations/{organization_name}/projects/{project_name}/instances` until there are no more results.\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn project_instances_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Instance, Error<types::Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.project_instances_get(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.project_instances_get(
                            organization_name,
                            project_name,
                            None,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((
                                futures::stream::iter(page.items.into_iter().map(Ok)),
                                page.next_page,
                            ))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Create an instance in a project\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n"]
    pub async fn project_instances_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::InstanceCreate,
    ) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Get an instance in a project\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}`"]
    pub async fn project_instances_get_instance<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Delete an instance from a project\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}`"]
    pub async fn project_instances_delete_instance<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List disks attached to this instance\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `instance_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn instance_disks_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List disks attached to this instance as a Stream\n\nSends repeated `GET` requests to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks` until there are no more results.\n\nArguments:\n- `organization_name`\n- `project_name`\n- `instance_name`\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn instance_disks_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_disks_get(
            organization_name,
            project_name,
            instance_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.instance_disks_get(
                        organization_name,
                        project_name,
                        instance_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks/attach`"]
    pub async fn instance_disks_attach<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::DiskIdentifier,
    ) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks/attach",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks/detach`"]
    pub async fn instance_disks_detach<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::DiskIdentifier,
    ) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks/detach",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Migrate an instance to a different propolis-server, possibly on a different sled\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/migrate`"]
    pub async fn project_instances_migrate_instance<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::InstanceMigrate,
    ) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/migrate",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List network interfaces attached to this instance\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `instance_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn instance_network_interfaces_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::NetworkInterfaceResultsPage>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List network interfaces attached to this instance as a Stream\n\nSends repeated `GET` requests to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces` until there are no more results.\n\nArguments:\n- `organization_name`\n- `project_name`\n- `instance_name`\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn instance_network_interfaces_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::NetworkInterface, Error<types::Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_network_interfaces_get(
            organization_name,
            project_name,
            instance_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.instance_network_interfaces_get(
                        organization_name,
                        project_name,
                        instance_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "Create a network interface for an instance\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces`"]
    pub async fn instance_network_interfaces_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::NetworkInterfaceCreate,
    ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Get an interface attached to an instance\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces/{interface_name}`"]
    pub async fn instance_network_interfaces_get_interface<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        interface_name: &'a types::Name,
    ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
            progenitor_client::encode_path(&interface_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Detach a network interface from an instance\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces/{interface_name}`"]
    pub async fn instance_network_interfaces_delete_interface<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        interface_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
            progenitor_client::encode_path(&interface_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Reboot an instance\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/reboot`"]
    pub async fn project_instances_instance_reboot<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/reboot",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Boot an instance\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/start`"]
    pub async fn project_instances_instance_start<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/start",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Halt an instance\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/stop`"]
    pub async fn project_instances_instance_stop<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/stop",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&instance_name.to_string()),
        );
        let request = self.client.post(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List snapshots in a project\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/snapshots`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn project_snapshots_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::SnapshotResultsPage>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List snapshots in a project as a Stream\n\nSends repeated `GET` requests to `/organizations/{organization_name}/projects/{project_name}/snapshots` until there are no more results.\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn project_snapshots_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Snapshot, Error<types::Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.project_snapshots_get(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.project_snapshots_get(
                            organization_name,
                            project_name,
                            None,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((
                                futures::stream::iter(page.items.into_iter().map(Ok)),
                                page.next_page,
                            ))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Create a snapshot of a disk\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/snapshots`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n"]
    pub async fn project_snapshots_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::SnapshotCreate,
    ) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Get a snapshot in a project\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/snapshots/{snapshot_name}`"]
    pub async fn project_snapshots_get_snapshot<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        snapshot_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&snapshot_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Delete a snapshot from a project\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/snapshots/{snapshot_name}`"]
    pub async fn project_snapshots_delete_snapshot<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        snapshot_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&snapshot_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List VPCs in a project\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn project_vpcs_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::VpcResultsPage>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List VPCs in a project as a Stream\n\nSends repeated `GET` requests to `/organizations/{organization_name}/projects/{project_name}/vpcs` until there are no more results.\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn project_vpcs_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Vpc, Error<types::Error>>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.project_vpcs_get(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.project_vpcs_get(
                            organization_name,
                            project_name,
                            None,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((
                                futures::stream::iter(page.items.into_iter().map(Ok)),
                                page.next_page,
                            ))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Create a VPC in a project\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n"]
    pub async fn project_vpcs_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::VpcCreate,
    ) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Get a VPC in a project\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}`"]
    pub async fn project_vpcs_get_vpc<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Update a VPC\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}`"]
    pub async fn project_vpcs_put_vpc<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcUpdate,
    ) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Delete a vpc from a project\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}`"]
    pub async fn project_vpcs_delete_vpc<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List firewall rules for a VPC\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/firewall/rules`"]
    pub async fn vpc_firewall_rules_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
    ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Replace the firewall rules for a VPC\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/firewall/rules`"]
    pub async fn vpc_firewall_rules_put<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcFirewallRuleUpdateParams,
    ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List VPC Custom and System Routers\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn vpc_routers_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::VpcRouterResultsPage>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List VPC Custom and System Routers as a Stream\n\nSends repeated `GET` requests to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers` until there are no more results.\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn vpc_routers_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::VpcRouter, Error<types::Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_routers_get(
            organization_name,
            project_name,
            vpc_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_routers_get(
                        organization_name,
                        project_name,
                        vpc_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "Create a VPC Router\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers`"]
    pub async fn vpc_routers_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcRouterCreate,
    ) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Get a VPC Router\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}`"]
    pub async fn vpc_routers_get_router<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
    ) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&router_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Update a VPC Router\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}`"]
    pub async fn vpc_routers_put_router<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        body: &'a types::VpcRouterUpdate,
    ) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&router_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Delete a router from its VPC\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}`"]
    pub async fn vpc_routers_delete_router<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&router_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List a Router's routes\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `router_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn routers_routes_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::RouterRouteResultsPage>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&router_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List a Router's routes as a Stream\n\nSends repeated `GET` requests to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes` until there are no more results.\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `router_name`\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn routers_routes_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::RouterRoute, Error<types::Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.routers_routes_get(
            organization_name,
            project_name,
            vpc_name,
            router_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.routers_routes_get(
                        organization_name,
                        project_name,
                        vpc_name,
                        router_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "Create a VPC Router\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes`"]
    pub async fn routers_routes_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        body: &'a types::RouterRouteCreateParams,
    ) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&router_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Get a VPC Router route\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}`"]
    pub async fn routers_routes_get_route<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
    ) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&router_name.to_string()),
            progenitor_client::encode_path(&route_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Update a Router route\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}`"]
    pub async fn routers_routes_put_route<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
        body: &'a types::RouterRouteUpdateParams,
    ) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&router_name.to_string()),
            progenitor_client::encode_path(&route_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Delete a route from its router\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}`"]
    pub async fn routers_routes_delete_route<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&router_name.to_string()),
            progenitor_client::encode_path(&route_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List subnets in a VPC\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn vpc_subnets_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::VpcSubnetResultsPage>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List subnets in a VPC as a Stream\n\nSends repeated `GET` requests to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets` until there are no more results.\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn vpc_subnets_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::VpcSubnet, Error<types::Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_subnets_get(
            organization_name,
            project_name,
            vpc_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_subnets_get(
                        organization_name,
                        project_name,
                        vpc_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "Create a subnet in a VPC\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets`"]
    pub async fn vpc_subnets_post<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcSubnetCreate,
    ) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
        );
        let request = self.client.post(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Get subnet in a VPC\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`"]
    pub async fn vpc_subnets_get_subnet<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
    ) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&subnet_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Update a VPC Subnet\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`"]
    pub async fn vpc_subnets_put_subnet<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        body: &'a types::VpcSubnetUpdate,
    ) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&subnet_name.to_string()),
        );
        let request = self.client.put(url).json(body).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Delete a subnet from a VPC\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`"]
    pub async fn vpc_subnets_delete_subnet<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&subnet_name.to_string()),
        );
        let request = self.client.delete(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List network interfaces in a VPC subnet\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}/network-interfaces`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `subnet_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn subnet_network_interfaces_get<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::NetworkInterfaceResultsPage>, Error<types::Error>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}/network-interfaces",
            self.baseurl,
            progenitor_client::encode_path(&organization_name.to_string()),
            progenitor_client::encode_path(&project_name.to_string()),
            progenitor_client::encode_path(&vpc_name.to_string()),
            progenitor_client::encode_path(&subnet_name.to_string()),
        );
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List network interfaces in a VPC subnet as a Stream\n\nSends repeated `GET` requests to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}/network-interfaces` until there are no more results.\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `subnet_name`\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn subnet_network_interfaces_get_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::NetworkInterface, Error<types::Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.subnet_network_interfaces_get(
            organization_name,
            project_name,
            vpc_name,
            subnet_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items.into_iter().map(Ok));
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.subnet_network_interfaces_get(
                        organization_name,
                        project_name,
                        vpc_name,
                        subnet_name,
                        None,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((
                            futures::stream::iter(page.items.into_iter().map(Ok)),
                            page.next_page,
                        ))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    #[doc = "List the built-in roles\n\nSends a `GET` request to `/roles`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n"]
    pub async fn roles_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<ResponseValue<types::RoleResultsPage>, Error<types::Error>> {
        let url = format!("{}/roles", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List the built-in roles as a Stream\n\nSends repeated `GET` requests to `/roles` until there are no more results.\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n"]
    pub fn roles_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
    ) -> impl futures::Stream<Item = Result<types::Role, Error<types::Error>>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.roles_get(limit, None)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.roles_get(None, state.as_deref())
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Fetch a specific built-in role\n\nSends a `GET` request to `/roles/{role_name}`\n\nArguments:\n- `role_name`: The built-in role's unique name.\n"]
    pub async fn roles_get_role<'a>(
        &'a self,
        role_name: &'a str,
    ) -> Result<ResponseValue<types::Role>, Error<types::Error>> {
        let url = format!(
            "{}/roles/{}",
            self.baseurl,
            progenitor_client::encode_path(&role_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List all sagas (for debugging)\n\nSends a `GET` request to `/sagas`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn sagas_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::SagaResultsPage>, Error<types::Error>> {
        let url = format!("{}/sagas", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List all sagas (for debugging) as a Stream\n\nSends repeated `GET` requests to `/sagas` until there are no more results.\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn sagas_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Saga, Error<types::Error>>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.sagas_get(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.sagas_get(None, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Fetch information about a single saga (for debugging)\n\nSends a `GET` request to `/sagas/{saga_id}`"]
    pub async fn sagas_get_saga<'a>(
        &'a self,
        saga_id: &'a uuid::Uuid,
    ) -> Result<ResponseValue<types::Saga>, Error<types::Error>> {
        let url = format!(
            "{}/sagas/{}",
            self.baseurl,
            progenitor_client::encode_path(&saga_id.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "Fetch the user associated with the current session\n\nSends a `GET` request to `/session/me`"]
    pub async fn session_me<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::SessionUser>, Error<types::Error>> {
        let url = format!("{}/session/me", self.baseurl,);
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List all timeseries schema\n\nSends a `GET` request to `/timeseries/schema`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n"]
    pub async fn timeseries_schema_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<ResponseValue<types::TimeseriesSchemaResultsPage>, Error<types::Error>> {
        let url = format!("{}/timeseries/schema", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List all timeseries schema as a Stream\n\nSends repeated `GET` requests to `/timeseries/schema` until there are no more results.\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n"]
    pub fn timeseries_schema_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
    ) -> impl futures::Stream<Item = Result<types::TimeseriesSchema, Error<types::Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.timeseries_schema_get(limit, None)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.timeseries_schema_get(None, state.as_deref())
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Refresh update metadata\n\nSends a `POST` request to `/updates/refresh`"]
    pub async fn updates_refresh<'a>(&'a self) -> Result<ResponseValue<()>, Error<types::Error>> {
        let url = format!("{}/updates/refresh", self.baseurl,);
        let request = self.client.post(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List the built-in system users\n\nSends a `GET` request to `/users`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retreive the subsequent page\n- `sort_by`\n"]
    pub async fn users_get<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::Error>> {
        let url = format!("{}/users", self.baseurl,);
        let mut query = Vec::new();
        if let Some(v) = &limit {
            query.push(("limit", v.to_string()));
        }

        if let Some(v) = &page_token {
            query.push(("page_token", v.to_string()));
        }

        if let Some(v) = &sort_by {
            query.push(("sort_by", v.to_string()));
        }

        let request = self.client.get(url).query(&query).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    #[doc = "List the built-in system users as a Stream\n\nSends repeated `GET` requests to `/users` until there are no more results.\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `sort_by`\n"]
    pub fn users_get_stream<'a>(
        &'a self,
        limit: Option<std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::User, Error<types::Error>>> + Unpin + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.users_get(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items.into_iter().map(Ok));
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.users_get(None, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((
                                    futures::stream::iter(page.items.into_iter().map(Ok)),
                                    page.next_page,
                                ))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    #[doc = "Fetch a specific built-in system user\n\nSends a `GET` request to `/users/{user_name}`\n\nArguments:\n- `user_name`: The built-in user's unique name.\n"]
    pub async fn users_get_user<'a>(
        &'a self,
        user_name: &'a types::Name,
    ) -> Result<ResponseValue<types::User>, Error<types::Error>> {
        let url = format!(
            "{}/users/{}",
            self.baseurl,
            progenitor_client::encode_path(&user_name.to_string()),
        );
        let request = self.client.get(url).build()?;
        let result = self.client.execute(request).await;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::from_response(response).await?,
            )),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
}
