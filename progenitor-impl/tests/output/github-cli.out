pub struct Cli<T: CliOverride = ()> {
    client: sdk::Client,
    over: T,
}

impl Cli {
    pub fn new(client: sdk::Client) -> Self {
        Self { client, over: () }
    }

    pub fn get_command(cmd: CliCommand) -> clap::Command {
        match cmd {
            CliCommand::MetaRoot => Self::cli_meta_root(),
            CliCommand::AppsGetAuthenticated => Self::cli_apps_get_authenticated(),
            CliCommand::AppsCreateFromManifest => Self::cli_apps_create_from_manifest(),
            CliCommand::AppsGetWebhookConfigForApp => Self::cli_apps_get_webhook_config_for_app(),
            CliCommand::AppsUpdateWebhookConfigForApp => {
                Self::cli_apps_update_webhook_config_for_app()
            }
            CliCommand::AppsListWebhookDeliveries => Self::cli_apps_list_webhook_deliveries(),
            CliCommand::AppsGetWebhookDelivery => Self::cli_apps_get_webhook_delivery(),
            CliCommand::AppsRedeliverWebhookDelivery => Self::cli_apps_redeliver_webhook_delivery(),
            CliCommand::AppsListInstallationRequestsForAuthenticatedApp => {
                Self::cli_apps_list_installation_requests_for_authenticated_app()
            }
            CliCommand::AppsListInstallations => Self::cli_apps_list_installations(),
            CliCommand::AppsGetInstallation => Self::cli_apps_get_installation(),
            CliCommand::AppsDeleteInstallation => Self::cli_apps_delete_installation(),
            CliCommand::AppsCreateInstallationAccessToken => {
                Self::cli_apps_create_installation_access_token()
            }
            CliCommand::AppsSuspendInstallation => Self::cli_apps_suspend_installation(),
            CliCommand::AppsUnsuspendInstallation => Self::cli_apps_unsuspend_installation(),
            CliCommand::AppsDeleteAuthorization => Self::cli_apps_delete_authorization(),
            CliCommand::AppsCheckToken => Self::cli_apps_check_token(),
            CliCommand::AppsDeleteToken => Self::cli_apps_delete_token(),
            CliCommand::AppsResetToken => Self::cli_apps_reset_token(),
            CliCommand::AppsScopeToken => Self::cli_apps_scope_token(),
            CliCommand::AppsGetBySlug => Self::cli_apps_get_by_slug(),
            CliCommand::CodesOfConductGetAllCodesOfConduct => {
                Self::cli_codes_of_conduct_get_all_codes_of_conduct()
            }
            CliCommand::CodesOfConductGetConductCode => {
                Self::cli_codes_of_conduct_get_conduct_code()
            }
            CliCommand::EmojisGet => Self::cli_emojis_get(),
            CliCommand::DependabotListAlertsForEnterprise => {
                Self::cli_dependabot_list_alerts_for_enterprise()
            }
            CliCommand::SecretScanningListAlertsForEnterprise => {
                Self::cli_secret_scanning_list_alerts_for_enterprise()
            }
            CliCommand::ActivityListPublicEvents => Self::cli_activity_list_public_events(),
            CliCommand::ActivityGetFeeds => Self::cli_activity_get_feeds(),
            CliCommand::GistsList => Self::cli_gists_list(),
            CliCommand::GistsCreate => Self::cli_gists_create(),
            CliCommand::GistsListPublic => Self::cli_gists_list_public(),
            CliCommand::GistsListStarred => Self::cli_gists_list_starred(),
            CliCommand::GistsGet => Self::cli_gists_get(),
            CliCommand::GistsDelete => Self::cli_gists_delete(),
            CliCommand::GistsUpdate => Self::cli_gists_update(),
            CliCommand::GistsListComments => Self::cli_gists_list_comments(),
            CliCommand::GistsCreateComment => Self::cli_gists_create_comment(),
            CliCommand::GistsGetComment => Self::cli_gists_get_comment(),
            CliCommand::GistsDeleteComment => Self::cli_gists_delete_comment(),
            CliCommand::GistsUpdateComment => Self::cli_gists_update_comment(),
            CliCommand::GistsListCommits => Self::cli_gists_list_commits(),
            CliCommand::GistsListForks => Self::cli_gists_list_forks(),
            CliCommand::GistsFork => Self::cli_gists_fork(),
            CliCommand::GistsCheckIsStarred => Self::cli_gists_check_is_starred(),
            CliCommand::GistsStar => Self::cli_gists_star(),
            CliCommand::GistsUnstar => Self::cli_gists_unstar(),
            CliCommand::GistsGetRevision => Self::cli_gists_get_revision(),
            CliCommand::GitignoreGetAllTemplates => Self::cli_gitignore_get_all_templates(),
            CliCommand::GitignoreGetTemplate => Self::cli_gitignore_get_template(),
            CliCommand::AppsListReposAccessibleToInstallation => {
                Self::cli_apps_list_repos_accessible_to_installation()
            }
            CliCommand::AppsRevokeInstallationAccessToken => {
                Self::cli_apps_revoke_installation_access_token()
            }
            CliCommand::IssuesList => Self::cli_issues_list(),
            CliCommand::LicensesGetAllCommonlyUsed => Self::cli_licenses_get_all_commonly_used(),
            CliCommand::LicensesGet => Self::cli_licenses_get(),
            CliCommand::MarkdownRender => Self::cli_markdown_render(),
            CliCommand::MetaGetAllVersions => Self::cli_meta_get_all_versions(),
            CliCommand::AppsGetSubscriptionPlanForAccount => {
                Self::cli_apps_get_subscription_plan_for_account()
            }
            CliCommand::AppsListPlans => Self::cli_apps_list_plans(),
            CliCommand::AppsListAccountsForPlan => Self::cli_apps_list_accounts_for_plan(),
            CliCommand::AppsGetSubscriptionPlanForAccountStubbed => {
                Self::cli_apps_get_subscription_plan_for_account_stubbed()
            }
            CliCommand::AppsListPlansStubbed => Self::cli_apps_list_plans_stubbed(),
            CliCommand::AppsListAccountsForPlanStubbed => {
                Self::cli_apps_list_accounts_for_plan_stubbed()
            }
            CliCommand::MetaGet => Self::cli_meta_get(),
            CliCommand::ActivityListPublicEventsForRepoNetwork => {
                Self::cli_activity_list_public_events_for_repo_network()
            }
            CliCommand::ActivityListNotificationsForAuthenticatedUser => {
                Self::cli_activity_list_notifications_for_authenticated_user()
            }
            CliCommand::ActivityMarkNotificationsAsRead => {
                Self::cli_activity_mark_notifications_as_read()
            }
            CliCommand::ActivityGetThread => Self::cli_activity_get_thread(),
            CliCommand::ActivityMarkThreadAsRead => Self::cli_activity_mark_thread_as_read(),
            CliCommand::ActivityGetThreadSubscriptionForAuthenticatedUser => {
                Self::cli_activity_get_thread_subscription_for_authenticated_user()
            }
            CliCommand::ActivitySetThreadSubscription => {
                Self::cli_activity_set_thread_subscription()
            }
            CliCommand::ActivityDeleteThreadSubscription => {
                Self::cli_activity_delete_thread_subscription()
            }
            CliCommand::MetaGetOctocat => Self::cli_meta_get_octocat(),
            CliCommand::OrgsList => Self::cli_orgs_list(),
            CliCommand::OrgsListPatGrantRequests => Self::cli_orgs_list_pat_grant_requests(),
            CliCommand::OrgsReviewPatGrantRequestsInBulk => {
                Self::cli_orgs_review_pat_grant_requests_in_bulk()
            }
            CliCommand::OrgsReviewPatGrantRequest => Self::cli_orgs_review_pat_grant_request(),
            CliCommand::OrgsListPatGrantRequestRepositories => {
                Self::cli_orgs_list_pat_grant_request_repositories()
            }
            CliCommand::OrgsListPatGrants => Self::cli_orgs_list_pat_grants(),
            CliCommand::OrgsUpdatePatAccesses => Self::cli_orgs_update_pat_accesses(),
            CliCommand::OrgsUpdatePatAccess => Self::cli_orgs_update_pat_access(),
            CliCommand::OrgsListPatGrantRepositories => {
                Self::cli_orgs_list_pat_grant_repositories()
            }
            CliCommand::MetaGetZen => Self::cli_meta_get_zen(),
            CliCommand::ActionsGetActionsCacheUsageForOrg => {
                Self::cli_actions_get_actions_cache_usage_for_org()
            }
            CliCommand::ActionsGetActionsCacheUsageByRepoForOrg => {
                Self::cli_actions_get_actions_cache_usage_by_repo_for_org()
            }
            CliCommand::OidcGetOidcCustomSubTemplateForOrg => {
                Self::cli_oidc_get_oidc_custom_sub_template_for_org()
            }
            CliCommand::OidcUpdateOidcCustomSubTemplateForOrg => {
                Self::cli_oidc_update_oidc_custom_sub_template_for_org()
            }
            CliCommand::ActionsGetGithubActionsPermissionsOrganization => {
                Self::cli_actions_get_github_actions_permissions_organization()
            }
            CliCommand::ActionsSetGithubActionsPermissionsOrganization => {
                Self::cli_actions_set_github_actions_permissions_organization()
            }
            CliCommand::ActionsListSelectedRepositoriesEnabledGithubActionsOrganization => {
                Self::cli_actions_list_selected_repositories_enabled_github_actions_organization()
            }
            CliCommand::ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization => {
                Self::cli_actions_set_selected_repositories_enabled_github_actions_organization()
            }
            CliCommand::ActionsEnableSelectedRepositoryGithubActionsOrganization => {
                Self::cli_actions_enable_selected_repository_github_actions_organization()
            }
            CliCommand::ActionsDisableSelectedRepositoryGithubActionsOrganization => {
                Self::cli_actions_disable_selected_repository_github_actions_organization()
            }
            CliCommand::ActionsGetAllowedActionsOrganization => {
                Self::cli_actions_get_allowed_actions_organization()
            }
            CliCommand::ActionsSetAllowedActionsOrganization => {
                Self::cli_actions_set_allowed_actions_organization()
            }
            CliCommand::ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization => {
                Self::cli_actions_get_github_actions_default_workflow_permissions_organization()
            }
            CliCommand::ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization => {
                Self::cli_actions_set_github_actions_default_workflow_permissions_organization()
            }
            CliCommand::ActionsListRequiredWorkflows => Self::cli_actions_list_required_workflows(),
            CliCommand::ActionsCreateRequiredWorkflow => {
                Self::cli_actions_create_required_workflow()
            }
            CliCommand::ActionsGetRequiredWorkflow => Self::cli_actions_get_required_workflow(),
            CliCommand::ActionsDeleteRequiredWorkflow => {
                Self::cli_actions_delete_required_workflow()
            }
            CliCommand::ActionsUpdateRequiredWorkflow => {
                Self::cli_actions_update_required_workflow()
            }
            CliCommand::ActionsListSelectedRepositoriesRequiredWorkflow => {
                Self::cli_actions_list_selected_repositories_required_workflow()
            }
            CliCommand::ActionsSetSelectedReposToRequiredWorkflow => {
                Self::cli_actions_set_selected_repos_to_required_workflow()
            }
            CliCommand::ActionsAddSelectedRepoToRequiredWorkflow => {
                Self::cli_actions_add_selected_repo_to_required_workflow()
            }
            CliCommand::ActionsRemoveSelectedRepoFromRequiredWorkflow => {
                Self::cli_actions_remove_selected_repo_from_required_workflow()
            }
            CliCommand::ActionsListSelfHostedRunnersForOrg => {
                Self::cli_actions_list_self_hosted_runners_for_org()
            }
            CliCommand::ActionsListRunnerApplicationsForOrg => {
                Self::cli_actions_list_runner_applications_for_org()
            }
            CliCommand::ActionsCreateRegistrationTokenForOrg => {
                Self::cli_actions_create_registration_token_for_org()
            }
            CliCommand::ActionsCreateRemoveTokenForOrg => {
                Self::cli_actions_create_remove_token_for_org()
            }
            CliCommand::ActionsGetSelfHostedRunnerForOrg => {
                Self::cli_actions_get_self_hosted_runner_for_org()
            }
            CliCommand::ActionsDeleteSelfHostedRunnerFromOrg => {
                Self::cli_actions_delete_self_hosted_runner_from_org()
            }
            CliCommand::ActionsListLabelsForSelfHostedRunnerForOrg => {
                Self::cli_actions_list_labels_for_self_hosted_runner_for_org()
            }
            CliCommand::ActionsSetCustomLabelsForSelfHostedRunnerForOrg => {
                Self::cli_actions_set_custom_labels_for_self_hosted_runner_for_org()
            }
            CliCommand::ActionsAddCustomLabelsToSelfHostedRunnerForOrg => {
                Self::cli_actions_add_custom_labels_to_self_hosted_runner_for_org()
            }
            CliCommand::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg => {
                Self::cli_actions_remove_all_custom_labels_from_self_hosted_runner_for_org()
            }
            CliCommand::ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg => {
                Self::cli_actions_remove_custom_label_from_self_hosted_runner_for_org()
            }
            CliCommand::ActionsListOrgSecrets => Self::cli_actions_list_org_secrets(),
            CliCommand::ActionsGetOrgPublicKey => Self::cli_actions_get_org_public_key(),
            CliCommand::ActionsGetOrgSecret => Self::cli_actions_get_org_secret(),
            CliCommand::ActionsCreateOrUpdateOrgSecret => {
                Self::cli_actions_create_or_update_org_secret()
            }
            CliCommand::ActionsDeleteOrgSecret => Self::cli_actions_delete_org_secret(),
            CliCommand::ActionsListSelectedReposForOrgSecret => {
                Self::cli_actions_list_selected_repos_for_org_secret()
            }
            CliCommand::ActionsSetSelectedReposForOrgSecret => {
                Self::cli_actions_set_selected_repos_for_org_secret()
            }
            CliCommand::ActionsAddSelectedRepoToOrgSecret => {
                Self::cli_actions_add_selected_repo_to_org_secret()
            }
            CliCommand::ActionsRemoveSelectedRepoFromOrgSecret => {
                Self::cli_actions_remove_selected_repo_from_org_secret()
            }
            CliCommand::ActionsListOrgVariables => Self::cli_actions_list_org_variables(),
            CliCommand::ActionsCreateOrgVariable => Self::cli_actions_create_org_variable(),
            CliCommand::ActionsGetOrgVariable => Self::cli_actions_get_org_variable(),
            CliCommand::ActionsDeleteOrgVariable => Self::cli_actions_delete_org_variable(),
            CliCommand::ActionsUpdateOrgVariable => Self::cli_actions_update_org_variable(),
            CliCommand::ActionsListSelectedReposForOrgVariable => {
                Self::cli_actions_list_selected_repos_for_org_variable()
            }
            CliCommand::ActionsSetSelectedReposForOrgVariable => {
                Self::cli_actions_set_selected_repos_for_org_variable()
            }
            CliCommand::ActionsAddSelectedRepoToOrgVariable => {
                Self::cli_actions_add_selected_repo_to_org_variable()
            }
            CliCommand::ActionsRemoveSelectedRepoFromOrgVariable => {
                Self::cli_actions_remove_selected_repo_from_org_variable()
            }
            CliCommand::OrgsListBlockedUsers => Self::cli_orgs_list_blocked_users(),
            CliCommand::OrgsCheckBlockedUser => Self::cli_orgs_check_blocked_user(),
            CliCommand::OrgsBlockUser => Self::cli_orgs_block_user(),
            CliCommand::OrgsUnblockUser => Self::cli_orgs_unblock_user(),
            CliCommand::CodeScanningListAlertsForOrg => {
                Self::cli_code_scanning_list_alerts_for_org()
            }
            CliCommand::CodespacesListInOrganization => Self::cli_codespaces_list_in_organization(),
            CliCommand::CodespacesSetCodespacesBilling => {
                Self::cli_codespaces_set_codespaces_billing()
            }
            CliCommand::CodespacesSetCodespacesBillingUsers => {
                Self::cli_codespaces_set_codespaces_billing_users()
            }
            CliCommand::CodespacesDeleteCodespacesBillingUsers => {
                Self::cli_codespaces_delete_codespaces_billing_users()
            }
            CliCommand::CodespacesListOrgSecrets => Self::cli_codespaces_list_org_secrets(),
            CliCommand::CodespacesGetOrgPublicKey => Self::cli_codespaces_get_org_public_key(),
            CliCommand::CodespacesGetOrgSecret => Self::cli_codespaces_get_org_secret(),
            CliCommand::CodespacesCreateOrUpdateOrgSecret => {
                Self::cli_codespaces_create_or_update_org_secret()
            }
            CliCommand::CodespacesDeleteOrgSecret => Self::cli_codespaces_delete_org_secret(),
            CliCommand::CodespacesListSelectedReposForOrgSecret => {
                Self::cli_codespaces_list_selected_repos_for_org_secret()
            }
            CliCommand::CodespacesSetSelectedReposForOrgSecret => {
                Self::cli_codespaces_set_selected_repos_for_org_secret()
            }
            CliCommand::CodespacesAddSelectedRepoToOrgSecret => {
                Self::cli_codespaces_add_selected_repo_to_org_secret()
            }
            CliCommand::CodespacesRemoveSelectedRepoFromOrgSecret => {
                Self::cli_codespaces_remove_selected_repo_from_org_secret()
            }
            CliCommand::DependabotListAlertsForOrg => Self::cli_dependabot_list_alerts_for_org(),
            CliCommand::DependabotListOrgSecrets => Self::cli_dependabot_list_org_secrets(),
            CliCommand::DependabotGetOrgPublicKey => Self::cli_dependabot_get_org_public_key(),
            CliCommand::DependabotGetOrgSecret => Self::cli_dependabot_get_org_secret(),
            CliCommand::DependabotCreateOrUpdateOrgSecret => {
                Self::cli_dependabot_create_or_update_org_secret()
            }
            CliCommand::DependabotDeleteOrgSecret => Self::cli_dependabot_delete_org_secret(),
            CliCommand::DependabotListSelectedReposForOrgSecret => {
                Self::cli_dependabot_list_selected_repos_for_org_secret()
            }
            CliCommand::DependabotSetSelectedReposForOrgSecret => {
                Self::cli_dependabot_set_selected_repos_for_org_secret()
            }
            CliCommand::DependabotAddSelectedRepoToOrgSecret => {
                Self::cli_dependabot_add_selected_repo_to_org_secret()
            }
            CliCommand::DependabotRemoveSelectedRepoFromOrgSecret => {
                Self::cli_dependabot_remove_selected_repo_from_org_secret()
            }
            CliCommand::PackagesListDockerMigrationConflictingPackagesForOrganization => {
                Self::cli_packages_list_docker_migration_conflicting_packages_for_organization()
            }
            CliCommand::ActivityListPublicOrgEvents => Self::cli_activity_list_public_org_events(),
            CliCommand::OrgsListFailedInvitations => Self::cli_orgs_list_failed_invitations(),
            CliCommand::OrgsListWebhooks => Self::cli_orgs_list_webhooks(),
            CliCommand::OrgsCreateWebhook => Self::cli_orgs_create_webhook(),
            CliCommand::OrgsGetWebhook => Self::cli_orgs_get_webhook(),
            CliCommand::OrgsDeleteWebhook => Self::cli_orgs_delete_webhook(),
            CliCommand::OrgsUpdateWebhook => Self::cli_orgs_update_webhook(),
            CliCommand::OrgsGetWebhookConfigForOrg => Self::cli_orgs_get_webhook_config_for_org(),
            CliCommand::OrgsUpdateWebhookConfigForOrg => {
                Self::cli_orgs_update_webhook_config_for_org()
            }
            CliCommand::OrgsListWebhookDeliveries => Self::cli_orgs_list_webhook_deliveries(),
            CliCommand::OrgsGetWebhookDelivery => Self::cli_orgs_get_webhook_delivery(),
            CliCommand::OrgsRedeliverWebhookDelivery => Self::cli_orgs_redeliver_webhook_delivery(),
            CliCommand::OrgsPingWebhook => Self::cli_orgs_ping_webhook(),
            CliCommand::AppsGetOrgInstallation => Self::cli_apps_get_org_installation(),
            CliCommand::OrgsListAppInstallations => Self::cli_orgs_list_app_installations(),
            CliCommand::InteractionsGetRestrictionsForOrg => {
                Self::cli_interactions_get_restrictions_for_org()
            }
            CliCommand::InteractionsSetRestrictionsForOrg => {
                Self::cli_interactions_set_restrictions_for_org()
            }
            CliCommand::InteractionsRemoveRestrictionsForOrg => {
                Self::cli_interactions_remove_restrictions_for_org()
            }
            CliCommand::OrgsListPendingInvitations => Self::cli_orgs_list_pending_invitations(),
            CliCommand::OrgsCreateInvitation => Self::cli_orgs_create_invitation(),
            CliCommand::OrgsCancelInvitation => Self::cli_orgs_cancel_invitation(),
            CliCommand::OrgsListInvitationTeams => Self::cli_orgs_list_invitation_teams(),
            CliCommand::IssuesListForOrg => Self::cli_issues_list_for_org(),
            CliCommand::OrgsListMembers => Self::cli_orgs_list_members(),
            CliCommand::OrgsCheckMembershipForUser => Self::cli_orgs_check_membership_for_user(),
            CliCommand::OrgsRemoveMember => Self::cli_orgs_remove_member(),
            CliCommand::CodespacesGetCodespacesForUserInOrg => {
                Self::cli_codespaces_get_codespaces_for_user_in_org()
            }
            CliCommand::CodespacesDeleteFromOrganization => {
                Self::cli_codespaces_delete_from_organization()
            }
            CliCommand::CodespacesStopInOrganization => Self::cli_codespaces_stop_in_organization(),
            CliCommand::OrgsGetMembershipForUser => Self::cli_orgs_get_membership_for_user(),
            CliCommand::OrgsSetMembershipForUser => Self::cli_orgs_set_membership_for_user(),
            CliCommand::OrgsRemoveMembershipForUser => Self::cli_orgs_remove_membership_for_user(),
            CliCommand::MigrationsListForOrg => Self::cli_migrations_list_for_org(),
            CliCommand::MigrationsStartForOrg => Self::cli_migrations_start_for_org(),
            CliCommand::MigrationsGetStatusForOrg => Self::cli_migrations_get_status_for_org(),
            CliCommand::MigrationsDownloadArchiveForOrg => {
                Self::cli_migrations_download_archive_for_org()
            }
            CliCommand::MigrationsDeleteArchiveForOrg => {
                Self::cli_migrations_delete_archive_for_org()
            }
            CliCommand::MigrationsUnlockRepoForOrg => Self::cli_migrations_unlock_repo_for_org(),
            CliCommand::MigrationsListReposForOrg => Self::cli_migrations_list_repos_for_org(),
            CliCommand::OrgsListOutsideCollaborators => Self::cli_orgs_list_outside_collaborators(),
            CliCommand::OrgsConvertMemberToOutsideCollaborator => {
                Self::cli_orgs_convert_member_to_outside_collaborator()
            }
            CliCommand::OrgsRemoveOutsideCollaborator => {
                Self::cli_orgs_remove_outside_collaborator()
            }
            CliCommand::PackagesListPackagesForOrganization => {
                Self::cli_packages_list_packages_for_organization()
            }
            CliCommand::PackagesGetPackageForOrganization => {
                Self::cli_packages_get_package_for_organization()
            }
            CliCommand::PackagesDeletePackageForOrg => Self::cli_packages_delete_package_for_org(),
            CliCommand::PackagesRestorePackageForOrg => {
                Self::cli_packages_restore_package_for_org()
            }
            CliCommand::PackagesGetAllPackageVersionsForPackageOwnedByOrg => {
                Self::cli_packages_get_all_package_versions_for_package_owned_by_org()
            }
            CliCommand::PackagesGetPackageVersionForOrganization => {
                Self::cli_packages_get_package_version_for_organization()
            }
            CliCommand::PackagesDeletePackageVersionForOrg => {
                Self::cli_packages_delete_package_version_for_org()
            }
            CliCommand::PackagesRestorePackageVersionForOrg => {
                Self::cli_packages_restore_package_version_for_org()
            }
            CliCommand::ProjectsListForOrg => Self::cli_projects_list_for_org(),
            CliCommand::ProjectsCreateForOrg => Self::cli_projects_create_for_org(),
            CliCommand::OrgsListPublicMembers => Self::cli_orgs_list_public_members(),
            CliCommand::OrgsCheckPublicMembershipForUser => {
                Self::cli_orgs_check_public_membership_for_user()
            }
            CliCommand::OrgsSetPublicMembershipForAuthenticatedUser => {
                Self::cli_orgs_set_public_membership_for_authenticated_user()
            }
            CliCommand::OrgsRemovePublicMembershipForAuthenticatedUser => {
                Self::cli_orgs_remove_public_membership_for_authenticated_user()
            }
            CliCommand::ReposListForOrg => Self::cli_repos_list_for_org(),
            CliCommand::ReposCreateInOrg => Self::cli_repos_create_in_org(),
            CliCommand::ReposGetOrgRulesets => Self::cli_repos_get_org_rulesets(),
            CliCommand::ReposCreateOrgRuleset => Self::cli_repos_create_org_ruleset(),
            CliCommand::ReposGetOrgRuleset => Self::cli_repos_get_org_ruleset(),
            CliCommand::ReposUpdateOrgRuleset => Self::cli_repos_update_org_ruleset(),
            CliCommand::ReposDeleteOrgRuleset => Self::cli_repos_delete_org_ruleset(),
            CliCommand::SecretScanningListAlertsForOrg => {
                Self::cli_secret_scanning_list_alerts_for_org()
            }
            CliCommand::OrgsListSecurityManagerTeams => {
                Self::cli_orgs_list_security_manager_teams()
            }
            CliCommand::OrgsAddSecurityManagerTeam => Self::cli_orgs_add_security_manager_team(),
            CliCommand::OrgsRemoveSecurityManagerTeam => {
                Self::cli_orgs_remove_security_manager_team()
            }
            CliCommand::BillingGetGithubActionsBillingOrg => {
                Self::cli_billing_get_github_actions_billing_org()
            }
            CliCommand::BillingGetGithubPackagesBillingOrg => {
                Self::cli_billing_get_github_packages_billing_org()
            }
            CliCommand::BillingGetSharedStorageBillingOrg => {
                Self::cli_billing_get_shared_storage_billing_org()
            }
            CliCommand::TeamsList => Self::cli_teams_list(),
            CliCommand::TeamsCreate => Self::cli_teams_create(),
            CliCommand::TeamsGetByName => Self::cli_teams_get_by_name(),
            CliCommand::TeamsDeleteInOrg => Self::cli_teams_delete_in_org(),
            CliCommand::TeamsUpdateInOrg => Self::cli_teams_update_in_org(),
            CliCommand::TeamsListDiscussionsInOrg => Self::cli_teams_list_discussions_in_org(),
            CliCommand::TeamsCreateDiscussionInOrg => Self::cli_teams_create_discussion_in_org(),
            CliCommand::TeamsGetDiscussionInOrg => Self::cli_teams_get_discussion_in_org(),
            CliCommand::TeamsDeleteDiscussionInOrg => Self::cli_teams_delete_discussion_in_org(),
            CliCommand::TeamsUpdateDiscussionInOrg => Self::cli_teams_update_discussion_in_org(),
            CliCommand::TeamsListDiscussionCommentsInOrg => {
                Self::cli_teams_list_discussion_comments_in_org()
            }
            CliCommand::TeamsCreateDiscussionCommentInOrg => {
                Self::cli_teams_create_discussion_comment_in_org()
            }
            CliCommand::TeamsGetDiscussionCommentInOrg => {
                Self::cli_teams_get_discussion_comment_in_org()
            }
            CliCommand::TeamsDeleteDiscussionCommentInOrg => {
                Self::cli_teams_delete_discussion_comment_in_org()
            }
            CliCommand::TeamsUpdateDiscussionCommentInOrg => {
                Self::cli_teams_update_discussion_comment_in_org()
            }
            CliCommand::ReactionsListForTeamDiscussionCommentInOrg => {
                Self::cli_reactions_list_for_team_discussion_comment_in_org()
            }
            CliCommand::ReactionsCreateForTeamDiscussionCommentInOrg => {
                Self::cli_reactions_create_for_team_discussion_comment_in_org()
            }
            CliCommand::ReactionsDeleteForTeamDiscussionComment => {
                Self::cli_reactions_delete_for_team_discussion_comment()
            }
            CliCommand::ReactionsListForTeamDiscussionInOrg => {
                Self::cli_reactions_list_for_team_discussion_in_org()
            }
            CliCommand::ReactionsCreateForTeamDiscussionInOrg => {
                Self::cli_reactions_create_for_team_discussion_in_org()
            }
            CliCommand::ReactionsDeleteForTeamDiscussion => {
                Self::cli_reactions_delete_for_team_discussion()
            }
            CliCommand::TeamsListPendingInvitationsInOrg => {
                Self::cli_teams_list_pending_invitations_in_org()
            }
            CliCommand::TeamsListMembersInOrg => Self::cli_teams_list_members_in_org(),
            CliCommand::TeamsGetMembershipForUserInOrg => {
                Self::cli_teams_get_membership_for_user_in_org()
            }
            CliCommand::TeamsAddOrUpdateMembershipForUserInOrg => {
                Self::cli_teams_add_or_update_membership_for_user_in_org()
            }
            CliCommand::TeamsRemoveMembershipForUserInOrg => {
                Self::cli_teams_remove_membership_for_user_in_org()
            }
            CliCommand::TeamsListProjectsInOrg => Self::cli_teams_list_projects_in_org(),
            CliCommand::TeamsCheckPermissionsForProjectInOrg => {
                Self::cli_teams_check_permissions_for_project_in_org()
            }
            CliCommand::TeamsAddOrUpdateProjectPermissionsInOrg => {
                Self::cli_teams_add_or_update_project_permissions_in_org()
            }
            CliCommand::TeamsRemoveProjectInOrg => Self::cli_teams_remove_project_in_org(),
            CliCommand::TeamsListReposInOrg => Self::cli_teams_list_repos_in_org(),
            CliCommand::TeamsCheckPermissionsForRepoInOrg => {
                Self::cli_teams_check_permissions_for_repo_in_org()
            }
            CliCommand::TeamsAddOrUpdateRepoPermissionsInOrg => {
                Self::cli_teams_add_or_update_repo_permissions_in_org()
            }
            CliCommand::TeamsRemoveRepoInOrg => Self::cli_teams_remove_repo_in_org(),
            CliCommand::TeamsListChildInOrg => Self::cli_teams_list_child_in_org(),
            CliCommand::OrgsEnableOrDisableSecurityProductOnAllOrgRepos => {
                Self::cli_orgs_enable_or_disable_security_product_on_all_org_repos()
            }
            CliCommand::ProjectsGetCard => Self::cli_projects_get_card(),
            CliCommand::ProjectsDeleteCard => Self::cli_projects_delete_card(),
            CliCommand::ProjectsUpdateCard => Self::cli_projects_update_card(),
            CliCommand::ProjectsMoveCard => Self::cli_projects_move_card(),
            CliCommand::ProjectsGetColumn => Self::cli_projects_get_column(),
            CliCommand::ProjectsDeleteColumn => Self::cli_projects_delete_column(),
            CliCommand::ProjectsUpdateColumn => Self::cli_projects_update_column(),
            CliCommand::UsersListSshSigningKeysForUser => {
                Self::cli_users_list_ssh_signing_keys_for_user()
            }
            CliCommand::ProjectsMoveColumn => Self::cli_projects_move_column(),
            CliCommand::ProjectsGet => Self::cli_projects_get(),
            CliCommand::ProjectsDelete => Self::cli_projects_delete(),
            CliCommand::ProjectsUpdate => Self::cli_projects_update(),
            CliCommand::ProjectsListCollaborators => Self::cli_projects_list_collaborators(),
            CliCommand::ProjectsAddCollaborator => Self::cli_projects_add_collaborator(),
            CliCommand::ProjectsRemoveCollaborator => Self::cli_projects_remove_collaborator(),
            CliCommand::ProjectsGetPermissionForUser => {
                Self::cli_projects_get_permission_for_user()
            }
            CliCommand::ProjectsListColumns => Self::cli_projects_list_columns(),
            CliCommand::ProjectsCreateColumn => Self::cli_projects_create_column(),
            CliCommand::RateLimitGet => Self::cli_rate_limit_get(),
            CliCommand::ActionsListRepoRequiredWorkflows => {
                Self::cli_actions_list_repo_required_workflows()
            }
            CliCommand::ActionsGetRepoRequiredWorkflow => {
                Self::cli_actions_get_repo_required_workflow()
            }
            CliCommand::ActionsGetRepoRequiredWorkflowUsage => {
                Self::cli_actions_get_repo_required_workflow_usage()
            }
            CliCommand::ReposGet => Self::cli_repos_get(),
            CliCommand::ReposDelete => Self::cli_repos_delete(),
            CliCommand::ReposUpdate => Self::cli_repos_update(),
            CliCommand::ActionsListArtifactsForRepo => Self::cli_actions_list_artifacts_for_repo(),
            CliCommand::ActionsGetArtifact => Self::cli_actions_get_artifact(),
            CliCommand::ActionsDeleteArtifact => Self::cli_actions_delete_artifact(),
            CliCommand::ActionsDownloadArtifact => Self::cli_actions_download_artifact(),
            CliCommand::ActionsGetActionsCacheUsage => Self::cli_actions_get_actions_cache_usage(),
            CliCommand::ActionsGetActionsCacheList => Self::cli_actions_get_actions_cache_list(),
            CliCommand::ActionsDeleteActionsCacheByKey => {
                Self::cli_actions_delete_actions_cache_by_key()
            }
            CliCommand::ActionsDeleteActionsCacheById => {
                Self::cli_actions_delete_actions_cache_by_id()
            }
            CliCommand::ActionsGetJobForWorkflowRun => Self::cli_actions_get_job_for_workflow_run(),
            CliCommand::ActionsDownloadJobLogsForWorkflowRun => {
                Self::cli_actions_download_job_logs_for_workflow_run()
            }
            CliCommand::ActionsReRunJobForWorkflowRun => {
                Self::cli_actions_re_run_job_for_workflow_run()
            }
            CliCommand::ActionsGetCustomOidcSubClaimForRepo => {
                Self::cli_actions_get_custom_oidc_sub_claim_for_repo()
            }
            CliCommand::ActionsSetCustomOidcSubClaimForRepo => {
                Self::cli_actions_set_custom_oidc_sub_claim_for_repo()
            }
            CliCommand::ActionsListRepoOrganizationSecrets => {
                Self::cli_actions_list_repo_organization_secrets()
            }
            CliCommand::ActionsListRepoOrganizationVariables => {
                Self::cli_actions_list_repo_organization_variables()
            }
            CliCommand::ActionsGetGithubActionsPermissionsRepository => {
                Self::cli_actions_get_github_actions_permissions_repository()
            }
            CliCommand::ActionsSetGithubActionsPermissionsRepository => {
                Self::cli_actions_set_github_actions_permissions_repository()
            }
            CliCommand::ActionsGetWorkflowAccessToRepository => {
                Self::cli_actions_get_workflow_access_to_repository()
            }
            CliCommand::ActionsSetWorkflowAccessToRepository => {
                Self::cli_actions_set_workflow_access_to_repository()
            }
            CliCommand::ActionsGetAllowedActionsRepository => {
                Self::cli_actions_get_allowed_actions_repository()
            }
            CliCommand::ActionsSetAllowedActionsRepository => {
                Self::cli_actions_set_allowed_actions_repository()
            }
            CliCommand::ActionsGetGithubActionsDefaultWorkflowPermissionsRepository => {
                Self::cli_actions_get_github_actions_default_workflow_permissions_repository()
            }
            CliCommand::ActionsSetGithubActionsDefaultWorkflowPermissionsRepository => {
                Self::cli_actions_set_github_actions_default_workflow_permissions_repository()
            }
            CliCommand::ActionsListRequiredWorkflowRuns => {
                Self::cli_actions_list_required_workflow_runs()
            }
            CliCommand::ActionsListSelfHostedRunnersForRepo => {
                Self::cli_actions_list_self_hosted_runners_for_repo()
            }
            CliCommand::ActionsListRunnerApplicationsForRepo => {
                Self::cli_actions_list_runner_applications_for_repo()
            }
            CliCommand::ActionsCreateRegistrationTokenForRepo => {
                Self::cli_actions_create_registration_token_for_repo()
            }
            CliCommand::ActionsCreateRemoveTokenForRepo => {
                Self::cli_actions_create_remove_token_for_repo()
            }
            CliCommand::ActionsGetSelfHostedRunnerForRepo => {
                Self::cli_actions_get_self_hosted_runner_for_repo()
            }
            CliCommand::ActionsDeleteSelfHostedRunnerFromRepo => {
                Self::cli_actions_delete_self_hosted_runner_from_repo()
            }
            CliCommand::ActionsListLabelsForSelfHostedRunnerForRepo => {
                Self::cli_actions_list_labels_for_self_hosted_runner_for_repo()
            }
            CliCommand::ActionsSetCustomLabelsForSelfHostedRunnerForRepo => {
                Self::cli_actions_set_custom_labels_for_self_hosted_runner_for_repo()
            }
            CliCommand::ActionsAddCustomLabelsToSelfHostedRunnerForRepo => {
                Self::cli_actions_add_custom_labels_to_self_hosted_runner_for_repo()
            }
            CliCommand::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo => {
                Self::cli_actions_remove_all_custom_labels_from_self_hosted_runner_for_repo()
            }
            CliCommand::ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo => {
                Self::cli_actions_remove_custom_label_from_self_hosted_runner_for_repo()
            }
            CliCommand::ActionsListWorkflowRunsForRepo => {
                Self::cli_actions_list_workflow_runs_for_repo()
            }
            CliCommand::ActionsGetWorkflowRun => Self::cli_actions_get_workflow_run(),
            CliCommand::ActionsDeleteWorkflowRun => Self::cli_actions_delete_workflow_run(),
            CliCommand::ActionsGetReviewsForRun => Self::cli_actions_get_reviews_for_run(),
            CliCommand::ActionsApproveWorkflowRun => Self::cli_actions_approve_workflow_run(),
            CliCommand::ActionsListWorkflowRunArtifacts => {
                Self::cli_actions_list_workflow_run_artifacts()
            }
            CliCommand::ActionsGetWorkflowRunAttempt => {
                Self::cli_actions_get_workflow_run_attempt()
            }
            CliCommand::ActionsListJobsForWorkflowRunAttempt => {
                Self::cli_actions_list_jobs_for_workflow_run_attempt()
            }
            CliCommand::ActionsDownloadWorkflowRunAttemptLogs => {
                Self::cli_actions_download_workflow_run_attempt_logs()
            }
            CliCommand::ActionsCancelWorkflowRun => Self::cli_actions_cancel_workflow_run(),
            CliCommand::ActionsReviewCustomGatesForRun => {
                Self::cli_actions_review_custom_gates_for_run()
            }
            CliCommand::ActionsListJobsForWorkflowRun => {
                Self::cli_actions_list_jobs_for_workflow_run()
            }
            CliCommand::ActionsDownloadWorkflowRunLogs => {
                Self::cli_actions_download_workflow_run_logs()
            }
            CliCommand::ActionsDeleteWorkflowRunLogs => {
                Self::cli_actions_delete_workflow_run_logs()
            }
            CliCommand::ActionsGetPendingDeploymentsForRun => {
                Self::cli_actions_get_pending_deployments_for_run()
            }
            CliCommand::ActionsReviewPendingDeploymentsForRun => {
                Self::cli_actions_review_pending_deployments_for_run()
            }
            CliCommand::ActionsReRunWorkflow => Self::cli_actions_re_run_workflow(),
            CliCommand::ActionsReRunWorkflowFailedJobs => {
                Self::cli_actions_re_run_workflow_failed_jobs()
            }
            CliCommand::ActionsGetWorkflowRunUsage => Self::cli_actions_get_workflow_run_usage(),
            CliCommand::ActionsListRepoSecrets => Self::cli_actions_list_repo_secrets(),
            CliCommand::ActionsGetRepoPublicKey => Self::cli_actions_get_repo_public_key(),
            CliCommand::ActionsGetRepoSecret => Self::cli_actions_get_repo_secret(),
            CliCommand::ActionsCreateOrUpdateRepoSecret => {
                Self::cli_actions_create_or_update_repo_secret()
            }
            CliCommand::ActionsDeleteRepoSecret => Self::cli_actions_delete_repo_secret(),
            CliCommand::ActionsListRepoVariables => Self::cli_actions_list_repo_variables(),
            CliCommand::ActionsCreateRepoVariable => Self::cli_actions_create_repo_variable(),
            CliCommand::ActionsGetRepoVariable => Self::cli_actions_get_repo_variable(),
            CliCommand::ActionsDeleteRepoVariable => Self::cli_actions_delete_repo_variable(),
            CliCommand::ActionsUpdateRepoVariable => Self::cli_actions_update_repo_variable(),
            CliCommand::ActionsListRepoWorkflows => Self::cli_actions_list_repo_workflows(),
            CliCommand::ActionsGetWorkflow => Self::cli_actions_get_workflow(),
            CliCommand::ActionsDisableWorkflow => Self::cli_actions_disable_workflow(),
            CliCommand::ActionsCreateWorkflowDispatch => {
                Self::cli_actions_create_workflow_dispatch()
            }
            CliCommand::ActionsEnableWorkflow => Self::cli_actions_enable_workflow(),
            CliCommand::ActionsListWorkflowRuns => Self::cli_actions_list_workflow_runs(),
            CliCommand::ActionsGetWorkflowUsage => Self::cli_actions_get_workflow_usage(),
            CliCommand::IssuesListAssignees => Self::cli_issues_list_assignees(),
            CliCommand::IssuesCheckUserCanBeAssigned => {
                Self::cli_issues_check_user_can_be_assigned()
            }
            CliCommand::ReposListAutolinks => Self::cli_repos_list_autolinks(),
            CliCommand::ReposCreateAutolink => Self::cli_repos_create_autolink(),
            CliCommand::ReposGetAutolink => Self::cli_repos_get_autolink(),
            CliCommand::ReposDeleteAutolink => Self::cli_repos_delete_autolink(),
            CliCommand::ReposEnableAutomatedSecurityFixes => {
                Self::cli_repos_enable_automated_security_fixes()
            }
            CliCommand::ReposDisableAutomatedSecurityFixes => {
                Self::cli_repos_disable_automated_security_fixes()
            }
            CliCommand::ReposListBranches => Self::cli_repos_list_branches(),
            CliCommand::ReposGetBranch => Self::cli_repos_get_branch(),
            CliCommand::ReposGetBranchProtection => Self::cli_repos_get_branch_protection(),
            CliCommand::ReposUpdateBranchProtection => Self::cli_repos_update_branch_protection(),
            CliCommand::ReposDeleteBranchProtection => Self::cli_repos_delete_branch_protection(),
            CliCommand::ReposGetAdminBranchProtection => {
                Self::cli_repos_get_admin_branch_protection()
            }
            CliCommand::ReposSetAdminBranchProtection => {
                Self::cli_repos_set_admin_branch_protection()
            }
            CliCommand::ReposDeleteAdminBranchProtection => {
                Self::cli_repos_delete_admin_branch_protection()
            }
            CliCommand::ReposGetPullRequestReviewProtection => {
                Self::cli_repos_get_pull_request_review_protection()
            }
            CliCommand::ReposDeletePullRequestReviewProtection => {
                Self::cli_repos_delete_pull_request_review_protection()
            }
            CliCommand::ReposUpdatePullRequestReviewProtection => {
                Self::cli_repos_update_pull_request_review_protection()
            }
            CliCommand::ReposGetCommitSignatureProtection => {
                Self::cli_repos_get_commit_signature_protection()
            }
            CliCommand::ReposCreateCommitSignatureProtection => {
                Self::cli_repos_create_commit_signature_protection()
            }
            CliCommand::ReposDeleteCommitSignatureProtection => {
                Self::cli_repos_delete_commit_signature_protection()
            }
            CliCommand::ReposGetStatusChecksProtection => {
                Self::cli_repos_get_status_checks_protection()
            }
            CliCommand::ReposRemoveStatusCheckProtection => {
                Self::cli_repos_remove_status_check_protection()
            }
            CliCommand::ReposUpdateStatusCheckProtection => {
                Self::cli_repos_update_status_check_protection()
            }
            CliCommand::ReposGetAllStatusCheckContexts => {
                Self::cli_repos_get_all_status_check_contexts()
            }
            CliCommand::ReposSetStatusCheckContexts => Self::cli_repos_set_status_check_contexts(),
            CliCommand::ReposAddStatusCheckContexts => Self::cli_repos_add_status_check_contexts(),
            CliCommand::ReposRemoveStatusCheckContexts => {
                Self::cli_repos_remove_status_check_contexts()
            }
            CliCommand::ReposGetAccessRestrictions => Self::cli_repos_get_access_restrictions(),
            CliCommand::ReposDeleteAccessRestrictions => {
                Self::cli_repos_delete_access_restrictions()
            }
            CliCommand::ReposGetAppsWithAccessToProtectedBranch => {
                Self::cli_repos_get_apps_with_access_to_protected_branch()
            }
            CliCommand::ReposSetAppAccessRestrictions => {
                Self::cli_repos_set_app_access_restrictions()
            }
            CliCommand::ReposAddAppAccessRestrictions => {
                Self::cli_repos_add_app_access_restrictions()
            }
            CliCommand::ReposRemoveAppAccessRestrictions => {
                Self::cli_repos_remove_app_access_restrictions()
            }
            CliCommand::ReposGetTeamsWithAccessToProtectedBranch => {
                Self::cli_repos_get_teams_with_access_to_protected_branch()
            }
            CliCommand::ReposSetTeamAccessRestrictions => {
                Self::cli_repos_set_team_access_restrictions()
            }
            CliCommand::ReposAddTeamAccessRestrictions => {
                Self::cli_repos_add_team_access_restrictions()
            }
            CliCommand::ReposRemoveTeamAccessRestrictions => {
                Self::cli_repos_remove_team_access_restrictions()
            }
            CliCommand::ReposGetUsersWithAccessToProtectedBranch => {
                Self::cli_repos_get_users_with_access_to_protected_branch()
            }
            CliCommand::ReposSetUserAccessRestrictions => {
                Self::cli_repos_set_user_access_restrictions()
            }
            CliCommand::ReposAddUserAccessRestrictions => {
                Self::cli_repos_add_user_access_restrictions()
            }
            CliCommand::ReposRemoveUserAccessRestrictions => {
                Self::cli_repos_remove_user_access_restrictions()
            }
            CliCommand::ReposRenameBranch => Self::cli_repos_rename_branch(),
            CliCommand::ChecksCreate => Self::cli_checks_create(),
            CliCommand::ChecksGet => Self::cli_checks_get(),
            CliCommand::ChecksUpdate => Self::cli_checks_update(),
            CliCommand::ChecksListAnnotations => Self::cli_checks_list_annotations(),
            CliCommand::ChecksRerequestRun => Self::cli_checks_rerequest_run(),
            CliCommand::ChecksCreateSuite => Self::cli_checks_create_suite(),
            CliCommand::ChecksSetSuitesPreferences => Self::cli_checks_set_suites_preferences(),
            CliCommand::ChecksGetSuite => Self::cli_checks_get_suite(),
            CliCommand::ChecksListForSuite => Self::cli_checks_list_for_suite(),
            CliCommand::ChecksRerequestSuite => Self::cli_checks_rerequest_suite(),
            CliCommand::CodeScanningListAlertsForRepo => {
                Self::cli_code_scanning_list_alerts_for_repo()
            }
            CliCommand::CodeScanningGetAlert => Self::cli_code_scanning_get_alert(),
            CliCommand::CodeScanningUpdateAlert => Self::cli_code_scanning_update_alert(),
            CliCommand::CodeScanningListAlertInstances => {
                Self::cli_code_scanning_list_alert_instances()
            }
            CliCommand::CodeScanningListRecentAnalyses => {
                Self::cli_code_scanning_list_recent_analyses()
            }
            CliCommand::CodeScanningGetAnalysis => Self::cli_code_scanning_get_analysis(),
            CliCommand::CodeScanningDeleteAnalysis => Self::cli_code_scanning_delete_analysis(),
            CliCommand::CodeScanningListCodeqlDatabases => {
                Self::cli_code_scanning_list_codeql_databases()
            }
            CliCommand::CodeScanningGetCodeqlDatabase => {
                Self::cli_code_scanning_get_codeql_database()
            }
            CliCommand::CodeScanningGetDefaultSetup => Self::cli_code_scanning_get_default_setup(),
            CliCommand::CodeScanningUpdateDefaultSetup => {
                Self::cli_code_scanning_update_default_setup()
            }
            CliCommand::CodeScanningUploadSarif => Self::cli_code_scanning_upload_sarif(),
            CliCommand::CodeScanningGetSarif => Self::cli_code_scanning_get_sarif(),
            CliCommand::ReposCodeownersErrors => Self::cli_repos_codeowners_errors(),
            CliCommand::CodespacesListInRepositoryForAuthenticatedUser => {
                Self::cli_codespaces_list_in_repository_for_authenticated_user()
            }
            CliCommand::CodespacesCreateWithRepoForAuthenticatedUser => {
                Self::cli_codespaces_create_with_repo_for_authenticated_user()
            }
            CliCommand::CodespacesListDevcontainersInRepositoryForAuthenticatedUser => {
                Self::cli_codespaces_list_devcontainers_in_repository_for_authenticated_user()
            }
            CliCommand::CodespacesRepoMachinesForAuthenticatedUser => {
                Self::cli_codespaces_repo_machines_for_authenticated_user()
            }
            CliCommand::CodespacesPreFlightWithRepoForAuthenticatedUser => {
                Self::cli_codespaces_pre_flight_with_repo_for_authenticated_user()
            }
            CliCommand::CodespacesListRepoSecrets => Self::cli_codespaces_list_repo_secrets(),
            CliCommand::CodespacesGetRepoPublicKey => Self::cli_codespaces_get_repo_public_key(),
            CliCommand::CodespacesGetRepoSecret => Self::cli_codespaces_get_repo_secret(),
            CliCommand::CodespacesCreateOrUpdateRepoSecret => {
                Self::cli_codespaces_create_or_update_repo_secret()
            }
            CliCommand::CodespacesDeleteRepoSecret => Self::cli_codespaces_delete_repo_secret(),
            CliCommand::ReposListCollaborators => Self::cli_repos_list_collaborators(),
            CliCommand::ReposCheckCollaborator => Self::cli_repos_check_collaborator(),
            CliCommand::ReposAddCollaborator => Self::cli_repos_add_collaborator(),
            CliCommand::ReposRemoveCollaborator => Self::cli_repos_remove_collaborator(),
            CliCommand::ReposGetCollaboratorPermissionLevel => {
                Self::cli_repos_get_collaborator_permission_level()
            }
            CliCommand::ReposListCommitCommentsForRepo => {
                Self::cli_repos_list_commit_comments_for_repo()
            }
            CliCommand::ReposGetCommitComment => Self::cli_repos_get_commit_comment(),
            CliCommand::ReposDeleteCommitComment => Self::cli_repos_delete_commit_comment(),
            CliCommand::ReposUpdateCommitComment => Self::cli_repos_update_commit_comment(),
            CliCommand::ReactionsListForCommitComment => {
                Self::cli_reactions_list_for_commit_comment()
            }
            CliCommand::ReactionsCreateForCommitComment => {
                Self::cli_reactions_create_for_commit_comment()
            }
            CliCommand::ReactionsDeleteForCommitComment => {
                Self::cli_reactions_delete_for_commit_comment()
            }
            CliCommand::ReposListCommits => Self::cli_repos_list_commits(),
            CliCommand::ReposListBranchesForHeadCommit => {
                Self::cli_repos_list_branches_for_head_commit()
            }
            CliCommand::ReposListCommentsForCommit => Self::cli_repos_list_comments_for_commit(),
            CliCommand::ReposCreateCommitComment => Self::cli_repos_create_commit_comment(),
            CliCommand::ReposListPullRequestsAssociatedWithCommit => {
                Self::cli_repos_list_pull_requests_associated_with_commit()
            }
            CliCommand::ReposGetCommit => Self::cli_repos_get_commit(),
            CliCommand::ChecksListForRef => Self::cli_checks_list_for_ref(),
            CliCommand::ChecksListSuitesForRef => Self::cli_checks_list_suites_for_ref(),
            CliCommand::ReposGetCombinedStatusForRef => {
                Self::cli_repos_get_combined_status_for_ref()
            }
            CliCommand::ReposListCommitStatusesForRef => {
                Self::cli_repos_list_commit_statuses_for_ref()
            }
            CliCommand::ReposGetCommunityProfileMetrics => {
                Self::cli_repos_get_community_profile_metrics()
            }
            CliCommand::ReposCompareCommits => Self::cli_repos_compare_commits(),
            CliCommand::ReposGetContent => Self::cli_repos_get_content(),
            CliCommand::ReposCreateOrUpdateFileContents => {
                Self::cli_repos_create_or_update_file_contents()
            }
            CliCommand::ReposDeleteFile => Self::cli_repos_delete_file(),
            CliCommand::ReposListContributors => Self::cli_repos_list_contributors(),
            CliCommand::DependabotListAlertsForRepo => Self::cli_dependabot_list_alerts_for_repo(),
            CliCommand::DependabotGetAlert => Self::cli_dependabot_get_alert(),
            CliCommand::DependabotUpdateAlert => Self::cli_dependabot_update_alert(),
            CliCommand::DependabotListRepoSecrets => Self::cli_dependabot_list_repo_secrets(),
            CliCommand::DependabotGetRepoPublicKey => Self::cli_dependabot_get_repo_public_key(),
            CliCommand::DependabotGetRepoSecret => Self::cli_dependabot_get_repo_secret(),
            CliCommand::DependabotCreateOrUpdateRepoSecret => {
                Self::cli_dependabot_create_or_update_repo_secret()
            }
            CliCommand::DependabotDeleteRepoSecret => Self::cli_dependabot_delete_repo_secret(),
            CliCommand::DependencyGraphDiffRange => Self::cli_dependency_graph_diff_range(),
            CliCommand::DependencyGraphExportSbom => Self::cli_dependency_graph_export_sbom(),
            CliCommand::DependencyGraphCreateRepositorySnapshot => {
                Self::cli_dependency_graph_create_repository_snapshot()
            }
            CliCommand::ReposListDeployments => Self::cli_repos_list_deployments(),
            CliCommand::ReposCreateDeployment => Self::cli_repos_create_deployment(),
            CliCommand::ReposGetDeployment => Self::cli_repos_get_deployment(),
            CliCommand::ReposDeleteDeployment => Self::cli_repos_delete_deployment(),
            CliCommand::ReposListDeploymentStatuses => Self::cli_repos_list_deployment_statuses(),
            CliCommand::ReposCreateDeploymentStatus => Self::cli_repos_create_deployment_status(),
            CliCommand::ReposGetDeploymentStatus => Self::cli_repos_get_deployment_status(),
            CliCommand::ReposCreateDispatchEvent => Self::cli_repos_create_dispatch_event(),
            CliCommand::ReposGetAllEnvironments => Self::cli_repos_get_all_environments(),
            CliCommand::ReposGetEnvironment => Self::cli_repos_get_environment(),
            CliCommand::ReposCreateOrUpdateEnvironment => {
                Self::cli_repos_create_or_update_environment()
            }
            CliCommand::ReposDeleteAnEnvironment => Self::cli_repos_delete_an_environment(),
            CliCommand::ReposListDeploymentBranchPolicies => {
                Self::cli_repos_list_deployment_branch_policies()
            }
            CliCommand::ReposCreateDeploymentBranchPolicy => {
                Self::cli_repos_create_deployment_branch_policy()
            }
            CliCommand::ReposGetDeploymentBranchPolicy => {
                Self::cli_repos_get_deployment_branch_policy()
            }
            CliCommand::ReposUpdateDeploymentBranchPolicy => {
                Self::cli_repos_update_deployment_branch_policy()
            }
            CliCommand::ReposDeleteDeploymentBranchPolicy => {
                Self::cli_repos_delete_deployment_branch_policy()
            }
            CliCommand::ReposGetAllDeploymentProtectionRules => {
                Self::cli_repos_get_all_deployment_protection_rules()
            }
            CliCommand::ReposCreateDeploymentProtectionRule => {
                Self::cli_repos_create_deployment_protection_rule()
            }
            CliCommand::ReposListCustomDeploymentRuleIntegrations => {
                Self::cli_repos_list_custom_deployment_rule_integrations()
            }
            CliCommand::ReposGetCustomDeploymentProtectionRule => {
                Self::cli_repos_get_custom_deployment_protection_rule()
            }
            CliCommand::ReposDisableDeploymentProtectionRule => {
                Self::cli_repos_disable_deployment_protection_rule()
            }
            CliCommand::ActivityListRepoEvents => Self::cli_activity_list_repo_events(),
            CliCommand::ReposListForks => Self::cli_repos_list_forks(),
            CliCommand::ReposCreateFork => Self::cli_repos_create_fork(),
            CliCommand::GitCreateBlob => Self::cli_git_create_blob(),
            CliCommand::GitGetBlob => Self::cli_git_get_blob(),
            CliCommand::GitCreateCommit => Self::cli_git_create_commit(),
            CliCommand::GitGetCommit => Self::cli_git_get_commit(),
            CliCommand::GitListMatchingRefs => Self::cli_git_list_matching_refs(),
            CliCommand::GitGetRef => Self::cli_git_get_ref(),
            CliCommand::GitCreateRef => Self::cli_git_create_ref(),
            CliCommand::GitDeleteRef => Self::cli_git_delete_ref(),
            CliCommand::GitUpdateRef => Self::cli_git_update_ref(),
            CliCommand::GitCreateTag => Self::cli_git_create_tag(),
            CliCommand::GitGetTag => Self::cli_git_get_tag(),
            CliCommand::GitCreateTree => Self::cli_git_create_tree(),
            CliCommand::GitGetTree => Self::cli_git_get_tree(),
            CliCommand::ReposListWebhooks => Self::cli_repos_list_webhooks(),
            CliCommand::ReposCreateWebhook => Self::cli_repos_create_webhook(),
            CliCommand::ReposGetWebhook => Self::cli_repos_get_webhook(),
            CliCommand::ReposDeleteWebhook => Self::cli_repos_delete_webhook(),
            CliCommand::ReposUpdateWebhook => Self::cli_repos_update_webhook(),
            CliCommand::ReposGetWebhookConfigForRepo => {
                Self::cli_repos_get_webhook_config_for_repo()
            }
            CliCommand::ReposUpdateWebhookConfigForRepo => {
                Self::cli_repos_update_webhook_config_for_repo()
            }
            CliCommand::ReposListWebhookDeliveries => Self::cli_repos_list_webhook_deliveries(),
            CliCommand::ReposGetWebhookDelivery => Self::cli_repos_get_webhook_delivery(),
            CliCommand::ReposRedeliverWebhookDelivery => {
                Self::cli_repos_redeliver_webhook_delivery()
            }
            CliCommand::ReposPingWebhook => Self::cli_repos_ping_webhook(),
            CliCommand::ReposTestPushWebhook => Self::cli_repos_test_push_webhook(),
            CliCommand::MigrationsGetImportStatus => Self::cli_migrations_get_import_status(),
            CliCommand::MigrationsStartImport => Self::cli_migrations_start_import(),
            CliCommand::MigrationsCancelImport => Self::cli_migrations_cancel_import(),
            CliCommand::MigrationsUpdateImport => Self::cli_migrations_update_import(),
            CliCommand::MigrationsGetCommitAuthors => Self::cli_migrations_get_commit_authors(),
            CliCommand::MigrationsMapCommitAuthor => Self::cli_migrations_map_commit_author(),
            CliCommand::MigrationsGetLargeFiles => Self::cli_migrations_get_large_files(),
            CliCommand::MigrationsSetLfsPreference => Self::cli_migrations_set_lfs_preference(),
            CliCommand::AppsGetRepoInstallation => Self::cli_apps_get_repo_installation(),
            CliCommand::InteractionsGetRestrictionsForRepo => {
                Self::cli_interactions_get_restrictions_for_repo()
            }
            CliCommand::InteractionsSetRestrictionsForRepo => {
                Self::cli_interactions_set_restrictions_for_repo()
            }
            CliCommand::InteractionsRemoveRestrictionsForRepo => {
                Self::cli_interactions_remove_restrictions_for_repo()
            }
            CliCommand::ReposListInvitations => Self::cli_repos_list_invitations(),
            CliCommand::ReposDeleteInvitation => Self::cli_repos_delete_invitation(),
            CliCommand::ReposUpdateInvitation => Self::cli_repos_update_invitation(),
            CliCommand::IssuesListForRepo => Self::cli_issues_list_for_repo(),
            CliCommand::IssuesCreate => Self::cli_issues_create(),
            CliCommand::IssuesListCommentsForRepo => Self::cli_issues_list_comments_for_repo(),
            CliCommand::IssuesGetComment => Self::cli_issues_get_comment(),
            CliCommand::IssuesDeleteComment => Self::cli_issues_delete_comment(),
            CliCommand::IssuesUpdateComment => Self::cli_issues_update_comment(),
            CliCommand::ReactionsListForIssueComment => {
                Self::cli_reactions_list_for_issue_comment()
            }
            CliCommand::ReactionsCreateForIssueComment => {
                Self::cli_reactions_create_for_issue_comment()
            }
            CliCommand::ReactionsDeleteForIssueComment => {
                Self::cli_reactions_delete_for_issue_comment()
            }
            CliCommand::IssuesListEventsForRepo => Self::cli_issues_list_events_for_repo(),
            CliCommand::IssuesGetEvent => Self::cli_issues_get_event(),
            CliCommand::IssuesGet => Self::cli_issues_get(),
            CliCommand::IssuesUpdate => Self::cli_issues_update(),
            CliCommand::IssuesAddAssignees => Self::cli_issues_add_assignees(),
            CliCommand::IssuesRemoveAssignees => Self::cli_issues_remove_assignees(),
            CliCommand::IssuesCheckUserCanBeAssignedToIssue => {
                Self::cli_issues_check_user_can_be_assigned_to_issue()
            }
            CliCommand::IssuesListComments => Self::cli_issues_list_comments(),
            CliCommand::IssuesCreateComment => Self::cli_issues_create_comment(),
            CliCommand::IssuesListEvents => Self::cli_issues_list_events(),
            CliCommand::IssuesListLabelsOnIssue => Self::cli_issues_list_labels_on_issue(),
            CliCommand::IssuesSetLabels => Self::cli_issues_set_labels(),
            CliCommand::IssuesAddLabels => Self::cli_issues_add_labels(),
            CliCommand::IssuesRemoveAllLabels => Self::cli_issues_remove_all_labels(),
            CliCommand::IssuesRemoveLabel => Self::cli_issues_remove_label(),
            CliCommand::IssuesLock => Self::cli_issues_lock(),
            CliCommand::IssuesUnlock => Self::cli_issues_unlock(),
            CliCommand::ReactionsListForIssue => Self::cli_reactions_list_for_issue(),
            CliCommand::ReactionsCreateForIssue => Self::cli_reactions_create_for_issue(),
            CliCommand::ReactionsDeleteForIssue => Self::cli_reactions_delete_for_issue(),
            CliCommand::IssuesListEventsForTimeline => Self::cli_issues_list_events_for_timeline(),
            CliCommand::ReposListDeployKeys => Self::cli_repos_list_deploy_keys(),
            CliCommand::ReposCreateDeployKey => Self::cli_repos_create_deploy_key(),
            CliCommand::ReposGetDeployKey => Self::cli_repos_get_deploy_key(),
            CliCommand::ReposDeleteDeployKey => Self::cli_repos_delete_deploy_key(),
            CliCommand::IssuesListLabelsForRepo => Self::cli_issues_list_labels_for_repo(),
            CliCommand::IssuesCreateLabel => Self::cli_issues_create_label(),
            CliCommand::IssuesGetLabel => Self::cli_issues_get_label(),
            CliCommand::IssuesDeleteLabel => Self::cli_issues_delete_label(),
            CliCommand::IssuesUpdateLabel => Self::cli_issues_update_label(),
            CliCommand::ReposListLanguages => Self::cli_repos_list_languages(),
            CliCommand::ReposEnableLfsForRepo => Self::cli_repos_enable_lfs_for_repo(),
            CliCommand::ReposDisableLfsForRepo => Self::cli_repos_disable_lfs_for_repo(),
            CliCommand::LicensesGetForRepo => Self::cli_licenses_get_for_repo(),
            CliCommand::ReposMergeUpstream => Self::cli_repos_merge_upstream(),
            CliCommand::ReposMerge => Self::cli_repos_merge(),
            CliCommand::IssuesListMilestones => Self::cli_issues_list_milestones(),
            CliCommand::IssuesCreateMilestone => Self::cli_issues_create_milestone(),
            CliCommand::IssuesGetMilestone => Self::cli_issues_get_milestone(),
            CliCommand::IssuesDeleteMilestone => Self::cli_issues_delete_milestone(),
            CliCommand::IssuesUpdateMilestone => Self::cli_issues_update_milestone(),
            CliCommand::IssuesListLabelsForMilestone => {
                Self::cli_issues_list_labels_for_milestone()
            }
            CliCommand::ActivityListRepoNotificationsForAuthenticatedUser => {
                Self::cli_activity_list_repo_notifications_for_authenticated_user()
            }
            CliCommand::ActivityMarkRepoNotificationsAsRead => {
                Self::cli_activity_mark_repo_notifications_as_read()
            }
            CliCommand::ReposGetPages => Self::cli_repos_get_pages(),
            CliCommand::ReposUpdateInformationAboutPagesSite => {
                Self::cli_repos_update_information_about_pages_site()
            }
            CliCommand::ReposCreatePagesSite => Self::cli_repos_create_pages_site(),
            CliCommand::ReposDeletePagesSite => Self::cli_repos_delete_pages_site(),
            CliCommand::ReposListPagesBuilds => Self::cli_repos_list_pages_builds(),
            CliCommand::ReposRequestPagesBuild => Self::cli_repos_request_pages_build(),
            CliCommand::ReposGetLatestPagesBuild => Self::cli_repos_get_latest_pages_build(),
            CliCommand::ReposGetPagesBuild => Self::cli_repos_get_pages_build(),
            CliCommand::ReposCreatePagesDeployment => Self::cli_repos_create_pages_deployment(),
            CliCommand::ReposGetPagesHealthCheck => Self::cli_repos_get_pages_health_check(),
            CliCommand::ProjectsListForRepo => Self::cli_projects_list_for_repo(),
            CliCommand::ProjectsCreateForRepo => Self::cli_projects_create_for_repo(),
            CliCommand::PullsList => Self::cli_pulls_list(),
            CliCommand::PullsCreate => Self::cli_pulls_create(),
            CliCommand::PullsListReviewCommentsForRepo => {
                Self::cli_pulls_list_review_comments_for_repo()
            }
            CliCommand::PullsGetReviewComment => Self::cli_pulls_get_review_comment(),
            CliCommand::PullsDeleteReviewComment => Self::cli_pulls_delete_review_comment(),
            CliCommand::PullsUpdateReviewComment => Self::cli_pulls_update_review_comment(),
            CliCommand::ReactionsListForPullRequestReviewComment => {
                Self::cli_reactions_list_for_pull_request_review_comment()
            }
            CliCommand::ReactionsCreateForPullRequestReviewComment => {
                Self::cli_reactions_create_for_pull_request_review_comment()
            }
            CliCommand::ReactionsDeleteForPullRequestComment => {
                Self::cli_reactions_delete_for_pull_request_comment()
            }
            CliCommand::PullsGet => Self::cli_pulls_get(),
            CliCommand::PullsUpdate => Self::cli_pulls_update(),
            CliCommand::CodespacesCreateWithPrForAuthenticatedUser => {
                Self::cli_codespaces_create_with_pr_for_authenticated_user()
            }
            CliCommand::PullsListReviewComments => Self::cli_pulls_list_review_comments(),
            CliCommand::PullsCreateReviewComment => Self::cli_pulls_create_review_comment(),
            CliCommand::PullsCreateReplyForReviewComment => {
                Self::cli_pulls_create_reply_for_review_comment()
            }
            CliCommand::PullsListCommits => Self::cli_pulls_list_commits(),
            CliCommand::PullsListFiles => Self::cli_pulls_list_files(),
            CliCommand::PullsCheckIfMerged => Self::cli_pulls_check_if_merged(),
            CliCommand::PullsMerge => Self::cli_pulls_merge(),
            CliCommand::PullsListRequestedReviewers => Self::cli_pulls_list_requested_reviewers(),
            CliCommand::PullsRequestReviewers => Self::cli_pulls_request_reviewers(),
            CliCommand::PullsRemoveRequestedReviewers => {
                Self::cli_pulls_remove_requested_reviewers()
            }
            CliCommand::PullsListReviews => Self::cli_pulls_list_reviews(),
            CliCommand::PullsCreateReview => Self::cli_pulls_create_review(),
            CliCommand::PullsGetReview => Self::cli_pulls_get_review(),
            CliCommand::PullsUpdateReview => Self::cli_pulls_update_review(),
            CliCommand::PullsDeletePendingReview => Self::cli_pulls_delete_pending_review(),
            CliCommand::PullsListCommentsForReview => Self::cli_pulls_list_comments_for_review(),
            CliCommand::PullsDismissReview => Self::cli_pulls_dismiss_review(),
            CliCommand::PullsSubmitReview => Self::cli_pulls_submit_review(),
            CliCommand::PullsUpdateBranch => Self::cli_pulls_update_branch(),
            CliCommand::ReposGetReadme => Self::cli_repos_get_readme(),
            CliCommand::ReposGetReadmeInDirectory => Self::cli_repos_get_readme_in_directory(),
            CliCommand::ActivityListReposWatchedByUser => {
                Self::cli_activity_list_repos_watched_by_user()
            }
            CliCommand::ReposGetReleaseAsset => Self::cli_repos_get_release_asset(),
            CliCommand::ReposDeleteReleaseAsset => Self::cli_repos_delete_release_asset(),
            CliCommand::ReposUpdateReleaseAsset => Self::cli_repos_update_release_asset(),
            CliCommand::ReposGenerateReleaseNotes => Self::cli_repos_generate_release_notes(),
            CliCommand::ReposGetLatestRelease => Self::cli_repos_get_latest_release(),
            CliCommand::ReposGetReleaseByTag => Self::cli_repos_get_release_by_tag(),
            CliCommand::ActivityListReposStarredByUser => {
                Self::cli_activity_list_repos_starred_by_user()
            }
            CliCommand::ReposListReleaseAssets => Self::cli_repos_list_release_assets(),
            CliCommand::ReposUploadReleaseAsset => Self::cli_repos_upload_release_asset(),
            CliCommand::ReactionsListForRelease => Self::cli_reactions_list_for_release(),
            CliCommand::ReactionsCreateForRelease => Self::cli_reactions_create_for_release(),
            CliCommand::ReactionsDeleteForRelease => Self::cli_reactions_delete_for_release(),
            CliCommand::ReposGetBranchRules => Self::cli_repos_get_branch_rules(),
            CliCommand::ReposGetRepoRulesets => Self::cli_repos_get_repo_rulesets(),
            CliCommand::ReposCreateRepoRuleset => Self::cli_repos_create_repo_ruleset(),
            CliCommand::ReposGetRepoRuleset => Self::cli_repos_get_repo_ruleset(),
            CliCommand::ReposUpdateRepoRuleset => Self::cli_repos_update_repo_ruleset(),
            CliCommand::ReposDeleteRepoRuleset => Self::cli_repos_delete_repo_ruleset(),
            CliCommand::SecretScanningListAlertsForRepo => {
                Self::cli_secret_scanning_list_alerts_for_repo()
            }
            CliCommand::SecretScanningGetAlert => Self::cli_secret_scanning_get_alert(),
            CliCommand::SecretScanningUpdateAlert => Self::cli_secret_scanning_update_alert(),
            CliCommand::SecretScanningListLocationsForAlert => {
                Self::cli_secret_scanning_list_locations_for_alert()
            }
            CliCommand::SecurityAdvisoriesListRepositoryAdvisories => {
                Self::cli_security_advisories_list_repository_advisories()
            }
            CliCommand::SecurityAdvisoriesCreateRepositoryAdvisory => {
                Self::cli_security_advisories_create_repository_advisory()
            }
            CliCommand::SecurityAdvisoriesCreatePrivateVulnerabilityReport => {
                Self::cli_security_advisories_create_private_vulnerability_report()
            }
            CliCommand::SecurityAdvisoriesGetRepositoryAdvisory => {
                Self::cli_security_advisories_get_repository_advisory()
            }
            CliCommand::SecurityAdvisoriesUpdateRepositoryAdvisory => {
                Self::cli_security_advisories_update_repository_advisory()
            }
            CliCommand::ActivityListStargazersForRepo => {
                Self::cli_activity_list_stargazers_for_repo()
            }
            CliCommand::ReposGetCodeFrequencyStats => Self::cli_repos_get_code_frequency_stats(),
            CliCommand::ReposGetCommitActivityStats => Self::cli_repos_get_commit_activity_stats(),
            CliCommand::ReposGetContributorsStats => Self::cli_repos_get_contributors_stats(),
            CliCommand::ReposGetParticipationStats => Self::cli_repos_get_participation_stats(),
            CliCommand::ReposGetPunchCardStats => Self::cli_repos_get_punch_card_stats(),
            CliCommand::ReposCreateCommitStatus => Self::cli_repos_create_commit_status(),
            CliCommand::ActivityListWatchersForRepo => Self::cli_activity_list_watchers_for_repo(),
            CliCommand::ActivityGetRepoSubscription => Self::cli_activity_get_repo_subscription(),
            CliCommand::ActivitySetRepoSubscription => Self::cli_activity_set_repo_subscription(),
            CliCommand::ActivityDeleteRepoSubscription => {
                Self::cli_activity_delete_repo_subscription()
            }
            CliCommand::ReposListTags => Self::cli_repos_list_tags(),
            CliCommand::ReposListTagProtection => Self::cli_repos_list_tag_protection(),
            CliCommand::ReposCreateTagProtection => Self::cli_repos_create_tag_protection(),
            CliCommand::ReposDeleteTagProtection => Self::cli_repos_delete_tag_protection(),
            CliCommand::ReposDownloadTarballArchive => Self::cli_repos_download_tarball_archive(),
            CliCommand::ReposListTeams => Self::cli_repos_list_teams(),
            CliCommand::ReposGetAllTopics => Self::cli_repos_get_all_topics(),
            CliCommand::ReposReplaceAllTopics => Self::cli_repos_replace_all_topics(),
            CliCommand::ReposGetClones => Self::cli_repos_get_clones(),
            CliCommand::ReposGetTopPaths => Self::cli_repos_get_top_paths(),
            CliCommand::ReposGetTopReferrers => Self::cli_repos_get_top_referrers(),
            CliCommand::ReposGetViews => Self::cli_repos_get_views(),
            CliCommand::ReposTransfer => Self::cli_repos_transfer(),
            CliCommand::ReposCheckVulnerabilityAlerts => {
                Self::cli_repos_check_vulnerability_alerts()
            }
            CliCommand::ReposEnableVulnerabilityAlerts => {
                Self::cli_repos_enable_vulnerability_alerts()
            }
            CliCommand::ReposDisableVulnerabilityAlerts => {
                Self::cli_repos_disable_vulnerability_alerts()
            }
            CliCommand::ReposDownloadZipballArchive => Self::cli_repos_download_zipball_archive(),
            CliCommand::ReposCreateUsingTemplate => Self::cli_repos_create_using_template(),
            CliCommand::ReposListPublic => Self::cli_repos_list_public(),
            CliCommand::ActionsListEnvironmentSecrets => {
                Self::cli_actions_list_environment_secrets()
            }
            CliCommand::ActionsGetEnvironmentPublicKey => {
                Self::cli_actions_get_environment_public_key()
            }
            CliCommand::ActionsGetEnvironmentSecret => Self::cli_actions_get_environment_secret(),
            CliCommand::ActionsCreateOrUpdateEnvironmentSecret => {
                Self::cli_actions_create_or_update_environment_secret()
            }
            CliCommand::ActionsDeleteEnvironmentSecret => {
                Self::cli_actions_delete_environment_secret()
            }
            CliCommand::ActionsListEnvironmentVariables => {
                Self::cli_actions_list_environment_variables()
            }
            CliCommand::ActionsCreateEnvironmentVariable => {
                Self::cli_actions_create_environment_variable()
            }
            CliCommand::ActionsGetEnvironmentVariable => {
                Self::cli_actions_get_environment_variable()
            }
            CliCommand::ActionsDeleteEnvironmentVariable => {
                Self::cli_actions_delete_environment_variable()
            }
            CliCommand::ActionsUpdateEnvironmentVariable => {
                Self::cli_actions_update_environment_variable()
            }
            CliCommand::SearchCode => Self::cli_search_code(),
            CliCommand::SearchCommits => Self::cli_search_commits(),
            CliCommand::SearchIssuesAndPullRequests => Self::cli_search_issues_and_pull_requests(),
            CliCommand::SearchLabels => Self::cli_search_labels(),
            CliCommand::SearchRepos => Self::cli_search_repos(),
            CliCommand::SearchTopics => Self::cli_search_topics(),
            CliCommand::SearchUsers => Self::cli_search_users(),
            CliCommand::TeamsGetLegacy => Self::cli_teams_get_legacy(),
            CliCommand::TeamsDeleteLegacy => Self::cli_teams_delete_legacy(),
            CliCommand::TeamsUpdateLegacy => Self::cli_teams_update_legacy(),
            CliCommand::TeamsListDiscussionsLegacy => Self::cli_teams_list_discussions_legacy(),
            CliCommand::TeamsCreateDiscussionLegacy => Self::cli_teams_create_discussion_legacy(),
            CliCommand::TeamsGetDiscussionLegacy => Self::cli_teams_get_discussion_legacy(),
            CliCommand::TeamsDeleteDiscussionLegacy => Self::cli_teams_delete_discussion_legacy(),
            CliCommand::TeamsUpdateDiscussionLegacy => Self::cli_teams_update_discussion_legacy(),
            CliCommand::TeamsListDiscussionCommentsLegacy => {
                Self::cli_teams_list_discussion_comments_legacy()
            }
            CliCommand::TeamsCreateDiscussionCommentLegacy => {
                Self::cli_teams_create_discussion_comment_legacy()
            }
            CliCommand::TeamsGetDiscussionCommentLegacy => {
                Self::cli_teams_get_discussion_comment_legacy()
            }
            CliCommand::TeamsDeleteDiscussionCommentLegacy => {
                Self::cli_teams_delete_discussion_comment_legacy()
            }
            CliCommand::TeamsUpdateDiscussionCommentLegacy => {
                Self::cli_teams_update_discussion_comment_legacy()
            }
            CliCommand::ReactionsListForTeamDiscussionCommentLegacy => {
                Self::cli_reactions_list_for_team_discussion_comment_legacy()
            }
            CliCommand::ReactionsCreateForTeamDiscussionCommentLegacy => {
                Self::cli_reactions_create_for_team_discussion_comment_legacy()
            }
            CliCommand::ReactionsListForTeamDiscussionLegacy => {
                Self::cli_reactions_list_for_team_discussion_legacy()
            }
            CliCommand::ReactionsCreateForTeamDiscussionLegacy => {
                Self::cli_reactions_create_for_team_discussion_legacy()
            }
            CliCommand::TeamsListPendingInvitationsLegacy => {
                Self::cli_teams_list_pending_invitations_legacy()
            }
            CliCommand::TeamsListMembersLegacy => Self::cli_teams_list_members_legacy(),
            CliCommand::TeamsGetMemberLegacy => Self::cli_teams_get_member_legacy(),
            CliCommand::TeamsAddMemberLegacy => Self::cli_teams_add_member_legacy(),
            CliCommand::TeamsRemoveMemberLegacy => Self::cli_teams_remove_member_legacy(),
            CliCommand::TeamsGetMembershipForUserLegacy => {
                Self::cli_teams_get_membership_for_user_legacy()
            }
            CliCommand::TeamsAddOrUpdateMembershipForUserLegacy => {
                Self::cli_teams_add_or_update_membership_for_user_legacy()
            }
            CliCommand::TeamsRemoveMembershipForUserLegacy => {
                Self::cli_teams_remove_membership_for_user_legacy()
            }
            CliCommand::TeamsListProjectsLegacy => Self::cli_teams_list_projects_legacy(),
            CliCommand::TeamsCheckPermissionsForProjectLegacy => {
                Self::cli_teams_check_permissions_for_project_legacy()
            }
            CliCommand::TeamsAddOrUpdateProjectPermissionsLegacy => {
                Self::cli_teams_add_or_update_project_permissions_legacy()
            }
            CliCommand::TeamsRemoveProjectLegacy => Self::cli_teams_remove_project_legacy(),
            CliCommand::TeamsListReposLegacy => Self::cli_teams_list_repos_legacy(),
            CliCommand::TeamsCheckPermissionsForRepoLegacy => {
                Self::cli_teams_check_permissions_for_repo_legacy()
            }
            CliCommand::TeamsAddOrUpdateRepoPermissionsLegacy => {
                Self::cli_teams_add_or_update_repo_permissions_legacy()
            }
            CliCommand::TeamsRemoveRepoLegacy => Self::cli_teams_remove_repo_legacy(),
            CliCommand::TeamsListChildLegacy => Self::cli_teams_list_child_legacy(),
            CliCommand::UsersGetAuthenticated => Self::cli_users_get_authenticated(),
            CliCommand::UsersUpdateAuthenticated => Self::cli_users_update_authenticated(),
            CliCommand::UsersListBlockedByAuthenticatedUser => {
                Self::cli_users_list_blocked_by_authenticated_user()
            }
            CliCommand::UsersCheckBlocked => Self::cli_users_check_blocked(),
            CliCommand::UsersBlock => Self::cli_users_block(),
            CliCommand::UsersUnblock => Self::cli_users_unblock(),
            CliCommand::CodespacesListForAuthenticatedUser => {
                Self::cli_codespaces_list_for_authenticated_user()
            }
            CliCommand::CodespacesCreateForAuthenticatedUser => {
                Self::cli_codespaces_create_for_authenticated_user()
            }
            CliCommand::CodespacesListSecretsForAuthenticatedUser => {
                Self::cli_codespaces_list_secrets_for_authenticated_user()
            }
            CliCommand::CodespacesGetPublicKeyForAuthenticatedUser => {
                Self::cli_codespaces_get_public_key_for_authenticated_user()
            }
            CliCommand::CodespacesGetSecretForAuthenticatedUser => {
                Self::cli_codespaces_get_secret_for_authenticated_user()
            }
            CliCommand::CodespacesCreateOrUpdateSecretForAuthenticatedUser => {
                Self::cli_codespaces_create_or_update_secret_for_authenticated_user()
            }
            CliCommand::CodespacesDeleteSecretForAuthenticatedUser => {
                Self::cli_codespaces_delete_secret_for_authenticated_user()
            }
            CliCommand::CodespacesListRepositoriesForSecretForAuthenticatedUser => {
                Self::cli_codespaces_list_repositories_for_secret_for_authenticated_user()
            }
            CliCommand::CodespacesSetRepositoriesForSecretForAuthenticatedUser => {
                Self::cli_codespaces_set_repositories_for_secret_for_authenticated_user()
            }
            CliCommand::CodespacesAddRepositoryForSecretForAuthenticatedUser => {
                Self::cli_codespaces_add_repository_for_secret_for_authenticated_user()
            }
            CliCommand::CodespacesRemoveRepositoryForSecretForAuthenticatedUser => {
                Self::cli_codespaces_remove_repository_for_secret_for_authenticated_user()
            }
            CliCommand::CodespacesGetForAuthenticatedUser => {
                Self::cli_codespaces_get_for_authenticated_user()
            }
            CliCommand::CodespacesDeleteForAuthenticatedUser => {
                Self::cli_codespaces_delete_for_authenticated_user()
            }
            CliCommand::CodespacesUpdateForAuthenticatedUser => {
                Self::cli_codespaces_update_for_authenticated_user()
            }
            CliCommand::CodespacesExportForAuthenticatedUser => {
                Self::cli_codespaces_export_for_authenticated_user()
            }
            CliCommand::CodespacesGetExportDetailsForAuthenticatedUser => {
                Self::cli_codespaces_get_export_details_for_authenticated_user()
            }
            CliCommand::CodespacesCodespaceMachinesForAuthenticatedUser => {
                Self::cli_codespaces_codespace_machines_for_authenticated_user()
            }
            CliCommand::CodespacesPublishForAuthenticatedUser => {
                Self::cli_codespaces_publish_for_authenticated_user()
            }
            CliCommand::CodespacesStartForAuthenticatedUser => {
                Self::cli_codespaces_start_for_authenticated_user()
            }
            CliCommand::CodespacesStopForAuthenticatedUser => {
                Self::cli_codespaces_stop_for_authenticated_user()
            }
            CliCommand::PackagesListDockerMigrationConflictingPackagesForAuthenticatedUser => {
                Self::cli_packages_list_docker_migration_conflicting_packages_for_authenticated_user(
                )
            }
            CliCommand::UsersSetPrimaryEmailVisibilityForAuthenticatedUser => {
                Self::cli_users_set_primary_email_visibility_for_authenticated_user()
            }
            CliCommand::UsersListEmailsForAuthenticatedUser => {
                Self::cli_users_list_emails_for_authenticated_user()
            }
            CliCommand::UsersAddEmailForAuthenticatedUser => {
                Self::cli_users_add_email_for_authenticated_user()
            }
            CliCommand::UsersDeleteEmailForAuthenticatedUser => {
                Self::cli_users_delete_email_for_authenticated_user()
            }
            CliCommand::UsersListFollowersForAuthenticatedUser => {
                Self::cli_users_list_followers_for_authenticated_user()
            }
            CliCommand::UsersListFollowedByAuthenticatedUser => {
                Self::cli_users_list_followed_by_authenticated_user()
            }
            CliCommand::UsersCheckPersonIsFollowedByAuthenticated => {
                Self::cli_users_check_person_is_followed_by_authenticated()
            }
            CliCommand::UsersFollow => Self::cli_users_follow(),
            CliCommand::UsersUnfollow => Self::cli_users_unfollow(),
            CliCommand::UsersListGpgKeysForAuthenticatedUser => {
                Self::cli_users_list_gpg_keys_for_authenticated_user()
            }
            CliCommand::UsersCreateGpgKeyForAuthenticatedUser => {
                Self::cli_users_create_gpg_key_for_authenticated_user()
            }
            CliCommand::UsersGetGpgKeyForAuthenticatedUser => {
                Self::cli_users_get_gpg_key_for_authenticated_user()
            }
            CliCommand::UsersDeleteGpgKeyForAuthenticatedUser => {
                Self::cli_users_delete_gpg_key_for_authenticated_user()
            }
            CliCommand::AppsListInstallationsForAuthenticatedUser => {
                Self::cli_apps_list_installations_for_authenticated_user()
            }
            CliCommand::AppsListInstallationReposForAuthenticatedUser => {
                Self::cli_apps_list_installation_repos_for_authenticated_user()
            }
            CliCommand::AppsAddRepoToInstallationForAuthenticatedUser => {
                Self::cli_apps_add_repo_to_installation_for_authenticated_user()
            }
            CliCommand::AppsRemoveRepoFromInstallationForAuthenticatedUser => {
                Self::cli_apps_remove_repo_from_installation_for_authenticated_user()
            }
            CliCommand::InteractionsGetRestrictionsForAuthenticatedUser => {
                Self::cli_interactions_get_restrictions_for_authenticated_user()
            }
            CliCommand::InteractionsSetRestrictionsForAuthenticatedUser => {
                Self::cli_interactions_set_restrictions_for_authenticated_user()
            }
            CliCommand::InteractionsRemoveRestrictionsForAuthenticatedUser => {
                Self::cli_interactions_remove_restrictions_for_authenticated_user()
            }
            CliCommand::IssuesListForAuthenticatedUser => {
                Self::cli_issues_list_for_authenticated_user()
            }
            CliCommand::UsersListPublicSshKeysForAuthenticatedUser => {
                Self::cli_users_list_public_ssh_keys_for_authenticated_user()
            }
            CliCommand::UsersCreatePublicSshKeyForAuthenticatedUser => {
                Self::cli_users_create_public_ssh_key_for_authenticated_user()
            }
            CliCommand::UsersGetPublicSshKeyForAuthenticatedUser => {
                Self::cli_users_get_public_ssh_key_for_authenticated_user()
            }
            CliCommand::UsersDeletePublicSshKeyForAuthenticatedUser => {
                Self::cli_users_delete_public_ssh_key_for_authenticated_user()
            }
            CliCommand::AppsListSubscriptionsForAuthenticatedUser => {
                Self::cli_apps_list_subscriptions_for_authenticated_user()
            }
            CliCommand::AppsListSubscriptionsForAuthenticatedUserStubbed => {
                Self::cli_apps_list_subscriptions_for_authenticated_user_stubbed()
            }
            CliCommand::OrgsListMembershipsForAuthenticatedUser => {
                Self::cli_orgs_list_memberships_for_authenticated_user()
            }
            CliCommand::OrgsGetMembershipForAuthenticatedUser => {
                Self::cli_orgs_get_membership_for_authenticated_user()
            }
            CliCommand::OrgsUpdateMembershipForAuthenticatedUser => {
                Self::cli_orgs_update_membership_for_authenticated_user()
            }
            CliCommand::MigrationsListForAuthenticatedUser => {
                Self::cli_migrations_list_for_authenticated_user()
            }
            CliCommand::MigrationsStartForAuthenticatedUser => {
                Self::cli_migrations_start_for_authenticated_user()
            }
            CliCommand::MigrationsGetStatusForAuthenticatedUser => {
                Self::cli_migrations_get_status_for_authenticated_user()
            }
            CliCommand::MigrationsGetArchiveForAuthenticatedUser => {
                Self::cli_migrations_get_archive_for_authenticated_user()
            }
            CliCommand::MigrationsDeleteArchiveForAuthenticatedUser => {
                Self::cli_migrations_delete_archive_for_authenticated_user()
            }
            CliCommand::MigrationsUnlockRepoForAuthenticatedUser => {
                Self::cli_migrations_unlock_repo_for_authenticated_user()
            }
            CliCommand::MigrationsListReposForAuthenticatedUser => {
                Self::cli_migrations_list_repos_for_authenticated_user()
            }
            CliCommand::OrgsListForAuthenticatedUser => {
                Self::cli_orgs_list_for_authenticated_user()
            }
            CliCommand::PackagesListPackagesForAuthenticatedUser => {
                Self::cli_packages_list_packages_for_authenticated_user()
            }
            CliCommand::PackagesGetPackageForAuthenticatedUser => {
                Self::cli_packages_get_package_for_authenticated_user()
            }
            CliCommand::PackagesDeletePackageForAuthenticatedUser => {
                Self::cli_packages_delete_package_for_authenticated_user()
            }
            CliCommand::PackagesRestorePackageForAuthenticatedUser => {
                Self::cli_packages_restore_package_for_authenticated_user()
            }
            CliCommand::PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser => {
                Self::cli_packages_get_all_package_versions_for_package_owned_by_authenticated_user(
                )
            }
            CliCommand::PackagesGetPackageVersionForAuthenticatedUser => {
                Self::cli_packages_get_package_version_for_authenticated_user()
            }
            CliCommand::PackagesDeletePackageVersionForAuthenticatedUser => {
                Self::cli_packages_delete_package_version_for_authenticated_user()
            }
            CliCommand::PackagesRestorePackageVersionForAuthenticatedUser => {
                Self::cli_packages_restore_package_version_for_authenticated_user()
            }
            CliCommand::ProjectsCreateForAuthenticatedUser => {
                Self::cli_projects_create_for_authenticated_user()
            }
            CliCommand::UsersListPublicEmailsForAuthenticatedUser => {
                Self::cli_users_list_public_emails_for_authenticated_user()
            }
            CliCommand::ReposListForAuthenticatedUser => {
                Self::cli_repos_list_for_authenticated_user()
            }
            CliCommand::ReposCreateForAuthenticatedUser => {
                Self::cli_repos_create_for_authenticated_user()
            }
            CliCommand::ReposListInvitationsForAuthenticatedUser => {
                Self::cli_repos_list_invitations_for_authenticated_user()
            }
            CliCommand::ReposDeclineInvitationForAuthenticatedUser => {
                Self::cli_repos_decline_invitation_for_authenticated_user()
            }
            CliCommand::ReposAcceptInvitationForAuthenticatedUser => {
                Self::cli_repos_accept_invitation_for_authenticated_user()
            }
            CliCommand::UsersListSocialAccountsForAuthenticatedUser => {
                Self::cli_users_list_social_accounts_for_authenticated_user()
            }
            CliCommand::UsersAddSocialAccountForAuthenticatedUser => {
                Self::cli_users_add_social_account_for_authenticated_user()
            }
            CliCommand::UsersDeleteSocialAccountForAuthenticatedUser => {
                Self::cli_users_delete_social_account_for_authenticated_user()
            }
            CliCommand::UsersListSshSigningKeysForAuthenticatedUser => {
                Self::cli_users_list_ssh_signing_keys_for_authenticated_user()
            }
            CliCommand::UsersCreateSshSigningKeyForAuthenticatedUser => {
                Self::cli_users_create_ssh_signing_key_for_authenticated_user()
            }
            CliCommand::UsersGetSshSigningKeyForAuthenticatedUser => {
                Self::cli_users_get_ssh_signing_key_for_authenticated_user()
            }
            CliCommand::UsersDeleteSshSigningKeyForAuthenticatedUser => {
                Self::cli_users_delete_ssh_signing_key_for_authenticated_user()
            }
            CliCommand::ActivityListReposStarredByAuthenticatedUser => {
                Self::cli_activity_list_repos_starred_by_authenticated_user()
            }
            CliCommand::ActivityCheckRepoIsStarredByAuthenticatedUser => {
                Self::cli_activity_check_repo_is_starred_by_authenticated_user()
            }
            CliCommand::ActivityStarRepoForAuthenticatedUser => {
                Self::cli_activity_star_repo_for_authenticated_user()
            }
            CliCommand::ActivityUnstarRepoForAuthenticatedUser => {
                Self::cli_activity_unstar_repo_for_authenticated_user()
            }
            CliCommand::ActivityListWatchedReposForAuthenticatedUser => {
                Self::cli_activity_list_watched_repos_for_authenticated_user()
            }
            CliCommand::TeamsListForAuthenticatedUser => {
                Self::cli_teams_list_for_authenticated_user()
            }
            CliCommand::UsersList => Self::cli_users_list(),
            CliCommand::UsersGetByUsername => Self::cli_users_get_by_username(),
            CliCommand::PackagesListDockerMigrationConflictingPackagesForUser => {
                Self::cli_packages_list_docker_migration_conflicting_packages_for_user()
            }
            CliCommand::ActivityListEventsForAuthenticatedUser => {
                Self::cli_activity_list_events_for_authenticated_user()
            }
            CliCommand::ActivityListOrgEventsForAuthenticatedUser => {
                Self::cli_activity_list_org_events_for_authenticated_user()
            }
            CliCommand::ActivityListPublicEventsForUser => {
                Self::cli_activity_list_public_events_for_user()
            }
            CliCommand::UsersListFollowersForUser => Self::cli_users_list_followers_for_user(),
            CliCommand::UsersListFollowingForUser => Self::cli_users_list_following_for_user(),
            CliCommand::UsersCheckFollowingForUser => Self::cli_users_check_following_for_user(),
            CliCommand::GistsListForUser => Self::cli_gists_list_for_user(),
            CliCommand::UsersListGpgKeysForUser => Self::cli_users_list_gpg_keys_for_user(),
            CliCommand::UsersGetContextForUser => Self::cli_users_get_context_for_user(),
            CliCommand::AppsGetUserInstallation => Self::cli_apps_get_user_installation(),
            CliCommand::UsersListPublicKeysForUser => Self::cli_users_list_public_keys_for_user(),
            CliCommand::OrgsListForUser => Self::cli_orgs_list_for_user(),
            CliCommand::PackagesListPackagesForUser => Self::cli_packages_list_packages_for_user(),
            CliCommand::PackagesGetPackageForUser => Self::cli_packages_get_package_for_user(),
            CliCommand::PackagesDeletePackageForUser => {
                Self::cli_packages_delete_package_for_user()
            }
            CliCommand::PackagesRestorePackageForUser => {
                Self::cli_packages_restore_package_for_user()
            }
            CliCommand::PackagesGetAllPackageVersionsForPackageOwnedByUser => {
                Self::cli_packages_get_all_package_versions_for_package_owned_by_user()
            }
            CliCommand::PackagesGetPackageVersionForUser => {
                Self::cli_packages_get_package_version_for_user()
            }
            CliCommand::PackagesDeletePackageVersionForUser => {
                Self::cli_packages_delete_package_version_for_user()
            }
            CliCommand::PackagesRestorePackageVersionForUser => {
                Self::cli_packages_restore_package_version_for_user()
            }
            CliCommand::ProjectsListForUser => Self::cli_projects_list_for_user(),
            CliCommand::ActivityListReceivedEventsForUser => {
                Self::cli_activity_list_received_events_for_user()
            }
            CliCommand::ActivityListReceivedPublicEventsForUser => {
                Self::cli_activity_list_received_public_events_for_user()
            }
            CliCommand::ReposListForUser => Self::cli_repos_list_for_user(),
            CliCommand::BillingGetGithubActionsBillingUser => {
                Self::cli_billing_get_github_actions_billing_user()
            }
            CliCommand::BillingGetGithubPackagesBillingUser => {
                Self::cli_billing_get_github_packages_billing_user()
            }
            CliCommand::BillingGetSharedStorageBillingUser => {
                Self::cli_billing_get_shared_storage_billing_user()
            }
            CliCommand::UsersListSocialAccountsForUser => {
                Self::cli_users_list_social_accounts_for_user()
            }
        }
    }

    pub fn cli_meta_root() -> clap::Command {
        clap::Command::new("").about(
            "GitHub API Root\n\nGet Hypermedia links to resources accessible in GitHub's REST API",
        )
    }

    pub fn cli_apps_get_authenticated() -> clap::Command {
        clap :: Command :: new ("") . about ("Get the authenticated app\n\nReturns the GitHub App associated with the authentication credentials used. To see how many app installations are associated with this GitHub App, see the `installations_count` in the response. For more details about your app's installations, see the \"[List installations for the authenticated app](https://docs.github.com/rest/reference/apps#list-installations-for-the-authenticated-app)\" endpoint.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_apps_create_from_manifest() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("code") . long ("code") . required (true) . value_parser (clap :: value_parser ! (String))) . about ("Create a GitHub App from a manifest\n\nUse this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/). When you create a GitHub App with the manifest flow, you receive a temporary `code` used to retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.")
    }

    pub fn cli_apps_get_webhook_config_for_app() -> clap::Command {
        clap :: Command :: new ("") . about ("Get a webhook configuration for an app\n\nReturns the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see \"[Creating a GitHub App](/developers/apps/creating-a-github-app).\"\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_apps_update_webhook_config_for_app() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("content-type") . long ("content-type") . required (false) . value_parser (clap :: value_parser ! (types :: WebhookConfigContentType))) . arg (clap :: Arg :: new ("insecure-ssl") . long ("insecure-ssl") . required (false) . value_parser (clap :: value_parser ! (types :: WebhookConfigInsecureSsl))) . arg (clap :: Arg :: new ("secret") . long ("secret") . required (false) . value_parser (clap :: value_parser ! (types :: WebhookConfigSecret))) . arg (clap :: Arg :: new ("url") . long ("url") . required (false) . value_parser (clap :: value_parser ! (types :: WebhookConfigUrl))) . about ("Update a webhook configuration for an app\n\nUpdates the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see \"[Creating a GitHub App](/developers/apps/creating-a-github-app).\"\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_apps_list_webhook_deliveries() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("cursor") . long ("cursor") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("redelivery") . long ("redelivery") . required (false) . value_parser (clap :: value_parser ! (bool))) . about ("List deliveries for an app webhook\n\nReturns a list of webhook deliveries for the webhook configured for a GitHub App.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_apps_get_webhook_delivery() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("delivery-id") . long ("delivery-id") . required (true) . value_parser (clap :: value_parser ! (i64))) . about ("Get a delivery for an app webhook\n\nReturns a delivery for the webhook configured for a GitHub App.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_apps_redeliver_webhook_delivery() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("delivery-id") . long ("delivery-id") . required (true) . value_parser (clap :: value_parser ! (i64))) . about ("Redeliver a delivery for an app webhook\n\nRedeliver a delivery for the webhook configured for a GitHub App.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_apps_list_installation_requests_for_authenticated_app() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List installation requests for the authenticated app\n\nLists all the pending \
                 installation requests for the authenticated GitHub App.",
            )
    }

    pub fn cli_apps_list_installations() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("outdated") . long ("outdated") . required (false) . value_parser (clap :: value_parser ! (String))) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . about ("List installations for the authenticated app\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.\n\nThe permissions the installation has are included under the `permissions` key.")
    }

    pub fn cli_apps_get_installation() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("installation-id") . long ("installation-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the installation.")) . about ("Get an installation for the authenticated app\n\nEnables an authenticated GitHub App to find an installation's information using the installation id.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_apps_delete_installation() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("installation-id") . long ("installation-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the installation.")) . about ("Delete an installation for the authenticated app\n\nUninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily suspend an app's access to your account's resources, then we recommend the \"[Suspend an app installation](https://docs.github.com/rest/reference/apps/#suspend-an-app-installation)\" endpoint.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_apps_create_installation_access_token() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("installation-id") . long ("installation-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the installation.")) . about ("Create an installation access token for an app\n\nCreates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access. To restrict the access to specific repositories, you can provide the `repository_ids` when creating the token. When you omit `repository_ids`, the response does not contain the `repositories` key.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_apps_suspend_installation() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("installation-id") . long ("installation-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the installation.")) . about ("Suspend an app installation\n\nSuspends a GitHub App on a user, organization, or business account, which blocks the app from accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub API or webhook events is blocked for that account.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_apps_unsuspend_installation() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("installation-id") . long ("installation-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the installation.")) . about ("Unsuspend an app installation\n\nRemoves a GitHub App installation suspension.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_apps_delete_authorization() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("client-id") . long ("client-id") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The client ID of the GitHub app.")) . arg (clap :: Arg :: new ("access-token") . long ("access-token") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The OAuth access token used to authenticate to the GitHub API.")) . about ("Delete an app authorization\n\nOAuth and GitHub application owners can revoke a grant for their application and a specific user. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. You must also provide a valid OAuth `access_token` as an input parameter and the grant for the token's owner will be deleted.\nDeleting an application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).")
    }

    pub fn cli_apps_check_token() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("client-id") . long ("client-id") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The client ID of the GitHub app.")) . arg (clap :: Arg :: new ("access-token") . long ("access-token") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The access_token of the OAuth or GitHub application.")) . about ("Check a token\n\nOAuth applications and GitHub applications with OAuth authorizations can use this API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where the username is the application `client_id` and the password is its `client_secret`. Invalid tokens will return `404 NOT FOUND`.")
    }

    pub fn cli_apps_delete_token() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("client-id") . long ("client-id") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The client ID of the GitHub app.")) . arg (clap :: Arg :: new ("access-token") . long ("access-token") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The OAuth access token used to authenticate to the GitHub API.")) . about ("Delete an app token\n\nOAuth  or GitHub application owners can revoke a single token for an OAuth application or a GitHub application with an OAuth authorization. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the application's `client_id` and `client_secret` as the username and password.")
    }

    pub fn cli_apps_reset_token() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("client-id") . long ("client-id") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The client ID of the GitHub app.")) . arg (clap :: Arg :: new ("access-token") . long ("access-token") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The access_token of the OAuth or GitHub application.")) . about ("Reset a token\n\nOAuth applications and GitHub applications with OAuth authorizations can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the \"token\" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.")
    }

    pub fn cli_apps_scope_token() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("client-id") . long ("client-id") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The client ID of the GitHub app.")) . arg (clap :: Arg :: new ("access-token") . long ("access-token") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The access token used to authenticate to the GitHub API.")) . arg (clap :: Arg :: new ("target") . long ("target") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the user or organization to scope the user-to-server access token to. **Required** unless `target_id` is specified.")) . arg (clap :: Arg :: new ("target-id") . long ("target-id") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The ID of the user or organization to scope the user-to-server access token to. **Required** unless `target` is specified.")) . about ("Create a scoped access token\n\nUse a non-scoped user-to-server access token to create a repository scoped and/or permission scoped user-to-server access token. You can specify which repositories the token can access and which permissions are granted to the token. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the `client_id` and `client_secret` of the GitHub App as the username and password. Invalid tokens will return `404 NOT FOUND`.")
    }

    pub fn cli_apps_get_by_slug() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("app-slug") . long ("app-slug") . required (true) . value_parser (clap :: value_parser ! (String))) . about ("Get an app\n\n**Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).\n\nIf the GitHub App you specify is public, you can access this endpoint without authenticating. If the GitHub App you specify is private, you must authenticate with a [personal access token](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line/) or an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.")
    }

    pub fn cli_codes_of_conduct_get_all_codes_of_conduct() -> clap::Command {
        clap::Command::new("").about("Get all codes of conduct")
    }

    pub fn cli_codes_of_conduct_get_conduct_code() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("key")
                    .long("key")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about("Get a code of conduct")
    }

    pub fn cli_emojis_get() -> clap::Command {
        clap::Command::new("")
            .about("Get emojis\n\nLists all the emojis available to use on GitHub.")
    }

    pub fn cli_dependabot_list_alerts_for_enterprise() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("enterprise") . long ("enterprise") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug version of the enterprise name. You can also substitute this value with the enterprise id.")) . arg (clap :: Arg :: new ("after") . long ("after") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor.")) . arg (clap :: Arg :: new ("before") . long ("before") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: DependabotListAlertsForEnterpriseDirection :: Asc . to_string () , types :: DependabotListAlertsForEnterpriseDirection :: Desc . to_string () ,]) , | s | types :: DependabotListAlertsForEnterpriseDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("ecosystem") . long ("ecosystem") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`")) . arg (clap :: Arg :: new ("first") . long ("first") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("**Deprecated**. The number of results per page (max 100), starting from the first matching result.\nThis parameter must not be used in combination with `last`.\nInstead, use `per_page` in combination with `after` to fetch the first page of results.")) . arg (clap :: Arg :: new ("last") . long ("last") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("**Deprecated**. The number of results per page (max 100), starting from the last matching result.\nThis parameter must not be used in combination with `first`.\nInstead, use `per_page` in combination with `before` to fetch the last page of results.")) . arg (clap :: Arg :: new ("package") . long ("package") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of package names. If specified, only alerts for these packages will be returned.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("scope") . long ("scope") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: DependabotListAlertsForEnterpriseScope :: Development . to_string () , types :: DependabotListAlertsForEnterpriseScope :: Runtime . to_string () ,]) , | s | types :: DependabotListAlertsForEnterpriseScope :: try_from (s) . unwrap ())) . help ("The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.")) . arg (clap :: Arg :: new ("severity") . long ("severity") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: DependabotListAlertsForEnterpriseSort :: Created . to_string () , types :: DependabotListAlertsForEnterpriseSort :: Updated . to_string () ,]) , | s | types :: DependabotListAlertsForEnterpriseSort :: try_from (s) . unwrap ())) . help ("The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`")) . about ("List Dependabot alerts for an enterprise\n\nLists Dependabot alerts for repositories that are owned by the specified enterprise.\nTo use this endpoint, you must be a member of the enterprise, and you must use an\naccess token with the `repo` scope or `security_events` scope.\nAlerts are only returned for organizations in the enterprise for which you are an organization owner or a security manager. For more information about security managers, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"")
    }

    pub fn cli_secret_scanning_list_alerts_for_enterprise() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("enterprise") . long ("enterprise") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug version of the enterprise name. You can also substitute this value with the enterprise id.")) . arg (clap :: Arg :: new ("after") . long ("after") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor.")) . arg (clap :: Arg :: new ("before") . long ("before") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecretScanningListAlertsForEnterpriseDirection :: Asc . to_string () , types :: SecretScanningListAlertsForEnterpriseDirection :: Desc . to_string () ,]) , | s | types :: SecretScanningListAlertsForEnterpriseDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("resolution") . long ("resolution") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.")) . arg (clap :: Arg :: new ("secret-type") . long ("secret-type") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of secret types to return. By default all secret types are returned.\nSee \"[Secret scanning patterns](https://docs.github.com/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)\"\nfor a complete list of secret types.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecretScanningListAlertsForEnterpriseSort :: Created . to_string () , types :: SecretScanningListAlertsForEnterpriseSort :: Updated . to_string () ,]) , | s | types :: SecretScanningListAlertsForEnterpriseSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecretScanningListAlertsForEnterpriseState :: Open . to_string () , types :: SecretScanningListAlertsForEnterpriseState :: Resolved . to_string () ,]) , | s | types :: SecretScanningListAlertsForEnterpriseState :: try_from (s) . unwrap ())) . help ("Set to `open` or `resolved` to only list secret scanning alerts in a specific state.")) . about ("List secret scanning alerts for an enterprise\n\nLists secret scanning alerts for eligible repositories in an enterprise, from newest to oldest.\nTo use this endpoint, you must be a member of the enterprise, and you must use an access token with the `repo` scope or `security_events` scope. Alerts are only returned for organizations in the enterprise for which you are an organization owner or a [security manager](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).")
    }

    pub fn cli_activity_list_public_events() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List public events\n\nWe delay the public events feed by five minutes, which \
                 means the most recent event returned by the public events API actually occurred \
                 at least five minutes ago.",
            )
    }

    pub fn cli_activity_get_feeds() -> clap::Command {
        clap :: Command :: new ("") . about ("Get feeds\n\nGitHub provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard)) format. The Feeds API lists all the feeds available to the authenticated user:\n\n*   **Timeline**: The GitHub global public timeline\n*   **User**: The public timeline for any user, using [URI template](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia)\n*   **Current user public**: The public timeline for the authenticated user\n*   **Current user**: The private timeline for the authenticated user\n*   **Current user actor**: The private timeline for activity created by the authenticated user\n*   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of.\n*   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub.\n\n**Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use the older, non revocable auth tokens.")
    }

    pub fn cli_gists_list() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . about ("List gists for the authenticated user\n\nLists the authenticated user's gists or if called anonymously, this endpoint returns all public gists:")
    }

    pub fn cli_gists_create() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("description")
                    .long("description")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Description of the gist"),
            )
            .arg(
                clap::Arg::new("public")
                    .long("public")
                    .required(false)
                    .value_parser(clap::value_parser!(types::GistsCreateBodyPublic)),
            )
            .about(
                "Create a gist\n\nAllows you to add a new gist with one or more \
                 files.\n\n**Note:** Don't name your files \"gistfile\" with a numerical suffix. \
                 This is the format of the automatic naming scheme that Gist uses internally.",
            )
    }

    pub fn cli_gists_list_public() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . about ("List public gists\n\nList public gists sorted by most recently updated to least recently updated.\n\nNote: With [pagination](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination), you can fetch up to 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.")
    }

    pub fn cli_gists_list_starred() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . about ("List starred gists\n\nList the authenticated user's starred gists:")
    }

    pub fn cli_gists_get() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .about("Get a gist")
    }

    pub fn cli_gists_delete() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .about("Delete a gist")
    }

    pub fn cli_gists_update() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .about(
                "Update a gist\n\nAllows you to update a gist's description and to update, \
                 delete, or rename gist files. Files from the previous version of the gist that \
                 aren't explicitly changed during an edit are unchanged.",
            )
    }

    pub fn cli_gists_list_comments() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List gist comments")
    }

    pub fn cli_gists_create_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .arg(
                clap::Arg::new("body")
                    .long("body")
                    .required(true)
                    .value_parser(clap::value_parser!(types::GistsCreateCommentBodyBody))
                    .help("The comment text."),
            )
            .about("Create a gist comment")
    }

    pub fn cli_gists_get_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .about("Get a gist comment")
    }

    pub fn cli_gists_delete_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .about("Delete a gist comment")
    }

    pub fn cli_gists_update_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .arg(
                clap::Arg::new("body")
                    .long("body")
                    .required(true)
                    .value_parser(clap::value_parser!(types::GistsUpdateCommentBodyBody))
                    .help("The comment text."),
            )
            .about("Update a gist comment")
    }

    pub fn cli_gists_list_commits() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List gist commits")
    }

    pub fn cli_gists_list_forks() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List gist forks")
    }

    pub fn cli_gists_fork() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .about("Fork a gist")
    }

    pub fn cli_gists_check_is_starred() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .about("Check if a gist is starred")
    }

    pub fn cli_gists_star() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("gist-id") . long ("gist-id") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The unique identifier of the gist.")) . about ("Star a gist\n\nNote that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"")
    }

    pub fn cli_gists_unstar() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .about("Unstar a gist")
    }

    pub fn cli_gists_get_revision() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("gist-id")
                    .long("gist-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The unique identifier of the gist."),
            )
            .arg(
                clap::Arg::new("sha")
                    .long("sha")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about("Get a gist revision")
    }

    pub fn cli_gitignore_get_all_templates() -> clap::Command {
        clap :: Command :: new ("") . about ("Get all gitignore templates\n\nList all templates available to pass as an option when [creating a repository](https://docs.github.com/rest/reference/repos#create-a-repository-for-the-authenticated-user).")
    }

    pub fn cli_gitignore_get_template() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String))) . about ("Get a gitignore template\n\nThe API also allows fetching the source of a single template.\nUse the raw [media type](https://docs.github.com/rest/overview/media-types/) to get the raw contents.")
    }

    pub fn cli_apps_list_repos_accessible_to_installation() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List repositories accessible to the app installation\n\nList repositories that an app installation can access.\n\nYou must use an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.")
    }

    pub fn cli_apps_revoke_installation_access_token() -> clap::Command {
        clap :: Command :: new ("") . about ("Revoke an installation access token\n\nRevokes the installation token you're using to authenticate as an installation and access this endpoint.\n\nOnce an installation token is revoked, the token is invalidated and cannot be used. Other endpoints that require the revoked installation token must have a new installation token to work. You can create a new token using the \"[Create an installation access token for an app](https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app)\" endpoint.\n\nYou must use an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.")
    }

    pub fn cli_issues_list() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("collab") . long ("collab") . required (false) . value_parser (clap :: value_parser ! (bool))) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListDirection :: Asc . to_string () , types :: IssuesListDirection :: Desc . to_string () ,]) , | s | types :: IssuesListDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("filter") . long ("filter") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListFilter :: Assigned . to_string () , types :: IssuesListFilter :: Created . to_string () , types :: IssuesListFilter :: Mentioned . to_string () , types :: IssuesListFilter :: Subscribed . to_string () , types :: IssuesListFilter :: Repos . to_string () , types :: IssuesListFilter :: All . to_string () ,]) , | s | types :: IssuesListFilter :: try_from (s) . unwrap ())) . help ("Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.")) . arg (clap :: Arg :: new ("labels") . long ("labels") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A list of comma separated label names. Example: `bug,ui,@high`")) . arg (clap :: Arg :: new ("orgs") . long ("orgs") . required (false) . value_parser (clap :: value_parser ! (bool))) . arg (clap :: Arg :: new ("owned") . long ("owned") . required (false) . value_parser (clap :: value_parser ! (bool))) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("pulls") . long ("pulls") . required (false) . value_parser (clap :: value_parser ! (bool))) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListSort :: Created . to_string () , types :: IssuesListSort :: Updated . to_string () , types :: IssuesListSort :: Comments . to_string () ,]) , | s | types :: IssuesListSort :: try_from (s) . unwrap ())) . help ("What to sort results by.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListState :: Open . to_string () , types :: IssuesListState :: Closed . to_string () , types :: IssuesListState :: All . to_string () ,]) , | s | types :: IssuesListState :: try_from (s) . unwrap ())) . help ("Indicates the state of the issues to return.")) . about ("List issues assigned to the authenticated user\n\nList issues assigned to the authenticated user across all visible repositories including owned repositories, member\nrepositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not\nnecessarily assigned to you.\n\n\n**Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this\nreason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by\nthe `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull\nrequest id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.")
    }

    pub fn cli_licenses_get_all_commonly_used() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("featured")
                    .long("featured")
                    .required(false)
                    .value_parser(clap::value_parser!(bool)),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("Get all commonly used licenses")
    }

    pub fn cli_licenses_get() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("license")
                    .long("license")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about("Get a license")
    }

    pub fn cli_markdown_render() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("context")
                    .long("context")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The repository context to use when creating references in `gfm` mode.  \
                         For example, setting `context` to `octo-org/octo-repo` will change the \
                         text `#42` into an HTML link to issue 42 in the `octo-org/octo-repo` \
                         repository.",
                    ),
            )
            .arg(
                clap::Arg::new("mode")
                    .long("mode")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::MarkdownRenderBodyMode::Markdown.to_string(),
                            types::MarkdownRenderBodyMode::Gfm.to_string(),
                        ]),
                        |s| types::MarkdownRenderBodyMode::try_from(s).unwrap(),
                    ))
                    .help("The rendering mode."),
            )
            .arg(
                clap::Arg::new("text")
                    .long("text")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The Markdown text to render in HTML."),
            )
            .about("Render a Markdown document")
    }

    pub fn cli_meta_get_all_versions() -> clap::Command {
        clap::Command::new("")
            .about("Get all API versions\n\nGet all supported GitHub API versions.")
    }

    pub fn cli_apps_get_subscription_plan_for_account() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("account-id") . long ("account-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("account_id parameter")) . about ("Get a subscription plan for an account\n\nShows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.\n\nGitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.")
    }

    pub fn cli_apps_list_plans() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List plans\n\nLists all plans that are part of your GitHub Marketplace listing.\n\nGitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.")
    }

    pub fn cli_apps_list_accounts_for_plan() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("plan-id") . long ("plan-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the plan.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: AppsListAccountsForPlanDirection :: Asc . to_string () , types :: AppsListAccountsForPlanDirection :: Desc . to_string () ,]) , | s | types :: AppsListAccountsForPlanDirection :: try_from (s) . unwrap ())) . help ("To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: AppsListAccountsForPlanSort :: Created . to_string () , types :: AppsListAccountsForPlanSort :: Updated . to_string () ,]) , | s | types :: AppsListAccountsForPlanSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by.")) . about ("List accounts for a plan\n\nReturns user and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.\n\nGitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.")
    }

    pub fn cli_apps_get_subscription_plan_for_account_stubbed() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("account-id") . long ("account-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("account_id parameter")) . about ("Get a subscription plan for an account (stubbed)\n\nShows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.\n\nGitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.")
    }

    pub fn cli_apps_list_plans_stubbed() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List plans (stubbed)\n\nLists all plans that are part of your GitHub Marketplace listing.\n\nGitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.")
    }

    pub fn cli_apps_list_accounts_for_plan_stubbed() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("plan-id") . long ("plan-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the plan.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: AppsListAccountsForPlanStubbedDirection :: Asc . to_string () , types :: AppsListAccountsForPlanStubbedDirection :: Desc . to_string () ,]) , | s | types :: AppsListAccountsForPlanStubbedDirection :: try_from (s) . unwrap ())) . help ("To return the oldest accounts first, set to `asc`. Ignored without the `sort` parameter.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: AppsListAccountsForPlanStubbedSort :: Created . to_string () , types :: AppsListAccountsForPlanStubbedSort :: Updated . to_string () ,]) , | s | types :: AppsListAccountsForPlanStubbedSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by.")) . about ("List accounts for a plan (stubbed)\n\nReturns repository and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.\n\nGitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.")
    }

    pub fn cli_meta_get() -> clap::Command {
        clap :: Command :: new ("") . about ("Get GitHub meta information\n\nReturns meta information about GitHub, including a list of GitHub's IP addresses. For more information, see \"[About GitHub's IP addresses](https://docs.github.com/articles/about-github-s-ip-addresses/).\"\n\nThe values shown in the documentation's response are example values. You must always query the API directly to get the latest values.\n\n**Note:** This endpoint returns both IPv4 and IPv6 addresses. However, not all features support IPv6. You should refer to the specific documentation for each feature to determine if IPv6 is supported.")
    }

    pub fn cli_activity_list_public_events_for_repo_network() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List public events for a network of repositories")
    }

    pub fn cli_activity_list_notifications_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("all") . long ("all") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("If `true`, show notifications marked as read.")) . arg (clap :: Arg :: new ("before") . long ("before") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("participating") . long ("participating") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("If `true`, only shows notifications in which the user is directly participating or mentioned.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 50).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . about ("List notifications for the authenticated user\n\nList all notifications for the current user, sorted by most recently updated.")
    }

    pub fn cli_activity_mark_notifications_as_read() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("last-read-at") . long ("last-read-at") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.")) . arg (clap :: Arg :: new ("read") . long ("read") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether the notification has been read.")) . about ("Mark notifications as read\n\nMarks all notifications as \"read\" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as \"read.\" To check whether any \"unread\" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.")
    }

    pub fn cli_activity_get_thread() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("thread-id") . long ("thread-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).")) . about ("Get a thread\n\nGets information about a notification thread.")
    }

    pub fn cli_activity_mark_thread_as_read() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("thread-id") . long ("thread-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).")) . about ("Mark a thread as read\n\nMarks a thread as \"read.\" Marking a thread as \"read\" is equivalent to clicking a notification in your notification inbox on GitHub: https://github.com/notifications.")
    }

    pub fn cli_activity_get_thread_subscription_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("thread-id") . long ("thread-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).")) . about ("Get a thread subscription for the authenticated user\n\nThis checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).\n\nNote that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.")
    }

    pub fn cli_activity_set_thread_subscription() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("thread-id") . long ("thread-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).")) . arg (clap :: Arg :: new ("ignored") . long ("ignored") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether to block all notifications from a thread.")) . about ("Set a thread subscription\n\nIf you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.\n\nYou can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.\n\nUnsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/rest/reference/activity#delete-a-thread-subscription) endpoint.")
    }

    pub fn cli_activity_delete_thread_subscription() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("thread-id") . long ("thread-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the notification thread. This corresponds to the value returned in the `id` field when you retrieve notifications (for example with the [`GET /notifications` operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).")) . about ("Delete a thread subscription\n\nMutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription) endpoint and set `ignore` to `true`.")
    }

    pub fn cli_meta_get_octocat() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("s")
                    .long("s")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The words to show in Octocat's speech bubble"),
            )
            .about("Get Octocat\n\nGet the octocat as ASCII art")
    }

    pub fn cli_orgs_list() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("An organization ID. Only return organizations with an ID greater than this ID.")) . about ("List organizations\n\nLists all organizations, in the order that they were created on GitHub.\n\n**Note:** Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of organizations.")
    }

    pub fn cli_orgs_list_pat_grant_requests() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: OrgsListPatGrantRequestsDirection :: Asc . to_string () , types :: OrgsListPatGrantRequestsDirection :: Desc . to_string () ,]) , | s | types :: OrgsListPatGrantRequestsDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("last-used-after") . long ("last-used-after") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("last-used-before") . long ("last-used-before") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("owner") . long ("owner") . required (false) . value_parser (clap :: value_parser ! (Vec < String >)) . help ("A list of owner usernames to use to filter the results.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("permission") . long ("permission") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The permission to use to filter the results.")) . arg (clap :: Arg :: new ("repository") . long ("repository") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository to use to filter the results.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: OrgsListPatGrantRequestsSort :: CreatedAt . to_string () ,]) , | s | types :: OrgsListPatGrantRequestsSort :: try_from (s) . unwrap ())) . help ("The property by which to sort the results.")) . about ("List requests to access organization resources with fine-grained personal access tokens\n\nLists requests from organization members to access organization resources with a fine-grained personal access token. Only GitHub Apps can call this API,\nusing the `organization_personal_access_token_requests: read` permission.\n\n**Note**: Fine-grained PATs are in public beta. Related APIs, events, and functionality are subject to change.")
    }

    pub fn cli_orgs_review_pat_grant_requests_in_bulk() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("action")
                    .long("action")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::OrgsReviewPatGrantRequestsInBulkBodyAction::Approve.to_string(),
                            types::OrgsReviewPatGrantRequestsInBulkBodyAction::Deny.to_string(),
                        ]),
                        |s| types::OrgsReviewPatGrantRequestsInBulkBodyAction::try_from(s).unwrap(),
                    ))
                    .help("Action to apply to the requests."),
            )
            .arg(
                clap::Arg::new("reason")
                    .long("reason")
                    .required(false)
                    .value_parser(clap::value_parser!(
                        types::OrgsReviewPatGrantRequestsInBulkBodyReason
                    ))
                    .help("Reason for approving or denying the requests. Max 1024 characters."),
            )
            .about(
                "Review requests to access organization resources with fine-grained personal \
                 access tokens\n\nApproves or denies multiple pending requests to access \
                 organization resources via a fine-grained personal access token. Only GitHub \
                 Apps can call this API,\nusing the `organization_personal_access_token_requests: \
                 write` permission.\n\n**Note**: Fine-grained PATs are in public beta. Related \
                 APIs, events, and functionality are subject to change.",
            )
    }

    pub fn cli_orgs_review_pat_grant_request() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pat-request-id")
                    .long("pat-request-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help(
                        "Unique identifier of the request for access via fine-grained personal \
                         access token.",
                    ),
            )
            .arg(
                clap::Arg::new("action")
                    .long("action")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::OrgsReviewPatGrantRequestBodyAction::Approve.to_string(),
                            types::OrgsReviewPatGrantRequestBodyAction::Deny.to_string(),
                        ]),
                        |s| types::OrgsReviewPatGrantRequestBodyAction::try_from(s).unwrap(),
                    ))
                    .help("Action to apply to the request."),
            )
            .arg(
                clap::Arg::new("reason")
                    .long("reason")
                    .required(false)
                    .value_parser(clap::value_parser!(
                        types::OrgsReviewPatGrantRequestBodyReason
                    ))
                    .help("Reason for approving or denying the request. Max 1024 characters."),
            )
            .about(
                "Review a request to access organization resources with a fine-grained personal \
                 access token\n\nApproves or denies a pending request to access organization \
                 resources via a fine-grained personal access token. Only GitHub Apps can call \
                 this API,\nusing the `organization_personal_access_token_requests: write` \
                 permission.\n\n**Note**: Fine-grained PATs are in public beta. Related APIs, \
                 events, and functionality are subject to change.",
            )
    }

    pub fn cli_orgs_list_pat_grant_request_repositories() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pat-request-id")
                    .long("pat-request-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help(
                        "Unique identifier of the request for access via fine-grained personal \
                         access token.",
                    ),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repositories requested to be accessed by a fine-grained personal access \
                 token\n\nLists the repositories a fine-grained personal access token request is \
                 requesting access to. Only GitHub Apps can call this API,\nusing the \
                 `organization_personal_access_token_requests: read` permission.\n\n**Note**: \
                 Fine-grained PATs are in public beta. Related APIs, events, and functionality \
                 are subject to change.",
            )
    }

    pub fn cli_orgs_list_pat_grants() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: OrgsListPatGrantsDirection :: Asc . to_string () , types :: OrgsListPatGrantsDirection :: Desc . to_string () ,]) , | s | types :: OrgsListPatGrantsDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("last-used-after") . long ("last-used-after") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show fine-grained personal access tokens used after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("last-used-before") . long ("last-used-before") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show fine-grained personal access tokens used before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("owner") . long ("owner") . required (false) . value_parser (clap :: value_parser ! (Vec < String >)) . help ("A list of owner usernames to use to filter the results.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("permission") . long ("permission") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The permission to use to filter the results.")) . arg (clap :: Arg :: new ("repository") . long ("repository") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository to use to filter the results.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: OrgsListPatGrantsSort :: CreatedAt . to_string () ,]) , | s | types :: OrgsListPatGrantsSort :: try_from (s) . unwrap ())) . help ("The property by which to sort the results.")) . about ("List fine-grained personal access tokens with access to organization resources\n\nLists approved fine-grained personal access tokens owned by organization members that can access organization resources. Only GitHub Apps can call this API,\nusing the `organization_personal_access_tokens: read` permission.\n\n**Note**: Fine-grained PATs are in public beta. Related APIs, events, and functionality are subject to change.")
    }

    pub fn cli_orgs_update_pat_accesses() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("action")
                    .long("action")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::OrgsUpdatePatAccessesBodyAction::Revoke.to_string(),
                        ]),
                        |s| types::OrgsUpdatePatAccessesBodyAction::try_from(s).unwrap(),
                    ))
                    .help("Action to apply to the fine-grained personal access token."),
            )
            .about(
                "Update the access to organization resources via fine-grained personal access \
                 tokens\n\nUpdates the access organization members have to organization resources \
                 via fine-grained personal access tokens. Limited to revoking a token's existing \
                 access. Only GitHub Apps can call this API,\nusing the \
                 `organization_personal_access_tokens: write` permission.\n\n**Note**: \
                 Fine-grained PATs are in public beta. Related APIs, events, and functionality \
                 are subject to change.",
            )
    }

    pub fn cli_orgs_update_pat_access() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pat-id")
                    .long("pat-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the fine-grained personal access token."),
            )
            .arg(
                clap::Arg::new("action")
                    .long("action")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::OrgsUpdatePatAccessBodyAction::Revoke.to_string(),
                        ]),
                        |s| types::OrgsUpdatePatAccessBodyAction::try_from(s).unwrap(),
                    ))
                    .help("Action to apply to the fine-grained personal access token."),
            )
            .about(
                "Update the access a fine-grained personal access token has to organization \
                 resources\n\nUpdates the access an organization member has to organization \
                 resources via a fine-grained personal access token. Limited to revoking the \
                 token's existing access. Limited to revoking a token's existing access. Only \
                 GitHub Apps can call this API,\nusing the `organization_personal_access_tokens: \
                 write` permission.\n\n**Note**: Fine-grained PATs are in public beta. Related \
                 APIs, events, and functionality are subject to change.",
            )
    }

    pub fn cli_orgs_list_pat_grant_repositories() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pat-id")
                    .long("pat-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the fine-grained personal access token."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repositories a fine-grained personal access token has access to\n\nLists \
                 the repositories a fine-grained personal access token has access to. Only GitHub \
                 Apps can call this API,\nusing the `organization_personal_access_tokens: read` \
                 permission.\n\n**Note**: Fine-grained PATs are in public beta. Related APIs, \
                 events, and functionality are subject to change.",
            )
    }

    pub fn cli_meta_get_zen() -> clap::Command {
        clap::Command::new("")
            .about("Get the Zen of GitHub\n\nGet a random sentence from the Zen of GitHub")
    }

    pub fn cli_actions_get_actions_cache_usage_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Get GitHub Actions cache usage for an organization\n\nGets the total GitHub \
                 Actions cache usage for an organization.\nThe data fetched using this API is \
                 refreshed approximately every 5 minutes, so values returned from this endpoint \
                 may take at least 5 minutes to get updated.\nYou must authenticate using an \
                 access token with the `read:org` scope to use this endpoint. GitHub Apps must \
                 have the `organization_admistration:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_actions_cache_usage_by_repo_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repositories with GitHub Actions cache usage for an organization\n\nLists \
                 repositories and their GitHub Actions cache usage for an organization.\nThe data \
                 fetched using this API is refreshed approximately every 5 minutes, so values \
                 returned from this endpoint may take at least 5 minutes to get updated.\nYou \
                 must authenticate using an access token with the `read:org` scope to use this \
                 endpoint. GitHub Apps must have the `organization_admistration:read` permission \
                 to use this endpoint.",
            )
    }

    pub fn cli_oidc_get_oidc_custom_sub_template_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Get the customization template for an OIDC subject claim for an \
                 organization\n\nGets the customization template for an OpenID Connect (OIDC) \
                 subject claim.\nYou must authenticate using an access token with the `read:org` \
                 scope to use this endpoint.\nGitHub Apps must have the \
                 `organization_administration:write` permission to use this endpoint.",
            )
    }

    pub fn cli_oidc_update_oidc_custom_sub_template_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Set the customization template for an OIDC subject claim for an \
                 organization\n\nCreates or updates the customization template for an OpenID \
                 Connect (OIDC) subject claim.\nYou must authenticate using an access token with \
                 the `write:org` scope to use this endpoint.\nGitHub Apps must have the \
                 `admin:org` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_github_actions_permissions_organization() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Get GitHub Actions permissions for an organization\n\nGets the GitHub Actions \
                 permissions policy for repositories and allowed actions and reusable workflows \
                 in an organization.\n\nYou must authenticate using an access token with the \
                 `admin:org` scope to use this endpoint. GitHub Apps must have the \
                 `administration` organization permission to use this API.",
            )
    }

    pub fn cli_actions_set_github_actions_permissions_organization() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("allowed-actions")
                    .long("allowed-actions")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::AllowedActions::All.to_string(),
                            types::AllowedActions::LocalOnly.to_string(),
                            types::AllowedActions::Selected.to_string(),
                        ]),
                        |s| types::AllowedActions::try_from(s).unwrap(),
                    )),
            )
            .arg(
                clap::Arg::new("enabled-repositories")
                    .long("enabled-repositories")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::EnabledRepositories::All.to_string(),
                            types::EnabledRepositories::None.to_string(),
                            types::EnabledRepositories::Selected.to_string(),
                        ]),
                        |s| types::EnabledRepositories::try_from(s).unwrap(),
                    )),
            )
            .about(
                "Set GitHub Actions permissions for an organization\n\nSets the GitHub Actions \
                 permissions policy for repositories and allowed actions and reusable workflows \
                 in an organization.\n\nYou must authenticate using an access token with the \
                 `admin:org` scope to use this endpoint. GitHub Apps must have the \
                 `administration` organization permission to use this API.",
            )
    }

    pub fn cli_actions_list_selected_repositories_enabled_github_actions_organization(
    ) -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List selected repositories enabled for GitHub Actions in an \
                 organization\n\nLists the selected repositories that are enabled for GitHub \
                 Actions in an organization. To use this endpoint, the organization permission \
                 policy for `enabled_repositories` must be configured to `selected`. For more \
                 information, see \"[Set GitHub Actions permissions for an \
                 organization](#set-github-actions-permissions-for-an-organization).\"\n\nYou \
                 must authenticate using an access token with the `admin:org` scope to use this \
                 endpoint. GitHub Apps must have the `administration` organization permission to \
                 use this API.",
            )
    }

    pub fn cli_actions_set_selected_repositories_enabled_github_actions_organization(
    ) -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Set selected repositories enabled for GitHub Actions in an \
                 organization\n\nReplaces the list of selected repositories that are enabled for \
                 GitHub Actions in an organization. To use this endpoint, the organization \
                 permission policy for `enabled_repositories` must be configured to `selected`. \
                 For more information, see \"[Set GitHub Actions permissions for an \
                 organization](#set-github-actions-permissions-for-an-organization).\"\n\nYou \
                 must authenticate using an access token with the `admin:org` scope to use this \
                 endpoint. GitHub Apps must have the `administration` organization permission to \
                 use this API.",
            )
    }

    pub fn cli_actions_enable_selected_repository_github_actions_organization() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the repository."),
            )
            .about(
                "Enable a selected repository for GitHub Actions in an organization\n\nAdds a \
                 repository to the list of selected repositories that are enabled for GitHub \
                 Actions in an organization. To use this endpoint, the organization permission \
                 policy for `enabled_repositories` must be must be configured to `selected`. For \
                 more information, see \"[Set GitHub Actions permissions for an \
                 organization](#set-github-actions-permissions-for-an-organization).\"\n\nYou \
                 must authenticate using an access token with the `admin:org` scope to use this \
                 endpoint. GitHub Apps must have the `administration` organization permission to \
                 use this API.",
            )
    }

    pub fn cli_actions_disable_selected_repository_github_actions_organization() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the repository."),
            )
            .about(
                "Disable a selected repository for GitHub Actions in an organization\n\nRemoves a \
                 repository from the list of selected repositories that are enabled for GitHub \
                 Actions in an organization. To use this endpoint, the organization permission \
                 policy for `enabled_repositories` must be configured to `selected`. For more \
                 information, see \"[Set GitHub Actions permissions for an \
                 organization](#set-github-actions-permissions-for-an-organization).\"\n\nYou \
                 must authenticate using an access token with the `admin:org` scope to use this \
                 endpoint. GitHub Apps must have the `administration` organization permission to \
                 use this API.",
            )
    }

    pub fn cli_actions_get_allowed_actions_organization() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Get allowed actions and reusable workflows for an organization\n\nGets the \
                 selected actions and reusable workflows that are allowed in an organization. To \
                 use this endpoint, the organization permission policy for `allowed_actions` must \
                 be configured to `selected`. For more information, see \"[Set GitHub Actions \
                 permissions for an \
                 organization](#set-github-actions-permissions-for-an-organization).\"\"\n\nYou \
                 must authenticate using an access token with the `admin:org` scope to use this \
                 endpoint. GitHub Apps must have the `administration` organization permission to \
                 use this API.",
            )
    }

    pub fn cli_actions_set_allowed_actions_organization() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("github-owned-allowed")
                    .long("github-owned-allowed")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Whether GitHub-owned actions are allowed. For example, this includes the \
                         actions in the `actions` organization.",
                    ),
            )
            .arg(
                clap::Arg::new("verified-allowed")
                    .long("verified-allowed")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Whether actions from GitHub Marketplace verified creators are allowed. \
                         Set to `true` to allow all actions by GitHub Marketplace verified \
                         creators.",
                    ),
            )
            .about(
                "Set allowed actions and reusable workflows for an organization\n\nSets the \
                 actions and reusable workflows that are allowed in an organization. To use this \
                 endpoint, the organization permission policy for `allowed_actions` must be \
                 configured to `selected`. For more information, see \"[Set GitHub Actions \
                 permissions for an \
                 organization](#set-github-actions-permissions-for-an-organization).\"\n\nYou \
                 must authenticate using an access token with the `admin:org` scope to use this \
                 endpoint. GitHub Apps must have the `administration` organization permission to \
                 use this API.",
            )
    }

    pub fn cli_actions_get_github_actions_default_workflow_permissions_organization(
    ) -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . about ("Get default workflow permissions for an organization\n\nGets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization,\nas well as whether GitHub Actions can submit approving pull request reviews. For more information, see\n\"[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization).\"\n\nYou must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.")
    }

    pub fn cli_actions_set_github_actions_default_workflow_permissions_organization(
    ) -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("can-approve-pull-request-reviews") . long ("can-approve-pull-request-reviews") . required (false) . value_parser (clap :: value_parser ! (types :: ActionsCanApprovePullRequestReviews))) . arg (clap :: Arg :: new ("default-workflow-permissions") . long ("default-workflow-permissions") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActionsDefaultWorkflowPermissions :: Read . to_string () , types :: ActionsDefaultWorkflowPermissions :: Write . to_string () ,]) , | s | types :: ActionsDefaultWorkflowPermissions :: try_from (s) . unwrap ()))) . about ("Set default workflow permissions for an organization\n\nSets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in an organization, and sets if GitHub Actions\ncan submit approving pull request reviews. For more information, see\n\"[Setting the permissions of the GITHUB_TOKEN for your organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization).\"\n\nYou must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.")
    }

    pub fn cli_actions_list_required_workflows() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List required workflows\n\nList all required workflows in an organization.\n\nYou must authenticate using an access token with the `read:org` scope to use this endpoint.\n\nFor more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_create_required_workflow() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The ID of the repository that contains the workflow file.")) . arg (clap :: Arg :: new ("scope") . long ("scope") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActionsCreateRequiredWorkflowBodyScope :: Selected . to_string () , types :: ActionsCreateRequiredWorkflowBodyScope :: All . to_string () ,]) , | s | types :: ActionsCreateRequiredWorkflowBodyScope :: try_from (s) . unwrap ())) . help ("Enable the required workflow for all repositories or selected repositories in the organization.")) . arg (clap :: Arg :: new ("workflow-file-path") . long ("workflow-file-path") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("Path of the workflow file to be configured as a required workflow.")) . about ("Create a required workflow\n\nCreate a required workflow in an organization.\n\nYou must authenticate using an access token with the `admin:org` scope to use this endpoint.\n\nFor more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_get_required_workflow() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("required-workflow-id") . long ("required-workflow-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the required workflow.")) . about ("Get a required workflow\n\nGet a required workflow configured in an organization.\n\nYou must authenticate using an access token with the `read:org` scope to use this endpoint.\n\nFor more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_delete_required_workflow() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("required-workflow-id") . long ("required-workflow-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the required workflow.")) . about ("Delete a required workflow\n\nDeletes a required workflow configured in an organization.\n\nYou must authenticate using an access token with the `admin:org` scope to use this endpoint.\n\nFor more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_update_required_workflow() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("required-workflow-id") . long ("required-workflow-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the required workflow.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The ID of the repository that contains the workflow file.")) . arg (clap :: Arg :: new ("scope") . long ("scope") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActionsUpdateRequiredWorkflowBodyScope :: Selected . to_string () , types :: ActionsUpdateRequiredWorkflowBodyScope :: All . to_string () ,]) , | s | types :: ActionsUpdateRequiredWorkflowBodyScope :: try_from (s) . unwrap ())) . help ("Enable the required workflow for all repositories or selected repositories in the organization.")) . arg (clap :: Arg :: new ("workflow-file-path") . long ("workflow-file-path") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Path of the workflow file to be configured as a required workflow.")) . about ("Update a required workflow\n\nUpdate a required workflow in an organization.\n\nYou must authenticate using an access token with the `admin:org` scope to use this endpoint.\n\nFor more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_list_selected_repositories_required_workflow() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("required-workflow-id") . long ("required-workflow-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the required workflow.")) . about ("List selected repositories for a required workflow\n\nLists the selected repositories that are configured for a required workflow in an organization. To use this endpoint, the required workflow must be configured to run on selected repositories.\n\nYou must authenticate using an access token with the `read:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this endpoint.\n\nFor more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_set_selected_repos_to_required_workflow() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("required-workflow-id") . long ("required-workflow-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the required workflow.")) . about ("Sets repositories for a required workflow\n\nSets the repositories for a required workflow that is required for selected repositories.\n\nYou must authenticate using an access token with the `admin:org` scope to use this endpoint.\n\nFor more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_add_selected_repo_to_required_workflow() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("required-workflow-id") . long ("required-workflow-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the required workflow.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the repository.")) . about ("Add a repository to a required workflow\n\nAdds a repository to a required workflow. To use this endpoint, the required workflow must be configured to run on selected repositories.\n\nYou must authenticate using an access token with the `admin:org` scope to use this endpoint.\n\nFor more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_remove_selected_repo_from_required_workflow() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("required-workflow-id") . long ("required-workflow-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the required workflow.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the repository.")) . about ("Remove a selected repository from required workflow\n\nRemoves a repository from a required workflow. To use this endpoint, the required workflow must be configured to run on selected repositories.\n\nYou must authenticate using an access token with the `admin:org` scope to use this endpoint.\n\nFor more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_list_self_hosted_runners_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List self-hosted runners for an organization\n\nLists all self-hosted runners \
                 configured in an organization.\n\nYou must authenticate using an access token \
                 with the `admin:org` scope to use this endpoint.",
            )
    }

    pub fn cli_actions_list_runner_applications_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "List runner applications for an organization\n\nLists binaries for the runner \
                 application that you can download and run.\n\nYou must authenticate using an \
                 access token with the `admin:org` scope to use this endpoint.",
            )
    }

    pub fn cli_actions_create_registration_token_for_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . about ("Create a registration token for an organization\n\nReturns a token that you can pass to the `config` script. The token expires after one hour.\n\nYou must authenticate using an access token with the `admin:org` scope to use this endpoint.\n\n#### Example using registration token\n\nConfigure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.\n\n```\n./config.sh --url https://github.com/octo-org --token TOKEN\n```")
    }

    pub fn cli_actions_create_remove_token_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Create a remove token for an organization\n\nReturns a token that you can pass \
                 to the `config` script to remove a self-hosted runner from an organization. The \
                 token expires after one hour.\n\nYou must authenticate using an access token \
                 with the `admin:org` scope to use this endpoint.\n\n#### Example using remove \
                 token\n\nTo remove your self-hosted runner from an organization, replace `TOKEN` \
                 with the remove token provided by this\nendpoint.\n\n```\n./config.sh remove \
                 --token TOKEN\n```",
            )
    }

    pub fn cli_actions_get_self_hosted_runner_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "Get a self-hosted runner for an organization\n\nGets a specific self-hosted \
                 runner configured in an organization.\n\nYou must authenticate using an access \
                 token with the `admin:org` scope to use this endpoint.",
            )
    }

    pub fn cli_actions_delete_self_hosted_runner_from_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "Delete a self-hosted runner from an organization\n\nForces the removal of a \
                 self-hosted runner from an organization. You can use this endpoint to completely \
                 remove the runner when the machine you were using no longer exists.\n\nYou must \
                 authenticate using an access token with the `admin:org` scope to use this \
                 endpoint.",
            )
    }

    pub fn cli_actions_list_labels_for_self_hosted_runner_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "List labels for a self-hosted runner for an organization\n\nLists all labels for \
                 a self-hosted runner configured in an organization.\n\nYou must authenticate \
                 using an access token with the `admin:org` scope to use this endpoint.",
            )
    }

    pub fn cli_actions_set_custom_labels_for_self_hosted_runner_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "Set custom labels for a self-hosted runner for an organization\n\nRemove all \
                 previous custom labels and set the new custom labels for a specific\nself-hosted \
                 runner configured in an organization.\n\nYou must authenticate using an access \
                 token with the `admin:org` scope to use this endpoint.",
            )
    }

    pub fn cli_actions_add_custom_labels_to_self_hosted_runner_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "Add custom labels to a self-hosted runner for an organization\n\nAdd custom \
                 labels to a self-hosted runner configured in an organization.\n\nYou must \
                 authenticate using an access token with the `admin:org` scope to use this \
                 endpoint.",
            )
    }

    pub fn cli_actions_remove_all_custom_labels_from_self_hosted_runner_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "Remove all custom labels from a self-hosted runner for an organization\n\nRemove \
                 all custom labels from a self-hosted runner configured in an\norganization. \
                 Returns the remaining read-only labels from the runner.\n\nYou must authenticate \
                 using an access token with the `admin:org` scope to use this endpoint.",
            )
    }

    pub fn cli_actions_remove_custom_label_from_self_hosted_runner_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of a self-hosted runner's custom label."),
            )
            .about(
                "Remove a custom label from a self-hosted runner for an organization\n\nRemove a \
                 custom label from a self-hosted runner configured\nin an organization. Returns \
                 the remaining labels from the runner.\n\nThis endpoint returns a `404 Not Found` \
                 status if the custom label is not\npresent on the runner.\n\nYou must \
                 authenticate using an access token with the `admin:org` scope to use this \
                 endpoint.",
            )
    }

    pub fn cli_actions_list_org_secrets() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List organization secrets\n\nLists all secrets available in an organization \
                 without revealing their encrypted values. You must authenticate using an access \
                 token with the `admin:org` scope to use this endpoint. GitHub Apps must have the \
                 `secrets` organization permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_org_public_key() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Get an organization public key\n\nGets your public key, which you need to \
                 encrypt secrets. You need to encrypt a secret before you can create or update \
                 secrets. You must authenticate using an access token with the `admin:org` scope \
                 to use this endpoint. GitHub Apps must have the `secrets` organization \
                 permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_org_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Get an organization secret\n\nGets a single organization secret without \
                 revealing its encrypted value. You must authenticate using an access token with \
                 the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` \
                 organization permission to use this endpoint.",
            )
    }

    pub fn cli_actions_create_or_update_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("encrypted-value") . long ("encrypted-value") . required (false) . value_parser (clap :: value_parser ! (types :: ActionsCreateOrUpdateOrgSecretBodyEncryptedValue)) . help ("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/reference/actions#get-an-organization-public-key) endpoint.")) . arg (clap :: Arg :: new ("key-id") . long ("key-id") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("ID of the key you used to encrypt the secret.")) . arg (clap :: Arg :: new ("visibility") . long ("visibility") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActionsCreateOrUpdateOrgSecretBodyVisibility :: All . to_string () , types :: ActionsCreateOrUpdateOrgSecretBodyVisibility :: Private . to_string () , types :: ActionsCreateOrUpdateOrgSecretBodyVisibility :: Selected . to_string () ,]) , | s | types :: ActionsCreateOrUpdateOrgSecretBodyVisibility :: try_from (s) . unwrap ())) . help ("Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.")) . about ("Create or update an organization secret\n\nCreates or updates an organization secret with an encrypted value. Encrypt your secret using\n[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access\ntoken with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to\nuse this endpoint.\n\n#### Example encrypting a secret using Node.js\n\nEncrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.\n\n```\nconst sodium = require('libsodium-wrappers')\nconst secret = 'plain-text-secret' // replace with the secret you want to encrypt\nconst key = 'base64-encoded-public-key' // replace with the Base64 encoded public key\n\n//Check if libsodium is ready and then proceed.\nsodium.ready.then(() => {\n  // Convert Secret & Base64 key to Uint8Array.\n  let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)\n  let binsec = sodium.from_string(secret)\n\n  //Encrypt the secret using LibSodium\n  let encBytes = sodium.crypto_box_seal(binsec, binkey)\n\n  // Convert encrypted Uint8Array to Base64\n  let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)\n\n  console.log(output)\n});\n```\n\n#### Example encrypting a secret using Python\n\nEncrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.\n\n```\nfrom base64 import b64encode\nfrom nacl import encoding, public\n\ndef encrypt(public_key: str, secret_value: str) -> str:\n  \"\"\"Encrypt a Unicode string using the public key.\"\"\"\n  public_key = public.PublicKey(public_key.encode(\"utf-8\"), encoding.Base64Encoder())\n  sealed_box = public.SealedBox(public_key)\n  encrypted = sealed_box.encrypt(secret_value.encode(\"utf-8\"))\n  return b64encode(encrypted).decode(\"utf-8\")\n```\n\n#### Example encrypting a secret using C#\n\nEncrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.\n\n```\nvar secretValue = System.Text.Encoding.UTF8.GetBytes(\"mySecret\");\nvar publicKey = Convert.FromBase64String(\"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=\");\n\nvar sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);\n\nConsole.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));\n```\n\n#### Example encrypting a secret using Ruby\n\nEncrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.\n\n```ruby\nrequire \"rbnacl\"\nrequire \"base64\"\n\nkey = Base64.decode64(\"+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=\")\npublic_key = RbNaCl::PublicKey.new(key)\n\nbox = RbNaCl::Boxes::Sealed.from_public_key(public_key)\nencrypted_secret = box.encrypt(\"my_secret\")\n\n# Print the base64 encoded secret\nputs Base64.strict_encode64(encrypted_secret)\n```")
    }

    pub fn cli_actions_delete_org_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Delete an organization secret\n\nDeletes a secret in an organization using the \
                 secret name. You must authenticate using an access token with the `admin:org` \
                 scope to use this endpoint. GitHub Apps must have the `secrets` organization \
                 permission to use this endpoint.",
            )
    }

    pub fn cli_actions_list_selected_repos_for_org_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List selected repositories for an organization secret\n\nLists all repositories \
                 that have been selected when the `visibility` for repository access to a secret \
                 is set to `selected`. You must authenticate using an access token with the \
                 `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` \
                 organization permission to use this endpoint.",
            )
    }

    pub fn cli_actions_set_selected_repos_for_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . about ("Set selected repositories for an organization secret\n\nReplaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.")
    }

    pub fn cli_actions_add_selected_repo_to_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64))) . about ("Add selected repository to an organization secret\n\nAdds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.")
    }

    pub fn cli_actions_remove_selected_repo_from_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64))) . about ("Remove selected repository from an organization secret\n\nRemoves a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.")
    }

    pub fn cli_actions_list_org_variables() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 30)."),
            )
            .about(
                "List organization variables\n\nLists all organization variables. You must \
                 authenticate using an access token with the `admin:org` scope to use this \
                 endpoint. GitHub Apps must have the `organization_actions_variables:read` \
                 organization permission to use this endpoint.",
            )
    }

    pub fn cli_actions_create_org_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("value")
                    .long("value")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The value of the variable."),
            )
            .arg(
                clap::Arg::new("visibility")
                    .long("visibility")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ActionsCreateOrgVariableBodyVisibility::All.to_string(),
                            types::ActionsCreateOrgVariableBodyVisibility::Private.to_string(),
                            types::ActionsCreateOrgVariableBodyVisibility::Selected.to_string(),
                        ]),
                        |s| types::ActionsCreateOrgVariableBodyVisibility::try_from(s).unwrap(),
                    ))
                    .help(
                        "The type of repositories in the organization that can access the \
                         variable. `selected` means only the repositories specified by \
                         `selected_repository_ids` can access the variable.",
                    ),
            )
            .about(
                "Create an organization variable\n\nCreates an organization variable that you can \
                 reference in a GitHub Actions workflow.\nYou must authenticate using an access \
                 token with the `admin:org` scope to use this endpoint.\nGitHub Apps must have \
                 the `organization_actions_variables:write` organization permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_actions_get_org_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .about(
                "Get an organization variable\n\nGets a specific variable in an organization. You \
                 must authenticate using an access token with the `admin:org` scope to use this \
                 endpoint. GitHub Apps must have the `organization_actions_variables:read` \
                 organization permission to use this endpoint.",
            )
    }

    pub fn cli_actions_delete_org_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .about(
                "Delete an organization variable\n\nDeletes an organization variable using the \
                 variable name.\nYou must authenticate using an access token with the `admin:org` \
                 scope to use this endpoint.\nGitHub Apps must have the \
                 `organization_actions_variables:write` organization permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_actions_update_org_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("value")
                    .long("value")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The value of the variable."),
            )
            .arg(
                clap::Arg::new("visibility")
                    .long("visibility")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ActionsUpdateOrgVariableBodyVisibility::All.to_string(),
                            types::ActionsUpdateOrgVariableBodyVisibility::Private.to_string(),
                            types::ActionsUpdateOrgVariableBodyVisibility::Selected.to_string(),
                        ]),
                        |s| types::ActionsUpdateOrgVariableBodyVisibility::try_from(s).unwrap(),
                    ))
                    .help(
                        "The type of repositories in the organization that can access the \
                         variable. `selected` means only the repositories specified by \
                         `selected_repository_ids` can access the variable.",
                    ),
            )
            .about(
                "Update an organization variable\n\nUpdates an organization variable that you can \
                 reference in a GitHub Actions workflow.\nYou must authenticate using an access \
                 token with the `admin:org` scope to use this endpoint.\nGitHub Apps must have \
                 the `organization_actions_variables:write` organization permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_actions_list_selected_repos_for_org_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List selected repositories for an organization variable\n\nLists all \
                 repositories that can access an organization variable that is available to \
                 selected repositories. You must authenticate using an access token with the \
                 `admin:org` scope to use this endpoint. GitHub Apps must have the \
                 `organization_actions_variables:read` organization permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_actions_set_selected_repos_for_org_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .about(
                "Set selected repositories for an organization variable\n\nReplaces all \
                 repositories for an organization variable that is available to selected \
                 repositories. Organization variables that are available to selected repositories \
                 have their `visibility` field set to `selected`. You must authenticate using an \
                 access token with the `admin:org` scope to use this endpoint. GitHub Apps must \
                 have the `organization_actions_variables:write` organization permission to use \
                 this endpoint.",
            )
    }

    pub fn cli_actions_add_selected_repo_to_org_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64)),
            )
            .about(
                "Add selected repository to an organization variable\n\nAdds a repository to an \
                 organization variable that is available to selected repositories. Organization \
                 variables that are available to selected repositories have their `visibility` \
                 field set to `selected`. You must authenticate using an access token with the \
                 `admin:org` scope to use this endpoint. GitHub Apps must have the \
                 `organization_actions_variables:write` organization permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_actions_remove_selected_repo_from_org_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64)),
            )
            .about(
                "Remove selected repository from an organization variable\n\nRemoves a repository \
                 from an organization variable that is available to selected repositories. \
                 Organization variables that are available to selected repositories have their \
                 `visibility` field set to `selected`. You must authenticate using an access \
                 token with the `admin:org` scope to use this endpoint. GitHub Apps must have the \
                 `organization_actions_variables:write` organization permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_orgs_list_blocked_users() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List users blocked by an organization\n\nList the users blocked by an \
                 organization.",
            )
    }

    pub fn cli_orgs_check_blocked_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about("Check if a user is blocked by an organization")
    }

    pub fn cli_orgs_block_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about("Block a user from an organization")
    }

    pub fn cli_orgs_unblock_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about("Unblock a user from an organization")
    }

    pub fn cli_code_scanning_list_alerts_for_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("after") . long ("after") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor.")) . arg (clap :: Arg :: new ("before") . long ("before") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: CodeScanningListAlertsForOrgDirection :: Asc . to_string () , types :: CodeScanningListAlertsForOrgDirection :: Desc . to_string () ,]) , | s | types :: CodeScanningListAlertsForOrgDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("severity") . long ("severity") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: CodeScanningAlertSeverity :: Critical . to_string () , types :: CodeScanningAlertSeverity :: High . to_string () , types :: CodeScanningAlertSeverity :: Medium . to_string () , types :: CodeScanningAlertSeverity :: Low . to_string () , types :: CodeScanningAlertSeverity :: Warning . to_string () , types :: CodeScanningAlertSeverity :: Note . to_string () , types :: CodeScanningAlertSeverity :: Error . to_string () ,]) , | s | types :: CodeScanningAlertSeverity :: try_from (s) . unwrap ())) . help ("If specified, only code scanning alerts with this severity will be returned.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: CodeScanningListAlertsForOrgSort :: Created . to_string () , types :: CodeScanningListAlertsForOrgSort :: Updated . to_string () ,]) , | s | types :: CodeScanningListAlertsForOrgSort :: try_from (s) . unwrap ())) . help ("The property by which to sort the results.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: CodeScanningAlertState :: Open . to_string () , types :: CodeScanningAlertState :: Closed . to_string () , types :: CodeScanningAlertState :: Dismissed . to_string () , types :: CodeScanningAlertState :: Fixed . to_string () ,]) , | s | types :: CodeScanningAlertState :: try_from (s) . unwrap ())) . help ("If specified, only code scanning alerts with this state will be returned.")) . arg (clap :: Arg :: new ("tool-guid") . long ("tool-guid") . required (false) . value_parser (clap :: value_parser ! (types :: CodeScanningAnalysisToolGuid)) . help ("The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools may not include a GUID in their analysis data. You can specify the tool by using either `tool_guid` or `tool_name`, but not both.")) . arg (clap :: Arg :: new ("tool-name") . long ("tool-name") . required (false) . value_parser (clap :: value_parser ! (types :: CodeScanningAnalysisToolName)) . help ("The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using either `tool_name` or `tool_guid`, but not both.")) . about ("List code scanning alerts for an organization\n\nLists code scanning alerts for the default branch for all eligible repositories in an organization. Eligible repositories are repositories that are owned by organizations that you own or for which you are a security manager. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"\n\nTo use this endpoint, you must be an owner or security manager for the organization, and you must use an access token with the `repo` scope or `security_events` scope.\n\nFor public repositories, you may instead use the `public_repo` scope.\n\nGitHub Apps must have the `security_events` read permission to use this endpoint.")
    }

    pub fn cli_codespaces_list_in_organization() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List codespaces for the organization\n\nLists the codespaces associated to a \
                 specified organization.\n\nYou must authenticate using an access token with the \
                 `admin:org` scope to use this endpoint.",
            )
    }

    pub fn cli_codespaces_set_codespaces_billing() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("visibility") . long ("visibility") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: CodespacesSetCodespacesBillingBodyVisibility :: Disabled . to_string () , types :: CodespacesSetCodespacesBillingBodyVisibility :: SelectedMembers . to_string () , types :: CodespacesSetCodespacesBillingBodyVisibility :: AllMembers . to_string () , types :: CodespacesSetCodespacesBillingBodyVisibility :: AllMembersAndOutsideCollaborators . to_string () ,]) , | s | types :: CodespacesSetCodespacesBillingBodyVisibility :: try_from (s) . unwrap ())) . help ("Which users can access codespaces in the organization. `disabled` means that no users can access codespaces in the organization.")) . about ("Manage access control for organization codespaces\n\nSets which users can access codespaces in an organization. This is synonymous with granting or revoking codespaces billing permissions for users according to the visibility.\nYou must authenticate using an access token with the `admin:org` scope to use this endpoint.")
    }

    pub fn cli_codespaces_set_codespaces_billing_users() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . about ("Add users to Codespaces billing for an organization\n\nCodespaces for the specified users will be billed to the organization.\nTo use this endpoint, the billing settings for the organization must be set to `selected_members`. For information on how to change this setting please see [these docs].(https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces) You must authenticate using an access token with the `admin:org` scope to use this endpoint.")
    }

    pub fn cli_codespaces_delete_codespaces_billing_users() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . about ("Removes users from Codespaces billing for an organization\n\nCodespaces for the specified users will no longer be billed to the organization.\nTo use this endpoint, the billing settings for the organization must be set to `selected_members`. For information on how to change this setting please see [these docs].(https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces) You must authenticate using an access token with the `admin:org` scope to use this endpoint.")
    }

    pub fn cli_codespaces_list_org_secrets() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List organization secrets\n\nLists all Codespaces secrets available at the \
                 organization-level without revealing their encrypted values.\nYou must \
                 authenticate using an access token with the `admin:org` scope to use this \
                 endpoint.",
            )
    }

    pub fn cli_codespaces_get_org_public_key() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Get an organization public key\n\nGets a public key for an organization, which \
                 is required in order to encrypt secrets. You need to encrypt the value of a \
                 secret before you can create or update secrets. You must authenticate using an \
                 access token with the `admin:org` scope to use this endpoint.",
            )
    }

    pub fn cli_codespaces_get_org_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Get an organization secret\n\nGets an organization secret without revealing its \
                 encrypted value.\nYou must authenticate using an access token with the \
                 `admin:org` scope to use this endpoint.",
            )
    }

    pub fn cli_codespaces_create_or_update_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("encrypted-value") . long ("encrypted-value") . required (false) . value_parser (clap :: value_parser ! (types :: CodespacesCreateOrUpdateOrgSecretBodyEncryptedValue)) . help ("The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/reference/codespaces#get-an-organization-public-key) endpoint.")) . arg (clap :: Arg :: new ("key-id") . long ("key-id") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The ID of the key you used to encrypt the secret.")) . arg (clap :: Arg :: new ("visibility") . long ("visibility") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: CodespacesCreateOrUpdateOrgSecretBodyVisibility :: All . to_string () , types :: CodespacesCreateOrUpdateOrgSecretBodyVisibility :: Private . to_string () , types :: CodespacesCreateOrUpdateOrgSecretBodyVisibility :: Selected . to_string () ,]) , | s | types :: CodespacesCreateOrUpdateOrgSecretBodyVisibility :: try_from (s) . unwrap ())) . help ("Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.")) . about ("Create or update an organization secret\n\nCreates or updates an organization secret with an encrypted value. Encrypt your secret using\n[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access\ntoken with the `admin:org` scope to use this endpoint.\n\n#### Example encrypting a secret using Node.js\n\nEncrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.\n\n```\nconst sodium = require('libsodium-wrappers')\nconst secret = 'plain-text-secret' // replace with the secret you want to encrypt\nconst key = 'base64-encoded-public-key' // replace with the Base64 encoded public key\n\n//Check if libsodium is ready and then proceed.\nsodium.ready.then(() => {\n  // Convert Secret & Base64 key to Uint8Array.\n  let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)\n  let binsec = sodium.from_string(secret)\n\n  //Encrypt the secret using LibSodium\n  let encBytes = sodium.crypto_box_seal(binsec, binkey)\n\n  // Convert encrypted Uint8Array to Base64\n  let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)\n\n  console.log(output)\n});\n```\n\n#### Example encrypting a secret using Python\n\nEncrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.\n\n```\nfrom base64 import b64encode\nfrom nacl import encoding, public\n\ndef encrypt(public_key: str, secret_value: str) -> str:\n  \"\"\"Encrypt a Unicode string using the public key.\"\"\"\n  public_key = public.PublicKey(public_key.encode(\"utf-8\"), encoding.Base64Encoder())\n  sealed_box = public.SealedBox(public_key)\n  encrypted = sealed_box.encrypt(secret_value.encode(\"utf-8\"))\n  return b64encode(encrypted).decode(\"utf-8\")\n```\n\n#### Example encrypting a secret using C#\n\nEncrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.\n\n```\nvar secretValue = System.Text.Encoding.UTF8.GetBytes(\"mySecret\");\nvar publicKey = Convert.FromBase64String(\"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=\");\n\nvar sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);\n\nConsole.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));\n```\n\n#### Example encrypting a secret using Ruby\n\nEncrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.\n\n```ruby\nrequire \"rbnacl\"\nrequire \"base64\"\n\nkey = Base64.decode64(\"+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=\")\npublic_key = RbNaCl::PublicKey.new(key)\n\nbox = RbNaCl::Boxes::Sealed.from_public_key(public_key)\nencrypted_secret = box.encrypt(\"my_secret\")\n\n# Print the base64 encoded secret\nputs Base64.strict_encode64(encrypted_secret)\n```")
    }

    pub fn cli_codespaces_delete_org_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Delete an organization secret\n\nDeletes an organization secret using the secret \
                 name. You must authenticate using an access token with the `admin:org` scope to \
                 use this endpoint.",
            )
    }

    pub fn cli_codespaces_list_selected_repos_for_org_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List selected repositories for an organization secret\n\nLists all repositories \
                 that have been selected when the `visibility` for repository access to a secret \
                 is set to `selected`. You must authenticate using an access token with the \
                 `admin:org` scope to use this endpoint.",
            )
    }

    pub fn cli_codespaces_set_selected_repos_for_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . about ("Set selected repositories for an organization secret\n\nReplaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint.")
    }

    pub fn cli_codespaces_add_selected_repo_to_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64))) . about ("Add selected repository to an organization secret\n\nAdds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint.")
    }

    pub fn cli_codespaces_remove_selected_repo_from_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64))) . about ("Remove selected repository from an organization secret\n\nRemoves a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint.")
    }

    pub fn cli_dependabot_list_alerts_for_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("after") . long ("after") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor.")) . arg (clap :: Arg :: new ("before") . long ("before") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: DependabotListAlertsForOrgDirection :: Asc . to_string () , types :: DependabotListAlertsForOrgDirection :: Desc . to_string () ,]) , | s | types :: DependabotListAlertsForOrgDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("ecosystem") . long ("ecosystem") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`")) . arg (clap :: Arg :: new ("first") . long ("first") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("**Deprecated**. The number of results per page (max 100), starting from the first matching result.\nThis parameter must not be used in combination with `last`.\nInstead, use `per_page` in combination with `after` to fetch the first page of results.")) . arg (clap :: Arg :: new ("last") . long ("last") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("**Deprecated**. The number of results per page (max 100), starting from the last matching result.\nThis parameter must not be used in combination with `first`.\nInstead, use `per_page` in combination with `before` to fetch the last page of results.")) . arg (clap :: Arg :: new ("package") . long ("package") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of package names. If specified, only alerts for these packages will be returned.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("scope") . long ("scope") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: DependabotListAlertsForOrgScope :: Development . to_string () , types :: DependabotListAlertsForOrgScope :: Runtime . to_string () ,]) , | s | types :: DependabotListAlertsForOrgScope :: try_from (s) . unwrap ())) . help ("The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.")) . arg (clap :: Arg :: new ("severity") . long ("severity") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: DependabotListAlertsForOrgSort :: Created . to_string () , types :: DependabotListAlertsForOrgSort :: Updated . to_string () ,]) , | s | types :: DependabotListAlertsForOrgSort :: try_from (s) . unwrap ())) . help ("The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`")) . about ("List Dependabot alerts for an organization\n\nLists Dependabot alerts for an organization.\n\nTo use this endpoint, you must be an owner or security manager for the organization, and you must use an access token with the `repo` scope or `security_events` scope.\n\nFor public repositories, you may instead use the `public_repo` scope.\n\nGitHub Apps must have **Dependabot alerts** read permission to use this endpoint.")
    }

    pub fn cli_dependabot_list_org_secrets() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List organization secrets\n\nLists all secrets available in an organization \
                 without revealing their encrypted values. You must authenticate using an access \
                 token with the `admin:org` scope to use this endpoint. GitHub Apps must have the \
                 `dependabot_secrets` organization permission to use this endpoint.",
            )
    }

    pub fn cli_dependabot_get_org_public_key() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Get an organization public key\n\nGets your public key, which you need to \
                 encrypt secrets. You need to encrypt a secret before you can create or update \
                 secrets. You must authenticate using an access token with the `admin:org` scope \
                 to use this endpoint. GitHub Apps must have the `dependabot_secrets` \
                 organization permission to use this endpoint.",
            )
    }

    pub fn cli_dependabot_get_org_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Get an organization secret\n\nGets a single organization secret without \
                 revealing its encrypted value. You must authenticate using an access token with \
                 the `admin:org` scope to use this endpoint. GitHub Apps must have the \
                 `dependabot_secrets` organization permission to use this endpoint.",
            )
    }

    pub fn cli_dependabot_create_or_update_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("encrypted-value") . long ("encrypted-value") . required (false) . value_parser (clap :: value_parser ! (types :: DependabotCreateOrUpdateOrgSecretBodyEncryptedValue)) . help ("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/reference/dependabot#get-an-organization-public-key) endpoint.")) . arg (clap :: Arg :: new ("key-id") . long ("key-id") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("ID of the key you used to encrypt the secret.")) . arg (clap :: Arg :: new ("visibility") . long ("visibility") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: DependabotCreateOrUpdateOrgSecretBodyVisibility :: All . to_string () , types :: DependabotCreateOrUpdateOrgSecretBodyVisibility :: Private . to_string () , types :: DependabotCreateOrUpdateOrgSecretBodyVisibility :: Selected . to_string () ,]) , | s | types :: DependabotCreateOrUpdateOrgSecretBodyVisibility :: try_from (s) . unwrap ())) . help ("Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.")) . about ("Create or update an organization secret\n\nCreates or updates an organization secret with an encrypted value. Encrypt your secret using\n[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access\ntoken with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization\npermission to use this endpoint.\n\n#### Example encrypting a secret using Node.js\n\nEncrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.\n\n```\nconst sodium = require('libsodium-wrappers')\nconst secret = 'plain-text-secret' // replace with the secret you want to encrypt\nconst key = 'base64-encoded-public-key' // replace with the Base64 encoded public key\n\n//Check if libsodium is ready and then proceed.\nsodium.ready.then(() => {\n  // Convert Secret & Base64 key to Uint8Array.\n  let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)\n  let binsec = sodium.from_string(secret)\n\n  //Encrypt the secret using LibSodium\n  let encBytes = sodium.crypto_box_seal(binsec, binkey)\n\n  // Convert encrypted Uint8Array to Base64\n  let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)\n\n  console.log(output)\n});\n```\n\n#### Example encrypting a secret using Python\n\nEncrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.\n\n```\nfrom base64 import b64encode\nfrom nacl import encoding, public\n\ndef encrypt(public_key: str, secret_value: str) -> str:\n  \"\"\"Encrypt a Unicode string using the public key.\"\"\"\n  public_key = public.PublicKey(public_key.encode(\"utf-8\"), encoding.Base64Encoder())\n  sealed_box = public.SealedBox(public_key)\n  encrypted = sealed_box.encrypt(secret_value.encode(\"utf-8\"))\n  return b64encode(encrypted).decode(\"utf-8\")\n```\n\n#### Example encrypting a secret using C#\n\nEncrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.\n\n```\nvar secretValue = System.Text.Encoding.UTF8.GetBytes(\"mySecret\");\nvar publicKey = Convert.FromBase64String(\"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=\");\n\nvar sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);\n\nConsole.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));\n```\n\n#### Example encrypting a secret using Ruby\n\nEncrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.\n\n```ruby\nrequire \"rbnacl\"\nrequire \"base64\"\n\nkey = Base64.decode64(\"+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=\")\npublic_key = RbNaCl::PublicKey.new(key)\n\nbox = RbNaCl::Boxes::Sealed.from_public_key(public_key)\nencrypted_secret = box.encrypt(\"my_secret\")\n\n# Print the base64 encoded secret\nputs Base64.strict_encode64(encrypted_secret)\n```")
    }

    pub fn cli_dependabot_delete_org_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Delete an organization secret\n\nDeletes a secret in an organization using the \
                 secret name. You must authenticate using an access token with the `admin:org` \
                 scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` \
                 organization permission to use this endpoint.",
            )
    }

    pub fn cli_dependabot_list_selected_repos_for_org_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List selected repositories for an organization secret\n\nLists all repositories \
                 that have been selected when the `visibility` for repository access to a secret \
                 is set to `selected`. You must authenticate using an access token with the \
                 `admin:org` scope to use this endpoint. GitHub Apps must have the \
                 `dependabot_secrets` organization permission to use this endpoint.",
            )
    }

    pub fn cli_dependabot_set_selected_repos_for_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . about ("Set selected repositories for an organization secret\n\nReplaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.")
    }

    pub fn cli_dependabot_add_selected_repo_to_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64))) . about ("Add selected repository to an organization secret\n\nAdds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.")
    }

    pub fn cli_dependabot_remove_selected_repo_from_org_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64))) . about ("Remove selected repository from an organization secret\n\nRemoves a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.")
    }

    pub fn cli_packages_list_docker_migration_conflicting_packages_for_organization(
    ) -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Get list of conflicting packages during Docker migration for \
                 organization\n\nLists all packages that are in a specific organization, are \
                 readable by the requesting user, and that encountered a conflict during a Docker \
                 migration.\nTo use this endpoint, you must authenticate using an access token \
                 with the `read:packages` scope.",
            )
    }

    pub fn cli_activity_list_public_org_events() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List public organization events")
    }

    pub fn cli_orgs_list_failed_invitations() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List failed organization invitations\n\nThe return hash contains `failed_at` and \
                 `failed_reason` fields which represent the time at which the invitation failed \
                 and the reason for the failure.",
            )
    }

    pub fn cli_orgs_list_webhooks() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List organization webhooks")
    }

    pub fn cli_orgs_create_webhook() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("active")
                    .long("active")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Determines if notifications are sent when the webhook is triggered. Set \
                         to `true` to send notifications.",
                    ),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("Must be passed as \"web\"."),
            )
            .about(
                "Create an organization webhook\n\nHere's how you can create a hook that posts \
                 payloads in JSON format:",
            )
    }

    pub fn cli_orgs_get_webhook() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .about(
                "Get an organization webhook\n\nReturns a webhook configured in an organization. \
                 To get only the webhook `config` properties, see \"[Get a webhook configuration \
                 for an organization](/rest/reference/orgs#\
                 get-a-webhook-configuration-for-an-organization).\"",
            )
    }

    pub fn cli_orgs_delete_webhook() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .about("Delete an organization webhook")
    }

    pub fn cli_orgs_update_webhook() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .arg(
                clap::Arg::new("active")
                    .long("active")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Determines if notifications are sent when the webhook is triggered. Set \
                         to `true` to send notifications.",
                    ),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String)),
            )
            .about(
                "Update an organization webhook\n\nUpdates a webhook configured in an \
                 organization. When you update a webhook, the `secret` will be overwritten. If \
                 you previously had a `secret` set, you must provide the same `secret` or set a \
                 new `secret` or the secret will be removed. If you are only updating individual \
                 webhook `config` properties, use \"[Update a webhook configuration for an \
                 organization](/rest/reference/orgs#\
                 update-a-webhook-configuration-for-an-organization).\"",
            )
    }

    pub fn cli_orgs_get_webhook_config_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .about(
                "Get a webhook configuration for an organization\n\nReturns the webhook \
                 configuration for an organization. To get more information about the webhook, \
                 including the `active` state and `events`, use \"[Get an organization webhook \
                 ](/rest/reference/orgs#get-an-organization-webhook).\"\n\nAccess tokens must \
                 have the `admin:org_hook` scope, and GitHub Apps must have the \
                 `organization_hooks:read` permission.",
            )
    }

    pub fn cli_orgs_update_webhook_config_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .arg(
                clap::Arg::new("content-type")
                    .long("content-type")
                    .required(false)
                    .value_parser(clap::value_parser!(types::WebhookConfigContentType)),
            )
            .arg(
                clap::Arg::new("insecure-ssl")
                    .long("insecure-ssl")
                    .required(false)
                    .value_parser(clap::value_parser!(types::WebhookConfigInsecureSsl)),
            )
            .arg(
                clap::Arg::new("secret")
                    .long("secret")
                    .required(false)
                    .value_parser(clap::value_parser!(types::WebhookConfigSecret)),
            )
            .arg(
                clap::Arg::new("url")
                    .long("url")
                    .required(false)
                    .value_parser(clap::value_parser!(types::WebhookConfigUrl)),
            )
            .about(
                "Update a webhook configuration for an organization\n\nUpdates the webhook \
                 configuration for an organization. To update more information about the webhook, \
                 including the `active` state and `events`, use \"[Update an organization webhook \
                 ](/rest/reference/orgs#update-an-organization-webhook).\"\n\nAccess tokens must \
                 have the `admin:org_hook` scope, and GitHub Apps must have the \
                 `organization_hooks:write` permission.",
            )
    }

    pub fn cli_orgs_list_webhook_deliveries() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .arg(
                clap::Arg::new("cursor")
                    .long("cursor")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "Used for pagination: the starting delivery from which the page of \
                         deliveries is fetched. Refer to the `link` header for the next and \
                         previous page cursors.",
                    ),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("redelivery")
                    .long("redelivery")
                    .required(false)
                    .value_parser(clap::value_parser!(bool)),
            )
            .about(
                "List deliveries for an organization webhook\n\nReturns a list of webhook \
                 deliveries for a webhook configured in an organization.",
            )
    }

    pub fn cli_orgs_get_webhook_delivery() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .arg(
                clap::Arg::new("delivery-id")
                    .long("delivery-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64)),
            )
            .about(
                "Get a webhook delivery for an organization webhook\n\nReturns a delivery for a \
                 webhook configured in an organization.",
            )
    }

    pub fn cli_orgs_redeliver_webhook_delivery() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .arg(
                clap::Arg::new("delivery-id")
                    .long("delivery-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64)),
            )
            .about(
                "Redeliver a delivery for an organization webhook\n\nRedeliver a delivery for a \
                 webhook configured in an organization.",
            )
    }

    pub fn cli_orgs_ping_webhook() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("hook-id") . long ("hook-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the hook.")) . about ("Ping an organization webhook\n\nThis will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.")
    }

    pub fn cli_apps_get_org_installation() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . about ("Get an organization installation for the authenticated app\n\nEnables an authenticated GitHub App to find the organization's installation information.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_orgs_list_app_installations() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List app installations for an organization\n\nLists all GitHub Apps in an \
                 organization. The installation count includes all GitHub Apps installed on \
                 repositories in the organization. You must be an organization owner with \
                 `admin:read` scope to use this endpoint.",
            )
    }

    pub fn cli_interactions_get_restrictions_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Get interaction restrictions for an organization\n\nShows which type of GitHub \
                 user can interact with this organization and when the restriction expires. If \
                 there is no restrictions, you will see an empty response.",
            )
    }

    pub fn cli_interactions_set_restrictions_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("expiry")
                    .long("expiry")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::InteractionExpiry::OneDay.to_string(),
                            types::InteractionExpiry::ThreeDays.to_string(),
                            types::InteractionExpiry::OneWeek.to_string(),
                            types::InteractionExpiry::OneMonth.to_string(),
                            types::InteractionExpiry::SixMonths.to_string(),
                        ]),
                        |s| types::InteractionExpiry::try_from(s).unwrap(),
                    )),
            )
            .arg(
                clap::Arg::new("limit")
                    .long("limit")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::InteractionGroup::ExistingUsers.to_string(),
                            types::InteractionGroup::ContributorsOnly.to_string(),
                            types::InteractionGroup::CollaboratorsOnly.to_string(),
                        ]),
                        |s| types::InteractionGroup::try_from(s).unwrap(),
                    )),
            )
            .about(
                "Set interaction restrictions for an organization\n\nTemporarily restricts \
                 interactions to a certain type of GitHub user in any public repository in the \
                 given organization. You must be an organization owner to set these restrictions. \
                 Setting the interaction limit at the organization level will overwrite any \
                 interaction limits that are set for individual repositories owned by the \
                 organization.",
            )
    }

    pub fn cli_interactions_remove_restrictions_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Remove interaction restrictions for an organization\n\nRemoves all interaction \
                 restrictions from public repositories in the given organization. You must be an \
                 organization owner to remove restrictions.",
            )
    }

    pub fn cli_orgs_list_pending_invitations() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("invitation-source")
                    .long("invitation-source")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::OrgsListPendingInvitationsInvitationSource::All.to_string(),
                            types::OrgsListPendingInvitationsInvitationSource::Member.to_string(),
                            types::OrgsListPendingInvitationsInvitationSource::Scim.to_string(),
                        ]),
                        |s| types::OrgsListPendingInvitationsInvitationSource::try_from(s).unwrap(),
                    ))
                    .help("Filter invitations by their invitation source."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("role")
                    .long("role")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::OrgsListPendingInvitationsRole::All.to_string(),
                            types::OrgsListPendingInvitationsRole::Admin.to_string(),
                            types::OrgsListPendingInvitationsRole::DirectMember.to_string(),
                            types::OrgsListPendingInvitationsRole::BillingManager.to_string(),
                            types::OrgsListPendingInvitationsRole::HiringManager.to_string(),
                        ]),
                        |s| types::OrgsListPendingInvitationsRole::try_from(s).unwrap(),
                    ))
                    .help("Filter invitations by their member role."),
            )
            .about(
                "List pending organization invitations\n\nThe return hash contains a `role` field \
                 which refers to the Organization Invitation role and will be one of the \
                 following values: `direct_member`, `admin`, `billing_manager`, or \
                 `hiring_manager`. If the invitee is not a GitHub member, the `login` field in \
                 the return hash will be `null`.",
            )
    }

    pub fn cli_orgs_create_invitation() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("email") . long ("email") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("**Required unless you provide `invitee_id`**. Email address of the person you are inviting, which can be an existing GitHub user.")) . arg (clap :: Arg :: new ("invitee-id") . long ("invitee-id") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("**Required unless you provide `email`**. GitHub user ID for the person you are inviting.")) . arg (clap :: Arg :: new ("role") . long ("role") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: OrgsCreateInvitationBodyRole :: Admin . to_string () , types :: OrgsCreateInvitationBodyRole :: DirectMember . to_string () , types :: OrgsCreateInvitationBodyRole :: BillingManager . to_string () ,]) , | s | types :: OrgsCreateInvitationBodyRole :: try_from (s) . unwrap ())) . help ("The role for the new member. \n * `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.  \n * `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.  \n * `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization.")) . about ("Create an organization invitation\n\nInvite people to an organization by using their GitHub user ID or their email address. In order to create invitations in an organization, the authenticated user must be an organization owner.\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.")
    }

    pub fn cli_orgs_cancel_invitation() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("invitation-id") . long ("invitation-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the invitation.")) . about ("Cancel an organization invitation\n\nCancel an organization invitation. In order to cancel an organization invitation, the authenticated user must be an organization owner.\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).")
    }

    pub fn cli_orgs_list_invitation_teams() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("invitation-id")
                    .long("invitation-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the invitation."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List organization invitation teams\n\nList all teams associated with an \
                 invitation. In order to see invitations in an organization, the authenticated \
                 user must be an organization owner.",
            )
    }

    pub fn cli_issues_list_for_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListForOrgDirection :: Asc . to_string () , types :: IssuesListForOrgDirection :: Desc . to_string () ,]) , | s | types :: IssuesListForOrgDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("filter") . long ("filter") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListForOrgFilter :: Assigned . to_string () , types :: IssuesListForOrgFilter :: Created . to_string () , types :: IssuesListForOrgFilter :: Mentioned . to_string () , types :: IssuesListForOrgFilter :: Subscribed . to_string () , types :: IssuesListForOrgFilter :: Repos . to_string () , types :: IssuesListForOrgFilter :: All . to_string () ,]) , | s | types :: IssuesListForOrgFilter :: try_from (s) . unwrap ())) . help ("Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.")) . arg (clap :: Arg :: new ("labels") . long ("labels") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A list of comma separated label names. Example: `bug,ui,@high`")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListForOrgSort :: Created . to_string () , types :: IssuesListForOrgSort :: Updated . to_string () , types :: IssuesListForOrgSort :: Comments . to_string () ,]) , | s | types :: IssuesListForOrgSort :: try_from (s) . unwrap ())) . help ("What to sort results by.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListForOrgState :: Open . to_string () , types :: IssuesListForOrgState :: Closed . to_string () , types :: IssuesListForOrgState :: All . to_string () ,]) , | s | types :: IssuesListForOrgState :: try_from (s) . unwrap ())) . help ("Indicates the state of the issues to return.")) . about ("List organization issues assigned to the authenticated user\n\nList issues in an organization assigned to the authenticated user.\n\n**Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this\nreason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by\nthe `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull\nrequest id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.")
    }

    pub fn cli_orgs_list_members() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("filter") . long ("filter") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: OrgsListMembersFilter :: _2faDisabled . to_string () , types :: OrgsListMembersFilter :: All . to_string () ,]) , | s | types :: OrgsListMembersFilter :: try_from (s) . unwrap ())) . help ("Filter members returned in the list. `2fa_disabled` means that only members without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned. This options is only available for organization owners.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("role") . long ("role") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: OrgsListMembersRole :: All . to_string () , types :: OrgsListMembersRole :: Admin . to_string () , types :: OrgsListMembersRole :: Member . to_string () ,]) , | s | types :: OrgsListMembersRole :: try_from (s) . unwrap ())) . help ("Filter members returned by their role.")) . about ("List organization members\n\nList all users who are members of an organization. If the authenticated user is also a member of this organization then both concealed and public members will be returned.")
    }

    pub fn cli_orgs_check_membership_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Check organization membership for a user\n\nCheck if a user is, publicly or \
                 privately, a member of the organization.",
            )
    }

    pub fn cli_orgs_remove_member() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Remove an organization member\n\nRemoving a user from this list will remove them \
                 from all teams and they will no longer have any access to the organization's \
                 repositories.",
            )
    }

    pub fn cli_codespaces_get_codespaces_for_user_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List codespaces for a user in organization\n\nLists the codespaces that a member \
                 of an organization has for repositories in that organization.\n\nYou must \
                 authenticate using an access token with the `admin:org` scope to use this \
                 endpoint.",
            )
    }

    pub fn cli_codespaces_delete_from_organization() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("codespace-name")
                    .long("codespace-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the codespace."),
            )
            .about(
                "Delete a codespace from the organization\n\nDeletes a user's codespace.\n\nYou \
                 must authenticate using an access token with the `admin:org` scope to use this \
                 endpoint.",
            )
    }

    pub fn cli_codespaces_stop_in_organization() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("codespace-name")
                    .long("codespace-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the codespace."),
            )
            .about(
                "Stop a codespace for an organization user\n\nStops a user's codespace.\n\nYou \
                 must authenticate using an access token with the `admin:org` scope to use this \
                 endpoint.",
            )
    }

    pub fn cli_orgs_get_membership_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Get organization membership for a user\n\nIn order to get a user's membership \
                 with an organization, the authenticated user must be an organization member. The \
                 `state` parameter in the response can be used to identify the user's membership \
                 status.",
            )
    }

    pub fn cli_orgs_set_membership_for_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("role") . long ("role") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: OrgsSetMembershipForUserBodyRole :: Admin . to_string () , types :: OrgsSetMembershipForUserBodyRole :: Member . to_string () ,]) , | s | types :: OrgsSetMembershipForUserBodyRole :: try_from (s) . unwrap ())) . help ("The role to give the user in the organization. Can be one of:  \n * `admin` - The user will become an owner of the organization.  \n * `member` - The user will become a non-owner member of the organization.")) . about ("Set organization membership for a user\n\nOnly authenticated organization owners can add a member to the organization or update the member's role.\n\n*   If the authenticated user is _adding_ a member to the organization, the invited user will receive an email inviting them to the organization. The user's [membership status](https://docs.github.com/rest/reference/orgs#get-organization-membership-for-a-user) will be `pending` until they accept the invitation.\n    \n*   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the authenticated user changes a member's role to `admin`, the affected user will receive an email notifying them that they've been made an organization owner. If the authenticated user changes an owner's role to `member`, no email will be sent.\n\n**Rate limits**\n\nTo prevent abuse, the authenticated user is limited to 50 organization invitations per 24 hour period. If the organization is more than one month old or on a paid plan, the limit is 500 invitations per 24 hour period.")
    }

    pub fn cli_orgs_remove_membership_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Remove organization membership for a user\n\nIn order to remove a user's \
                 membership with an organization, the authenticated user must be an organization \
                 owner.\n\nIf the specified user is an active member of the organization, this \
                 will remove them from the organization. If the specified user has been invited \
                 to the organization, this will cancel their invitation. The specified user will \
                 receive an email notification in both cases.",
            )
    }

    pub fn cli_migrations_list_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("exclude")
                    .long("exclude")
                    .required(false)
                    .value_parser(clap::value_parser!(
                        Vec<types::MigrationsListForOrgExcludeItem>
                    ))
                    .help("Exclude attributes from the API response to improve performance"),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List organization migrations\n\nLists the most recent migrations, including both \
                 exports (which can be started through the REST API) and imports (which cannot be \
                 started using the REST API).\n\nA list of `repositories` is only returned for \
                 export migrations.",
            )
    }

    pub fn cli_migrations_start_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("exclude-attachments")
                    .long("exclude-attachments")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether attachments should be excluded from the migration (to \
                         reduce migration archive file size).",
                    ),
            )
            .arg(
                clap::Arg::new("exclude-git-data")
                    .long("exclude-git-data")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether the repository git data should be excluded from the \
                         migration.",
                    ),
            )
            .arg(
                clap::Arg::new("exclude-metadata")
                    .long("exclude-metadata")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether metadata should be excluded and only git source should \
                         be included for the migration.",
                    ),
            )
            .arg(
                clap::Arg::new("exclude-owner-projects")
                    .long("exclude-owner-projects")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether projects owned by the organization or users should be \
                         excluded. from the migration.",
                    ),
            )
            .arg(
                clap::Arg::new("exclude-releases")
                    .long("exclude-releases")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether releases should be excluded from the migration (to \
                         reduce migration archive file size).",
                    ),
            )
            .arg(
                clap::Arg::new("lock-repositories")
                    .long("lock-repositories")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether repositories should be locked (to prevent \
                         manipulation) while migrating data.",
                    ),
            )
            .arg(
                clap::Arg::new("org-metadata-only")
                    .long("org-metadata-only")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether this should only include organization metadata \
                         (repositories array should be empty and will ignore other flags).",
                    ),
            )
            .about(
                "Start an organization migration\n\nInitiates the generation of a migration \
                 archive.",
            )
    }

    pub fn cli_migrations_get_status_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("migration-id")
                    .long("migration-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the migration."),
            )
            .arg(
                clap::Arg::new("exclude")
                    .long("exclude")
                    .required(false)
                    .value_parser(clap::value_parser!(
                        Vec<types::MigrationsGetStatusForOrgExcludeItem>
                    ))
                    .help("Exclude attributes from the API response to improve performance"),
            )
            .about(
                "Get an organization migration status\n\nFetches the status of a \
                 migration.\n\nThe `state` of a migration can be one of the following \
                 values:\n\n*   `pending`, which means the migration hasn't started yet.\n*   \
                 `exporting`, which means the migration is in progress.\n*   `exported`, which \
                 means the migration finished successfully.\n*   `failed`, which means the \
                 migration failed.",
            )
    }

    pub fn cli_migrations_download_archive_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("migration-id")
                    .long("migration-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the migration."),
            )
            .about(
                "Download an organization migration archive\n\nFetches the URL to a migration \
                 archive.",
            )
    }

    pub fn cli_migrations_delete_archive_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("migration-id")
                    .long("migration-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the migration."),
            )
            .about(
                "Delete an organization migration archive\n\nDeletes a previous migration \
                 archive. Migration archives are automatically deleted after seven days.",
            )
    }

    pub fn cli_migrations_unlock_repo_for_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("migration-id") . long ("migration-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the migration.")) . arg (clap :: Arg :: new ("repo-name") . long ("repo-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("repo_name parameter")) . about ("Unlock an organization repository\n\nUnlocks a repository that was locked for migration. You should unlock each migrated repository and [delete them](https://docs.github.com/rest/repos/repos#delete-a-repository) when the migration is complete and you no longer need the source data.")
    }

    pub fn cli_migrations_list_repos_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("migration-id")
                    .long("migration-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the migration."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repositories in an organization migration\n\nList all the repositories for \
                 this organization migration.",
            )
    }

    pub fn cli_orgs_list_outside_collaborators() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("filter") . long ("filter") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: OrgsListOutsideCollaboratorsFilter :: _2faDisabled . to_string () , types :: OrgsListOutsideCollaboratorsFilter :: All . to_string () ,]) , | s | types :: OrgsListOutsideCollaboratorsFilter :: try_from (s) . unwrap ())) . help ("Filter the list of outside collaborators. `2fa_disabled` means that only outside collaborators without [two-factor authentication](https://github.com/blog/1614-two-factor-authentication) enabled will be returned.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List outside collaborators for an organization\n\nList all users who are outside collaborators of an organization.")
    }

    pub fn cli_orgs_convert_member_to_outside_collaborator() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("async") . long ("async") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued.")) . about ("Convert an organization member to outside collaborator\n\nWhen an organization member is converted to an outside collaborator, they'll only have access to the repositories that their current team membership allows. The user will no longer be a member of the organization. For more information, see \"[Converting an organization member to an outside collaborator](https://docs.github.com/articles/converting-an-organization-member-to-an-outside-collaborator/)\". Converting an organization member to an outside collaborator may be restricted by enterprise administrators. For more information, see \"[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories).\"")
    }

    pub fn cli_orgs_remove_outside_collaborator() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Remove outside collaborator from an organization\n\nRemoving a user from this \
                 list will remove them from all the organization's repositories.",
            )
    }

    pub fn cli_packages_list_packages_for_organization() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesListPackagesForOrganizationPackageType :: Npm . to_string () , types :: PackagesListPackagesForOrganizationPackageType :: Maven . to_string () , types :: PackagesListPackagesForOrganizationPackageType :: Rubygems . to_string () , types :: PackagesListPackagesForOrganizationPackageType :: Docker . to_string () , types :: PackagesListPackagesForOrganizationPackageType :: Nuget . to_string () , types :: PackagesListPackagesForOrganizationPackageType :: Container . to_string () ,]) , | s | types :: PackagesListPackagesForOrganizationPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("visibility") . long ("visibility") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesListPackagesForOrganizationVisibility :: Public . to_string () , types :: PackagesListPackagesForOrganizationVisibility :: Private . to_string () , types :: PackagesListPackagesForOrganizationVisibility :: Internal . to_string () ,]) , | s | types :: PackagesListPackagesForOrganizationVisibility :: try_from (s) . unwrap ())) . help ("The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")) . about ("List packages for an organization\n\nLists packages in an organization readable by the user.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` scope. If the `package_type` belongs to a registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_get_package_for_organization() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesGetPackageForOrganizationPackageType :: Npm . to_string () , types :: PackagesGetPackageForOrganizationPackageType :: Maven . to_string () , types :: PackagesGetPackageForOrganizationPackageType :: Rubygems . to_string () , types :: PackagesGetPackageForOrganizationPackageType :: Docker . to_string () , types :: PackagesGetPackageForOrganizationPackageType :: Nuget . to_string () , types :: PackagesGetPackageForOrganizationPackageType :: Container . to_string () ,]) , | s | types :: PackagesGetPackageForOrganizationPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . about ("Get a package for an organization\n\nGets a specific package in an organization.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_delete_package_for_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesDeletePackageForOrgPackageType :: Npm . to_string () , types :: PackagesDeletePackageForOrgPackageType :: Maven . to_string () , types :: PackagesDeletePackageForOrgPackageType :: Rubygems . to_string () , types :: PackagesDeletePackageForOrgPackageType :: Docker . to_string () , types :: PackagesDeletePackageForOrgPackageType :: Nuget . to_string () , types :: PackagesDeletePackageForOrgPackageType :: Container . to_string () ,]) , | s | types :: PackagesDeletePackageForOrgPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . about ("Delete a package for an organization\n\nDeletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.\n\nTo use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `read:packages` and `delete:packages` scopes. In addition:\n- If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"\n- If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to delete. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")
    }

    pub fn cli_packages_restore_package_for_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesRestorePackageForOrgPackageType :: Npm . to_string () , types :: PackagesRestorePackageForOrgPackageType :: Maven . to_string () , types :: PackagesRestorePackageForOrgPackageType :: Rubygems . to_string () , types :: PackagesRestorePackageForOrgPackageType :: Docker . to_string () , types :: PackagesRestorePackageForOrgPackageType :: Nuget . to_string () , types :: PackagesRestorePackageForOrgPackageType :: Container . to_string () ,]) , | s | types :: PackagesRestorePackageForOrgPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("token") . long ("token") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("package token")) . about ("Restore a package for an organization\n\nRestores an entire package in an organization.\n\nYou can restore a deleted package under the following conditions:\n  - The package was deleted within the last 30 days.\n  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.\n\nTo use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `read:packages` and `write:packages` scopes. In addition:\n- If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"\n- If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to restore. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")
    }

    pub fn cli_packages_get_all_package_versions_for_package_owned_by_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType :: Npm . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType :: Maven . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType :: Rubygems . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType :: Docker . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType :: Nuget . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType :: Container . to_string () ,]) , | s | types :: PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesGetAllPackageVersionsForPackageOwnedByOrgState :: Active . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByOrgState :: Deleted . to_string () ,]) , | s | types :: PackagesGetAllPackageVersionsForPackageOwnedByOrgState :: try_from (s) . unwrap ())) . help ("The state of the package, either active or deleted.")) . about ("List package versions for a package owned by an organization\n\nLists package versions for a package owned by an organization.\n\nIf the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_get_package_version_for_organization() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesGetPackageVersionForOrganizationPackageType :: Npm . to_string () , types :: PackagesGetPackageVersionForOrganizationPackageType :: Maven . to_string () , types :: PackagesGetPackageVersionForOrganizationPackageType :: Rubygems . to_string () , types :: PackagesGetPackageVersionForOrganizationPackageType :: Docker . to_string () , types :: PackagesGetPackageVersionForOrganizationPackageType :: Nuget . to_string () , types :: PackagesGetPackageVersionForOrganizationPackageType :: Container . to_string () ,]) , | s | types :: PackagesGetPackageVersionForOrganizationPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("package-version-id") . long ("package-version-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("Unique identifier of the package version.")) . about ("Get a package version for an organization\n\nGets a specific package version in an organization.\n\nYou must authenticate using an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_delete_package_version_for_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesDeletePackageVersionForOrgPackageType :: Npm . to_string () , types :: PackagesDeletePackageVersionForOrgPackageType :: Maven . to_string () , types :: PackagesDeletePackageVersionForOrgPackageType :: Rubygems . to_string () , types :: PackagesDeletePackageVersionForOrgPackageType :: Docker . to_string () , types :: PackagesDeletePackageVersionForOrgPackageType :: Nuget . to_string () , types :: PackagesDeletePackageVersionForOrgPackageType :: Container . to_string () ,]) , | s | types :: PackagesDeletePackageVersionForOrgPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("package-version-id") . long ("package-version-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("Unique identifier of the package version.")) . about ("Delete package version for an organization\n\nDeletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.\n\nTo use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `read:packages` and `delete:packages` scopes. In addition:\n- If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"\n- If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to delete. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")
    }

    pub fn cli_packages_restore_package_version_for_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesRestorePackageVersionForOrgPackageType :: Npm . to_string () , types :: PackagesRestorePackageVersionForOrgPackageType :: Maven . to_string () , types :: PackagesRestorePackageVersionForOrgPackageType :: Rubygems . to_string () , types :: PackagesRestorePackageVersionForOrgPackageType :: Docker . to_string () , types :: PackagesRestorePackageVersionForOrgPackageType :: Nuget . to_string () , types :: PackagesRestorePackageVersionForOrgPackageType :: Container . to_string () ,]) , | s | types :: PackagesRestorePackageVersionForOrgPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("package-version-id") . long ("package-version-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("Unique identifier of the package version.")) . about ("Restore package version for an organization\n\nRestores a specific package version in an organization.\n\nYou can restore a deleted package under the following conditions:\n  - The package was deleted within the last 30 days.\n  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.\n\nTo use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `read:packages` and `write:packages` scopes. In addition:\n- If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"\n- If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to restore. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")
    }

    pub fn cli_projects_list_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ProjectsListForOrgState::Open.to_string(),
                            types::ProjectsListForOrgState::Closed.to_string(),
                            types::ProjectsListForOrgState::All.to_string(),
                        ]),
                        |s| types::ProjectsListForOrgState::try_from(s).unwrap(),
                    ))
                    .help("Indicates the state of the projects to return."),
            )
            .about(
                "List organization projects\n\nLists the projects in an organization. Returns a \
                 `404 Not Found` status if projects are disabled in the organization. If you do \
                 not have sufficient privileges to perform this action, a `401 Unauthorized` or \
                 `410 Gone` status is returned.",
            )
    }

    pub fn cli_projects_create_for_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("body")
                    .long("body")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The description of the project."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the project."),
            )
            .about(
                "Create an organization project\n\nCreates an organization project board. Returns \
                 a `410 Gone` status if projects are disabled in the organization or if the \
                 organization does not have existing classic projects. If you do not have \
                 sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` \
                 status is returned.",
            )
    }

    pub fn cli_orgs_list_public_members() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List public organization members\n\nMembers of an organization can choose to \
                 have their membership publicized or not.",
            )
    }

    pub fn cli_orgs_check_public_membership_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about("Check public organization membership for a user")
    }

    pub fn cli_orgs_set_public_membership_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Set public organization membership for the authenticated user\n\nThe user can publicize their own membership. (A user cannot publicize the membership for another user.)\n\nNote that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"")
    }

    pub fn cli_orgs_remove_public_membership_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about("Remove public organization membership for the authenticated user")
    }

    pub fn cli_repos_list_for_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposListForOrgDirection :: Asc . to_string () , types :: ReposListForOrgDirection :: Desc . to_string () ,]) , | s | types :: ReposListForOrgDirection :: try_from (s) . unwrap ())) . help ("The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposListForOrgSort :: Created . to_string () , types :: ReposListForOrgSort :: Updated . to_string () , types :: ReposListForOrgSort :: Pushed . to_string () , types :: ReposListForOrgSort :: FullName . to_string () ,]) , | s | types :: ReposListForOrgSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by.")) . arg (clap :: Arg :: new ("type") . long ("type") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposListForOrgType :: All . to_string () , types :: ReposListForOrgType :: Public . to_string () , types :: ReposListForOrgType :: Private . to_string () , types :: ReposListForOrgType :: Forks . to_string () , types :: ReposListForOrgType :: Sources . to_string () , types :: ReposListForOrgType :: Member . to_string () ,]) , | s | types :: ReposListForOrgType :: try_from (s) . unwrap ())) . help ("Specifies the types of repositories you want returned.")) . about ("List organization repositories\n\nLists repositories for the specified organization.\n\n**Note:** In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"")
    }

    pub fn cli_repos_create_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("allow-auto-merge") . long ("allow-auto-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.")) . arg (clap :: Arg :: new ("allow-merge-commit") . long ("allow-merge-commit") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.")) . arg (clap :: Arg :: new ("allow-rebase-merge") . long ("allow-rebase-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.")) . arg (clap :: Arg :: new ("allow-squash-merge") . long ("allow-squash-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.")) . arg (clap :: Arg :: new ("auto-init") . long ("auto-init") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Pass `true` to create an initial commit with empty README.")) . arg (clap :: Arg :: new ("delete-branch-on-merge") . long ("delete-branch-on-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**")) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A short description of the repository.")) . arg (clap :: Arg :: new ("gitignore-template") . long ("gitignore-template") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, \"Haskell\".")) . arg (clap :: Arg :: new ("has-downloads") . long ("has-downloads") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether downloads are enabled.")) . arg (clap :: Arg :: new ("has-issues") . long ("has-issues") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to enable issues for this repository or `false` to disable them.")) . arg (clap :: Arg :: new ("has-projects") . long ("has-projects") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.")) . arg (clap :: Arg :: new ("has-wiki") . long ("has-wiki") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to enable the wiki for this repository or `false` to disable it.")) . arg (clap :: Arg :: new ("homepage") . long ("homepage") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A URL with more information about the repository.")) . arg (clap :: Arg :: new ("is-template") . long ("is-template") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to make this repo available as a template repository or `false` to prevent it.")) . arg (clap :: Arg :: new ("license-template") . long ("license-template") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, \"mit\" or \"mpl-2.0\".")) . arg (clap :: Arg :: new ("merge-commit-message") . long ("merge-commit-message") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposCreateInOrgBodyMergeCommitMessage :: PrBody . to_string () , types :: ReposCreateInOrgBodyMergeCommitMessage :: PrTitle . to_string () , types :: ReposCreateInOrgBodyMergeCommitMessage :: Blank . to_string () ,]) , | s | types :: ReposCreateInOrgBodyMergeCommitMessage :: try_from (s) . unwrap ())) . help ("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")) . arg (clap :: Arg :: new ("merge-commit-title") . long ("merge-commit-title") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposCreateInOrgBodyMergeCommitTitle :: PrTitle . to_string () , types :: ReposCreateInOrgBodyMergeCommitTitle :: MergeMessage . to_string () ,]) , | s | types :: ReposCreateInOrgBodyMergeCommitTitle :: try_from (s) . unwrap ())) . help ("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")) . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository.")) . arg (clap :: Arg :: new ("private") . long ("private") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether the repository is private.")) . arg (clap :: Arg :: new ("squash-merge-commit-message") . long ("squash-merge-commit-message") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposCreateInOrgBodySquashMergeCommitMessage :: PrBody . to_string () , types :: ReposCreateInOrgBodySquashMergeCommitMessage :: CommitMessages . to_string () , types :: ReposCreateInOrgBodySquashMergeCommitMessage :: Blank . to_string () ,]) , | s | types :: ReposCreateInOrgBodySquashMergeCommitMessage :: try_from (s) . unwrap ())) . help ("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")) . arg (clap :: Arg :: new ("squash-merge-commit-title") . long ("squash-merge-commit-title") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposCreateInOrgBodySquashMergeCommitTitle :: PrTitle . to_string () , types :: ReposCreateInOrgBodySquashMergeCommitTitle :: CommitOrPrTitle . to_string () ,]) , | s | types :: ReposCreateInOrgBodySquashMergeCommitTitle :: try_from (s) . unwrap ())) . help ("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")) . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.")) . arg (clap :: Arg :: new ("use-squash-pr-title-as-default") . long ("use-squash-pr-title-as-default") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property has been deprecated. Please use `squash_merge_commit_title` instead.")) . arg (clap :: Arg :: new ("visibility") . long ("visibility") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposCreateInOrgBodyVisibility :: Public . to_string () , types :: ReposCreateInOrgBodyVisibility :: Private . to_string () ,]) , | s | types :: ReposCreateInOrgBodyVisibility :: try_from (s) . unwrap ())) . help ("The visibility of the repository.")) . about ("Create an organization repository\n\nCreates a new repository in the specified organization. The authenticated user must be a member of the organization.\n\n**OAuth scope requirements**\n\nWhen using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:\n\n*   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.\n*   `repo` scope to create a private repository")
    }

    pub fn cli_repos_get_org_rulesets() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about(
                "Get all organization repository rulesets\n\nGet all the repository rulesets for \
                 an organization.",
            )
    }

    pub fn cli_repos_create_org_ruleset() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("enforcement")
                    .long("enforcement")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::RepositoryRuleEnforcement::Disabled.to_string(),
                            types::RepositoryRuleEnforcement::Active.to_string(),
                            types::RepositoryRuleEnforcement::Evaluate.to_string(),
                        ]),
                        |s| types::RepositoryRuleEnforcement::try_from(s).unwrap(),
                    )),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the ruleset."),
            )
            .arg(
                clap::Arg::new("target")
                    .long("target")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposCreateOrgRulesetBodyTarget::Branch.to_string(),
                            types::ReposCreateOrgRulesetBodyTarget::Tag.to_string(),
                        ]),
                        |s| types::ReposCreateOrgRulesetBodyTarget::try_from(s).unwrap(),
                    ))
                    .help("The target of the ruleset."),
            )
            .about(
                "Create an organization repository ruleset\n\nCreate a repository ruleset for an \
                 organization.",
            )
    }

    pub fn cli_repos_get_org_ruleset() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ruleset-id")
                    .long("ruleset-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The ID of the ruleset."),
            )
            .about(
                "Get an organization repository ruleset\n\nGet a repository ruleset for an \
                 organization.",
            )
    }

    pub fn cli_repos_update_org_ruleset() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ruleset-id")
                    .long("ruleset-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The ID of the ruleset."),
            )
            .arg(
                clap::Arg::new("enforcement")
                    .long("enforcement")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::RepositoryRuleEnforcement::Disabled.to_string(),
                            types::RepositoryRuleEnforcement::Active.to_string(),
                            types::RepositoryRuleEnforcement::Evaluate.to_string(),
                        ]),
                        |s| types::RepositoryRuleEnforcement::try_from(s).unwrap(),
                    )),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the ruleset."),
            )
            .arg(
                clap::Arg::new("target")
                    .long("target")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposUpdateOrgRulesetBodyTarget::Branch.to_string(),
                            types::ReposUpdateOrgRulesetBodyTarget::Tag.to_string(),
                        ]),
                        |s| types::ReposUpdateOrgRulesetBodyTarget::try_from(s).unwrap(),
                    ))
                    .help("The target of the ruleset."),
            )
            .about(
                "Update an organization repository ruleset\n\nUpdate a ruleset for an \
                 organization.",
            )
    }

    pub fn cli_repos_delete_org_ruleset() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ruleset-id")
                    .long("ruleset-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The ID of the ruleset."),
            )
            .about(
                "Delete an organization repository ruleset\n\nDelete a ruleset for an \
                 organization.",
            )
    }

    pub fn cli_secret_scanning_list_alerts_for_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("after") . long ("after") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty \"after\" query string.")) . arg (clap :: Arg :: new ("before") . long ("before") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty \"before\" query string.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecretScanningListAlertsForOrgDirection :: Asc . to_string () , types :: SecretScanningListAlertsForOrgDirection :: Desc . to_string () ,]) , | s | types :: SecretScanningListAlertsForOrgDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("resolution") . long ("resolution") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.")) . arg (clap :: Arg :: new ("secret-type") . long ("secret-type") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of secret types to return. By default all secret types are returned.\nSee \"[Secret scanning patterns](https://docs.github.com/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)\"\nfor a complete list of secret types.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecretScanningListAlertsForOrgSort :: Created . to_string () , types :: SecretScanningListAlertsForOrgSort :: Updated . to_string () ,]) , | s | types :: SecretScanningListAlertsForOrgSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecretScanningListAlertsForOrgState :: Open . to_string () , types :: SecretScanningListAlertsForOrgState :: Resolved . to_string () ,]) , | s | types :: SecretScanningListAlertsForOrgState :: try_from (s) . unwrap ())) . help ("Set to `open` or `resolved` to only list secret scanning alerts in a specific state.")) . about ("List secret scanning alerts for an organization\n\nLists secret scanning alerts for eligible repositories in an organization, from newest to oldest.\nTo use this endpoint, you must be an administrator or security manager for the organization, and you must use an access token with the `repo` scope or `security_events` scope.\nFor public repositories, you may instead use the `public_repo` scope.\n\nGitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.")
    }

    pub fn cli_orgs_list_security_manager_teams() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . about ("List security manager teams\n\nLists teams that are security managers for an organization. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"\n\nTo use this endpoint, you must be an administrator or security manager for the organization, and you must use an access token with the `read:org` scope.\n\nGitHub Apps must have the `administration` organization read permission to use this endpoint.")
    }

    pub fn cli_orgs_add_security_manager_team() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . about ("Add a security manager team\n\nAdds a team as a security manager for an organization. For more information, see \"[Managing security for an organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization) for an organization.\"\n\nTo use this endpoint, you must be an administrator for the organization, and you must use an access token with the `write:org` scope.\n\nGitHub Apps must have the `administration` organization read-write permission to use this endpoint.")
    }

    pub fn cli_orgs_remove_security_manager_team() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . about ("Remove a security manager team\n\nRemoves the security manager role from a team for an organization. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization) team from an organization.\"\n\nTo use this endpoint, you must be an administrator for the organization, and you must use an access token with the `admin:org` scope.\n\nGitHub Apps must have the `administration` organization read-write permission to use this endpoint.")
    }

    pub fn cli_billing_get_github_actions_billing_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . about ("Get GitHub Actions billing for an organization\n\nGets the summary of the free and paid GitHub Actions minutes used.\n\nPaid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see \"[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)\".\n\nAccess tokens must have the `repo` or `admin:org` scope.")
    }

    pub fn cli_billing_get_github_packages_billing_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . about ("Get GitHub Packages billing for an organization\n\nGets the free and paid storage used for GitHub Packages in gigabytes.\n\nPaid minutes only apply to packages stored for private repositories. For more information, see \"[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages).\"\n\nAccess tokens must have the `repo` or `admin:org` scope.")
    }

    pub fn cli_billing_get_shared_storage_billing_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . about ("Get shared storage billing for an organization\n\nGets the estimated paid and estimated total storage used for GitHub Actions and GitHub Packages.\n\nPaid minutes only apply to packages stored for private repositories. For more information, see \"[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages).\"\n\nAccess tokens must have the `repo` or `admin:org` scope.")
    }

    pub fn cli_teams_list() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List teams\n\nLists all teams in an organization that are visible to the \
                 authenticated user.",
            )
    }

    pub fn cli_teams_create() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The description of the team.")) . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the team.")) . arg (clap :: Arg :: new ("notification-setting") . long ("notification-setting") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsCreateBodyNotificationSetting :: NotificationsEnabled . to_string () , types :: TeamsCreateBodyNotificationSetting :: NotificationsDisabled . to_string () ,]) , | s | types :: TeamsCreateBodyNotificationSetting :: try_from (s) . unwrap ())) . help ("The notification setting the team has chosen. The options are:  \n * `notifications_enabled` - team members receive notifications when the team is @mentioned.  \n * `notifications_disabled` - no one receives notifications.  \nDefault: `notifications_enabled`")) . arg (clap :: Arg :: new ("parent-team-id") . long ("parent-team-id") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The ID of a team to set as the parent team.")) . arg (clap :: Arg :: new ("permission") . long ("permission") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsCreateBodyPermission :: Pull . to_string () , types :: TeamsCreateBodyPermission :: Push . to_string () ,]) , | s | types :: TeamsCreateBodyPermission :: try_from (s) . unwrap ())) . help ("**Deprecated**. The permission that new repositories will be added to the team with when none is specified.")) . arg (clap :: Arg :: new ("privacy") . long ("privacy") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsCreateBodyPrivacy :: Secret . to_string () , types :: TeamsCreateBodyPrivacy :: Closed . to_string () ,]) , | s | types :: TeamsCreateBodyPrivacy :: try_from (s) . unwrap ())) . help ("The level of privacy this team should have. The options are:  \n**For a non-nested team:**  \n * `secret` - only visible to organization owners and members of this team.  \n * `closed` - visible to all members of this organization.  \nDefault: `secret`  \n**For a parent or child team:**  \n * `closed` - visible to all members of this organization.  \nDefault for child team: `closed`")) . about ("Create a team\n\nTo create a team, the authenticated user must be a member or owner of `{org}`. By default, organization members can create teams. Organization owners can limit team creation to organization owners. For more information, see \"[Setting team creation permissions](https://docs.github.com/articles/setting-team-creation-permissions-in-your-organization).\"\n\nWhen you create a new team, you automatically become a team maintainer without explicitly adding yourself to the optional array of `maintainers`. For more information, see \"[About teams](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/about-teams)\".")
    }

    pub fn cli_teams_get_by_name() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .about(
                "Get a team by name\n\nGets a team using the team's `slug`. To create the `slug`, \
                 GitHub replaces special characters in the `name` string, changes all words to \
                 lowercase, and replaces spaces with a `-` separator. For example, `\"My TEam \
                 Nme\"` would become `my-team-name`.\n\n**Note:** You can also specify a team by \
                 `org_id` and `team_id` using the route `GET \
                 /organizations/{org_id}/team/{team_id}`.",
            )
    }

    pub fn cli_teams_delete_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .about(
                "Delete a team\n\nTo delete a team, the authenticated user must be an \
                 organization owner or team maintainer.\n\nIf you are an organization owner, \
                 deleting a parent team will delete all of its child teams as well.\n\n**Note:** \
                 You can also specify a team by `org_id` and `team_id` using the route `DELETE \
                 /organizations/{org_id}/team/{team_id}`.",
            )
    }

    pub fn cli_teams_update_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .arg(
                clap::Arg::new("description")
                    .long("description")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The description of the team."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the team."),
            )
            .arg(
                clap::Arg::new("notification-setting")
                    .long("notification-setting")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::TeamsUpdateInOrgBodyNotificationSetting::NotificationsEnabled
                                .to_string(),
                            types::TeamsUpdateInOrgBodyNotificationSetting::NotificationsDisabled
                                .to_string(),
                        ]),
                        |s| types::TeamsUpdateInOrgBodyNotificationSetting::try_from(s).unwrap(),
                    ))
                    .help(
                        "The notification setting the team has chosen. Editing teams without \
                         specifying this parameter leaves `notification_setting` intact. The \
                         options are: \n * `notifications_enabled` - team members receive \
                         notifications when the team is @mentioned.  \n * \
                         `notifications_disabled` - no one receives notifications.",
                    ),
            )
            .arg(
                clap::Arg::new("parent-team-id")
                    .long("parent-team-id")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The ID of a team to set as the parent team."),
            )
            .arg(
                clap::Arg::new("permission")
                    .long("permission")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::TeamsUpdateInOrgBodyPermission::Pull.to_string(),
                            types::TeamsUpdateInOrgBodyPermission::Push.to_string(),
                            types::TeamsUpdateInOrgBodyPermission::Admin.to_string(),
                        ]),
                        |s| types::TeamsUpdateInOrgBodyPermission::try_from(s).unwrap(),
                    ))
                    .help(
                        "**Deprecated**. The permission that new repositories will be added to \
                         the team with when none is specified.",
                    ),
            )
            .arg(
                clap::Arg::new("privacy")
                    .long("privacy")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::TeamsUpdateInOrgBodyPrivacy::Secret.to_string(),
                            types::TeamsUpdateInOrgBodyPrivacy::Closed.to_string(),
                        ]),
                        |s| types::TeamsUpdateInOrgBodyPrivacy::try_from(s).unwrap(),
                    ))
                    .help(
                        "The level of privacy this team should have. Editing teams without \
                         specifying this parameter leaves `privacy` intact. When a team is \
                         nested, the `privacy` for parent teams cannot be `secret`. The options \
                         are:  \n**For a non-nested team:**  \n * `secret` - only visible to \
                         organization owners and members of this team.  \n * `closed` - visible \
                         to all members of this organization.  \n**For a parent or child team:**  \
                         \n * `closed` - visible to all members of this organization.",
                    ),
            )
            .about(
                "Update a team\n\nTo edit a team, the authenticated user must either be an \
                 organization owner or a team maintainer.\n\n**Note:** You can also specify a \
                 team by `org_id` and `team_id` using the route `PATCH \
                 /organizations/{org_id}/team/{team_id}`.",
            )
    }

    pub fn cli_teams_list_discussions_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsListDiscussionsInOrgDirection :: Asc . to_string () , types :: TeamsListDiscussionsInOrgDirection :: Desc . to_string () ,]) , | s | types :: TeamsListDiscussionsInOrgDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("pinned") . long ("pinned") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Pinned discussions only filter")) . about ("List discussions\n\nList all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions`.")
    }

    pub fn cli_teams_create_discussion_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The discussion post's body text.")) . arg (clap :: Arg :: new ("private") . long ("private") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.")) . arg (clap :: Arg :: new ("title") . long ("title") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The discussion post's title.")) . about ("Create a discussion\n\nCreates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions`.")
    }

    pub fn cli_teams_get_discussion_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . about ("Get a discussion\n\nGet a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.")
    }

    pub fn cli_teams_delete_discussion_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . about ("Delete a discussion\n\nDelete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.")
    }

    pub fn cli_teams_update_discussion_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The discussion post's body text.")) . arg (clap :: Arg :: new ("title") . long ("title") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The discussion post's title.")) . about ("Update a discussion\n\nEdits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.")
    }

    pub fn cli_teams_list_discussion_comments_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsListDiscussionCommentsInOrgDirection :: Asc . to_string () , types :: TeamsListDiscussionCommentsInOrgDirection :: Desc . to_string () ,]) , | s | types :: TeamsListDiscussionCommentsInOrgDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List discussion comments\n\nList all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.")
    }

    pub fn cli_teams_create_discussion_comment_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The discussion comment's body text.")) . about ("Create a discussion comment\n\nCreates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.")
    }

    pub fn cli_teams_get_discussion_comment_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("comment-number") . long ("comment-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the comment.")) . about ("Get a discussion comment\n\nGet a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.")
    }

    pub fn cli_teams_delete_discussion_comment_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("comment-number") . long ("comment-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the comment.")) . about ("Delete a discussion comment\n\nDeletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.")
    }

    pub fn cli_teams_update_discussion_comment_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("comment-number") . long ("comment-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the comment.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The discussion comment's body text.")) . about ("Update a discussion comment\n\nEdits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.")
    }

    pub fn cli_reactions_list_for_team_discussion_comment_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("comment-number") . long ("comment-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the comment.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsListForTeamDiscussionCommentInOrgContent :: plus1 . to_string () , types :: ReactionsListForTeamDiscussionCommentInOrgContent :: minus1 . to_string () , types :: ReactionsListForTeamDiscussionCommentInOrgContent :: Laugh . to_string () , types :: ReactionsListForTeamDiscussionCommentInOrgContent :: Confused . to_string () , types :: ReactionsListForTeamDiscussionCommentInOrgContent :: Heart . to_string () , types :: ReactionsListForTeamDiscussionCommentInOrgContent :: Hooray . to_string () , types :: ReactionsListForTeamDiscussionCommentInOrgContent :: Rocket . to_string () , types :: ReactionsListForTeamDiscussionCommentInOrgContent :: Eyes . to_string () ,]) , | s | types :: ReactionsListForTeamDiscussionCommentInOrgContent :: try_from (s) . unwrap ())) . help ("Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion comment.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List reactions for a team discussion comment\n\nList the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.")
    }

    pub fn cli_reactions_create_for_team_discussion_comment_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("comment-number") . long ("comment-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the comment.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsCreateForTeamDiscussionCommentInOrgBodyContent :: plus1 . to_string () , types :: ReactionsCreateForTeamDiscussionCommentInOrgBodyContent :: minus1 . to_string () , types :: ReactionsCreateForTeamDiscussionCommentInOrgBodyContent :: Laugh . to_string () , types :: ReactionsCreateForTeamDiscussionCommentInOrgBodyContent :: Confused . to_string () , types :: ReactionsCreateForTeamDiscussionCommentInOrgBodyContent :: Heart . to_string () , types :: ReactionsCreateForTeamDiscussionCommentInOrgBodyContent :: Hooray . to_string () , types :: ReactionsCreateForTeamDiscussionCommentInOrgBodyContent :: Rocket . to_string () , types :: ReactionsCreateForTeamDiscussionCommentInOrgBodyContent :: Eyes . to_string () ,]) , | s | types :: ReactionsCreateForTeamDiscussionCommentInOrgBodyContent :: try_from (s) . unwrap ())) . help ("The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion comment.")) . about ("Create reaction for a team discussion comment\n\nCreate a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.")
    }

    pub fn cli_reactions_delete_for_team_discussion_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("comment-number") . long ("comment-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the comment.")) . arg (clap :: Arg :: new ("reaction-id") . long ("reaction-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the reaction.")) . about ("Delete team discussion comment reaction\n\n**Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.\n\nDelete a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_reactions_list_for_team_discussion_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsListForTeamDiscussionInOrgContent :: plus1 . to_string () , types :: ReactionsListForTeamDiscussionInOrgContent :: minus1 . to_string () , types :: ReactionsListForTeamDiscussionInOrgContent :: Laugh . to_string () , types :: ReactionsListForTeamDiscussionInOrgContent :: Confused . to_string () , types :: ReactionsListForTeamDiscussionInOrgContent :: Heart . to_string () , types :: ReactionsListForTeamDiscussionInOrgContent :: Hooray . to_string () , types :: ReactionsListForTeamDiscussionInOrgContent :: Rocket . to_string () , types :: ReactionsListForTeamDiscussionInOrgContent :: Eyes . to_string () ,]) , | s | types :: ReactionsListForTeamDiscussionInOrgContent :: try_from (s) . unwrap ())) . help ("Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List reactions for a team discussion\n\nList the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.")
    }

    pub fn cli_reactions_create_for_team_discussion_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsCreateForTeamDiscussionInOrgBodyContent :: plus1 . to_string () , types :: ReactionsCreateForTeamDiscussionInOrgBodyContent :: minus1 . to_string () , types :: ReactionsCreateForTeamDiscussionInOrgBodyContent :: Laugh . to_string () , types :: ReactionsCreateForTeamDiscussionInOrgBodyContent :: Confused . to_string () , types :: ReactionsCreateForTeamDiscussionInOrgBodyContent :: Heart . to_string () , types :: ReactionsCreateForTeamDiscussionInOrgBodyContent :: Hooray . to_string () , types :: ReactionsCreateForTeamDiscussionInOrgBodyContent :: Rocket . to_string () , types :: ReactionsCreateForTeamDiscussionInOrgBodyContent :: Eyes . to_string () ,]) , | s | types :: ReactionsCreateForTeamDiscussionInOrgBodyContent :: try_from (s) . unwrap ())) . help ("The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion.")) . about ("Create reaction for a team discussion\n\nCreate a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.")
    }

    pub fn cli_reactions_delete_for_team_discussion() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("reaction-id") . long ("reaction-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the reaction.")) . about ("Delete team discussion reaction\n\n**Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.\n\nDelete a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_teams_list_pending_invitations_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List pending team invitations\n\nThe return hash contains a `role` field which \
                 refers to the Organization Invitation role and will be one of the following \
                 values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or \
                 `reinstate`. If the invitee is not a GitHub member, the `login` field in the \
                 return hash will be `null`.\n\n**Note:** You can also specify a team by `org_id` \
                 and `team_id` using the route `GET \
                 /organizations/{org_id}/team/{team_id}/invitations`.",
            )
    }

    pub fn cli_teams_list_members_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("role")
                    .long("role")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::TeamsListMembersInOrgRole::Member.to_string(),
                            types::TeamsListMembersInOrgRole::Maintainer.to_string(),
                            types::TeamsListMembersInOrgRole::All.to_string(),
                        ]),
                        |s| types::TeamsListMembersInOrgRole::try_from(s).unwrap(),
                    ))
                    .help("Filters members returned by their role in the team."),
            )
            .about(
                "List team members\n\nTeam members will include the members of child teams.\n\nTo \
                 list members in a team, the team must be visible to the authenticated user.",
            )
    }

    pub fn cli_teams_get_membership_for_user_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Get team membership for a user\n\nTeam members will include the members of child teams.\n\nTo get a user's membership with a team, the team must be visible to the authenticated user.\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/memberships/{username}`.\n\n**Note:**\nThe response contains the `state` of the membership and the member's `role`.\n\nThe `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).")
    }

    pub fn cli_teams_add_or_update_membership_for_user_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("role") . long ("role") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsAddOrUpdateMembershipForUserInOrgBodyRole :: Member . to_string () , types :: TeamsAddOrUpdateMembershipForUserInOrgBodyRole :: Maintainer . to_string () ,]) , | s | types :: TeamsAddOrUpdateMembershipForUserInOrgBodyRole :: try_from (s) . unwrap ())) . help ("The role that this user should have in the team.")) . about ("Add or update team membership for a user\n\nAdds an organization member to a team. An authenticated organization owner or team maintainer can add organization members to a team.\n\nTeam synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\n**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see \"[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/).\"\n\nAn organization owner can add someone who is not part of the team's organization to a team. When an organization owner adds someone to a team who is not an organization member, this endpoint will send an invitation to the person via email. This newly-created membership will be in the \"pending\" state until the person accepts the invitation, at which point the membership will transition to the \"active\" state and the user will be added as a member of the team.\n\nIf the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/memberships/{username}`.")
    }

    pub fn cli_teams_remove_membership_for_user_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Remove team membership for a user\n\nTo remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.\n\nTeam synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\n**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see \"[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/).\"\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/memberships/{username}`.")
    }

    pub fn cli_teams_list_projects_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List team projects\n\nLists the organization projects for a team.\n\n**Note:** \
                 You can also specify a team by `org_id` and `team_id` using the route `GET \
                 /organizations/{org_id}/team/{team_id}/projects`.",
            )
    }

    pub fn cli_teams_check_permissions_for_project_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .about(
                "Check team permissions for a project\n\nChecks whether a team has `read`, \
                 `write`, or `admin` permissions for an organization project. The response \
                 includes projects inherited from a parent team.\n\n**Note:** You can also \
                 specify a team by `org_id` and `team_id` using the route `GET \
                 /organizations/{org_id}/team/{team_id}/projects/{project_id}`.",
            )
    }

    pub fn cli_teams_add_or_update_project_permissions_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .about(
                "Add or update team project permissions\n\nAdds an organization project to a \
                 team. To add a project to a team or update the team's permission on a project, \
                 the authenticated user must have `admin` permissions for the project. The \
                 project and team must be part of the same organization.\n\n**Note:** You can \
                 also specify a team by `org_id` and `team_id` using the route `PUT \
                 /organizations/{org_id}/team/{team_id}/projects/{project_id}`.",
            )
    }

    pub fn cli_teams_remove_project_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .about(
                "Remove a project from a team\n\nRemoves an organization project from a team. An \
                 organization owner or a team maintainer can remove any project from the team. To \
                 remove a project from a team as an organization member, the authenticated user \
                 must have `read` access to both the team and project, or `admin` access to the \
                 team or project. This endpoint removes the project from the team, but does not \
                 delete the project.\n\n**Note:** You can also specify a team by `org_id` and \
                 `team_id` using the route `DELETE \
                 /organizations/{org_id}/team/{team_id}/projects/{project_id}`.",
            )
    }

    pub fn cli_teams_list_repos_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List team repositories\n\nLists a team's repositories visible to the \
                 authenticated user.\n\n**Note:** You can also specify a team by `org_id` and \
                 `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos`.",
            )
    }

    pub fn cli_teams_check_permissions_for_repo_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Check team permissions for a repository\n\nChecks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.\n\nYou can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.\n\nIf a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.")
    }

    pub fn cli_teams_add_or_update_repo_permissions_in_org() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("team-slug") . long ("team-slug") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The slug of the team name.")) . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("permission") . long ("permission") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The permission to grant the team on this repository. We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.")) . about ("Add or update team repository permissions\n\nTo add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"\n\n**Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.\n\nFor more information about the permission levels, see \"[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)\".")
    }

    pub fn cli_teams_remove_repo_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Remove a repository from a team\n\nIf the authenticated user is an organization \
                 owner or a team maintainer, they can remove any repositories from the team. To \
                 remove a repository from a team as an organization member, the authenticated \
                 user must have admin access to the repository and must be able to see the team. \
                 This does not delete the repository, it just removes it from the \
                 team.\n\n**Note:** You can also specify a team by `org_id` and `team_id` using \
                 the route `DELETE /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.",
            )
    }

    pub fn cli_teams_list_child_in_org() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("team-slug")
                    .long("team-slug")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The slug of the team name."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List child teams\n\nLists the child teams of the team specified by \
                 `{team_slug}`.\n\n**Note:** You can also specify a team by `org_id` and \
                 `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/teams`.",
            )
    }

    pub fn cli_orgs_enable_or_disable_security_product_on_all_org_repos() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("security-product") . long ("security-product") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: OrgsEnableOrDisableSecurityProductOnAllOrgReposSecurityProduct :: DependencyGraph . to_string () , types :: OrgsEnableOrDisableSecurityProductOnAllOrgReposSecurityProduct :: DependabotAlerts . to_string () , types :: OrgsEnableOrDisableSecurityProductOnAllOrgReposSecurityProduct :: DependabotSecurityUpdates . to_string () , types :: OrgsEnableOrDisableSecurityProductOnAllOrgReposSecurityProduct :: AdvancedSecurity . to_string () , types :: OrgsEnableOrDisableSecurityProductOnAllOrgReposSecurityProduct :: CodeScanningDefaultSetup . to_string () , types :: OrgsEnableOrDisableSecurityProductOnAllOrgReposSecurityProduct :: SecretScanning . to_string () , types :: OrgsEnableOrDisableSecurityProductOnAllOrgReposSecurityProduct :: SecretScanningPushProtection . to_string () ,]) , | s | types :: OrgsEnableOrDisableSecurityProductOnAllOrgReposSecurityProduct :: try_from (s) . unwrap ())) . help ("The security feature to enable or disable.")) . arg (clap :: Arg :: new ("enablement") . long ("enablement") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: OrgsEnableOrDisableSecurityProductOnAllOrgReposEnablement :: EnableAll . to_string () , types :: OrgsEnableOrDisableSecurityProductOnAllOrgReposEnablement :: DisableAll . to_string () ,]) , | s | types :: OrgsEnableOrDisableSecurityProductOnAllOrgReposEnablement :: try_from (s) . unwrap ())) . help ("The action to take.\n\n`enable_all` means to enable the specified security feature for all repositories in the organization.\n`disable_all` means to disable the specified security feature for all repositories in the organization.")) . about ("Enable or disable a security feature for an organization\n\nEnables or disables the specified security feature for all eligible repositories in an organization.\n\nTo use this endpoint, you must be an organization owner or be member of a team with the security manager role.\nA token with the 'write:org' scope is also required.\n\nGitHub Apps must have the `organization_administration:write` permission to use this endpoint.\n\nFor more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"")
    }

    pub fn cli_projects_get_card() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("card-id")
                    .long("card-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the card."),
            )
            .about("Get a project card")
    }

    pub fn cli_projects_delete_card() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("card-id")
                    .long("card-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the card."),
            )
            .about("Delete a project card")
    }

    pub fn cli_projects_update_card() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("card-id")
                    .long("card-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the card."),
            )
            .arg(
                clap::Arg::new("archived")
                    .long("archived")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help("Whether or not the card is archived"),
            )
            .arg(
                clap::Arg::new("note")
                    .long("note")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The project card's note"),
            )
            .about("Update an existing project card")
    }

    pub fn cli_projects_move_card() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("card-id")
                    .long("card-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the card."),
            )
            .arg(
                clap::Arg::new("column-id")
                    .long("column-id")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the column the card should be moved to"),
            )
            .arg(
                clap::Arg::new("position")
                    .long("position")
                    .required(true)
                    .value_parser(clap::value_parser!(types::ProjectsMoveCardBodyPosition))
                    .help(
                        "The position of the card in a column. Can be one of: `top`, `bottom`, or \
                         `after:<card_id>` to place after the specified card.",
                    ),
            )
            .about("Move a project card")
    }

    pub fn cli_projects_get_column() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("column-id")
                    .long("column-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the column."),
            )
            .about("Get a project column")
    }

    pub fn cli_projects_delete_column() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("column-id")
                    .long("column-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the column."),
            )
            .about("Delete a project column")
    }

    pub fn cli_projects_update_column() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("column-id")
                    .long("column-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the column."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("Name of the project column"),
            )
            .about("Update an existing project column")
    }

    pub fn cli_users_list_ssh_signing_keys_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List SSH signing keys for a user\n\nLists the SSH signing keys for a user. This \
                 operation is accessible by anyone.",
            )
    }

    pub fn cli_projects_move_column() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("column-id")
                    .long("column-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the column."),
            )
            .arg(
                clap::Arg::new("position")
                    .long("position")
                    .required(true)
                    .value_parser(clap::value_parser!(types::ProjectsMoveColumnBodyPosition))
                    .help(
                        "The position of the column in a project. Can be one of: `first`, `last`, \
                         or `after:<column_id>` to place after the specified column.",
                    ),
            )
            .about("Move a project column")
    }

    pub fn cli_projects_get() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .about(
                "Get a project\n\nGets a project by its `id`. Returns a `404 Not Found` status if \
                 projects are disabled. If you do not have sufficient privileges to perform this \
                 action, a `401 Unauthorized` or `410 Gone` status is returned.",
            )
    }

    pub fn cli_projects_delete() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .about(
                "Delete a project\n\nDeletes a project board. Returns a `404 Not Found` status if \
                 projects are disabled.",
            )
    }

    pub fn cli_projects_update() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .arg(
                clap::Arg::new("body")
                    .long("body")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Body of the project"),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Name of the project"),
            )
            .arg(
                clap::Arg::new("organization-permission")
                    .long("organization-permission")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ProjectsUpdateBodyOrganizationPermission::Read.to_string(),
                            types::ProjectsUpdateBodyOrganizationPermission::Write.to_string(),
                            types::ProjectsUpdateBodyOrganizationPermission::Admin.to_string(),
                            types::ProjectsUpdateBodyOrganizationPermission::None.to_string(),
                        ]),
                        |s| types::ProjectsUpdateBodyOrganizationPermission::try_from(s).unwrap(),
                    ))
                    .help(
                        "The baseline permission that all organization members have on this \
                         project",
                    ),
            )
            .arg(
                clap::Arg::new("private")
                    .long("private")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help("Whether or not this project can be seen by everyone."),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("State of the project; either 'open' or 'closed'"),
            )
            .about(
                "Update a project\n\nUpdates a project board's information. Returns a `404 Not \
                 Found` status if projects are disabled. If you do not have sufficient privileges \
                 to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.",
            )
    }

    pub fn cli_projects_list_collaborators() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .arg(
                clap::Arg::new("affiliation")
                    .long("affiliation")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ProjectsListCollaboratorsAffiliation::Outside.to_string(),
                            types::ProjectsListCollaboratorsAffiliation::Direct.to_string(),
                            types::ProjectsListCollaboratorsAffiliation::All.to_string(),
                        ]),
                        |s| types::ProjectsListCollaboratorsAffiliation::try_from(s).unwrap(),
                    ))
                    .help(
                        "Filters the collaborators by their affiliation. `outside` means outside \
                         collaborators of a project that are not a member of the project's \
                         organization. `direct` means collaborators with permissions to a \
                         project, regardless of organization membership status. `all` means all \
                         collaborators the authenticated user can see.",
                    ),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List project collaborators\n\nLists the collaborators for an organization \
                 project. For a project, the list of collaborators includes outside \
                 collaborators, organization members that are direct collaborators, organization \
                 members with access through team memberships, organization members with access \
                 through default organization permissions, and organization owners. You must be \
                 an organization owner or a project `admin` to list collaborators.",
            )
    }

    pub fn cli_projects_add_collaborator() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Add project collaborator\n\nAdds a collaborator to an organization project and \
                 sets their permission level. You must be an organization owner or a project \
                 `admin` to add a collaborator.",
            )
    }

    pub fn cli_projects_remove_collaborator() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Remove user as a collaborator\n\nRemoves a collaborator from an organization \
                 project. You must be an organization owner or a project `admin` to remove a \
                 collaborator.",
            )
    }

    pub fn cli_projects_get_permission_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Get project permission for a user\n\nReturns the collaborator's permission level \
                 for an organization project. Possible values for the `permission` key: `admin`, \
                 `write`, `read`, `none`. You must be an organization owner or a project `admin` \
                 to review a user's permission level.",
            )
    }

    pub fn cli_projects_list_columns() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List project columns")
    }

    pub fn cli_projects_create_column() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("project-id")
                    .long("project-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the project."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("Name of the project column"),
            )
            .about("Create a project column")
    }

    pub fn cli_rate_limit_get() -> clap::Command {
        clap::Command::new("").about(
            "Get rate limit status for the authenticated user\n\n**Note:** Accessing this \
             endpoint does not count against your REST API rate limit.\n\n**Note:** The `rate` \
             object is deprecated. If you're writing new API client code or updating existing \
             code, you should use the `core` object instead of the `rate` object. The `core` \
             object contains the same information that is present in the `rate` object.",
        )
    }

    pub fn cli_actions_list_repo_required_workflows() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List repository required workflows\n\nLists the required workflows in a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. For more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_get_repo_required_workflow() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("required-workflow-id-for-repo") . long ("required-workflow-id-for-repo") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The ID of the required workflow that has run at least once in a repository.")) . about ("Get a required workflow entity for a repository\n\nGets a specific required workflow present in a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. For more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_get_repo_required_workflow_usage() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("org") . long ("org") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The organization name. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("required-workflow-id-for-repo") . long ("required-workflow-id-for-repo") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The ID of the required workflow that has run at least once in a repository.")) . about ("Get required workflow usage\n\nGets the number of billable minutes used by a specific required workflow during the current billing cycle.\n\nBillable minutes only apply to required workflows running in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see \"[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions).\"\n\nAnyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.")
    }

    pub fn cli_repos_get() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Get a repository\n\nThe `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.\n\n**Note:** In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"")
    }

    pub fn cli_repos_delete() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Delete a repository\n\nDeleting a repository requires admin access. If OAuth is \
                 used, the `delete_repo` scope is required.\n\nIf an organization owner has \
                 configured the organization to prevent members from deleting \
                 organization-owned\nrepositories, you will get a `403 Forbidden` response.",
            )
    }

    pub fn cli_repos_update() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("allow-auto-merge") . long ("allow-auto-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.")) . arg (clap :: Arg :: new ("allow-forking") . long ("allow-forking") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow private forks, or `false` to prevent private forks.")) . arg (clap :: Arg :: new ("allow-merge-commit") . long ("allow-merge-commit") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.")) . arg (clap :: Arg :: new ("allow-rebase-merge") . long ("allow-rebase-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.")) . arg (clap :: Arg :: new ("allow-squash-merge") . long ("allow-squash-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.")) . arg (clap :: Arg :: new ("allow-update-branch") . long ("allow-update-branch") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.")) . arg (clap :: Arg :: new ("archived") . long ("archived") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether to archive this repository. `false` will unarchive a previously archived repository.")) . arg (clap :: Arg :: new ("default-branch") . long ("default-branch") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Updates the default branch for this repository.")) . arg (clap :: Arg :: new ("delete-branch-on-merge") . long ("delete-branch-on-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.")) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A short description of the repository.")) . arg (clap :: Arg :: new ("has-issues") . long ("has-issues") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to enable issues for this repository or `false` to disable them.")) . arg (clap :: Arg :: new ("has-projects") . long ("has-projects") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.")) . arg (clap :: Arg :: new ("has-wiki") . long ("has-wiki") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to enable the wiki for this repository or `false` to disable it.")) . arg (clap :: Arg :: new ("homepage") . long ("homepage") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A URL with more information about the repository.")) . arg (clap :: Arg :: new ("is-template") . long ("is-template") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to make this repo available as a template repository or `false` to prevent it.")) . arg (clap :: Arg :: new ("merge-commit-message") . long ("merge-commit-message") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposUpdateBodyMergeCommitMessage :: PrBody . to_string () , types :: ReposUpdateBodyMergeCommitMessage :: PrTitle . to_string () , types :: ReposUpdateBodyMergeCommitMessage :: Blank . to_string () ,]) , | s | types :: ReposUpdateBodyMergeCommitMessage :: try_from (s) . unwrap ())) . help ("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")) . arg (clap :: Arg :: new ("merge-commit-title") . long ("merge-commit-title") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposUpdateBodyMergeCommitTitle :: PrTitle . to_string () , types :: ReposUpdateBodyMergeCommitTitle :: MergeMessage . to_string () ,]) , | s | types :: ReposUpdateBodyMergeCommitTitle :: try_from (s) . unwrap ())) . help ("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")) . arg (clap :: Arg :: new ("name") . long ("name") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository.")) . arg (clap :: Arg :: new ("private") . long ("private") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to make the repository private or `false` to make it public. Default: `false`.  \n**Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.")) . arg (clap :: Arg :: new ("squash-merge-commit-message") . long ("squash-merge-commit-message") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposUpdateBodySquashMergeCommitMessage :: PrBody . to_string () , types :: ReposUpdateBodySquashMergeCommitMessage :: CommitMessages . to_string () , types :: ReposUpdateBodySquashMergeCommitMessage :: Blank . to_string () ,]) , | s | types :: ReposUpdateBodySquashMergeCommitMessage :: try_from (s) . unwrap ())) . help ("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")) . arg (clap :: Arg :: new ("squash-merge-commit-title") . long ("squash-merge-commit-title") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposUpdateBodySquashMergeCommitTitle :: PrTitle . to_string () , types :: ReposUpdateBodySquashMergeCommitTitle :: CommitOrPrTitle . to_string () ,]) , | s | types :: ReposUpdateBodySquashMergeCommitTitle :: try_from (s) . unwrap ())) . help ("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")) . arg (clap :: Arg :: new ("use-squash-pr-title-as-default") . long ("use-squash-pr-title-as-default") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property has been deprecated. Please use `squash_merge_commit_title` instead.")) . arg (clap :: Arg :: new ("visibility") . long ("visibility") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposUpdateBodyVisibility :: Public . to_string () , types :: ReposUpdateBodyVisibility :: Private . to_string () ,]) , | s | types :: ReposUpdateBodyVisibility :: try_from (s) . unwrap ())) . help ("The visibility of the repository.")) . arg (clap :: Arg :: new ("web-commit-signoff-required") . long ("web-commit-signoff-required") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.")) . about ("Update a repository\n\n**Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/rest/reference/repos#replace-all-repository-topics) endpoint.")
    }

    pub fn cli_actions_list_artifacts_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Filters artifacts by exact match on their name field."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List artifacts for a repository\n\nLists all artifacts for a repository. Anyone \
                 with read access to the repository can use this endpoint. If the repository is \
                 private you must use an access token with the `repo` scope. GitHub Apps must \
                 have the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_artifact() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("artifact-id")
                    .long("artifact-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the artifact."),
            )
            .about(
                "Get an artifact\n\nGets a specific artifact for a workflow run. Anyone with read \
                 access to the repository can use this endpoint. If the repository is private you \
                 must use an access token with the `repo` scope. GitHub Apps must have the \
                 `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_delete_artifact() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("artifact-id")
                    .long("artifact-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the artifact."),
            )
            .about(
                "Delete an artifact\n\nDeletes an artifact for a workflow run. You must \
                 authenticate using an access token with the `repo` scope to use this endpoint. \
                 GitHub Apps must have the `actions:write` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_download_artifact() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("artifact-id")
                    .long("artifact-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the artifact."),
            )
            .arg(
                clap::Arg::new("archive-format")
                    .long("archive-format")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about(
                "Download an artifact\n\nGets a redirect URL to download an archive for a \
                 repository. This URL expires after 1 minute. Look for `Location:` in\nthe \
                 response header to find the URL for the download. The `:archive_format` must be \
                 `zip`. Anyone with read access to\nthe repository can use this endpoint. If the \
                 repository is private you must use an access token with the `repo` \
                 scope.\nGitHub Apps must have the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_actions_cache_usage() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get GitHub Actions cache usage for a repository\n\nGets GitHub Actions cache \
                 usage for a repository.\nThe data fetched using this API is refreshed \
                 approximately every 5 minutes, so values returned from this endpoint may take at \
                 least 5 minutes to get updated.\nAnyone with read access to the repository can \
                 use this endpoint. If the repository is private, you must use an access token \
                 with the `repo` scope. GitHub Apps must have the `actions:read` permission to \
                 use this endpoint.",
            )
    }

    pub fn cli_actions_get_actions_cache_list() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("direction")
                    .long("direction")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ActionsGetActionsCacheListDirection::Asc.to_string(),
                            types::ActionsGetActionsCacheListDirection::Desc.to_string(),
                        ]),
                        |s| types::ActionsGetActionsCacheListDirection::try_from(s).unwrap(),
                    ))
                    .help("The direction to sort the results by."),
            )
            .arg(
                clap::Arg::new("key")
                    .long("key")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("An explicit key or prefix for identifying the cache"),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The full Git reference for narrowing down the cache. The `ref` for a \
                         branch should be formatted as `refs/heads/<branch name>`. To reference a \
                         pull request use `refs/pull/<number>/merge`.",
                    ),
            )
            .arg(
                clap::Arg::new("sort")
                    .long("sort")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ActionsGetActionsCacheListSort::CreatedAt.to_string(),
                            types::ActionsGetActionsCacheListSort::LastAccessedAt.to_string(),
                            types::ActionsGetActionsCacheListSort::SizeInBytes.to_string(),
                        ]),
                        |s| types::ActionsGetActionsCacheListSort::try_from(s).unwrap(),
                    ))
                    .help(
                        "The property to sort the results by. `created_at` means when the cache \
                         was created. `last_accessed_at` means when the cache was last accessed. \
                         `size_in_bytes` is the size of the cache in bytes.",
                    ),
            )
            .about(
                "List GitHub Actions caches for a repository\n\nLists the GitHub Actions caches \
                 for a repository.\nYou must authenticate using an access token with the `repo` \
                 scope to use this endpoint.\nGitHub Apps must have the `actions:read` permission \
                 to use this endpoint.",
            )
    }

    pub fn cli_actions_delete_actions_cache_by_key() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("key")
                    .long("key")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("A key for identifying the cache."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The full Git reference for narrowing down the cache. The `ref` for a \
                         branch should be formatted as `refs/heads/<branch name>`. To reference a \
                         pull request use `refs/pull/<number>/merge`.",
                    ),
            )
            .about(
                "Delete GitHub Actions caches for a repository (using a cache key)\n\nDeletes one \
                 or more GitHub Actions caches for a repository, using a complete cache key. By \
                 default, all caches that match the provided key are deleted, but you can \
                 optionally provide a Git ref to restrict deletions to caches that match both the \
                 provided key and the Git ref.\n\nYou must authenticate using an access token \
                 with the `repo` scope to use this endpoint.\n\nGitHub Apps must have the \
                 `actions:write` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_delete_actions_cache_by_id() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("cache-id")
                    .long("cache-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the GitHub Actions cache."),
            )
            .about(
                "Delete a GitHub Actions cache for a repository (using a cache ID)\n\nDeletes a \
                 GitHub Actions cache for a repository, using a cache ID.\n\nYou must \
                 authenticate using an access token with the `repo` scope to use this \
                 endpoint.\n\nGitHub Apps must have the `actions:write` permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_actions_get_job_for_workflow_run() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("job-id")
                    .long("job-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the job."),
            )
            .about(
                "Get a job for a workflow run\n\nGets a specific job in a workflow run. Anyone \
                 with read access to the repository can use this endpoint. If the repository is \
                 private you must use an access token with the `repo` scope. GitHub Apps must \
                 have the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_download_job_logs_for_workflow_run() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("job-id")
                    .long("job-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the job."),
            )
            .about(
                "Download job logs for a workflow run\n\nGets a redirect URL to download a plain \
                 text file of logs for a workflow job. This link expires after 1 minute. \
                 Look\nfor `Location:` in the response header to find the URL for the download. \
                 Anyone with read access to the repository can\nuse this endpoint. If the \
                 repository is private you must use an access token with the `repo` scope. GitHub \
                 Apps must\nhave the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_re_run_job_for_workflow_run() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("job-id")
                    .long("job-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the job."),
            )
            .about(
                "Re-run a job from a workflow run\n\nRe-run a job and its dependent jobs in a \
                 workflow run. You must authenticate using an access token with the `repo` scope \
                 to use this endpoint. GitHub Apps must have the `actions:write` permission to \
                 use this endpoint.",
            )
    }

    pub fn cli_actions_get_custom_oidc_sub_claim_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get the customization template for an OIDC subject claim for a \
                 repository\n\nGets the customization template for an OpenID Connect (OIDC) \
                 subject claim.\nYou must authenticate using an access token with the `repo` \
                 scope to use this\nendpoint. GitHub Apps must have the \
                 `organization_administration:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_set_custom_oidc_sub_claim_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("use-default")
                    .long("use-default")
                    .required(true)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Whether to use the default template or not. If `true`, the \
                         `include_claim_keys` field is ignored.",
                    ),
            )
            .about(
                "Set the customization template for an OIDC subject claim for a \
                 repository\n\nSets the customization template and `opt-in` or `opt-out` flag for \
                 an OpenID Connect (OIDC) subject claim for a repository.\nYou must authenticate \
                 using an access token with the `repo` scope to use this\nendpoint. GitHub Apps \
                 must have the `actions:write` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_list_repo_organization_secrets() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repository organization secrets\n\nLists all organization secrets shared \
                 with a repository without revealing their encrypted values. You must \
                 authenticate using an access token with the `repo` scope to use this endpoint. \
                 GitHub Apps must have the `secrets` repository permission to use this endpoint.",
            )
    }

    pub fn cli_actions_list_repo_organization_variables() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 30)."),
            )
            .about(
                "List repository organization variables\n\nLists all organiation variables shared \
                 with a repository. You must authenticate using an access token with the `repo` \
                 scope to use this endpoint. GitHub Apps must have the `actions_variables:read` \
                 repository permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_github_actions_permissions_repository() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get GitHub Actions permissions for a repository\n\nGets the GitHub Actions \
                 permissions policy for a repository, including whether GitHub Actions is enabled \
                 and the actions and reusable workflows allowed to run in the repository.\n\nYou \
                 must authenticate using an access token with the `repo` scope to use this \
                 endpoint. GitHub Apps must have the `administration` repository permission to \
                 use this API.",
            )
    }

    pub fn cli_actions_set_github_actions_permissions_repository() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("allowed-actions")
                    .long("allowed-actions")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::AllowedActions::All.to_string(),
                            types::AllowedActions::LocalOnly.to_string(),
                            types::AllowedActions::Selected.to_string(),
                        ]),
                        |s| types::AllowedActions::try_from(s).unwrap(),
                    )),
            )
            .arg(
                clap::Arg::new("enabled")
                    .long("enabled")
                    .required(true)
                    .value_parser(clap::value_parser!(types::ActionsEnabled)),
            )
            .about(
                "Set GitHub Actions permissions for a repository\n\nSets the GitHub Actions \
                 permissions policy for enabling GitHub Actions and allowed actions and reusable \
                 workflows in the repository.\n\nYou must authenticate using an access token with \
                 the `repo` scope to use this endpoint. GitHub Apps must have the \
                 `administration` repository permission to use this API.",
            )
    }

    pub fn cli_actions_get_workflow_access_to_repository() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Get the level of access for workflows outside of the repository\n\nGets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.\nThis endpoint only applies to private repositories.\nFor more information, see \"[Allowing access to components in a private repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository).\"\n\nYou must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the\nrepository `administration` permission to use this endpoint.")
    }

    pub fn cli_actions_set_workflow_access_to_repository() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("access-level") . long ("access-level") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActionsWorkflowAccessToRepositoryAccessLevel :: None . to_string () , types :: ActionsWorkflowAccessToRepositoryAccessLevel :: User . to_string () , types :: ActionsWorkflowAccessToRepositoryAccessLevel :: Organization . to_string () ,]) , | s | types :: ActionsWorkflowAccessToRepositoryAccessLevel :: try_from (s) . unwrap ())) . help ("Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the\nrepository.\n\n`none` means the access is only possible from workflows in this repository. `user` level access allows sharing across user owned private repos only. `organization` level access allows sharing across the organization.")) . about ("Set the level of access for workflows outside of the repository\n\nSets the level of access that workflows outside of the repository have to actions and reusable workflows in the repository.\nThis endpoint only applies to private repositories.\nFor more information, see \"[Allowing access to components in a private repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository)\".\n\nYou must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the\nrepository `administration` permission to use this endpoint.")
    }

    pub fn cli_actions_get_allowed_actions_repository() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get allowed actions and reusable workflows for a repository\n\nGets the settings \
                 for selected actions and reusable workflows that are allowed in a repository. To \
                 use this endpoint, the repository policy for `allowed_actions` must be \
                 configured to `selected`. For more information, see \"[Set GitHub Actions \
                 permissions for a \
                 repository](#set-github-actions-permissions-for-a-repository).\"\n\nYou must \
                 authenticate using an access token with the `repo` scope to use this endpoint. \
                 GitHub Apps must have the `administration` repository permission to use this API.",
            )
    }

    pub fn cli_actions_set_allowed_actions_repository() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("github-owned-allowed")
                    .long("github-owned-allowed")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Whether GitHub-owned actions are allowed. For example, this includes the \
                         actions in the `actions` organization.",
                    ),
            )
            .arg(
                clap::Arg::new("verified-allowed")
                    .long("verified-allowed")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Whether actions from GitHub Marketplace verified creators are allowed. \
                         Set to `true` to allow all actions by GitHub Marketplace verified \
                         creators.",
                    ),
            )
            .about(
                "Set allowed actions and reusable workflows for a repository\n\nSets the actions \
                 and reusable workflows that are allowed in a repository. To use this endpoint, \
                 the repository permission policy for `allowed_actions` must be configured to \
                 `selected`. For more information, see \"[Set GitHub Actions permissions for a \
                 repository](#set-github-actions-permissions-for-a-repository).\"\n\nYou must \
                 authenticate using an access token with the `repo` scope to use this endpoint. \
                 GitHub Apps must have the `administration` repository permission to use this API.",
            )
    }

    pub fn cli_actions_get_github_actions_default_workflow_permissions_repository() -> clap::Command
    {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Get default workflow permissions for a repository\n\nGets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository,\nas well as if GitHub Actions can submit approving pull request reviews.\nFor more information, see \"[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository).\"\n\nYou must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the repository `administration` permission to use this API.")
    }

    pub fn cli_actions_set_github_actions_default_workflow_permissions_repository() -> clap::Command
    {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("can-approve-pull-request-reviews") . long ("can-approve-pull-request-reviews") . required (false) . value_parser (clap :: value_parser ! (types :: ActionsCanApprovePullRequestReviews))) . arg (clap :: Arg :: new ("default-workflow-permissions") . long ("default-workflow-permissions") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActionsDefaultWorkflowPermissions :: Read . to_string () , types :: ActionsDefaultWorkflowPermissions :: Write . to_string () ,]) , | s | types :: ActionsDefaultWorkflowPermissions :: try_from (s) . unwrap ()))) . about ("Set default workflow permissions for a repository\n\nSets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in a repository, and sets if GitHub Actions\ncan submit approving pull request reviews.\nFor more information, see \"[Setting the permissions of the GITHUB_TOKEN for your repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository).\"\n\nYou must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the repository `administration` permission to use this API.")
    }

    pub fn cli_actions_list_required_workflow_runs() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("required-workflow-id-for-repo") . long ("required-workflow-id-for-repo") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The ID of the required workflow that has run at least once in a repository.")) . arg (clap :: Arg :: new ("actor") . long ("actor") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Returns workflow runs associated with a branch. Use the name of the branch of the `push`.")) . arg (clap :: Arg :: new ("check-suite-id") . long ("check-suite-id") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Returns workflow runs with the `check_suite_id` that you specify.")) . arg (clap :: Arg :: new ("created") . long ("created") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Returns workflow runs created within the given date-time range. For more information on the syntax, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"")) . arg (clap :: Arg :: new ("event") . long ("event") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see \"[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\"")) . arg (clap :: Arg :: new ("exclude-pull-requests") . long ("exclude-pull-requests") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("If `true` pull requests are omitted from the response (empty array).")) . arg (clap :: Arg :: new ("head-sha") . long ("head-sha") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Only returns workflow runs that are associated with the specified `head_sha`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("status") . long ("status") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActionsListRequiredWorkflowRunsStatus :: Completed . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: ActionRequired . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: Cancelled . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: Failure . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: Neutral . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: Skipped . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: Stale . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: Success . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: TimedOut . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: InProgress . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: Queued . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: Requested . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: Waiting . to_string () , types :: ActionsListRequiredWorkflowRunsStatus :: Pending . to_string () ,]) , | s | types :: ActionsListRequiredWorkflowRunsStatus :: try_from (s) . unwrap ())) . help ("Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`.")) . about ("List workflow runs for a required workflow\n\nList all workflow runs for a required workflow. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).\n\nAnyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. For more information, see \"[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).\"")
    }

    pub fn cli_actions_list_self_hosted_runners_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List self-hosted runners for a repository\n\nLists all self-hosted runners \
                 configured in a repository. You must authenticate using an access token with the \
                 `repo` scope to use this endpoint.",
            )
    }

    pub fn cli_actions_list_runner_applications_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "List runner applications for a repository\n\nLists binaries for the runner \
                 application that you can download and run.\n\nYou must authenticate using an \
                 access token with the `repo` scope to use this endpoint.",
            )
    }

    pub fn cli_actions_create_registration_token_for_repo() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Create a registration token for a repository\n\nReturns a token that you can pass to the `config` script. The token expires after one hour. You must authenticate\nusing an access token with the `repo` scope to use this endpoint.\n\n#### Example using registration token\n \nConfigure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.\n\n```\n./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN\n```")
    }

    pub fn cli_actions_create_remove_token_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Create a remove token for a repository\n\nReturns a token that you can pass to \
                 remove a self-hosted runner from a repository. The token expires after one \
                 hour.\nYou must authenticate using an access token with the `repo` scope to use \
                 this endpoint.\n\n#### Example using remove token\n \nTo remove your self-hosted \
                 runner from a repository, replace TOKEN with the remove token provided by this \
                 endpoint.\n\n```\n./config.sh remove --token TOKEN\n```",
            )
    }

    pub fn cli_actions_get_self_hosted_runner_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "Get a self-hosted runner for a repository\n\nGets a specific self-hosted runner \
                 configured in a repository.\n\nYou must authenticate using an access token with \
                 the `repo` scope to use this\nendpoint.",
            )
    }

    pub fn cli_actions_delete_self_hosted_runner_from_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "Delete a self-hosted runner from a repository\n\nForces the removal of a \
                 self-hosted runner from a repository. You can use this endpoint to completely \
                 remove the runner when the machine you were using no longer exists.\n\nYou must \
                 authenticate using an access token with the `repo`\nscope to use this endpoint.",
            )
    }

    pub fn cli_actions_list_labels_for_self_hosted_runner_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "List labels for a self-hosted runner for a repository\n\nLists all labels for a \
                 self-hosted runner configured in a repository.\n\nYou must authenticate using an \
                 access token with the `repo` scope to use this\nendpoint.",
            )
    }

    pub fn cli_actions_set_custom_labels_for_self_hosted_runner_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "Set custom labels for a self-hosted runner for a repository\n\nRemove all \
                 previous custom labels and set the new custom labels for a specific\nself-hosted \
                 runner configured in a repository.\n\nYou must authenticate using an access \
                 token with the `repo` scope to use this\nendpoint.",
            )
    }

    pub fn cli_actions_add_custom_labels_to_self_hosted_runner_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "Add custom labels to a self-hosted runner for a repository\n\nAdd custom labels \
                 to a self-hosted runner configured in a repository.\n\nYou must authenticate \
                 using an access token with the `repo` scope to use this\nendpoint.",
            )
    }

    pub fn cli_actions_remove_all_custom_labels_from_self_hosted_runner_for_repo() -> clap::Command
    {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .about(
                "Remove all custom labels from a self-hosted runner for a repository\n\nRemove \
                 all custom labels from a self-hosted runner configured in a\nrepository. Returns \
                 the remaining read-only labels from the runner.\n\nYou must authenticate using \
                 an access token with the `repo` scope to use this\nendpoint.",
            )
    }

    pub fn cli_actions_remove_custom_label_from_self_hosted_runner_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("runner-id")
                    .long("runner-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("Unique identifier of the self-hosted runner."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of a self-hosted runner's custom label."),
            )
            .about(
                "Remove a custom label from a self-hosted runner for a repository\n\nRemove a \
                 custom label from a self-hosted runner configured\nin a repository. Returns the \
                 remaining labels from the runner.\n\nThis endpoint returns a `404 Not Found` \
                 status if the custom label is not\npresent on the runner.\n\nYou must \
                 authenticate using an access token with the `repo` scope to use this\nendpoint.",
            )
    }

    pub fn cli_actions_list_workflow_runs_for_repo() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("actor") . long ("actor") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Returns workflow runs associated with a branch. Use the name of the branch of the `push`.")) . arg (clap :: Arg :: new ("check-suite-id") . long ("check-suite-id") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Returns workflow runs with the `check_suite_id` that you specify.")) . arg (clap :: Arg :: new ("created") . long ("created") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Returns workflow runs created within the given date-time range. For more information on the syntax, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"")) . arg (clap :: Arg :: new ("event") . long ("event") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see \"[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\"")) . arg (clap :: Arg :: new ("exclude-pull-requests") . long ("exclude-pull-requests") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("If `true` pull requests are omitted from the response (empty array).")) . arg (clap :: Arg :: new ("head-sha") . long ("head-sha") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Only returns workflow runs that are associated with the specified `head_sha`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("status") . long ("status") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActionsListWorkflowRunsForRepoStatus :: Completed . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: ActionRequired . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: Cancelled . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: Failure . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: Neutral . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: Skipped . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: Stale . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: Success . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: TimedOut . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: InProgress . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: Queued . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: Requested . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: Waiting . to_string () , types :: ActionsListWorkflowRunsForRepoStatus :: Pending . to_string () ,]) , | s | types :: ActionsListWorkflowRunsForRepoStatus :: try_from (s) . unwrap ())) . help ("Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`.")) . about ("List workflow runs for a repository\n\nLists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).\n\nAnyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.")
    }

    pub fn cli_actions_get_workflow_run() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .arg(
                clap::Arg::new("exclude-pull-requests")
                    .long("exclude-pull-requests")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help("If `true` pull requests are omitted from the response (empty array)."),
            )
            .about(
                "Get a workflow run\n\nGets a specific workflow run. Anyone with read access to \
                 the repository can use this endpoint. If the repository is private you must use \
                 an access token with the `repo` scope. GitHub Apps must have the `actions:read` \
                 permission to use this endpoint.",
            )
    }

    pub fn cli_actions_delete_workflow_run() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .about(
                "Delete a workflow run\n\nDelete a specific workflow run. Anyone with write \
                 access to the repository can use this endpoint. If the repository is\nprivate \
                 you must use an access token with the `repo` scope. GitHub Apps must have the \
                 `actions:write` permission to use\nthis endpoint.",
            )
    }

    pub fn cli_actions_get_reviews_for_run() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .about(
                "Get the review history for a workflow run\n\nAnyone with read access to the \
                 repository can use this endpoint. If the repository is private, you must use an \
                 access token with the `repo` scope. GitHub Apps must have the `actions:read` \
                 permission to use this endpoint.",
            )
    }

    pub fn cli_actions_approve_workflow_run() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("run-id") . long ("run-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the workflow run.")) . about ("Approve a workflow run for a fork pull request\n\nApproves a workflow run for a pull request from a public fork of a first time contributor. For more information, see [\"Approving workflow runs from public forks](https://docs.github.com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks).\"\n\nYou must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.")
    }

    pub fn cli_actions_list_workflow_run_artifacts() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List workflow run artifacts\n\nLists artifacts for a workflow run. Anyone with \
                 read access to the repository can use this endpoint. If the repository is \
                 private you must use an access token with the `repo` scope. GitHub Apps must \
                 have the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_workflow_run_attempt() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .arg(
                clap::Arg::new("attempt-number")
                    .long("attempt-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The attempt number of the workflow run."),
            )
            .arg(
                clap::Arg::new("exclude-pull-requests")
                    .long("exclude-pull-requests")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help("If `true` pull requests are omitted from the response (empty array)."),
            )
            .about(
                "Get a workflow run attempt\n\nGets a specific workflow run attempt. Anyone with \
                 read access to the repository\ncan use this endpoint. If the repository is \
                 private you must use an access token\nwith the `repo` scope. GitHub Apps must \
                 have the `actions:read` permission to\nuse this endpoint.",
            )
    }

    pub fn cli_actions_list_jobs_for_workflow_run_attempt() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("run-id") . long ("run-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the workflow run.")) . arg (clap :: Arg :: new ("attempt-number") . long ("attempt-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The attempt number of the workflow run.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List jobs for a workflow run attempt\n\nLists jobs for a specific workflow run attempt. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).")
    }

    pub fn cli_actions_download_workflow_run_attempt_logs() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .arg(
                clap::Arg::new("attempt-number")
                    .long("attempt-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The attempt number of the workflow run."),
            )
            .about(
                "Download workflow run attempt logs\n\nGets a redirect URL to download an archive \
                 of log files for a specific workflow run attempt. This link expires after\n1 \
                 minute. Look for `Location:` in the response header to find the URL for the \
                 download. Anyone with read access to\nthe repository can use this endpoint. If \
                 the repository is private you must use an access token with the `repo` \
                 scope.\nGitHub Apps must have the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_cancel_workflow_run() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .about(
                "Cancel a workflow run\n\nCancels a workflow run using its `id`. You must \
                 authenticate using an access token with the `repo` scope to use this endpoint. \
                 GitHub Apps must have the `actions:write` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_review_custom_gates_for_run() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("run-id") . long ("run-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the workflow run.")) . about ("Review custom deployment protection rules for a workflow run\n\nApprove or reject custom deployment protection rules provided by a GitHub App for a workflow run. For more information, see \"[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment).\"\n\n**Note:** GitHub Apps can only review their own custom deployment protection rules.\nTo approve or reject pending deployments that are waiting for review from a specific person or team, see [`POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments`](/rest/actions/workflow-runs#review-pending-deployments-for-a-workflow-run).\n\nGitHub Apps must have read and write permission for **Deployments** to use this endpoint.")
    }

    pub fn cli_actions_list_jobs_for_workflow_run() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("run-id") . long ("run-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the workflow run.")) . arg (clap :: Arg :: new ("filter") . long ("filter") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActionsListJobsForWorkflowRunFilter :: Latest . to_string () , types :: ActionsListJobsForWorkflowRunFilter :: All . to_string () ,]) , | s | types :: ActionsListJobsForWorkflowRunFilter :: try_from (s) . unwrap ())) . help ("Filters jobs by their `completed_at` timestamp. `latest` returns jobs from the most recent execution of the workflow run. `all` returns all jobs for a workflow run, including from old executions of the workflow run.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List jobs for a workflow run\n\nLists jobs for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).")
    }

    pub fn cli_actions_download_workflow_run_logs() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .about(
                "Download workflow run logs\n\nGets a redirect URL to download an archive of log \
                 files for a workflow run. This link expires after 1 minute. Look \
                 for\n`Location:` in the response header to find the URL for the download. Anyone \
                 with read access to the repository can use\nthis endpoint. If the repository is \
                 private you must use an access token with the `repo` scope. GitHub Apps must \
                 have\nthe `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_delete_workflow_run_logs() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .about(
                "Delete workflow run logs\n\nDeletes all logs for a workflow run. You must \
                 authenticate using an access token with the `repo` scope to use this endpoint. \
                 GitHub Apps must have the `actions:write` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_pending_deployments_for_run() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .about(
                "Get pending deployments for a workflow run\n\nGet all deployment environments \
                 for a workflow run that are waiting for protection rules to pass.\n\nAnyone with \
                 read access to the repository can use this endpoint. If the repository is \
                 private, you must use an access token with the `repo` scope. GitHub Apps must \
                 have the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_review_pending_deployments_for_run() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .arg(
                clap::Arg::new("comment")
                    .long("comment")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("A comment to accompany the deployment review"),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ActionsReviewPendingDeploymentsForRunBodyState::Approved
                                .to_string(),
                            types::ActionsReviewPendingDeploymentsForRunBodyState::Rejected
                                .to_string(),
                        ]),
                        |s| {
                            types::ActionsReviewPendingDeploymentsForRunBodyState::try_from(s)
                                .unwrap()
                        },
                    ))
                    .help("Whether to approve or reject deployment to the specified environments."),
            )
            .about(
                "Review pending deployments for a workflow run\n\nApprove or reject pending \
                 deployments that are waiting on approval by a required reviewer.\n\nRequired \
                 reviewers with read access to the repository contents and deployments can use \
                 this endpoint. Required reviewers must authenticate using an access token with \
                 the `repo` scope to use this endpoint.",
            )
    }

    pub fn cli_actions_re_run_workflow() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .about(
                "Re-run a workflow\n\nRe-runs your workflow run using its `id`. You must \
                 authenticate using an access token with the `repo` scope to use this endpoint. \
                 GitHub Apps must have the `actions:write` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_re_run_workflow_failed_jobs() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("run-id")
                    .long("run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the workflow run."),
            )
            .about(
                "Re-run failed jobs from a workflow run\n\nRe-run all of the failed jobs and \
                 their dependent jobs in a workflow run using the `id` of the workflow run. You \
                 must authenticate using an access token with the `repo` scope to use this \
                 endpoint.",
            )
    }

    pub fn cli_actions_get_workflow_run_usage() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("run-id") . long ("run-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the workflow run.")) . about ("Get workflow run usage\n\nGets the number of billable minutes and total run time for a specific workflow run. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see \"[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)\".\n\nAnyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.")
    }

    pub fn cli_actions_list_repo_secrets() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repository secrets\n\nLists all secrets available in a repository without \
                 revealing their encrypted values. You must authenticate using an access token \
                 with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` \
                 repository permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_repo_public_key() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get a repository public key\n\nGets your public key, which you need to encrypt \
                 secrets. You need to encrypt a secret before you can create or update secrets. \
                 Anyone with read access to the repository can use this endpoint. If the \
                 repository is private you must use an access token with the `repo` scope. GitHub \
                 Apps must have the `secrets` repository permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_repo_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Get a repository secret\n\nGets a single repository secret without revealing its \
                 encrypted value. You must authenticate using an access token with the `repo` \
                 scope to use this endpoint. GitHub Apps must have the `secrets` repository \
                 permission to use this endpoint.",
            )
    }

    pub fn cli_actions_create_or_update_repo_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("encrypted-value") . long ("encrypted-value") . required (false) . value_parser (clap :: value_parser ! (types :: ActionsCreateOrUpdateRepoSecretBodyEncryptedValue)) . help ("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/reference/actions#get-a-repository-public-key) endpoint.")) . arg (clap :: Arg :: new ("key-id") . long ("key-id") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("ID of the key you used to encrypt the secret.")) . about ("Create or update a repository secret\n\nCreates or updates a repository secret with an encrypted value. Encrypt your secret using\n[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access\ntoken with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use\nthis endpoint.\n\n#### Example encrypting a secret using Node.js\n\nEncrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.\n\n```\nconst sodium = require('libsodium-wrappers')\nconst secret = 'plain-text-secret' // replace with the secret you want to encrypt\nconst key = 'base64-encoded-public-key' // replace with the Base64 encoded public key\n\n//Check if libsodium is ready and then proceed.\nsodium.ready.then(() => {\n  // Convert Secret & Base64 key to Uint8Array.\n  let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)\n  let binsec = sodium.from_string(secret)\n\n  //Encrypt the secret using LibSodium\n  let encBytes = sodium.crypto_box_seal(binsec, binkey)\n\n  // Convert encrypted Uint8Array to Base64\n  let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)\n\n  console.log(output)\n});\n```\n\n#### Example encrypting a secret using Python\n\nEncrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.\n\n```\nfrom base64 import b64encode\nfrom nacl import encoding, public\n\ndef encrypt(public_key: str, secret_value: str) -> str:\n  \"\"\"Encrypt a Unicode string using the public key.\"\"\"\n  public_key = public.PublicKey(public_key.encode(\"utf-8\"), encoding.Base64Encoder())\n  sealed_box = public.SealedBox(public_key)\n  encrypted = sealed_box.encrypt(secret_value.encode(\"utf-8\"))\n  return b64encode(encrypted).decode(\"utf-8\")\n```\n\n#### Example encrypting a secret using C#\n\nEncrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.\n\n```\nvar secretValue = System.Text.Encoding.UTF8.GetBytes(\"mySecret\");\nvar publicKey = Convert.FromBase64String(\"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=\");\n\nvar sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);\n\nConsole.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));\n```\n\n#### Example encrypting a secret using Ruby\n\nEncrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.\n\n```ruby\nrequire \"rbnacl\"\nrequire \"base64\"\n\nkey = Base64.decode64(\"+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=\")\npublic_key = RbNaCl::PublicKey.new(key)\n\nbox = RbNaCl::Boxes::Sealed.from_public_key(public_key)\nencrypted_secret = box.encrypt(\"my_secret\")\n\n# Print the base64 encoded secret\nputs Base64.strict_encode64(encrypted_secret)\n```")
    }

    pub fn cli_actions_delete_repo_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Delete a repository secret\n\nDeletes a secret in a repository using the secret \
                 name. You must authenticate using an access token with the `repo` scope to use \
                 this endpoint. GitHub Apps must have the `secrets` repository permission to use \
                 this endpoint.",
            )
    }

    pub fn cli_actions_list_repo_variables() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 30)."),
            )
            .about(
                "List repository variables\n\nLists all repository variables. You must \
                 authenticate using an access token with the `repo` scope to use this endpoint. \
                 GitHub Apps must have the `actions_variables:read` repository permission to use \
                 this endpoint.",
            )
    }

    pub fn cli_actions_create_repo_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("value")
                    .long("value")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The value of the variable."),
            )
            .about(
                "Create a repository variable\n\nCreates a repository variable that you can \
                 reference in a GitHub Actions workflow.\nYou must authenticate using an access \
                 token with the `repo` scope to use this endpoint.\nGitHub Apps must have the \
                 `actions_variables:write` repository permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_repo_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .about(
                "Get a repository variable\n\nGets a specific variable in a repository. You must \
                 authenticate using an access token with the `repo` scope to use this endpoint. \
                 GitHub Apps must have the `actions_variables:read` repository permission to use \
                 this endpoint.",
            )
    }

    pub fn cli_actions_delete_repo_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .about(
                "Delete a repository variable\n\nDeletes a repository variable using the variable \
                 name.\nYou must authenticate using an access token with the `repo` scope to use \
                 this endpoint.\nGitHub Apps must have the `actions_variables:write` repository \
                 permission to use this endpoint.",
            )
    }

    pub fn cli_actions_update_repo_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("value")
                    .long("value")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The value of the variable."),
            )
            .about(
                "Update a repository variable\n\nUpdates a repository variable that you can \
                 reference in a GitHub Actions workflow.\nYou must authenticate using an access \
                 token with the `repo` scope to use this endpoint.\nGitHub Apps must have the \
                 `actions_variables:write` repository permission to use this endpoint.",
            )
    }

    pub fn cli_actions_list_repo_workflows() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repository workflows\n\nLists the workflows in a repository. Anyone with \
                 read access to the repository can use this endpoint. If the repository is \
                 private you must use an access token with the `repo` scope. GitHub Apps must \
                 have the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_workflow() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("workflow-id")
                    .long("workflow-id")
                    .required(true)
                    .value_parser(clap::value_parser!(types::ActionsGetWorkflowWorkflowId))
                    .help(
                        "The ID of the workflow. You can also pass the workflow file name as a \
                         string.",
                    ),
            )
            .about(
                "Get a workflow\n\nGets a specific workflow. You can replace `workflow_id` with \
                 the workflow file name. For example, you could use `main.yaml`. Anyone with read \
                 access to the repository can use this endpoint. If the repository is private you \
                 must use an access token with the `repo` scope. GitHub Apps must have the \
                 `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_disable_workflow() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("workflow-id")
                    .long("workflow-id")
                    .required(true)
                    .value_parser(clap::value_parser!(types::ActionsDisableWorkflowWorkflowId))
                    .help(
                        "The ID of the workflow. You can also pass the workflow file name as a \
                         string.",
                    ),
            )
            .about(
                "Disable a workflow\n\nDisables a workflow and sets the `state` of the workflow \
                 to `disabled_manually`. You can replace `workflow_id` with the workflow file \
                 name. For example, you could use `main.yaml`.\n\nYou must authenticate using an \
                 access token with the `repo` scope to use this endpoint. GitHub Apps must have \
                 the `actions:write` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_create_workflow_dispatch() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("workflow-id") . long ("workflow-id") . required (true) . value_parser (clap :: value_parser ! (types :: ActionsCreateWorkflowDispatchWorkflowId)) . help ("The ID of the workflow. You can also pass the workflow file name as a string.")) . arg (clap :: Arg :: new ("ref") . long ("ref") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The git reference for the workflow. The reference can be a branch or tag name.")) . about ("Create a workflow dispatch event\n\nYou can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.\n\nYou must configure your GitHub Actions workflow to run when the [`workflow_dispatch` webhook](/developers/webhooks-and-events/webhook-events-and-payloads#workflow_dispatch) event occurs. The `inputs` are configured in the workflow file. For more information about how to configure the `workflow_dispatch` event in the workflow file, see \"[Events that trigger workflows](/actions/reference/events-that-trigger-workflows#workflow_dispatch).\"\n\nYou must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint. For more information, see \"[Creating a personal access token for the command line](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line).\"")
    }

    pub fn cli_actions_enable_workflow() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("workflow-id")
                    .long("workflow-id")
                    .required(true)
                    .value_parser(clap::value_parser!(types::ActionsEnableWorkflowWorkflowId))
                    .help(
                        "The ID of the workflow. You can also pass the workflow file name as a \
                         string.",
                    ),
            )
            .about(
                "Enable a workflow\n\nEnables a workflow and sets the `state` of the workflow to \
                 `active`. You can replace `workflow_id` with the workflow file name. For \
                 example, you could use `main.yaml`.\n\nYou must authenticate using an access \
                 token with the `repo` scope to use this endpoint. GitHub Apps must have the \
                 `actions:write` permission to use this endpoint.",
            )
    }

    pub fn cli_actions_list_workflow_runs() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("workflow-id") . long ("workflow-id") . required (true) . value_parser (clap :: value_parser ! (types :: ActionsListWorkflowRunsWorkflowId)) . help ("The ID of the workflow. You can also pass the workflow file name as a string.")) . arg (clap :: Arg :: new ("actor") . long ("actor") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Returns workflow runs associated with a branch. Use the name of the branch of the `push`.")) . arg (clap :: Arg :: new ("check-suite-id") . long ("check-suite-id") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Returns workflow runs with the `check_suite_id` that you specify.")) . arg (clap :: Arg :: new ("created") . long ("created") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Returns workflow runs created within the given date-time range. For more information on the syntax, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"")) . arg (clap :: Arg :: new ("event") . long ("event") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see \"[Events that trigger workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\"")) . arg (clap :: Arg :: new ("exclude-pull-requests") . long ("exclude-pull-requests") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("If `true` pull requests are omitted from the response (empty array).")) . arg (clap :: Arg :: new ("head-sha") . long ("head-sha") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Only returns workflow runs that are associated with the specified `head_sha`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("status") . long ("status") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActionsListWorkflowRunsStatus :: Completed . to_string () , types :: ActionsListWorkflowRunsStatus :: ActionRequired . to_string () , types :: ActionsListWorkflowRunsStatus :: Cancelled . to_string () , types :: ActionsListWorkflowRunsStatus :: Failure . to_string () , types :: ActionsListWorkflowRunsStatus :: Neutral . to_string () , types :: ActionsListWorkflowRunsStatus :: Skipped . to_string () , types :: ActionsListWorkflowRunsStatus :: Stale . to_string () , types :: ActionsListWorkflowRunsStatus :: Success . to_string () , types :: ActionsListWorkflowRunsStatus :: TimedOut . to_string () , types :: ActionsListWorkflowRunsStatus :: InProgress . to_string () , types :: ActionsListWorkflowRunsStatus :: Queued . to_string () , types :: ActionsListWorkflowRunsStatus :: Requested . to_string () , types :: ActionsListWorkflowRunsStatus :: Waiting . to_string () , types :: ActionsListWorkflowRunsStatus :: Pending . to_string () ,]) , | s | types :: ActionsListWorkflowRunsStatus :: try_from (s) . unwrap ())) . help ("Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`.")) . about ("List workflow runs for a workflow\n\nList all workflow runs for a workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).\n\nAnyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.")
    }

    pub fn cli_actions_get_workflow_usage() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("workflow-id") . long ("workflow-id") . required (true) . value_parser (clap :: value_parser ! (types :: ActionsGetWorkflowUsageWorkflowId)) . help ("The ID of the workflow. You can also pass the workflow file name as a string.")) . about ("Get workflow usage\n\nGets the number of billable minutes used by a specific workflow during the current billing cycle. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see \"[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)\".\n\nYou can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.")
    }

    pub fn cli_issues_list_assignees() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List assignees\n\nLists the [available assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.")
    }

    pub fn cli_issues_check_user_can_be_assigned() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("assignee")
                    .long("assignee")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about(
                "Check if a user can be assigned\n\nChecks if a user has permission to be \
                 assigned to an issue in this repository.\n\nIf the `assignee` can be assigned to \
                 issues in the repository, a `204` header with no content is \
                 returned.\n\nOtherwise a `404` status code is returned.",
            )
    }

    pub fn cli_repos_list_autolinks() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .about(
                "List all autolinks of a repository\n\nThis returns a list of autolinks \
                 configured for the given repository.\n\nInformation about autolinks are only \
                 available to repository administrators.",
            )
    }

    pub fn cli_repos_create_autolink() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("is-alphanumeric")
                    .long("is-alphanumeric")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Whether this autolink reference matches alphanumeric characters. If \
                         true, the `<num>` parameter of the `url_template` matches alphanumeric \
                         characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this \
                         autolink reference only matches numeric characters.",
                    ),
            )
            .arg(
                clap::Arg::new("key-prefix")
                    .long("key-prefix")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "This prefix appended by certain characters will generate a link any time \
                         it is found in an issue, pull request, or commit.",
                    ),
            )
            .arg(
                clap::Arg::new("url-template")
                    .long("url-template")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The URL must contain `<num>` for the reference number. `<num>` matches \
                         different characters depending on the value of `is_alphanumeric`.",
                    ),
            )
            .about(
                "Create an autolink reference for a repository\n\nUsers with admin access to the \
                 repository can create an autolink.",
            )
    }

    pub fn cli_repos_get_autolink() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("autolink-id")
                    .long("autolink-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the autolink."),
            )
            .about(
                "Get an autolink reference of a repository\n\nThis returns a single autolink \
                 reference by ID that was configured for the given repository.\n\nInformation \
                 about autolinks are only available to repository administrators.",
            )
    }

    pub fn cli_repos_delete_autolink() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("autolink-id")
                    .long("autolink-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the autolink."),
            )
            .about(
                "Delete an autolink reference from a repository\n\nThis deletes a single autolink \
                 reference by ID that was configured for the given repository.\n\nInformation \
                 about autolinks are only available to repository administrators.",
            )
    }

    pub fn cli_repos_enable_automated_security_fixes() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Enable automated security fixes\n\nEnables automated security fixes for a repository. The authenticated user must have admin access to the repository. For more information, see \"[Configuring automated security fixes](https://docs.github.com/articles/configuring-automated-security-fixes)\".")
    }

    pub fn cli_repos_disable_automated_security_fixes() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Disable automated security fixes\n\nDisables automated security fixes for a repository. The authenticated user must have admin access to the repository. For more information, see \"[Configuring automated security fixes](https://docs.github.com/articles/configuring-automated-security-fixes)\".")
    }

    pub fn cli_repos_list_branches() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("protected")
                    .long("protected")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Setting to `true` returns only protected branches. When set to `false`, \
                         only unprotected branches are returned. Omitting this parameter returns \
                         all branches.",
                    ),
            )
            .about("List branches")
    }

    pub fn cli_repos_get_branch() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get a branch")
    }

    pub fn cli_repos_get_branch_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get branch protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_repos_update_branch_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . arg (clap :: Arg :: new ("allow-deletions") . long ("allow-deletions") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see \"[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)\" in the GitHub Help documentation.")) . arg (clap :: Arg :: new ("allow-force-pushes") . long ("allow-force-pushes") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see \"[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)\" in the GitHub Help documentation.\"")) . arg (clap :: Arg :: new ("allow-fork-syncing") . long ("allow-fork-syncing") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`.")) . arg (clap :: Arg :: new ("block-creations") . long ("block-creations") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.")) . arg (clap :: Arg :: new ("enforce-admins") . long ("enforce-admins") . required (true) . value_parser (clap :: value_parser ! (bool)) . help ("Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.")) . arg (clap :: Arg :: new ("lock-branch") . long ("lock-branch") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`.")) . arg (clap :: Arg :: new ("required-conversation-resolution") . long ("required-conversation-resolution") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.")) . arg (clap :: Arg :: new ("required-linear-history") . long ("required-linear-history") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see \"[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)\" in the GitHub Help documentation.")) . about ("Update branch protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nProtecting a branch requires admin or owner permissions to the repository.\n\n**Note**: Passing new arrays of `users` and `teams` replaces their previous values.\n\n**Note**: The list of users, apps, and teams in total is limited to 100 items.")
    }

    pub fn cli_repos_delete_branch_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Delete branch protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_repos_get_admin_branch_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get admin branch protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_repos_set_admin_branch_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Set admin branch protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nAdding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.")
    }

    pub fn cli_repos_delete_admin_branch_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Delete admin branch protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nRemoving admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.")
    }

    pub fn cli_repos_get_pull_request_review_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get pull request review protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_repos_delete_pull_request_review_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Delete pull request review protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_repos_update_pull_request_review_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . arg (clap :: Arg :: new ("dismiss-stale-reviews") . long ("dismiss-stale-reviews") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.")) . arg (clap :: Arg :: new ("require-code-owner-reviews") . long ("require-code-owner-reviews") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed.")) . arg (clap :: Arg :: new ("require-last-push-approval") . long ("require-last-push-approval") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`")) . arg (clap :: Arg :: new ("required-approving-review-count") . long ("required-approving-review-count") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.")) . about ("Update pull request review protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nUpdating pull request review enforcement requires admin or owner permissions to the repository and branch protection to be enabled.\n\n**Note**: Passing new arrays of `users` and `teams` replaces their previous values.")
    }

    pub fn cli_repos_get_commit_signature_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get commit signature protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nWhen authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch requires signed commits. An enabled status of `true` indicates you must sign commits on this branch. For more information, see [Signing commits with GPG](https://docs.github.com/articles/signing-commits-with-gpg) in GitHub Help.\n\n**Note**: You must enable branch protection to require signed commits.")
    }

    pub fn cli_repos_create_commit_signature_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Create commit signature protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nWhen authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits on a branch. You must enable branch protection to require signed commits.")
    }

    pub fn cli_repos_delete_commit_signature_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Delete commit signature protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nWhen authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed commits on a branch. You must enable branch protection to require signed commits.")
    }

    pub fn cli_repos_get_status_checks_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get status checks protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_repos_remove_status_check_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Remove status check protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_repos_update_status_check_protection() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . arg (clap :: Arg :: new ("strict") . long ("strict") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Require branches to be up to date before merging.")) . about ("Update status check protection\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nUpdating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.")
    }

    pub fn cli_repos_get_all_status_check_contexts() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get all status check contexts\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_repos_set_status_check_contexts() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Set status check contexts\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_repos_add_status_check_contexts() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Add status check contexts\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_repos_remove_status_check_contexts() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Remove status check contexts\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_repos_get_access_restrictions() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get access restrictions\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nLists who has access to this protected branch.\n\n**Note**: Users, apps, and teams `restrictions` are only available for organization-owned repositories.")
    }

    pub fn cli_repos_delete_access_restrictions() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Delete access restrictions\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nDisables the ability to restrict who can push to this branch.")
    }

    pub fn cli_repos_get_apps_with_access_to_protected_branch() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get apps with access to the protected branch\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nLists the GitHub Apps that have push access to this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.")
    }

    pub fn cli_repos_set_app_access_restrictions() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Set app access restrictions\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nReplaces the list of apps that have push access to this branch. This removes all apps that previously had push access and grants push access to the new list of apps. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.")
    }

    pub fn cli_repos_add_app_access_restrictions() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Add app access restrictions\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nGrants the specified apps push access for this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.")
    }

    pub fn cli_repos_remove_app_access_restrictions() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Remove app access restrictions\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nRemoves the ability of an app to push to this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.")
    }

    pub fn cli_repos_get_teams_with_access_to_protected_branch() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get teams with access to the protected branch\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nLists the teams who have push access to this branch. The list includes child teams.")
    }

    pub fn cli_repos_set_team_access_restrictions() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Set team access restrictions\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nReplaces the list of teams that have push access to this branch. This removes all teams that previously had push access and grants push access to the new list of teams. Team restrictions include child teams.")
    }

    pub fn cli_repos_add_team_access_restrictions() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Add team access restrictions\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nGrants the specified teams push access for this branch. You can also give push access to child teams.")
    }

    pub fn cli_repos_remove_team_access_restrictions() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Remove team access restrictions\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nRemoves the ability of a team to push to this branch. You can also remove push access for child teams.")
    }

    pub fn cli_repos_get_users_with_access_to_protected_branch() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get users with access to the protected branch\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nLists the people who have push access to this branch.")
    }

    pub fn cli_repos_set_user_access_restrictions() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Set user access restrictions\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nReplaces the list of people that have push access to this branch. This removes all people that previously had push access and grants push access to the new list of people.\n\n| Type    | Description                                                                                                                   |\n| ------- | ----------------------------------------------------------------------------------------------------------------------------- |\n| `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |")
    }

    pub fn cli_repos_add_user_access_restrictions() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Add user access restrictions\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nGrants the specified people push access for this branch.\n\n| Type    | Description                                                                                                                   |\n| ------- | ----------------------------------------------------------------------------------------------------------------------------- |\n| `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |")
    }

    pub fn cli_repos_remove_user_access_restrictions() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Remove user access restrictions\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nRemoves the ability of a user to push to this branch.\n\n| Type    | Description                                                                                                                                   |\n| ------- | --------------------------------------------------------------------------------------------------------------------------------------------- |\n| `array` | Usernames of the people who should no longer have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |")
    }

    pub fn cli_repos_rename_branch() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . arg (clap :: Arg :: new ("new-name") . long ("new-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The new name of the branch.")) . about ("Rename a branch\n\nRenames a branch in a repository.\n\n**Note:** Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see \"[Renaming a branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)\".\n\nThe permissions required to use this endpoint depends on whether you are renaming the default branch.\n\nTo rename a non-default branch:\n\n* Users must have push access.\n* GitHub Apps must have the `contents:write` repository permission.\n\nTo rename the default branch:\n\n* Users must have admin or owner permissions.\n* GitHub Apps must have the `administration:write` repository permission.")
    }

    pub fn cli_checks_create() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("completed-at") . long ("completed-at") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("conclusion") . long ("conclusion") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ChecksCreateBodyConclusion :: ActionRequired . to_string () , types :: ChecksCreateBodyConclusion :: Cancelled . to_string () , types :: ChecksCreateBodyConclusion :: Failure . to_string () , types :: ChecksCreateBodyConclusion :: Neutral . to_string () , types :: ChecksCreateBodyConclusion :: Success . to_string () , types :: ChecksCreateBodyConclusion :: Skipped . to_string () , types :: ChecksCreateBodyConclusion :: Stale . to_string () , types :: ChecksCreateBodyConclusion :: TimedOut . to_string () ,]) , | s | types :: ChecksCreateBodyConclusion :: try_from (s) . unwrap ())) . help ("**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.")) . arg (clap :: Arg :: new ("details-url") . long ("details-url") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The URL of the integrator's site that has the full details of the check. If the integrator does not provide this, then the homepage of the GitHub app is used.")) . arg (clap :: Arg :: new ("external-id") . long ("external-id") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A reference for the run on the integrator's system.")) . arg (clap :: Arg :: new ("head-sha") . long ("head-sha") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The SHA of the commit.")) . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the check. For example, \"code-coverage\".")) . arg (clap :: Arg :: new ("started-at") . long ("started-at") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("status") . long ("status") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ChecksCreateBodyStatus :: Queued . to_string () , types :: ChecksCreateBodyStatus :: InProgress . to_string () , types :: ChecksCreateBodyStatus :: Completed . to_string () ,]) , | s | types :: ChecksCreateBodyStatus :: try_from (s) . unwrap ())) . help ("The current status.")) . about ("Create a check run\n\n**Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.\n\nCreates a new check run for a specific commit in a repository. Your GitHub App must have the `checks:write` permission to create check runs.\n\nIn a check suite, GitHub limits the number of check runs with the same name to 1000. Once these check runs exceed 1000, GitHub will start to automatically delete older check runs.")
    }

    pub fn cli_checks_get() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("check-run-id")
                    .long("check-run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the check run."),
            )
            .about(
                "Get a check run\n\n**Note:** The Checks API only looks for pushes in the \
                 repository where the check suite or check run were created. Pushes to a branch \
                 in a forked repository are not detected and return an empty `pull_requests` \
                 array.\n\nGets a single check run using its `id`. GitHub Apps must have the \
                 `checks:read` permission on a private repository or pull access to a public \
                 repository to get check runs. OAuth Apps and authenticated users must have the \
                 `repo` scope to get check runs in a private repository.",
            )
    }

    pub fn cli_checks_update() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("check-run-id") . long ("check-run-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the check run.")) . arg (clap :: Arg :: new ("completed-at") . long ("completed-at") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("conclusion") . long ("conclusion") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ChecksUpdateBodyConclusion :: ActionRequired . to_string () , types :: ChecksUpdateBodyConclusion :: Cancelled . to_string () , types :: ChecksUpdateBodyConclusion :: Failure . to_string () , types :: ChecksUpdateBodyConclusion :: Neutral . to_string () , types :: ChecksUpdateBodyConclusion :: Success . to_string () , types :: ChecksUpdateBodyConclusion :: Skipped . to_string () , types :: ChecksUpdateBodyConclusion :: Stale . to_string () , types :: ChecksUpdateBodyConclusion :: TimedOut . to_string () ,]) , | s | types :: ChecksUpdateBodyConclusion :: try_from (s) . unwrap ())) . help ("**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.")) . arg (clap :: Arg :: new ("details-url") . long ("details-url") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The URL of the integrator's site that has the full details of the check.")) . arg (clap :: Arg :: new ("external-id") . long ("external-id") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A reference for the run on the integrator's system.")) . arg (clap :: Arg :: new ("name") . long ("name") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the check. For example, \"code-coverage\".")) . arg (clap :: Arg :: new ("started-at") . long ("started-at") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("status") . long ("status") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ChecksUpdateBodyStatus :: Queued . to_string () , types :: ChecksUpdateBodyStatus :: InProgress . to_string () , types :: ChecksUpdateBodyStatus :: Completed . to_string () ,]) , | s | types :: ChecksUpdateBodyStatus :: try_from (s) . unwrap ())) . help ("The current status.")) . about ("Update a check run\n\n**Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.\n\nUpdates a check run for a specific commit in a repository. Your GitHub App must have the `checks:write` permission to edit check runs.")
    }

    pub fn cli_checks_list_annotations() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("check-run-id")
                    .long("check-run-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the check run."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List check run annotations\n\nLists annotations for a check run using the \
                 annotation `id`. GitHub Apps must have the `checks:read` permission on a private \
                 repository or pull access to a public repository to get annotations for a check \
                 run. OAuth Apps and authenticated users must have the `repo` scope to get \
                 annotations for a check run in a private repository.",
            )
    }

    pub fn cli_checks_rerequest_run() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("check-run-id") . long ("check-run-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the check run.")) . about ("Rerequest a check run\n\nTriggers GitHub to rerequest an existing check run, without pushing new code to a repository. This endpoint will trigger the [`check_run` webhook](https://docs.github.com/webhooks/event-payloads/#check_run) event with the action `rerequested`. When a check run is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.\n\nTo rerequest a check run, your GitHub App must have the `checks:read` permission on a private repository or pull access to a public repository.")
    }

    pub fn cli_checks_create_suite() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("head-sha") . long ("head-sha") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The sha of the head commit.")) . about ("Create a check suite\n\n**Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.\n\nBy default, check suites are automatically created when you create a [check run](https://docs.github.com/rest/reference/checks#check-runs). You only need to use this endpoint for manually creating check suites when you've disabled automatic creation using \"[Update repository preferences for check suites](https://docs.github.com/rest/reference/checks#update-repository-preferences-for-check-suites)\". Your GitHub App must have the `checks:write` permission to create check suites.")
    }

    pub fn cli_checks_set_suites_preferences() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Update repository preferences for check suites\n\nChanges the default automatic flow when creating check suites. By default, a check suite is automatically created each time code is pushed to a repository. When you disable the automatic creation of check suites, you can manually [Create a check suite](https://docs.github.com/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository to set preferences for check suites.")
    }

    pub fn cli_checks_get_suite() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("check-suite-id")
                    .long("check-suite-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the check suite."),
            )
            .about(
                "Get a check suite\n\n**Note:** The Checks API only looks for pushes in the \
                 repository where the check suite or check run were created. Pushes to a branch \
                 in a forked repository are not detected and return an empty `pull_requests` \
                 array and a `null` value for `head_branch`.\n\nGets a single check suite using \
                 its `id`. GitHub Apps must have the `checks:read` permission on a private \
                 repository or pull access to a public repository to get check suites. OAuth Apps \
                 and authenticated users must have the `repo` scope to get check suites in a \
                 private repository.",
            )
    }

    pub fn cli_checks_list_for_suite() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("check-suite-id")
                    .long("check-suite-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the check suite."),
            )
            .arg(
                clap::Arg::new("check-name")
                    .long("check-name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Returns check runs with the specified `name`."),
            )
            .arg(
                clap::Arg::new("filter")
                    .long("filter")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ChecksListForSuiteFilter::Latest.to_string(),
                            types::ChecksListForSuiteFilter::All.to_string(),
                        ]),
                        |s| types::ChecksListForSuiteFilter::try_from(s).unwrap(),
                    ))
                    .help(
                        "Filters check runs by their `completed_at` timestamp. `latest` returns \
                         the most recent check runs.",
                    ),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("status")
                    .long("status")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ChecksListForSuiteStatus::Queued.to_string(),
                            types::ChecksListForSuiteStatus::InProgress.to_string(),
                            types::ChecksListForSuiteStatus::Completed.to_string(),
                        ]),
                        |s| types::ChecksListForSuiteStatus::try_from(s).unwrap(),
                    ))
                    .help("Returns check runs with the specified `status`."),
            )
            .about(
                "List check runs in a check suite\n\n**Note:** The Checks API only looks for \
                 pushes in the repository where the check suite or check run were created. Pushes \
                 to a branch in a forked repository are not detected and return an empty \
                 `pull_requests` array.\n\nLists check runs for a check suite using its `id`. \
                 GitHub Apps must have the `checks:read` permission on a private repository or \
                 pull access to a public repository to get check runs. OAuth Apps and \
                 authenticated users must have the `repo` scope to get check runs in a private \
                 repository.",
            )
    }

    pub fn cli_checks_rerequest_suite() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("check-suite-id") . long ("check-suite-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the check suite.")) . about ("Rerequest a check suite\n\nTriggers GitHub to rerequest an existing check suite, without pushing new code to a repository. This endpoint will trigger the [`check_suite` webhook](https://docs.github.com/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.\n\nTo rerequest a check suite, your GitHub App must have the `checks:read` permission on a private repository or pull access to a public repository.")
    }

    pub fn cli_code_scanning_list_alerts_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("direction")
                    .long("direction")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::CodeScanningListAlertsForRepoDirection::Asc.to_string(),
                            types::CodeScanningListAlertsForRepoDirection::Desc.to_string(),
                        ]),
                        |s| types::CodeScanningListAlertsForRepoDirection::try_from(s).unwrap(),
                    ))
                    .help("The direction to sort the results by."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(false)
                    .value_parser(clap::value_parser!(types::CodeScanningRef))
                    .help(
                        "The Git reference for the results you want to list. The `ref` for a \
                         branch can be formatted either as `refs/heads/<branch name>` or simply \
                         `<branch name>`. To reference a pull request use \
                         `refs/pull/<number>/merge`.",
                    ),
            )
            .arg(
                clap::Arg::new("severity")
                    .long("severity")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::CodeScanningAlertSeverity::Critical.to_string(),
                            types::CodeScanningAlertSeverity::High.to_string(),
                            types::CodeScanningAlertSeverity::Medium.to_string(),
                            types::CodeScanningAlertSeverity::Low.to_string(),
                            types::CodeScanningAlertSeverity::Warning.to_string(),
                            types::CodeScanningAlertSeverity::Note.to_string(),
                            types::CodeScanningAlertSeverity::Error.to_string(),
                        ]),
                        |s| types::CodeScanningAlertSeverity::try_from(s).unwrap(),
                    ))
                    .help(
                        "If specified, only code scanning alerts with this severity will be \
                         returned.",
                    ),
            )
            .arg(
                clap::Arg::new("sort")
                    .long("sort")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::CodeScanningListAlertsForRepoSort::Created.to_string(),
                            types::CodeScanningListAlertsForRepoSort::Updated.to_string(),
                        ]),
                        |s| types::CodeScanningListAlertsForRepoSort::try_from(s).unwrap(),
                    ))
                    .help("The property by which to sort the results."),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::CodeScanningAlertState::Open.to_string(),
                            types::CodeScanningAlertState::Closed.to_string(),
                            types::CodeScanningAlertState::Dismissed.to_string(),
                            types::CodeScanningAlertState::Fixed.to_string(),
                        ]),
                        |s| types::CodeScanningAlertState::try_from(s).unwrap(),
                    ))
                    .help(
                        "If specified, only code scanning alerts with this state will be returned.",
                    ),
            )
            .arg(
                clap::Arg::new("tool-guid")
                    .long("tool-guid")
                    .required(false)
                    .value_parser(clap::value_parser!(types::CodeScanningAnalysisToolGuid))
                    .help(
                        "The GUID of a code scanning tool. Only results by this tool will be \
                         listed. Note that some code scanning tools may not include a GUID in \
                         their analysis data. You can specify the tool by using either \
                         `tool_guid` or `tool_name`, but not both.",
                    ),
            )
            .arg(
                clap::Arg::new("tool-name")
                    .long("tool-name")
                    .required(false)
                    .value_parser(clap::value_parser!(types::CodeScanningAnalysisToolName))
                    .help(
                        "The name of a code scanning tool. Only results by this tool will be \
                         listed. You can specify the tool by using either `tool_name` or \
                         `tool_guid`, but not both.",
                    ),
            )
            .about(
                "List code scanning alerts for a repository\n\nLists code scanning alerts.\n\nTo \
                 use this endpoint, you must use an access token with the `security_events` scope \
                 or, for alerts from public repositories only, an access token with the \
                 `public_repo` scope.\n\nGitHub Apps must have the `security_events` \
                 read\npermission to use this endpoint.\n\nThe response includes a \
                 `most_recent_instance` object.\nThis provides details of the most recent \
                 instance of this alert\nfor the default branch (or for the specified Git \
                 reference if you used `ref` in the request).",
            )
    }

    pub fn cli_code_scanning_get_alert() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("alert-number")
                    .long("alert-number")
                    .required(true)
                    .value_parser(clap::value_parser!(types::AlertNumber))
                    .help(
                        "The number that identifies an alert. You can find this at the end of the \
                         URL for a code scanning alert within GitHub, and in the `number` field \
                         in the response from the `GET \
                         /repos/{owner}/{repo}/code-scanning/alerts` operation.",
                    ),
            )
            .about(
                "Get a code scanning alert\n\nGets a single code scanning alert. You must use an \
                 access token with the `security_events` scope to use this endpoint with private \
                 repos, the `public_repo` scope also grants permission to read security events on \
                 public repos only. GitHub Apps must have the `security_events` read permission \
                 to use this endpoint.",
            )
    }

    pub fn cli_code_scanning_update_alert() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("alert-number")
                    .long("alert-number")
                    .required(true)
                    .value_parser(clap::value_parser!(types::AlertNumber))
                    .help(
                        "The number that identifies an alert. You can find this at the end of the \
                         URL for a code scanning alert within GitHub, and in the `number` field \
                         in the response from the `GET \
                         /repos/{owner}/{repo}/code-scanning/alerts` operation.",
                    ),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::CodeScanningAlertSetState::Open.to_string(),
                            types::CodeScanningAlertSetState::Dismissed.to_string(),
                        ]),
                        |s| types::CodeScanningAlertSetState::try_from(s).unwrap(),
                    )),
            )
            .about(
                "Update a code scanning alert\n\nUpdates the status of a single code scanning \
                 alert. You must use an access token with the `security_events` scope to use this \
                 endpoint with private repositories. You can also use tokens with the \
                 `public_repo` scope for public repositories only. GitHub Apps must have the \
                 `security_events` write permission to use this endpoint.",
            )
    }

    pub fn cli_code_scanning_list_alert_instances() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("alert-number")
                    .long("alert-number")
                    .required(true)
                    .value_parser(clap::value_parser!(types::AlertNumber))
                    .help(
                        "The number that identifies an alert. You can find this at the end of the \
                         URL for a code scanning alert within GitHub, and in the `number` field \
                         in the response from the `GET \
                         /repos/{owner}/{repo}/code-scanning/alerts` operation.",
                    ),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(false)
                    .value_parser(clap::value_parser!(types::CodeScanningRef))
                    .help(
                        "The Git reference for the results you want to list. The `ref` for a \
                         branch can be formatted either as `refs/heads/<branch name>` or simply \
                         `<branch name>`. To reference a pull request use \
                         `refs/pull/<number>/merge`.",
                    ),
            )
            .about(
                "List instances of a code scanning alert\n\nLists all instances of the specified \
                 code scanning alert.\nYou must use an access token with the `security_events` \
                 scope to use this endpoint with private repos,\nthe `public_repo` scope also \
                 grants permission to read security events on public repos only.\nGitHub Apps \
                 must have the `security_events` read permission to use this endpoint.",
            )
    }

    pub fn cli_code_scanning_list_recent_analyses() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("direction")
                    .long("direction")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::CodeScanningListRecentAnalysesDirection::Asc.to_string(),
                            types::CodeScanningListRecentAnalysesDirection::Desc.to_string(),
                        ]),
                        |s| types::CodeScanningListRecentAnalysesDirection::try_from(s).unwrap(),
                    ))
                    .help("The direction to sort the results by."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(false)
                    .value_parser(clap::value_parser!(types::CodeScanningRef))
                    .help(
                        "The Git reference for the analyses you want to list. The `ref` for a \
                         branch can be formatted either as `refs/heads/<branch name>` or simply \
                         `<branch name>`. To reference a pull request use \
                         `refs/pull/<number>/merge`.",
                    ),
            )
            .arg(
                clap::Arg::new("sarif-id")
                    .long("sarif-id")
                    .required(false)
                    .value_parser(clap::value_parser!(types::CodeScanningAnalysisSarifId))
                    .help("Filter analyses belonging to the same SARIF upload."),
            )
            .arg(
                clap::Arg::new("sort")
                    .long("sort")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::CodeScanningListRecentAnalysesSort::Created.to_string(),
                        ]),
                        |s| types::CodeScanningListRecentAnalysesSort::try_from(s).unwrap(),
                    ))
                    .help("The property by which to sort the results."),
            )
            .arg(
                clap::Arg::new("tool-guid")
                    .long("tool-guid")
                    .required(false)
                    .value_parser(clap::value_parser!(types::CodeScanningAnalysisToolGuid))
                    .help(
                        "The GUID of a code scanning tool. Only results by this tool will be \
                         listed. Note that some code scanning tools may not include a GUID in \
                         their analysis data. You can specify the tool by using either \
                         `tool_guid` or `tool_name`, but not both.",
                    ),
            )
            .arg(
                clap::Arg::new("tool-name")
                    .long("tool-name")
                    .required(false)
                    .value_parser(clap::value_parser!(types::CodeScanningAnalysisToolName))
                    .help(
                        "The name of a code scanning tool. Only results by this tool will be \
                         listed. You can specify the tool by using either `tool_name` or \
                         `tool_guid`, but not both.",
                    ),
            )
            .about(
                "List code scanning analyses for a repository\n\nLists the details of all code \
                 scanning analyses for a repository,\nstarting with the most recent.\nThe \
                 response is paginated and you can use the `page` and `per_page` parameters\nto \
                 list the analyses you're interested in.\nBy default 30 analyses are listed per \
                 page.\n\nThe `rules_count` field in the response give the number of rules\nthat \
                 were run in the analysis.\nFor very old analyses this data is not \
                 available,\nand `0` is returned in this field.\n\nYou must use an access token \
                 with the `security_events` scope to use this endpoint with private repos,\nthe \
                 `public_repo` scope also grants permission to read security events on public \
                 repos only.\nGitHub Apps must have the `security_events` read permission to use \
                 this endpoint.\n\n**Deprecation notice**:\nThe `tool_name` field is deprecated \
                 and will, in future, not be included in the response for this endpoint. The \
                 example response reflects this change. The tool name can now be found inside the \
                 `tool` field.",
            )
    }

    pub fn cli_code_scanning_get_analysis() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("analysis-id") . long ("analysis-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation.")) . about ("Get a code scanning analysis for a repository\n\nGets a specified code scanning analysis for a repository.\nYou must use an access token with the `security_events` scope to use this endpoint with private repos,\nthe `public_repo` scope also grants permission to read security events on public repos only.\nGitHub Apps must have the `security_events` read permission to use this endpoint.\n\nThe default JSON response contains fields that describe the analysis.\nThis includes the Git reference and commit SHA to which the analysis relates,\nthe datetime of the analysis, the name of the code scanning tool,\nand the number of alerts.\n\nThe `rules_count` field in the default response give the number of rules\nthat were run in the analysis.\nFor very old analyses this data is not available,\nand `0` is returned in this field.\n\nIf you use the Accept header `application/sarif+json`,\nthe response contains the analysis data that was uploaded.\nThis is formatted as\n[SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html).")
    }

    pub fn cli_code_scanning_delete_analysis() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("analysis-id")
                    .long("analysis-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help(
                        "The ID of the analysis, as returned from the `GET \
                         /repos/{owner}/{repo}/code-scanning/analyses` operation.",
                    ),
            )
            .arg(
                clap::Arg::new("confirm-delete")
                    .long("confirm-delete")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "Allow deletion if the specified analysis is the last in a set. If you \
                         attempt to delete the final analysis in a set without setting this \
                         parameter to `true`, you'll get a 400 response with the message: \
                         `Analysis is last of its type and deletion may result in the loss of \
                         historical alert data. Please specify confirm_delete.`",
                    ),
            )
            .about(
                "Delete a code scanning analysis from a repository\n\nDeletes a specified code \
                 scanning analysis from a repository. For\nprivate repositories, you must use an \
                 access token with the `repo` scope. For public repositories,\nyou must use an \
                 access token with `public_repo` scope.\nGitHub Apps must have the \
                 `security_events` write permission to use this endpoint.\n\nYou can delete one \
                 analysis at a time.\nTo delete a series of analyses, start with the most recent \
                 analysis and work backwards.\nConceptually, the process is similar to the undo \
                 function in a text editor.\n\nWhen you list the analyses for a repository,\none \
                 or more will be identified as deletable in the response:\n\n```\n\"deletable\": \
                 true\n```\n\nAn analysis is deletable when it's the most recent in a set of \
                 analyses.\nTypically, a repository will have multiple sets of analyses\nfor each \
                 enabled code scanning tool,\nwhere a set is determined by a unique combination \
                 of analysis values:\n\n* `ref`\n* `tool`\n* `category`\n\nIf you attempt to \
                 delete an analysis that is not the most recent in a set,\nyou'll get a 400 \
                 response with the message:\n\n```\nAnalysis specified is not \
                 deletable.\n```\n\nThe response from a successful `DELETE` operation provides \
                 you with\ntwo alternative URLs for deleting the next analysis in the \
                 set:\n`next_analysis_url` and `confirm_delete_url`.\nUse the `next_analysis_url` \
                 URL if you want to avoid accidentally deleting the final analysis\nin a set. \
                 This is a useful option if you want to preserve at least one analysis\nfor the \
                 specified tool in your repository.\nUse the `confirm_delete_url` URL if you are \
                 content to remove all analyses for a tool.\nWhen you delete the last analysis in \
                 a set, the value of `next_analysis_url` and `confirm_delete_url`\nin the 200 \
                 response is `null`.\n\nAs an example of the deletion process,\nlet's imagine \
                 that you added a workflow that configured a particular code scanning tool\nto \
                 analyze the code in a repository. This tool has added 15 analyses:\n10 on the \
                 default branch, and another 5 on a topic branch.\nYou therefore have two \
                 separate sets of analyses for this tool.\nYou've now decided that you want to \
                 remove all of the analyses for the tool.\nTo do this you must make 15 separate \
                 deletion requests.\nTo start, you must find an analysis that's identified as \
                 deletable.\nEach set of analyses always has one that's identified as \
                 deletable.\nHaving found the deletable analysis for one of the two sets,\ndelete \
                 this analysis and then continue deleting the next analysis in the set until \
                 they're all deleted.\nThen repeat the process for the second set.\nThe procedure \
                 therefore consists of a nested loop:\n\n**Outer loop**:\n* List the analyses for \
                 the repository, filtered by tool.\n* Parse this list to find a deletable \
                 analysis. If found:\n\n  **Inner loop**:\n  * Delete the identified analysis.\n  \
                 * Parse the response for the value of `confirm_delete_url` and, if found, use \
                 this in the next iteration.\n\nThe above process assumes that you want to remove \
                 all trace of the tool's analyses from the GitHub user interface, for the \
                 specified repository, and it therefore uses the `confirm_delete_url` value. \
                 Alternatively, you could use the `next_analysis_url` value, which would leave \
                 the last analysis in each set undeleted to avoid removing a tool's analysis \
                 entirely.",
            )
    }

    pub fn cli_code_scanning_list_codeql_databases() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "List CodeQL databases for a repository\n\nLists the CodeQL databases that are \
                 available in a repository.\n\nFor private repositories, you must use an access \
                 token with the `security_events` scope.\nFor public repositories, you can use \
                 tokens with the `security_events` or `public_repo` scope.\nGitHub Apps must have \
                 the `contents` read permission to use this endpoint.",
            )
    }

    pub fn cli_code_scanning_get_codeql_database() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("language") . long ("language") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The language of the CodeQL database.")) . about ("Get a CodeQL database for a repository\n\nGets a CodeQL database for a language in a repository.\n\nBy default this endpoint returns JSON metadata about the CodeQL database. To\ndownload the CodeQL database binary content, set the `Accept` header of the request\nto [`application/zip`](https://docs.github.com/rest/overview/media-types), and make sure\nyour HTTP client is configured to follow redirects or use the `Location` header\nto make a second request to get the redirect URL.\n\nFor private repositories, you must use an access token with the `security_events` scope.\nFor public repositories, you can use tokens with the `security_events` or `public_repo` scope.\nGitHub Apps must have the `contents` read permission to use this endpoint.")
    }

    pub fn cli_code_scanning_get_default_setup() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get a code scanning default setup configuration\n\nGets a code scanning default \
                 setup configuration.\nYou must use an access token with the `repo` scope to use \
                 this endpoint with private repos or the `public_repo`\nscope for public repos. \
                 GitHub Apps must have the `repo` write permission to use this endpoint.",
            )
    }

    pub fn cli_code_scanning_update_default_setup() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("query-suite")
                    .long("query-suite")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::CodeScanningDefaultSetupUpdateQuerySuite::Default.to_string(),
                            types::CodeScanningDefaultSetupUpdateQuerySuite::Extended.to_string(),
                        ]),
                        |s| types::CodeScanningDefaultSetupUpdateQuerySuite::try_from(s).unwrap(),
                    ))
                    .help("CodeQL query suite to be used."),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::CodeScanningDefaultSetupUpdateState::Configured.to_string(),
                            types::CodeScanningDefaultSetupUpdateState::NotConfigured.to_string(),
                        ]),
                        |s| types::CodeScanningDefaultSetupUpdateState::try_from(s).unwrap(),
                    ))
                    .help("Whether code scanning default setup has been configured or not."),
            )
            .about(
                "Update a code scanning default setup configuration\n\nUpdates a code scanning \
                 default setup configuration.\nYou must use an access token with the `repo` scope \
                 to use this endpoint with private repos or the `public_repo`\nscope for public \
                 repos. GitHub Apps must have the `repo` write permission to use this endpoint.",
            )
    }

    pub fn cli_code_scanning_upload_sarif() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("checkout-uri") . long ("checkout-uri") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The base directory used in the analysis, as it appears in the SARIF file.\nThis property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository.")) . arg (clap :: Arg :: new ("commit-sha") . long ("commit-sha") . required (true) . value_parser (clap :: value_parser ! (types :: CodeScanningAnalysisCommitSha))) . arg (clap :: Arg :: new ("ref") . long ("ref") . required (true) . value_parser (clap :: value_parser ! (types :: CodeScanningRef))) . arg (clap :: Arg :: new ("sarif") . long ("sarif") . required (true) . value_parser (clap :: value_parser ! (types :: CodeScanningAnalysisSarifFile))) . arg (clap :: Arg :: new ("started-at") . long ("started-at") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("tool-name") . long ("tool-name") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to \"API\". If the uploaded SARIF contains a tool GUID, this will be available for filtering using the `tool_guid` parameter of operations such as `GET /repos/{owner}/{repo}/code-scanning/alerts`.")) . arg (clap :: Arg :: new ("validate") . long ("validate") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether the SARIF file will be validated according to the code scanning specifications.\nThis parameter is intended to help integrators ensure that the uploaded SARIF files are correctly rendered by code scanning.")) . about ("Upload an analysis as SARIF data\n\nUploads SARIF data containing the results of a code scanning analysis to make the results available in a repository. You must use an access token with the `security_events` scope to use this endpoint for private repositories. You can also use tokens with the `public_repo` scope for public repositories only. GitHub Apps must have the `security_events` write permission to use this endpoint.\n\nThere are two places where you can upload code scanning results.\n - If you upload to a pull request, for example `--ref refs/pull/42/merge` or `--ref refs/pull/42/head`, then the results appear as alerts in a pull request check. For more information, see \"[Triaging code scanning alerts in pull requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests).\"\n - If you upload to a branch, for example `--ref refs/heads/my-branch`, then the results appear in the **Security** tab for your repository. For more information, see \"[Managing code scanning alerts for your repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository).\"\n\nYou must compress the SARIF-formatted analysis data that you want to upload, using `gzip`, and then encode it as a Base64 format string. For example:\n\n```\ngzip -c analysis-data.sarif | base64 -w0\n```\n<br>\nSARIF upload supports a maximum number of entries per the following data objects, and an analysis will be rejected if any of these objects is above its maximum value. For some objects, there are additional values over which the entries will be ignored while keeping the most important entries whenever applicable.\nTo get the most out of your analysis when it includes data above the supported limits, try to optimize the analysis configuration. For example, for the CodeQL tool, identify and remove the most noisy queries.\n\n\n| **SARIF data**                   | **Maximum values** | **Additional limits**                                                            |\n|----------------------------------|:------------------:|----------------------------------------------------------------------------------|\n| Runs per file                    |         20         |                                                                                  |\n| Results per run                  |       25,000       | Only the top 5,000 results will be included, prioritized by severity.            |\n| Rules per run                    |       25,000       |                                                                                  |\n| Tool extensions per run          |        100         |                                                                                  |\n| Thread Flow Locations per result |       10,000       | Only the top 1,000 Thread Flow Locations will be included, using prioritization. |\n| Location per result\t             |       1,000        | Only 100 locations will be included.                                             |\n| Tags per rule\t                   |         20         | Only 10 tags will be included.                                                   |\n\n\nThe `202 Accepted` response includes an `id` value.\nYou can use this ID to check the status of the upload by using it in the `/sarifs/{sarif_id}` endpoint.\nFor more information, see \"[Get information about a SARIF upload](/rest/reference/code-scanning#get-information-about-a-sarif-upload).\"")
    }

    pub fn cli_code_scanning_get_sarif() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("sarif-id")
                    .long("sarif-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The SARIF ID obtained after uploading."),
            )
            .about(
                "Get information about a SARIF upload\n\nGets information about a SARIF upload, \
                 including the status and the URL of the analysis that was uploaded so that you \
                 can retrieve details of the analysis. For more information, see \"[Get a code \
                 scanning analysis for a \
                 repository](/rest/reference/code-scanning#\
                 get-a-code-scanning-analysis-for-a-repository).\" You must use an access token \
                 with the `security_events` scope to use this endpoint with private repos, the \
                 `public_repo` scope also grants permission to read security events on public \
                 repos only. GitHub Apps must have the `security_events` read permission to use \
                 this endpoint.",
            )
    }

    pub fn cli_repos_codeowners_errors() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("ref") . long ("ref") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)")) . about ("List CODEOWNERS errors\n\nList any syntax errors that are detected in the CODEOWNERS\nfile.\n\nFor more information about the correct CODEOWNERS syntax,\nsee \"[About code owners](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners).\"")
    }

    pub fn cli_codespaces_list_in_repository_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List codespaces in a repository for the authenticated user\n\nLists the \
                 codespaces associated to a specified repository and the authenticated \
                 user.\n\nYou must authenticate using an access token with the `codespace` scope \
                 to use this endpoint.\n\nGitHub Apps must have read access to the `codespaces` \
                 repository permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_create_with_repo_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Create a codespace in a repository\n\nCreates a codespace owned by the \
                 authenticated user in the specified repository.\n\nYou must authenticate using \
                 an access token with the `codespace` scope to use this endpoint.\n\nGitHub Apps \
                 must have write access to the `codespaces` repository permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_codespaces_list_devcontainers_in_repository_for_authenticated_user() -> clap::Command
    {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List devcontainer configurations in a repository for the authenticated \
                 user\n\nLists the devcontainer.json files associated with a specified repository \
                 and the authenticated user. These files\nspecify launchpoint configurations for \
                 codespaces created within the repository.\n\nYou must authenticate using an \
                 access token with the `codespace` scope to use this endpoint.\n\nGitHub Apps \
                 must have read access to the `codespaces_metadata` repository permission to use \
                 this endpoint.",
            )
    }

    pub fn cli_codespaces_repo_machines_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("client-ip")
                    .long("client-ip")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("IP for location auto-detection when proxying a request"),
            )
            .arg(
                clap::Arg::new("location")
                    .long("location")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The location to check for available machines. Assigned by IP if not \
                         provided.",
                    ),
            )
            .about(
                "List available machine types for a repository\n\nList the machine types \
                 available for a given repository based on its configuration.\n\nYou must \
                 authenticate using an access token with the `codespace` scope to use this \
                 endpoint.\n\nGitHub Apps must have write access to the `codespaces_metadata` \
                 repository permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_pre_flight_with_repo_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("client-ip")
                    .long("client-ip")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "An alternative IP for default location auto-detection, such as when \
                         proxying a request.",
                    ),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The branch or commit to check for a default devcontainer path. If not \
                         specified, the default branch will be checked.",
                    ),
            )
            .about(
                "Get default attributes for a codespace\n\nGets the default attributes for \
                 codespaces created by the user with the repository.\n\nYou must authenticate \
                 using an access token with the `codespace` scope to use this endpoint.\n\nGitHub \
                 Apps must have write access to the `codespaces` repository permission to use \
                 this endpoint.",
            )
    }

    pub fn cli_codespaces_list_repo_secrets() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repository secrets\n\nLists all secrets available in a repository without \
                 revealing their encrypted values. You must authenticate using an access token \
                 with the `repo` scope to use this endpoint. GitHub Apps must have write access \
                 to the `codespaces_secrets` repository permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_get_repo_public_key() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get a repository public key\n\nGets your public key, which you need to encrypt \
                 secrets. You need to encrypt a secret before you can create or update secrets. \
                 Anyone with read access to the repository can use this endpoint. If the \
                 repository is private you must use an access token with the `repo` scope. GitHub \
                 Apps must have write access to the `codespaces_secrets` repository permission to \
                 use this endpoint.",
            )
    }

    pub fn cli_codespaces_get_repo_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Get a repository secret\n\nGets a single repository secret without revealing its \
                 encrypted value. You must authenticate using an access token with the `repo` \
                 scope to use this endpoint. GitHub Apps must have write access to the \
                 `codespaces_secrets` repository permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_create_or_update_repo_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("encrypted-value") . long ("encrypted-value") . required (false) . value_parser (clap :: value_parser ! (types :: CodespacesCreateOrUpdateRepoSecretBodyEncryptedValue)) . help ("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/reference/codespaces#get-a-repository-public-key) endpoint.")) . arg (clap :: Arg :: new ("key-id") . long ("key-id") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("ID of the key you used to encrypt the secret.")) . about ("Create or update a repository secret\n\nCreates or updates a repository secret with an encrypted value. Encrypt your secret using\n[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access\ntoken with the `repo` scope to use this endpoint. GitHub Apps must have write access to the `codespaces_secrets`\nrepository permission to use this endpoint.\n\n#### Example of encrypting a secret using Node.js\n\nEncrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.\n\n```\nconst sodium = require('libsodium-wrappers')\nconst secret = 'plain-text-secret' // replace with the secret you want to encrypt\nconst key = 'base64-encoded-public-key' // replace with the Base64 encoded public key\n\n//Check if libsodium is ready and then proceed.\nsodium.ready.then(() => {\n  // Convert Secret & Base64 key to Uint8Array.\n  let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)\n  let binsec = sodium.from_string(secret)\n\n  //Encrypt the secret using LibSodium\n  let encBytes = sodium.crypto_box_seal(binsec, binkey)\n\n  // Convert encrypted Uint8Array to Base64\n  let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)\n\n  console.log(output)\n});\n```\n\n#### Example of encrypting a secret using Python\n\nEncrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.\n\n```\nfrom base64 import b64encode\nfrom nacl import encoding, public\n\ndef encrypt(public_key: str, secret_value: str) -> str:\n  \"\"\"Encrypt a Unicode string using the public key.\"\"\"\n  public_key = public.PublicKey(public_key.encode(\"utf-8\"), encoding.Base64Encoder())\n  sealed_box = public.SealedBox(public_key)\n  encrypted = sealed_box.encrypt(secret_value.encode(\"utf-8\"))\n  return b64encode(encrypted).decode(\"utf-8\")\n```\n\n#### Example of encrypting a secret using C#\n\nEncrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.\n\n```\nvar secretValue = System.Text.Encoding.UTF8.GetBytes(\"mySecret\");\nvar publicKey = Convert.FromBase64String(\"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=\");\n\nvar sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);\n\nConsole.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));\n```\n\n#### Example of encrypting a secret using Ruby\n\nEncrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.\n\n```ruby\nrequire \"rbnacl\"\nrequire \"base64\"\n\nkey = Base64.decode64(\"+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=\")\npublic_key = RbNaCl::PublicKey.new(key)\n\nbox = RbNaCl::Boxes::Sealed.from_public_key(public_key)\nencrypted_secret = box.encrypt(\"my_secret\")\n\n# Print the base64 encoded secret\nputs Base64.strict_encode64(encrypted_secret)\n```")
    }

    pub fn cli_codespaces_delete_repo_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Delete a repository secret\n\nDeletes a secret in a repository using the secret \
                 name. You must authenticate using an access token with the `repo` scope to use \
                 this endpoint. GitHub Apps must have write access to the `codespaces_secrets` \
                 repository permission to use this endpoint.",
            )
    }

    pub fn cli_repos_list_collaborators() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("affiliation")
                    .long("affiliation")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposListCollaboratorsAffiliation::Outside.to_string(),
                            types::ReposListCollaboratorsAffiliation::Direct.to_string(),
                            types::ReposListCollaboratorsAffiliation::All.to_string(),
                        ]),
                        |s| types::ReposListCollaboratorsAffiliation::try_from(s).unwrap(),
                    ))
                    .help(
                        "Filter collaborators returned by their affiliation. `outside` means all \
                         outside collaborators of an organization-owned repository. `direct` \
                         means all collaborators with permissions to an organization-owned \
                         repository, regardless of organization membership status. `all` means \
                         all collaborators the authenticated user can see.",
                    ),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("permission")
                    .long("permission")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposListCollaboratorsPermission::Pull.to_string(),
                            types::ReposListCollaboratorsPermission::Triage.to_string(),
                            types::ReposListCollaboratorsPermission::Push.to_string(),
                            types::ReposListCollaboratorsPermission::Maintain.to_string(),
                            types::ReposListCollaboratorsPermission::Admin.to_string(),
                        ]),
                        |s| types::ReposListCollaboratorsPermission::try_from(s).unwrap(),
                    ))
                    .help(
                        "Filter collaborators by the permissions they have on the repository. If \
                         not specified, all collaborators will be returned.",
                    ),
            )
            .about(
                "List repository collaborators\n\nFor organization-owned repositories, the list \
                 of collaborators includes outside collaborators, organization members that are \
                 direct collaborators, organization members with access through team memberships, \
                 organization members with access through default organization permissions, and \
                 organization owners.\nOrganization members with write, maintain, or admin \
                 privileges on the organization-owned repository can use this endpoint.\n\nTeam \
                 members will include the members of child teams.\n\nYou must authenticate using \
                 an access token with the `read:org` and `repo` scopes with push access to use \
                 this\nendpoint. GitHub Apps must have the `members` organization permission and \
                 `metadata` repository permission to use this\nendpoint.",
            )
    }

    pub fn cli_repos_check_collaborator() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Check if a user is a repository collaborator\n\nFor organization-owned \
                 repositories, the list of collaborators includes outside collaborators, \
                 organization members that are direct collaborators, organization members with \
                 access through team memberships, organization members with access through \
                 default organization permissions, and organization owners.\n\nTeam members will \
                 include the members of child teams.\n\nYou must authenticate using an access \
                 token with the `read:org` and `repo` scopes with push access to use \
                 this\nendpoint. GitHub Apps must have the `members` organization permission and \
                 `metadata` repository permission to use this\nendpoint.",
            )
    }

    pub fn cli_repos_add_collaborator() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("permission") . long ("permission") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any.")) . about ("Add a repository collaborator\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.\n\nAdding an outside collaborator may be restricted by enterprise administrators. For more information, see \"[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories).\"\n\nFor more information on permission levels, see \"[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)\". There are restrictions on which permissions can be granted to organization members when an organization base role is in place. In this case, the permission being given must be equal to or higher than the org base permission. Otherwise, the request will fail with:\n\n```\nCannot assign {member} permission of {role name}\n```\n\nNote that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"\n\nThe invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [repository invitations API endpoints](https://docs.github.com/rest/reference/repos#invitations).\n\n**Updating an existing collaborator's permission level**\n\nThe endpoint can also be used to change the permissions of an existing collaborator without first removing and re-adding the collaborator. To change the permissions, use the same endpoint and pass a different `permission` parameter. The response will be a `204`, with no other indication that the permission level changed.\n\n**Rate limits**\n\nYou are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.")
    }

    pub fn cli_repos_remove_collaborator() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about("Remove a repository collaborator")
    }

    pub fn cli_repos_get_collaborator_permission_level() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Get repository permissions for a user\n\nChecks the repository permission of a \
                 collaborator. The possible repository permissions are `admin`, `write`, `read`, \
                 and `none`.",
            )
    }

    pub fn cli_repos_list_commit_comments_for_repo() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List commit comments for a repository\n\nCommit Comments use [these custom media types](https://docs.github.com/rest/reference/repos#custom-media-types). You can read more about the use of media types in the API [here](https://docs.github.com/rest/overview/media-types/).\n\nComments are ordered by ascending ID.")
    }

    pub fn cli_repos_get_commit_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .about("Get a commit comment")
    }

    pub fn cli_repos_delete_commit_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .about("Delete a commit comment")
    }

    pub fn cli_repos_update_commit_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .arg(
                clap::Arg::new("body")
                    .long("body")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The contents of the comment"),
            )
            .about("Update a commit comment")
    }

    pub fn cli_reactions_list_for_commit_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("comment-id") . long ("comment-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the comment.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsListForCommitCommentContent :: plus1 . to_string () , types :: ReactionsListForCommitCommentContent :: minus1 . to_string () , types :: ReactionsListForCommitCommentContent :: Laugh . to_string () , types :: ReactionsListForCommitCommentContent :: Confused . to_string () , types :: ReactionsListForCommitCommentContent :: Heart . to_string () , types :: ReactionsListForCommitCommentContent :: Hooray . to_string () , types :: ReactionsListForCommitCommentContent :: Rocket . to_string () , types :: ReactionsListForCommitCommentContent :: Eyes . to_string () ,]) , | s | types :: ReactionsListForCommitCommentContent :: try_from (s) . unwrap ())) . help ("Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a commit comment.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List reactions for a commit comment\n\nList the reactions to a [commit comment](https://docs.github.com/rest/reference/repos#comments).")
    }

    pub fn cli_reactions_create_for_commit_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("comment-id") . long ("comment-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the comment.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsCreateForCommitCommentBodyContent :: plus1 . to_string () , types :: ReactionsCreateForCommitCommentBodyContent :: minus1 . to_string () , types :: ReactionsCreateForCommitCommentBodyContent :: Laugh . to_string () , types :: ReactionsCreateForCommitCommentBodyContent :: Confused . to_string () , types :: ReactionsCreateForCommitCommentBodyContent :: Heart . to_string () , types :: ReactionsCreateForCommitCommentBodyContent :: Hooray . to_string () , types :: ReactionsCreateForCommitCommentBodyContent :: Rocket . to_string () , types :: ReactionsCreateForCommitCommentBodyContent :: Eyes . to_string () ,]) , | s | types :: ReactionsCreateForCommitCommentBodyContent :: try_from (s) . unwrap ())) . help ("The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the commit comment.")) . about ("Create reaction for a commit comment\n\nCreate a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments). A response with an HTTP `200` status means that you already added the reaction type to this commit comment.")
    }

    pub fn cli_reactions_delete_for_commit_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("comment-id") . long ("comment-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the comment.")) . arg (clap :: Arg :: new ("reaction-id") . long ("reaction-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the reaction.")) . about ("Delete a commit comment reaction\n\n**Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.\n\nDelete a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments).")
    }

    pub fn cli_repos_list_commits() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("author") . long ("author") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("GitHub username or email address to use to filter by commit author.")) . arg (clap :: Arg :: new ("committer") . long ("committer") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("GitHub username or email address to use to filter by commit committer.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("path") . long ("path") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Only commits containing this file path will be returned.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("sha") . long ("sha") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("SHA or branch to start listing commits from. Default: the repositorys default branch (usually `main`).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("until") . long ("until") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . about ("List commits\n\n**Signature verification object**\n\nThe response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:\n\n| Name | Type | Description |\n| ---- | ---- | ----------- |\n| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |\n| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |\n| `signature` | `string` | The signature that was extracted from the commit. |\n| `payload` | `string` | The value that was signed. |\n\nThese are the possible values for `reason` in the `verification` object:\n\n| Value | Description |\n| ----- | ----------- |\n| `expired_key` | The key that made the signature is expired. |\n| `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. |\n| `gpgverify_error` | There was an error communicating with the signature verification service. |\n| `gpgverify_unavailable` | The signature verification service is currently unavailable. |\n| `unsigned` | The object does not include a signature. |\n| `unknown_signature_type` | A non-PGP signature was found in the commit. |\n| `no_user` | No user was associated with the `committer` email address in the commit. |\n| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |\n| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |\n| `unknown_key` | The key that made the signature has not been registered with any user's account. |\n| `malformed_signature` | There was an error parsing the signature. |\n| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |\n| `valid` | None of the above errors applied, so the signature is considered to be verified. |")
    }

    pub fn cli_repos_list_branches_for_head_commit() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("commit-sha") . long ("commit-sha") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The SHA of the commit.")) . about ("List branches for HEAD commit\n\nProtected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nReturns all branches where the given commit SHA is the HEAD, or latest commit for the branch.")
    }

    pub fn cli_repos_list_comments_for_commit() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("commit-sha")
                    .long("commit-sha")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The SHA of the commit."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List commit comments\n\nUse the `:commit_sha` to specify the commit that will \
                 have its comments listed.",
            )
    }

    pub fn cli_repos_create_commit_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("commit-sha") . long ("commit-sha") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The SHA of the commit.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The contents of the comment.")) . arg (clap :: Arg :: new ("line") . long ("line") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("**Deprecated**. Use **position** parameter instead. Line number in the file to comment on.")) . arg (clap :: Arg :: new ("path") . long ("path") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Relative path of the file to comment on.")) . arg (clap :: Arg :: new ("position") . long ("position") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Line index in the diff to comment on.")) . about ("Create a commit comment\n\nCreate a comment for a commit using its `:commit_sha`.\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.")
    }

    pub fn cli_repos_list_pull_requests_associated_with_commit() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("commit-sha")
                    .long("commit-sha")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The SHA of the commit."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List pull requests associated with a commit\n\nLists the merged pull request \
                 that introduced the commit to the repository. If the commit is not present in \
                 the default branch, will only return open pull requests associated with the \
                 commit.",
            )
    }

    pub fn cli_repos_get_commit() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("ref") . long ("ref") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("ref parameter")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("Get a commit\n\nReturns the contents of a single commit reference. You must have `read` access for the repository to use this endpoint.\n\n**Note:** If there are more than 300 files in the commit diff, the response will include pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains the static commit information, and the only changes are to the file listing.\n\nYou can pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to  fetch `diff` and `patch` formats. Diffs with binary data will have no `patch` property.\n\nTo return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) in the `Accept` header. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.\n\n**Signature verification object**\n\nThe response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:\n\n| Name | Type | Description |\n| ---- | ---- | ----------- |\n| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |\n| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |\n| `signature` | `string` | The signature that was extracted from the commit. |\n| `payload` | `string` | The value that was signed. |\n\nThese are the possible values for `reason` in the `verification` object:\n\n| Value | Description |\n| ----- | ----------- |\n| `expired_key` | The key that made the signature is expired. |\n| `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. |\n| `gpgverify_error` | There was an error communicating with the signature verification service. |\n| `gpgverify_unavailable` | The signature verification service is currently unavailable. |\n| `unsigned` | The object does not include a signature. |\n| `unknown_signature_type` | A non-PGP signature was found in the commit. |\n| `no_user` | No user was associated with the `committer` email address in the commit. |\n| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |\n| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |\n| `unknown_key` | The key that made the signature has not been registered with any user's account. |\n| `malformed_signature` | There was an error parsing the signature. |\n| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |\n| `valid` | None of the above errors applied, so the signature is considered to be verified. |")
    }

    pub fn cli_checks_list_for_ref() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("ref parameter"),
            )
            .arg(
                clap::Arg::new("app-id")
                    .long("app-id")
                    .required(false)
                    .value_parser(clap::value_parser!(i64)),
            )
            .arg(
                clap::Arg::new("check-name")
                    .long("check-name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Returns check runs with the specified `name`."),
            )
            .arg(
                clap::Arg::new("filter")
                    .long("filter")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ChecksListForRefFilter::Latest.to_string(),
                            types::ChecksListForRefFilter::All.to_string(),
                        ]),
                        |s| types::ChecksListForRefFilter::try_from(s).unwrap(),
                    ))
                    .help(
                        "Filters check runs by their `completed_at` timestamp. `latest` returns \
                         the most recent check runs.",
                    ),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("status")
                    .long("status")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ChecksListForRefStatus::Queued.to_string(),
                            types::ChecksListForRefStatus::InProgress.to_string(),
                            types::ChecksListForRefStatus::Completed.to_string(),
                        ]),
                        |s| types::ChecksListForRefStatus::try_from(s).unwrap(),
                    ))
                    .help("Returns check runs with the specified `status`."),
            )
            .about(
                "List check runs for a Git reference\n\n**Note:** The Checks API only looks for \
                 pushes in the repository where the check suite or check run were created. Pushes \
                 to a branch in a forked repository are not detected and return an empty \
                 `pull_requests` array.\n\nLists check runs for a commit ref. The `ref` can be a \
                 SHA, branch name, or a tag name. GitHub Apps must have the `checks:read` \
                 permission on a private repository or pull access to a public repository to get \
                 check runs. OAuth Apps and authenticated users must have the `repo` scope to get \
                 check runs in a private repository.",
            )
    }

    pub fn cli_checks_list_suites_for_ref() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("ref parameter"),
            )
            .arg(
                clap::Arg::new("app-id")
                    .long("app-id")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Filters check suites by GitHub App `id`."),
            )
            .arg(
                clap::Arg::new("check-name")
                    .long("check-name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Returns check runs with the specified `name`."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List check suites for a Git reference\n\n**Note:** The Checks API only looks for \
                 pushes in the repository where the check suite or check run were created. Pushes \
                 to a branch in a forked repository are not detected and return an empty \
                 `pull_requests` array and a `null` value for `head_branch`.\n\nLists check \
                 suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. \
                 GitHub Apps must have the `checks:read` permission on a private repository or \
                 pull access to a public repository to list check suites. OAuth Apps and \
                 authenticated users must have the `repo` scope to get check suites in a private \
                 repository.",
            )
    }

    pub fn cli_repos_get_combined_status_for_ref() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("ref parameter"),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "Get the combined status for a specific reference\n\nUsers with pull access in a \
                 repository can access a combined view of commit statuses for a given ref. The \
                 ref can be a SHA, a branch name, or a tag name.\n\n\nAdditionally, a combined \
                 `state` is returned. The `state` is one of:\n\n*   **failure** if any of the \
                 contexts report as `error` or `failure`\n*   **pending** if there are no \
                 statuses or a context is `pending`\n*   **success** if the latest status for all \
                 contexts is `success`",
            )
    }

    pub fn cli_repos_list_commit_statuses_for_ref() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("ref parameter"),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List commit statuses for a reference\n\nUsers with pull access in a repository \
                 can view commit statuses for a given ref. The ref can be a SHA, a branch name, \
                 or a tag name. Statuses are returned in reverse chronological order. The first \
                 status in the list will be the latest one.\n\nThis resource is also available \
                 via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.",
            )
    }

    pub fn cli_repos_get_community_profile_metrics() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get community profile metrics\n\nReturns all community profile metrics for a \
                 repository. The repository cannot be a fork.\n\nThe returned metrics include an \
                 overall health score, the repository description, the presence of documentation, \
                 the\ndetected code of conduct, the detected license, and the presence of \
                 ISSUE\\_TEMPLATE, PULL\\_REQUEST\\_TEMPLATE,\nREADME, and CONTRIBUTING \
                 files.\n\nThe `health_percentage` score is defined as a percentage of how many \
                 of\nthese four documents are present: README, CONTRIBUTING, LICENSE, \
                 and\nCODE_OF_CONDUCT. For example, if all four documents are present, then\nthe \
                 `health_percentage` is `100`. If only one is present, then \
                 the\n`health_percentage` is `25`.\n\n`content_reports_enabled` is only returned \
                 for organization-owned repositories.",
            )
    }

    pub fn cli_repos_compare_commits() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("basehead") . long ("basehead") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The base branch and head branch to compare. This parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To compare with a branch that exists in a different repository in the same network as `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("Compare two commits\n\nCompares two commits against one another. You can compare branches in the same repository, or you can compare branches that exist in different repositories within the same repository network, including fork branches. For more information about how to view a repository's network, see \"[Understanding connections between repositories](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories).\"\n\nThis endpoint is equivalent to running the `git log BASE..HEAD` command, but it returns commits in a different order. The `git log BASE..HEAD` command returns commits in reverse chronological order, whereas the API returns commits in chronological order. You can pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.\n\nThe API response includes details about the files that were changed between the two commits. This includes the status of the change (if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.\n\nWhen calling this endpoint without any paging parameter (`per_page` or `page`), the returned list is limited to 250 commits, and the last commit in the list is the most recent of the entire comparison.\n\n**Working with large comparisons**\n\nTo process a response with a large number of commits, use a query parameter (`per_page` or `page`) to paginate the results. When using pagination:\n\n- The list of changed files is only shown on the first page of results, but it includes all changed files for the entire comparison.\n- The results are returned in chronological order, but the last commit in the returned list may not be the most recent one in the entire set if there are more pages of results.\n\nFor more information on working with pagination, see \"[Using pagination in the REST API](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api).\"\n\n**Signature verification object**\n\nThe response will include a `verification` object that describes the result of verifying the commit's signature. The `verification` object includes the following fields:\n\n| Name | Type | Description |\n| ---- | ---- | ----------- |\n| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |\n| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |\n| `signature` | `string` | The signature that was extracted from the commit. |\n| `payload` | `string` | The value that was signed. |\n\nThese are the possible values for `reason` in the `verification` object:\n\n| Value | Description |\n| ----- | ----------- |\n| `expired_key` | The key that made the signature is expired. |\n| `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. |\n| `gpgverify_error` | There was an error communicating with the signature verification service. |\n| `gpgverify_unavailable` | The signature verification service is currently unavailable. |\n| `unsigned` | The object does not include a signature. |\n| `unknown_signature_type` | A non-PGP signature was found in the commit. |\n| `no_user` | No user was associated with the `committer` email address in the commit. |\n| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |\n| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |\n| `unknown_key` | The key that made the signature has not been registered with any user's account. |\n| `malformed_signature` | There was an error parsing the signature. |\n| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |\n| `valid` | None of the above errors applied, so the signature is considered to be verified. |")
    }

    pub fn cli_repos_get_content() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("path") . long ("path") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("path parameter")) . arg (clap :: Arg :: new ("ref") . long ("ref") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the commit/branch/tag. Default: the repositorys default branch.")) . about ("Get repository content\n\nGets the contents of a file or directory in a repository. Specify the file path or directory in `:path`. If you omit\n`:path`, you will receive the contents of the repository's root directory. See the description below regarding what the API response includes for directories. \n\nFiles and symlinks support [a custom media type](https://docs.github.com/rest/reference/repos#custom-media-types) for\nretrieving the raw content or rendered HTML (when supported). All content types support [a custom media\ntype](https://docs.github.com/rest/reference/repos#custom-media-types) to ensure the content is returned in a consistent\nobject format.\n\n**Notes**:\n*   To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/rest/reference/git#trees).\n*   This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the [Git Trees\nAPI](https://docs.github.com/rest/reference/git#get-a-tree).\n *  Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents API to obtain a fresh download URL for each download.\n#### Size limits\nIf the requested file's size is:\n* 1 MB or smaller: All features of this endpoint are supported.\n* Between 1-100 MB: Only the `raw` or `object` [custom media types](https://docs.github.com/rest/repos/contents#custom-media-types-for-repository-contents) are supported. Both will work as normal, except that when using the `object` media type, the `content` field will be an empty string and the `encoding` field will be `\"none\"`. To get the contents of these larger files, use the `raw` media type.\n * Greater than 100 MB: This endpoint is not supported.\n\n#### If the content is a directory\nThe response will be an array of objects, one object for each item in the directory.\nWhen listing the contents of a directory, submodules have their \"type\" specified as \"file\". Logically, the value\n_should_ be \"submodule\". This behavior exists in API v3 [for backwards compatibility purposes](https://git.io/v1YCW).\nIn the next major version of the API, the type will be returned as \"submodule\".\n\n#### If the content is a symlink \nIf the requested `:path` points to a symlink, and the symlink's target is a normal file in the repository, then the\nAPI responds with the content of the file (in the format shown in the example. Otherwise, the API responds with an object \ndescribing the symlink itself.\n\n#### If the content is a submodule\nThe `submodule_git_url` identifies the location of the submodule repository, and the `sha` identifies a specific\ncommit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out\nthe submodule at that specific commit.\n\nIf the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links[\"git\"]`) and the\ngithub.com URLs (`html_url` and `_links[\"html\"]`) will have null values.")
    }

    pub fn cli_repos_create_or_update_file_contents() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("path") . long ("path") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("path parameter")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The branch name. Default: the repositorys default branch.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The new file content, using Base64 encoding.")) . arg (clap :: Arg :: new ("message") . long ("message") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The commit message.")) . arg (clap :: Arg :: new ("sha") . long ("sha") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("**Required if you are updating a file**. The blob SHA of the file being replaced.")) . about ("Create or update file contents\n\nCreates a new file or replaces an existing file in a repository. You must authenticate using an access token with the `workflow` scope to use this endpoint.\n\n**Note:** If you use this endpoint and the \"[Delete a file](https://docs.github.com/rest/reference/repos/#delete-file)\" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.")
    }

    pub fn cli_repos_delete_file() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("path") . long ("path") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("path parameter")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The branch name. Default: the repositorys default branch")) . arg (clap :: Arg :: new ("message") . long ("message") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The commit message.")) . arg (clap :: Arg :: new ("sha") . long ("sha") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The blob SHA of the file being deleted.")) . about ("Delete a file\n\nDeletes a file in a repository.\n\nYou can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.\n\nThe `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.\n\nYou must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.\n\n**Note:** If you use this endpoint and the \"[Create or update file contents](https://docs.github.com/rest/reference/repos/#create-or-update-file-contents)\" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.")
    }

    pub fn cli_repos_list_contributors() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("anon")
                    .long("anon")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Set to `1` or `true` to include anonymous contributors in results."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repository contributors\n\nLists contributors to the specified repository \
                 and sorts them by the number of commits per contributor in descending order. \
                 This endpoint may return information that is a few hours old because the GitHub \
                 REST API caches contributor data to improve performance.\n\nGitHub identifies \
                 contributors by author email address. This endpoint groups contribution counts \
                 by GitHub user, which includes all associated email addresses. To improve \
                 performance, only the first 500 author email addresses in the repository link to \
                 GitHub users. The rest will appear as anonymous contributors without associated \
                 GitHub user information.",
            )
    }

    pub fn cli_dependabot_list_alerts_for_repo() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("after") . long ("after") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor.")) . arg (clap :: Arg :: new ("before") . long ("before") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: DependabotListAlertsForRepoDirection :: Asc . to_string () , types :: DependabotListAlertsForRepoDirection :: Desc . to_string () ,]) , | s | types :: DependabotListAlertsForRepoDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("ecosystem") . long ("ecosystem") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.\n\nCan be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`")) . arg (clap :: Arg :: new ("first") . long ("first") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("**Deprecated**. The number of results per page (max 100), starting from the first matching result.\nThis parameter must not be used in combination with `last`.\nInstead, use `per_page` in combination with `after` to fetch the first page of results.")) . arg (clap :: Arg :: new ("last") . long ("last") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("**Deprecated**. The number of results per page (max 100), starting from the last matching result.\nThis parameter must not be used in combination with `first`.\nInstead, use `per_page` in combination with `before` to fetch the last page of results.")) . arg (clap :: Arg :: new ("manifest") . long ("manifest") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.")) . arg (clap :: Arg :: new ("package") . long ("package") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of package names. If specified, only alerts for these packages will be returned.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("**Deprecated**. Page number of the results to fetch. Use cursor-based pagination with `before` or `after` instead.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("scope") . long ("scope") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: DependabotListAlertsForRepoScope :: Development . to_string () , types :: DependabotListAlertsForRepoScope :: Runtime . to_string () ,]) , | s | types :: DependabotListAlertsForRepoScope :: try_from (s) . unwrap ())) . help ("The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.")) . arg (clap :: Arg :: new ("severity") . long ("severity") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of severities. If specified, only alerts with these severities will be returned.\n\nCan be: `low`, `medium`, `high`, `critical`")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: DependabotListAlertsForRepoSort :: Created . to_string () , types :: DependabotListAlertsForRepoSort :: Updated . to_string () ,]) , | s | types :: DependabotListAlertsForRepoSort :: try_from (s) . unwrap ())) . help ("The property by which to sort the results.\n`created` means when the alert was created.\n`updated` means when the alert's state last changed.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of states. If specified, only alerts with these states will be returned.\n\nCan be: `auto_dismissed`, `dismissed`, `fixed`, `open`")) . about ("List Dependabot alerts for a repository\n\nYou must use an access token with the `security_events` scope to use this endpoint with private repositories.\nYou can also use tokens with the `public_repo` scope for public repositories only.\nGitHub Apps must have **Dependabot alerts** read permission to use this endpoint.")
    }

    pub fn cli_dependabot_get_alert() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("alert-number")
                    .long("alert-number")
                    .required(true)
                    .value_parser(clap::value_parser!(types::AlertNumber))
                    .help(
                        "The number that identifies a Dependabot alert in its repository.\nYou \
                         can find this at the end of the URL for a Dependabot alert within \
                         GitHub,\nor in `number` fields in the response from the\n`GET \
                         /repos/{owner}/{repo}/dependabot/alerts` operation.",
                    ),
            )
            .about(
                "Get a Dependabot alert\n\nYou must use an access token with the \
                 `security_events` scope to use this endpoint with private repositories.\nYou can \
                 also use tokens with the `public_repo` scope for public repositories \
                 only.\nGitHub Apps must have **Dependabot alerts** read permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_dependabot_update_alert() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("alert-number")
                    .long("alert-number")
                    .required(true)
                    .value_parser(clap::value_parser!(types::AlertNumber))
                    .help(
                        "The number that identifies a Dependabot alert in its repository.\nYou \
                         can find this at the end of the URL for a Dependabot alert within \
                         GitHub,\nor in `number` fields in the response from the\n`GET \
                         /repos/{owner}/{repo}/dependabot/alerts` operation.",
                    ),
            )
            .arg(
                clap::Arg::new("dismissed-comment")
                    .long("dismissed-comment")
                    .required(false)
                    .value_parser(clap::value_parser!(
                        types::DependabotUpdateAlertBodyDismissedComment
                    ))
                    .help("An optional comment associated with dismissing the alert."),
            )
            .arg(
                clap::Arg::new("dismissed-reason")
                    .long("dismissed-reason")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::DependabotUpdateAlertBodyDismissedReason::FixStarted.to_string(),
                            types::DependabotUpdateAlertBodyDismissedReason::Inaccurate.to_string(),
                            types::DependabotUpdateAlertBodyDismissedReason::NoBandwidth
                                .to_string(),
                            types::DependabotUpdateAlertBodyDismissedReason::NotUsed.to_string(),
                            types::DependabotUpdateAlertBodyDismissedReason::TolerableRisk
                                .to_string(),
                        ]),
                        |s| types::DependabotUpdateAlertBodyDismissedReason::try_from(s).unwrap(),
                    ))
                    .help(
                        "**Required when `state` is `dismissed`.** A reason for dismissing the \
                         alert.",
                    ),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::DependabotUpdateAlertBodyState::Dismissed.to_string(),
                            types::DependabotUpdateAlertBodyState::Open.to_string(),
                        ]),
                        |s| types::DependabotUpdateAlertBodyState::try_from(s).unwrap(),
                    ))
                    .help(
                        "The state of the Dependabot alert.\nA `dismissed_reason` must be \
                         provided when setting the state to `dismissed`.",
                    ),
            )
            .about(
                "Update a Dependabot alert\n\nYou must use an access token with the \
                 `security_events` scope to use this endpoint with private repositories.\nYou can \
                 also use tokens with the `public_repo` scope for public repositories \
                 only.\nGitHub Apps must have **Dependabot alerts** write permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_dependabot_list_repo_secrets() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repository secrets\n\nLists all secrets available in a repository without \
                 revealing their encrypted values. You must authenticate using an access token \
                 with the `repo` scope to use this endpoint. GitHub Apps must have the \
                 `dependabot_secrets` repository permission to use this endpoint.",
            )
    }

    pub fn cli_dependabot_get_repo_public_key() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get a repository public key\n\nGets your public key, which you need to encrypt \
                 secrets. You need to encrypt a secret before you can create or update secrets. \
                 Anyone with read access to the repository can use this endpoint. If the \
                 repository is private you must use an access token with the `repo` scope. GitHub \
                 Apps must have the `dependabot_secrets` repository permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_dependabot_get_repo_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Get a repository secret\n\nGets a single repository secret without revealing its \
                 encrypted value. You must authenticate using an access token with the `repo` \
                 scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` \
                 repository permission to use this endpoint.",
            )
    }

    pub fn cli_dependabot_create_or_update_repo_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("encrypted-value") . long ("encrypted-value") . required (false) . value_parser (clap :: value_parser ! (types :: DependabotCreateOrUpdateRepoSecretBodyEncryptedValue)) . help ("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/reference/dependabot#get-a-repository-public-key) endpoint.")) . arg (clap :: Arg :: new ("key-id") . long ("key-id") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("ID of the key you used to encrypt the secret.")) . about ("Create or update a repository secret\n\nCreates or updates a repository secret with an encrypted value. Encrypt your secret using\n[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access\ntoken with the `repo` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets` repository\npermission to use this endpoint.\n\n#### Example encrypting a secret using Node.js\n\nEncrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.\n\n```\nconst sodium = require('libsodium-wrappers')\nconst secret = 'plain-text-secret' // replace with the secret you want to encrypt\nconst key = 'base64-encoded-public-key' // replace with the Base64 encoded public key\n\n//Check if libsodium is ready and then proceed.\nsodium.ready.then(() => {\n  // Convert Secret & Base64 key to Uint8Array.\n  let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)\n  let binsec = sodium.from_string(secret)\n\n  //Encrypt the secret using LibSodium\n  let encBytes = sodium.crypto_box_seal(binsec, binkey)\n\n  // Convert encrypted Uint8Array to Base64\n  let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)\n\n  console.log(output)\n});\n```\n\n#### Example encrypting a secret using Python\n\nEncrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.\n\n```\nfrom base64 import b64encode\nfrom nacl import encoding, public\n\ndef encrypt(public_key: str, secret_value: str) -> str:\n  \"\"\"Encrypt a Unicode string using the public key.\"\"\"\n  public_key = public.PublicKey(public_key.encode(\"utf-8\"), encoding.Base64Encoder())\n  sealed_box = public.SealedBox(public_key)\n  encrypted = sealed_box.encrypt(secret_value.encode(\"utf-8\"))\n  return b64encode(encrypted).decode(\"utf-8\")\n```\n\n#### Example encrypting a secret using C#\n\nEncrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.\n\n```\nvar secretValue = System.Text.Encoding.UTF8.GetBytes(\"mySecret\");\nvar publicKey = Convert.FromBase64String(\"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=\");\n\nvar sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);\n\nConsole.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));\n```\n\n#### Example encrypting a secret using Ruby\n\nEncrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.\n\n```ruby\nrequire \"rbnacl\"\nrequire \"base64\"\n\nkey = Base64.decode64(\"+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=\")\npublic_key = RbNaCl::PublicKey.new(key)\n\nbox = RbNaCl::Boxes::Sealed.from_public_key(public_key)\nencrypted_secret = box.encrypt(\"my_secret\")\n\n# Print the base64 encoded secret\nputs Base64.strict_encode64(encrypted_secret)\n```")
    }

    pub fn cli_dependabot_delete_repo_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Delete a repository secret\n\nDeletes a secret in a repository using the secret \
                 name. You must authenticate using an access token with the `repo` scope to use \
                 this endpoint. GitHub Apps must have the `dependabot_secrets` repository \
                 permission to use this endpoint.",
            )
    }

    pub fn cli_dependency_graph_diff_range() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("basehead")
                    .long("basehead")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The base and head Git revisions to compare. The Git revisions will be \
                         resolved to commit SHAs. Named revisions will be resolved to their \
                         corresponding HEAD commits, and an appropriate merge base will be \
                         determined. This parameter expects the format `{base}...{head}`.",
                    ),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The full path, relative to the repository root, of the dependency \
                         manifest file.",
                    ),
            )
            .about(
                "Get a diff of the dependencies between commits\n\nGets the diff of the \
                 dependency changes between two commits of a repository, based on the changes to \
                 the dependency manifests made in those commits.",
            )
    }

    pub fn cli_dependency_graph_export_sbom() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Export a software bill of materials (SBOM) for a repository.\n\nExports the \
                 software bill of materials (SBOM) for a repository in SPDX JSON format.",
            )
    }

    pub fn cli_dependency_graph_create_repository_snapshot() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(true)
                    .value_parser(clap::value_parser!(types::SnapshotRef))
                    .help("The repository branch that triggered this snapshot."),
            )
            .arg(
                clap::Arg::new("scanned")
                    .long("scanned")
                    .required(true)
                    .value_parser(clap::value_parser!(chrono::DateTime<chrono::offset::Utc>))
                    .help("The time at which the snapshot was scanned."),
            )
            .arg(
                clap::Arg::new("sha")
                    .long("sha")
                    .required(true)
                    .value_parser(clap::value_parser!(types::SnapshotSha))
                    .help(
                        "The commit SHA associated with this dependency snapshot. Maximum length: \
                         40 characters.",
                    ),
            )
            .arg(
                clap::Arg::new("version")
                    .long("version")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The version of the repository snapshot submission."),
            )
            .about(
                "Create a snapshot of dependencies for a repository\n\nCreate a new snapshot of a \
                 repository's dependencies. You must authenticate using an access token with the \
                 `repo` scope to use this endpoint for a repository that the requesting user has \
                 access to.",
            )
    }

    pub fn cli_repos_list_deployments() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("environment")
                    .long("environment")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The name of the environment that was deployed to (e.g., `staging` or \
                         `production`).",
                    ),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the ref. This can be a branch, tag, or SHA."),
            )
            .arg(
                clap::Arg::new("sha")
                    .long("sha")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The SHA recorded at creation time."),
            )
            .arg(
                clap::Arg::new("task")
                    .long("task")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The name of the task for the deployment (e.g., `deploy` or \
                         `deploy:migrations`).",
                    ),
            )
            .about(
                "List deployments\n\nSimple filtering of deployments is available via query \
                 parameters:",
            )
    }

    pub fn cli_repos_create_deployment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("auto-merge") . long ("auto-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.")) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Short description of the deployment.")) . arg (clap :: Arg :: new ("environment") . long ("environment") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Name for the target deployment environment (e.g., `production`, `staging`, `qa`).")) . arg (clap :: Arg :: new ("production-environment") . long ("production-environment") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.")) . arg (clap :: Arg :: new ("ref") . long ("ref") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The ref to deploy. This can be a branch, tag, or SHA.")) . arg (clap :: Arg :: new ("task") . long ("task") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).")) . arg (clap :: Arg :: new ("transient-environment") . long ("transient-environment") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`")) . about ("Create a deployment\n\nDeployments offer a few configurable parameters with certain defaults.\n\nThe `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them\nbefore we merge a pull request.\n\nThe `environment` parameter allows deployments to be issued to different runtime environments. Teams often have\nmultiple environments for verifying their applications, such as `production`, `staging`, and `qa`. This parameter\nmakes it easier to track which environments have requested deployments. The default environment is `production`.\n\nThe `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's default branch. If\nthe ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If the merge succeeds,\nthe API will return a successful merge commit. If merge conflicts prevent the merge from succeeding, the API will\nreturn a failure response.\n\nBy default, [commit statuses](https://docs.github.com/rest/commits/statuses) for every submitted context must be in a `success`\nstate. The `required_contexts` parameter allows you to specify a subset of contexts that must be `success`, or to\nspecify contexts that have not yet been submitted. You are not required to use commit statuses to deploy. If you do\nnot require any contexts or create any commit statuses, the deployment will always succeed.\n\nThe `payload` parameter is available for any extra information that a deployment system might need. It is a JSON text\nfield that will be passed on when a deployment event is dispatched.\n\nThe `task` parameter is used by the deployment system to allow different execution paths. In the web world this might\nbe `deploy:migrations` to run schema changes on the system. In the compiled world this could be a flag to compile an\napplication with debugging enabled.\n\nUsers with `repo` or `repo_deployment` scopes can create a deployment for a given ref.\n\n#### Merged branch response\nYou will see this response when GitHub automatically merges the base branch into the topic branch instead of creating\na deployment. This auto-merge happens when:\n*   Auto-merge option is enabled in the repository\n*   Topic branch does not include the latest changes on the base branch, which is `master` in the response example\n*   There are no merge conflicts\n\nIf there are no new commits in the base branch, a new request to create a deployment should give a successful\nresponse.\n\n#### Merge conflict response\nThis error happens when the `auto_merge` option is enabled and when the default branch (in this case `master`), can't\nbe merged into the branch that's being deployed (in this case `topic-branch`), due to merge conflicts.\n\n#### Failed commit status checks\nThis error happens when the `required_contexts` parameter indicates that one or more contexts need to have a `success`\nstatus for the commit to be deployed, but one or more of the required contexts do not have a state of `success`.")
    }

    pub fn cli_repos_get_deployment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("deployment-id")
                    .long("deployment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("deployment_id parameter"),
            )
            .about("Get a deployment")
    }

    pub fn cli_repos_delete_deployment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("deployment-id") . long ("deployment-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("deployment_id parameter")) . about ("Delete a deployment\n\nIf the repository only has one deployment, you can delete the deployment regardless of its status. If the repository has more than one deployment, you can only delete inactive deployments. This ensures that repositories with multiple deployments will always have an active deployment. Anyone with `repo` or `repo_deployment` scopes can delete a deployment.\n\nTo set a deployment as inactive, you must:\n\n*   Create a new deployment that is active so that the system has a record of the current state, then delete the previously active deployment.\n*   Mark the active deployment as inactive by adding any non-successful deployment status.\n\nFor more information, see \"[Create a deployment](https://docs.github.com/rest/deployments/deployments/#create-a-deployment)\" and \"[Create a deployment status](https://docs.github.com/rest/deployments/deployment-statuses#create-a-deployment-status).\"")
    }

    pub fn cli_repos_list_deployment_statuses() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("deployment-id")
                    .long("deployment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("deployment_id parameter"),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List deployment statuses\n\nUsers with pull access can view deployment statuses \
                 for a deployment:",
            )
    }

    pub fn cli_repos_create_deployment_status() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("deployment-id")
                    .long("deployment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("deployment_id parameter"),
            )
            .arg(
                clap::Arg::new("auto-inactive")
                    .long("auto-inactive")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Adds a new `inactive` status to all prior non-transient, non-production \
                         environment deployments with the same repository and `environment` name \
                         as the created status's deployment. An `inactive` status is only added \
                         to deployments that had a `success` state. Default: `true`",
                    ),
            )
            .arg(
                clap::Arg::new("description")
                    .long("description")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "A short description of the status. The maximum description length is 140 \
                         characters.",
                    ),
            )
            .arg(
                clap::Arg::new("environment")
                    .long("environment")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposCreateDeploymentStatusBodyEnvironment::Production
                                .to_string(),
                            types::ReposCreateDeploymentStatusBodyEnvironment::Staging.to_string(),
                            types::ReposCreateDeploymentStatusBodyEnvironment::Qa.to_string(),
                        ]),
                        |s| types::ReposCreateDeploymentStatusBodyEnvironment::try_from(s).unwrap(),
                    ))
                    .help(
                        "Name for the target deployment environment, which can be changed when \
                         setting a deploy status. For example, `production`, `staging`, or `qa`.",
                    ),
            )
            .arg(
                clap::Arg::new("environment-url")
                    .long("environment-url")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Sets the URL for accessing your environment. Default: `\"\"`"),
            )
            .arg(
                clap::Arg::new("log-url")
                    .long("log-url")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The full URL of the deployment's output. This parameter replaces \
                         `target_url`. We will continue to accept `target_url` to support legacy \
                         uses, but we recommend replacing `target_url` with `log_url`. Setting \
                         `log_url` will automatically set `target_url` to the same value. \
                         Default: `\"\"`",
                    ),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposCreateDeploymentStatusBodyState::Error.to_string(),
                            types::ReposCreateDeploymentStatusBodyState::Failure.to_string(),
                            types::ReposCreateDeploymentStatusBodyState::Inactive.to_string(),
                            types::ReposCreateDeploymentStatusBodyState::InProgress.to_string(),
                            types::ReposCreateDeploymentStatusBodyState::Queued.to_string(),
                            types::ReposCreateDeploymentStatusBodyState::Pending.to_string(),
                            types::ReposCreateDeploymentStatusBodyState::Success.to_string(),
                        ]),
                        |s| types::ReposCreateDeploymentStatusBodyState::try_from(s).unwrap(),
                    ))
                    .help(
                        "The state of the status. When you set a transient deployment to \
                         `inactive`, the deployment will be shown as `destroyed` in GitHub.",
                    ),
            )
            .arg(
                clap::Arg::new("target-url")
                    .long("target-url")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The target URL to associate with this status. This URL should contain \
                         output to keep the user updated while the task is running or serve as \
                         historical information for what happened in the deployment. **Note:** \
                         It's recommended to use the `log_url` parameter, which replaces \
                         `target_url`.",
                    ),
            )
            .about(
                "Create a deployment status\n\nUsers with `push` access can create deployment \
                 statuses for a given deployment.\n\nGitHub Apps require `read & write` access to \
                 \"Deployments\" and `read-only` access to \"Repo contents\" (for private repos). \
                 OAuth Apps require the `repo_deployment` scope.",
            )
    }

    pub fn cli_repos_get_deployment_status() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("deployment-id")
                    .long("deployment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("deployment_id parameter"),
            )
            .arg(
                clap::Arg::new("status-id")
                    .long("status-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64)),
            )
            .about(
                "Get a deployment status\n\nUsers with pull access can view a deployment status \
                 for a deployment:",
            )
    }

    pub fn cli_repos_create_dispatch_event() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("event-type") . long ("event-type") . required (true) . value_parser (clap :: value_parser ! (types :: ReposCreateDispatchEventBodyEventType)) . help ("A custom webhook event name. Must be 100 characters or fewer.")) . about ("Create a repository dispatch event\n\nYou can use this endpoint to trigger a webhook event called `repository_dispatch` when you want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see \"[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch).\"\n\nThe `client_payload` parameter is available for any extra information that your workflow might need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example, the `client_payload` can include a message that a user would like to send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.\n\nThis endpoint requires write access to the repository by providing either:\n\n  - Personal access tokens with `repo` scope. For more information, see \"[Creating a personal access token for the command line](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line)\" in the GitHub Help documentation.\n  - GitHub Apps with both `metadata:read` and `contents:read&write` permissions.\n\nThis input example shows how you can use the `client_payload` as a test to debug your workflow.")
    }

    pub fn cli_repos_get_all_environments() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List environments\n\nLists the environments for a repository.\n\nAnyone with \
                 read access to the repository can use this endpoint. If the repository is \
                 private, you must use an access token with the `repo` scope. GitHub Apps must \
                 have the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_repos_get_environment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .about(
                "Get an environment\n\n**Note:** To get information about name patterns that \
                 branches must match in order to deploy to this environment, see \"[Get a \
                 deployment branch \
                 policy](/rest/deployments/branch-policies#get-a-deployment-branch-policy).\"\n\\
                 nAnyone with read access to the repository can use this endpoint. If \
                 the\nrepository is private, you must use an access token with the `repo` scope. \
                 GitHub\nApps must have the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_repos_create_or_update_environment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .about(
                "Create or update an environment\n\nCreate or update an environment with \
                 protection rules, such as required reviewers. For more information about \
                 environment protection rules, see \
                 \"[Environments](/actions/reference/environments#environment-protection-rules).\"\
                 \n\n**Note:** To create or update name patterns that branches must match in \
                 order to deploy to this environment, see \"[Deployment branch \
                 policies](/rest/deployments/branch-policies).\"\n\n**Note:** To create or update \
                 secrets for an environment, see \
                 \"[Secrets](/rest/reference/actions#secrets).\"\n\nYou must authenticate using \
                 an access token with the `repo` scope to use this endpoint. GitHub Apps must \
                 have the `administration:write` permission for the repository to use this \
                 endpoint.",
            )
    }

    pub fn cli_repos_delete_an_environment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .about(
                "Delete an environment\n\nYou must authenticate using an access token with the \
                 repo scope to use this endpoint.",
            )
    }

    pub fn cli_repos_list_deployment_branch_policies() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List deployment branch policies\n\nLists the deployment branch policies for an \
                 environment.\n\nAnyone with read access to the repository can use this endpoint. \
                 If the repository is private, you must use an access token with the `repo` \
                 scope. GitHub Apps must have the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_repos_create_deployment_branch_policy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("environment-name") . long ("environment-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the environment.")) . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name pattern that branches must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).")) . about ("Create a deployment branch policy\n\nCreates a deployment branch policy for an environment.\n\nYou must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write` permission for the repository to use this endpoint.")
    }

    pub fn cli_repos_get_deployment_branch_policy() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .arg(
                clap::Arg::new("branch-policy-id")
                    .long("branch-policy-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the branch policy."),
            )
            .about(
                "Get a deployment branch policy\n\nGets a deployment branch policy for an \
                 environment.\n\nAnyone with read access to the repository can use this endpoint. \
                 If the repository is private, you must use an access token with the `repo` \
                 scope. GitHub Apps must have the `actions:read` permission to use this endpoint.",
            )
    }

    pub fn cli_repos_update_deployment_branch_policy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("environment-name") . long ("environment-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the environment.")) . arg (clap :: Arg :: new ("branch-policy-id") . long ("branch-policy-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the branch policy.")) . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name pattern that branches must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).")) . about ("Update a deployment branch policy\n\nUpdates a deployment branch policy for an environment.\n\nYou must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write` permission for the repository to use this endpoint.")
    }

    pub fn cli_repos_delete_deployment_branch_policy() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .arg(
                clap::Arg::new("branch-policy-id")
                    .long("branch-policy-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the branch policy."),
            )
            .about(
                "Delete a deployment branch policy\n\nDeletes a deployment branch policy for an \
                 environment.\n\nYou must authenticate using an access token with the `repo` \
                 scope to use this endpoint. GitHub Apps must have the `administration:write` \
                 permission for the repository to use this endpoint.",
            )
    }

    pub fn cli_repos_get_all_deployment_protection_rules() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("environment-name") . long ("environment-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the environment.")) . about ("Get all deployment protection rules for an environment\n\nGets all custom deployment protection rules that are enabled for an environment. Anyone with read access to the repository can use this endpoint. If the repository is private and you want to use a personal access token (classic), you must use an access token with the `repo` scope. GitHub Apps and fine-grained personal access tokens must have the `actions:read` permission to use this endpoint. For more information about environments, see \"[Using environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment).\"\n\nFor more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app).")
    }

    pub fn cli_repos_create_deployment_protection_rule() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("environment-name") . long ("environment-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the environment.")) . arg (clap :: Arg :: new ("integration-id") . long ("integration-id") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The ID of the custom app that will be enabled on the environment.")) . about ("Create a custom deployment protection rule on an environment\n\nEnable a custom deployment protection rule for an environment.\n\nYou must authenticate using an access token with the `repo` scope to use this endpoint. Enabling a custom protection rule requires admin or owner permissions to the repository. GitHub Apps must have the `actions:write` permission to use this endpoint.\n\nFor more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app).")
    }

    pub fn cli_repos_list_custom_deployment_rule_integrations() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("environment-name") . long ("environment-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the environment.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List custom deployment rule integrations available for an environment\n\nGets all custom deployment protection rule integrations that are available for an environment. Anyone with read access to the repository can use this endpoint. If the repository is private and you want to use a personal access token (classic), you must use an access token with the `repo` scope. GitHub Apps and fine-grained personal access tokens must have the `actions:read` permission to use this endpoint.\n\nFor more information about environments, see \"[Using environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment).\"\n\nFor more information about the app that is providing this custom deployment rule, see \"[GET an app](https://docs.github.com/rest/apps/apps#get-an-app)\".")
    }

    pub fn cli_repos_get_custom_deployment_protection_rule() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("environment-name") . long ("environment-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the environment.")) . arg (clap :: Arg :: new ("protection-rule-id") . long ("protection-rule-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the protection rule.")) . about ("Get a custom deployment protection rule\n\nGets an enabled custom deployment protection rule for an environment. Anyone with read access to the repository can use this endpoint. If the repository is private and you want to use a personal access token (classic), you must use an access token with the `repo` scope. GitHub Apps and fine-grained personal access tokens must have the `actions:read` permission to use this endpoint. For more information about environments, see \"[Using environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment).\"\n\nFor more information about the app that is providing this custom deployment rule, see [`GET /apps/{app_slug}`](https://docs.github.com/rest/apps/apps#get-an-app).")
    }

    pub fn cli_repos_disable_deployment_protection_rule() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("environment-name") . long ("environment-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the environment.")) . arg (clap :: Arg :: new ("protection-rule-id") . long ("protection-rule-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the protection rule.")) . about ("Disable a custom protection rule for an environment\n\nDisables a custom deployment protection rule for an environment.\n\nYou must authenticate using an access token with the `repo` scope to use this endpoint. Removing a custom protection rule requires admin or owner permissions to the repository. GitHub Apps must have the `actions:write` permission to use this endpoint. For more information, see \"[Get an app](https://docs.github.com/rest/apps/apps#get-an-app)\".")
    }

    pub fn cli_activity_list_repo_events() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repository events\n\n**Note**: This API is not built to serve real-time use \
                 cases. Depending on the time of day, event latency can be anywhere from 30s to \
                 6h.\n",
            )
    }

    pub fn cli_repos_list_forks() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("sort")
                    .long("sort")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposListForksSort::Newest.to_string(),
                            types::ReposListForksSort::Oldest.to_string(),
                            types::ReposListForksSort::Stargazers.to_string(),
                            types::ReposListForksSort::Watchers.to_string(),
                        ]),
                        |s| types::ReposListForksSort::try_from(s).unwrap(),
                    ))
                    .help("The sort order. `stargazers` will sort by star count."),
            )
            .about("List forks")
    }

    pub fn cli_repos_create_fork() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Create a fork\n\nCreate a fork for the authenticated user.\n\n**Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).\n\n**Note**: Although this endpoint works with GitHub Apps, the GitHub App must be installed on the destination account with access to all repositories and on the source account with access to the source repository.")
    }

    pub fn cli_git_create_blob() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("content")
                    .long("content")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The new blob's content."),
            )
            .arg(
                clap::Arg::new("encoding")
                    .long("encoding")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The encoding used for `content`. Currently, `\"utf-8\"` and `\"base64\"` \
                         are supported.",
                    ),
            )
            .about("Create a blob")
    }

    pub fn cli_git_get_blob() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("file-sha")
                    .long("file-sha")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about(
                "Get a blob\n\nThe `content` in the response will always be Base64 \
                 encoded.\n\n_Note_: This API supports blobs up to 100 megabytes in size.",
            )
    }

    pub fn cli_git_create_commit() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("message") . long ("message") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The commit message")) . arg (clap :: Arg :: new ("signature") . long ("signature") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the commit. GitHub adds the signature to the `gpgsig` header of the created commit. For a commit signature to be verifiable by Git or GitHub, it must be an ASCII-armored detached PGP signature over the string commit as it would be written to the object database. To pass a `signature` parameter, you need to first manually create a valid PGP signature, which can be complicated. You may find it easier to [use the command line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create signed commits.")) . arg (clap :: Arg :: new ("tree") . long ("tree") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The SHA of the tree object this commit points to")) . about ("Create a commit\n\nCreates a new Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).\n\n**Signature verification object**\n\nThe response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:\n\n| Name | Type | Description |\n| ---- | ---- | ----------- |\n| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |\n| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in the table below. |\n| `signature` | `string` | The signature that was extracted from the commit. |\n| `payload` | `string` | The value that was signed. |\n\nThese are the possible values for `reason` in the `verification` object:\n\n| Value | Description |\n| ----- | ----------- |\n| `expired_key` | The key that made the signature is expired. |\n| `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. |\n| `gpgverify_error` | There was an error communicating with the signature verification service. |\n| `gpgverify_unavailable` | The signature verification service is currently unavailable. |\n| `unsigned` | The object does not include a signature. |\n| `unknown_signature_type` | A non-PGP signature was found in the commit. |\n| `no_user` | No user was associated with the `committer` email address in the commit. |\n| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |\n| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |\n| `unknown_key` | The key that made the signature has not been registered with any user's account. |\n| `malformed_signature` | There was an error parsing the signature. |\n| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |\n| `valid` | None of the above errors applied, so the signature is considered to be verified. |")
    }

    pub fn cli_git_get_commit() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("commit-sha") . long ("commit-sha") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The SHA of the commit.")) . about ("Get a commit\n\nGets a Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).\n\n**Signature verification object**\n\nThe response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:\n\n| Name | Type | Description |\n| ---- | ---- | ----------- |\n| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |\n| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in the table below. |\n| `signature` | `string` | The signature that was extracted from the commit. |\n| `payload` | `string` | The value that was signed. |\n\nThese are the possible values for `reason` in the `verification` object:\n\n| Value | Description |\n| ----- | ----------- |\n| `expired_key` | The key that made the signature is expired. |\n| `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. |\n| `gpgverify_error` | There was an error communicating with the signature verification service. |\n| `gpgverify_unavailable` | The signature verification service is currently unavailable. |\n| `unsigned` | The object does not include a signature. |\n| `unknown_signature_type` | A non-PGP signature was found in the commit. |\n| `no_user` | No user was associated with the `committer` email address in the commit. |\n| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |\n| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |\n| `unknown_key` | The key that made the signature has not been registered with any user's account. |\n| `malformed_signature` | There was an error parsing the signature. |\n| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |\n| `valid` | None of the above errors applied, so the signature is considered to be verified. |")
    }

    pub fn cli_git_list_matching_refs() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("ref") . long ("ref") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("ref parameter")) . about ("List matching references\n\nReturns an array of references from your Git database that match the supplied name. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be returned as an array.\n\nWhen you use this endpoint without providing a `:ref`, it will return an array of all the references from your Git database, including notes and stashes if they exist on the server. Anything in the namespace is returned, not just `heads` and `tags`.\n\n**Note:** You need to explicitly [request a pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see \"[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)\".\n\nIf you request matching references for a branch named `feature` but the branch `feature` doesn't exist, the response can still include other matching head refs that start with the word `feature`, such as `featureA` and `featureB`.")
    }

    pub fn cli_git_get_ref() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("ref") . long ("ref") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("ref parameter")) . about ("Get a reference\n\nReturns a single reference from your Git database. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an existing ref, a `404` is returned.\n\n**Note:** You need to explicitly [request a pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see \"[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)\".")
    }

    pub fn cli_git_create_ref() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("key")
                    .long("key")
                    .required(false)
                    .value_parser(clap::value_parser!(String)),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The name of the fully qualified reference (ie: `refs/heads/master`). If \
                         it doesn't start with 'refs' and have at least two slashes, it will be \
                         rejected.",
                    ),
            )
            .arg(
                clap::Arg::new("sha")
                    .long("sha")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The SHA1 value for this reference."),
            )
            .about(
                "Create a reference\n\nCreates a reference for your repository. You are unable to \
                 create new references for empty repositories, even if the commit SHA-1 hash used \
                 exists. Empty repositories are repositories without branches.",
            )
    }

    pub fn cli_git_delete_ref() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("ref parameter"),
            )
            .about("Delete a reference")
    }

    pub fn cli_git_update_ref() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The name of the fully qualified reference to update. For example, \
                         `refs/heads/master`. If the value doesn't start with `refs` and have at \
                         least two slashes, it will be rejected.",
                    ),
            )
            .arg(
                clap::Arg::new("force")
                    .long("force")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether to force the update or to make sure the update is a \
                         fast-forward update. Leaving this out or setting it to `false` will make \
                         sure you're not overwriting work.",
                    ),
            )
            .arg(
                clap::Arg::new("sha")
                    .long("sha")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The SHA1 value to set this reference to"),
            )
            .about("Update a reference")
    }

    pub fn cli_git_create_tag() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("message") . long ("message") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The tag message.")) . arg (clap :: Arg :: new ("object") . long ("object") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The SHA of the git object this is tagging.")) . arg (clap :: Arg :: new ("tag") . long ("tag") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The tag's name. This is typically a version (e.g., \"v0.0.1\").")) . arg (clap :: Arg :: new ("type") . long ("type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: GitCreateTagBodyType :: Commit . to_string () , types :: GitCreateTagBodyType :: Tree . to_string () , types :: GitCreateTagBodyType :: Blob . to_string () ,]) , | s | types :: GitCreateTagBodyType :: try_from (s) . unwrap ())) . help ("The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.")) . about ("Create a tag object\n\nNote that creating a tag object does not create the reference that makes a tag in Git. If you want to create an annotated tag in Git, you have to do this call to create the tag object, and then [create](https://docs.github.com/rest/reference/git#create-a-reference) the `refs/tags/[tag]` reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.com/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.\n\n**Signature verification object**\n\nThe response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:\n\n| Name | Type | Description |\n| ---- | ---- | ----------- |\n| `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |\n| `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |\n| `signature` | `string` | The signature that was extracted from the commit. |\n| `payload` | `string` | The value that was signed. |\n\nThese are the possible values for `reason` in the `verification` object:\n\n| Value | Description |\n| ----- | ----------- |\n| `expired_key` | The key that made the signature is expired. |\n| `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. |\n| `gpgverify_error` | There was an error communicating with the signature verification service. |\n| `gpgverify_unavailable` | The signature verification service is currently unavailable. |\n| `unsigned` | The object does not include a signature. |\n| `unknown_signature_type` | A non-PGP signature was found in the commit. |\n| `no_user` | No user was associated with the `committer` email address in the commit. |\n| `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |\n| `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |\n| `unknown_key` | The key that made the signature has not been registered with any user's account. |\n| `malformed_signature` | There was an error parsing the signature. |\n| `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |\n| `valid` | None of the above errors applied, so the signature is considered to be verified. |")
    }

    pub fn cli_git_get_tag() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("tag-sha")
                    .long("tag-sha")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about(
                "Get a tag\n\n**Signature verification object**\n\nThe response will include a \
                 `verification` object that describes the result of verifying the commit's \
                 signature. The following fields are included in the `verification` object:\n\n| \
                 Name | Type | Description |\n| ---- | ---- | ----------- |\n| `verified` | \
                 `boolean` | Indicates whether GitHub considers the signature in this commit to \
                 be verified. |\n| `reason` | `string` | The reason for verified value. Possible \
                 values and their meanings are enumerated in table below. |\n| `signature` | \
                 `string` | The signature that was extracted from the commit. |\n| `payload` | \
                 `string` | The value that was signed. |\n\nThese are the possible values for \
                 `reason` in the `verification` object:\n\n| Value | Description |\n| ----- | \
                 ----------- |\n| `expired_key` | The key that made the signature is expired. \
                 |\n| `not_signing_key` | The \"signing\" flag is not among the usage flags in \
                 the GPG key that made the signature. |\n| `gpgverify_error` | There was an error \
                 communicating with the signature verification service. |\n| \
                 `gpgverify_unavailable` | The signature verification service is currently \
                 unavailable. |\n| `unsigned` | The object does not include a signature. |\n| \
                 `unknown_signature_type` | A non-PGP signature was found in the commit. |\n| \
                 `no_user` | No user was associated with the `committer` email address in the \
                 commit. |\n| `unverified_email` | The `committer` email address in the commit \
                 was associated with a user, but the email address is not verified on their \
                 account. |\n| `bad_email` | The `committer` email address in the commit is not \
                 included in the identities of the PGP key that made the signature. |\n| \
                 `unknown_key` | The key that made the signature has not been registered with any \
                 user's account. |\n| `malformed_signature` | There was an error parsing the \
                 signature. |\n| `invalid` | The signature could not be cryptographically \
                 verified using the key whose key-id was found in the signature. |\n| `valid` | \
                 None of the above errors applied, so the signature is considered to be verified. \
                 |",
            )
    }

    pub fn cli_git_create_tree() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("base-tree") . long ("base-tree") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The SHA1 of an existing Git tree object which will be used as the base for the new tree. If provided, a new Git tree object will be created from entries in the Git tree object pointed to by `base_tree` and entries defined in the `tree` parameter. Entries defined in the `tree` parameter will overwrite items from `base_tree` with the same `path`. If you're creating new changes on a branch, then normally you'd set `base_tree` to the SHA1 of the Git tree object of the current latest commit on the branch you're working on.\nIf not provided, GitHub will create a new Git tree object from only the entries defined in the `tree` parameter. If you create a new commit pointing to such a tree, then all files which were a part of the parent commit's tree and were not defined in the `tree` parameter will be listed as deleted by the new commit.\n")) . about ("Create a tree\n\nThe tree creation API accepts nested entries. If you specify both a tree and a nested path modifying that tree, this endpoint will overwrite the contents of the tree with the new path contents, and create a new tree structure.\n\nIf you use this endpoint to add, delete, or modify the file contents in a tree, you will need to commit the tree and then update a branch to point to the commit. For more information see \"[Create a commit](https://docs.github.com/rest/reference/git#create-a-commit)\" and \"[Update a reference](https://docs.github.com/rest/reference/git#update-a-reference).\"\n\nReturns an error if you try to delete a file that does not exist.")
    }

    pub fn cli_git_get_tree() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("tree-sha")
                    .long("tree-sha")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .arg(
                clap::Arg::new("recursive")
                    .long("recursive")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "Setting this parameter to any value returns the objects or subtrees \
                         referenced by the tree specified in `:tree_sha`. For example, setting \
                         `recursive` to any of the following will enable returning objects or \
                         subtrees: `0`, `1`, `\"true\"`, and `\"false\"`. Omit this parameter to \
                         prevent recursively returning objects or subtrees.",
                    ),
            )
            .about(
                "Get a tree\n\nReturns a single tree using the SHA1 value for that tree.\n\nIf \
                 `truncated` is `true` in the response then the number of items in the `tree` \
                 array exceeded our maximum limit. If you need to fetch more items, use the \
                 non-recursive method of fetching trees, and fetch one sub-tree at a \
                 time.\n\n\n**Note**: The limit for the `tree` array is 100,000 entries with a \
                 maximum size of 7 MB when using the `recursive` parameter.",
            )
    }

    pub fn cli_repos_list_webhooks() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repository webhooks\n\nLists webhooks for a repository. `last response` may \
                 return null if there have not been any deliveries within 30 days.",
            )
    }

    pub fn cli_repos_create_webhook() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Create a repository webhook\n\nRepositories can have multiple webhooks \
                 installed. Each webhook should have a unique `config`. Multiple webhooks \
                 can\nshare the same `config` as long as those webhooks do not have any `events` \
                 that overlap.",
            )
    }

    pub fn cli_repos_get_webhook() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .about(
                "Get a repository webhook\n\nReturns a webhook configured in a repository. To get \
                 only the webhook `config` properties, see \"[Get a webhook configuration for a \
                 repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository).\\
                 "",
            )
    }

    pub fn cli_repos_delete_webhook() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .about("Delete a repository webhook")
    }

    pub fn cli_repos_update_webhook() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .arg(
                clap::Arg::new("active")
                    .long("active")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Determines if notifications are sent when the webhook is triggered. Set \
                         to `true` to send notifications.",
                    ),
            )
            .about(
                "Update a repository webhook\n\nUpdates a webhook configured in a repository. If \
                 you previously had a `secret` set, you must provide the same `secret` or set a \
                 new `secret` or the secret will be removed. If you are only updating individual \
                 webhook `config` properties, use \"[Update a webhook configuration for a \
                 repository](/rest/reference/repos#\
                 update-a-webhook-configuration-for-a-repository).\"",
            )
    }

    pub fn cli_repos_get_webhook_config_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .about(
                "Get a webhook configuration for a repository\n\nReturns the webhook \
                 configuration for a repository. To get more information about the webhook, \
                 including the `active` state and `events`, use \"[Get a repository \
                 webhook](/rest/reference/orgs#get-a-repository-webhook).\"\n\nAccess tokens must \
                 have the `read:repo_hook` or `repo` scope, and GitHub Apps must have the \
                 `repository_hooks:read` permission.",
            )
    }

    pub fn cli_repos_update_webhook_config_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .arg(
                clap::Arg::new("content-type")
                    .long("content-type")
                    .required(false)
                    .value_parser(clap::value_parser!(types::WebhookConfigContentType)),
            )
            .arg(
                clap::Arg::new("insecure-ssl")
                    .long("insecure-ssl")
                    .required(false)
                    .value_parser(clap::value_parser!(types::WebhookConfigInsecureSsl)),
            )
            .arg(
                clap::Arg::new("secret")
                    .long("secret")
                    .required(false)
                    .value_parser(clap::value_parser!(types::WebhookConfigSecret)),
            )
            .arg(
                clap::Arg::new("url")
                    .long("url")
                    .required(false)
                    .value_parser(clap::value_parser!(types::WebhookConfigUrl)),
            )
            .about(
                "Update a webhook configuration for a repository\n\nUpdates the webhook \
                 configuration for a repository. To update more information about the webhook, \
                 including the `active` state and `events`, use \"[Update a repository \
                 webhook](/rest/reference/orgs#update-a-repository-webhook).\"\n\nAccess tokens \
                 must have the `write:repo_hook` or `repo` scope, and GitHub Apps must have the \
                 `repository_hooks:write` permission.",
            )
    }

    pub fn cli_repos_list_webhook_deliveries() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .arg(
                clap::Arg::new("cursor")
                    .long("cursor")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "Used for pagination: the starting delivery from which the page of \
                         deliveries is fetched. Refer to the `link` header for the next and \
                         previous page cursors.",
                    ),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("redelivery")
                    .long("redelivery")
                    .required(false)
                    .value_parser(clap::value_parser!(bool)),
            )
            .about(
                "List deliveries for a repository webhook\n\nReturns a list of webhook deliveries \
                 for a webhook configured in a repository.",
            )
    }

    pub fn cli_repos_get_webhook_delivery() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .arg(
                clap::Arg::new("delivery-id")
                    .long("delivery-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64)),
            )
            .about(
                "Get a delivery for a repository webhook\n\nReturns a delivery for a webhook \
                 configured in a repository.",
            )
    }

    pub fn cli_repos_redeliver_webhook_delivery() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .arg(
                clap::Arg::new("delivery-id")
                    .long("delivery-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64)),
            )
            .about(
                "Redeliver a delivery for a repository webhook\n\nRedeliver a webhook delivery \
                 for a webhook configured in a repository.",
            )
    }

    pub fn cli_repos_ping_webhook() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("hook-id") . long ("hook-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the hook.")) . about ("Ping a repository webhook\n\nThis will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.")
    }

    pub fn cli_repos_test_push_webhook() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("hook-id")
                    .long("hook-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the hook."),
            )
            .about(
                "Test the push repository webhook\n\nThis will trigger the hook with the latest \
                 push to the current repository if the hook is subscribed to `push` events. If \
                 the hook is not subscribed to `push` events, the server will respond with 204 \
                 but no test POST will be generated.\n\n**Note**: Previously \
                 `/repos/:owner/:repo/hooks/:hook_id/test`",
            )
    }

    pub fn cli_migrations_get_import_status() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Get an import status\n\nView the progress of an import.\n\n**Warning:** Support for importing Mercurial, Subversion and Team Foundation Version Control repositories will end\non October 17, 2023. For more details, see [changelog](https://gh.io/github-importer-non-git-eol). In the coming weeks, we will update\nthese docs to reflect relevant changes to the API and will contact all integrators using the \"Source imports\" API.\n\n**Import status**\n\nThis section includes details about the possible values of the `status` field of the Import Progress response.\n\nAn import that does not have errors will progress through these steps:\n\n*   `detecting` - the \"detection\" step of the import is in progress because the request did not include a `vcs` parameter. The import is identifying the type of source control present at the URL.\n*   `importing` - the \"raw\" step of the import is in progress. This is where commit data is fetched from the original repository. The import progress response will include `commit_count` (the total number of raw commits that will be imported) and `percent` (0 - 100, the current progress through the import).\n*   `mapping` - the \"rewrite\" step of the import is in progress. This is where SVN branches are converted to Git branches, and where author updates are applied. The import progress response does not include progress information.\n*   `pushing` - the \"push\" step of the import is in progress. This is where the importer updates the repository on GitHub. The import progress response will include `push_percent`, which is the percent value reported by `git push` when it is \"Writing objects\".\n*   `complete` - the import is complete, and the repository is ready on GitHub.\n\nIf there are problems, you will see one of these in the `status` field:\n\n*   `auth_failed` - the import requires authentication in order to connect to the original repository. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/migrations/source-imports#update-an-import) section.\n*   `error` - the import encountered an error. The import progress response will include the `failed_step` and an error message. Contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api) for more information.\n*   `detection_needs_auth` - the importer requires authentication for the originating repository to continue detection. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/migrations/source-imports#update-an-import) section.\n*   `detection_found_nothing` - the importer didn't recognize any source control at the URL. To resolve, [Cancel the import](https://docs.github.com/rest/migrations/source-imports#cancel-an-import) and [retry](https://docs.github.com/rest/migrations/source-imports#start-an-import) with the correct URL.\n*   `detection_found_multiple` - the importer found several projects or repositories at the provided URL. When this is the case, the Import Progress response will also include a `project_choices` field with the possible project choices as values. To update project choice, please see the [Update an import](https://docs.github.com/rest/migrations/source-imports#update-an-import) section.\n\n**The project_choices field**\n\nWhen multiple projects are found at the provided URL, the response hash will include a `project_choices` field, the value of which is an array of hashes each representing a project choice. The exact key/value pairs of the project hashes will differ depending on the version control type.\n\n**Git LFS related fields**\n\nThis section includes details about Git LFS related fields that may be present in the Import Progress response.\n\n*   `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value can be `opt_in`, `opt_out`, or `undecided` if no action has been taken.\n*   `has_large_files` - the boolean value describing whether files larger than 100MB were found during the `importing` step.\n*   `large_files_size` - the total size in gigabytes of files larger than 100MB found in the originating repository.\n*   `large_files_count` - the total number of files larger than 100MB found in the originating repository. To see a list of these files, make a \"Get Large Files\" request.")
    }

    pub fn cli_migrations_start_import() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("tfvc-project") . long ("tfvc-project") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("For a tfvc import, the name of the project that is being imported.")) . arg (clap :: Arg :: new ("vcs") . long ("vcs") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: MigrationsStartImportBodyVcs :: Subversion . to_string () , types :: MigrationsStartImportBodyVcs :: Git . to_string () , types :: MigrationsStartImportBodyVcs :: Mercurial . to_string () , types :: MigrationsStartImportBodyVcs :: Tfvc . to_string () ,]) , | s | types :: MigrationsStartImportBodyVcs :: try_from (s) . unwrap ())) . help ("The originating VCS type. Without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response.")) . arg (clap :: Arg :: new ("vcs-password") . long ("vcs-password") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("If authentication is required, the password to provide to `vcs_url`.")) . arg (clap :: Arg :: new ("vcs-url") . long ("vcs-url") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The URL of the originating repository.")) . arg (clap :: Arg :: new ("vcs-username") . long ("vcs-username") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("If authentication is required, the username to provide to `vcs_url`.")) . about ("Start an import\n\nStart a source import to a GitHub repository using GitHub Importer. Importing into a GitHub repository with GitHub Actions enabled is not supported and will return a status `422 Unprocessable Entity` response.\n**Warning:** Support for importing Mercurial, Subversion and Team Foundation Version Control repositories will end on October 17, 2023. For more details, see [changelog](https://gh.io/github-importer-non-git-eol). In the coming weeks, we will update these docs to reflect relevant changes to the API and will contact all integrators using the \"Source imports\" API.")
    }

    pub fn cli_migrations_cancel_import() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Cancel an import\n\nStop an import for a repository.\n\n**Warning:** Support for importing Mercurial, Subversion and Team Foundation Version Control repositories will end\non October 17, 2023. For more details, see [changelog](https://gh.io/github-importer-non-git-eol). In the coming weeks, we will update\nthese docs to reflect relevant changes to the API and will contact all integrators using the \"Source imports\" API.\n")
    }

    pub fn cli_migrations_update_import() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Update an import\n\nAn import can be updated with credentials or a project choice by passing in the appropriate parameters in this API\nrequest. If no parameters are provided, the import will be restarted.\n\nSome servers (e.g. TFS servers) can have several projects at a single URL. In those cases the import progress will\nhave the status `detection_found_multiple` and the Import Progress response will include a `project_choices` array.\nYou can select the project to import by providing one of the objects in the `project_choices` array in the update request.\n\n**Warning:** Support for importing Mercurial, Subversion and Team Foundation Version Control repositories will end\non October 17, 2023. For more details, see [changelog](https://gh.io/github-importer-non-git-eol). In the coming weeks, we will update\nthese docs to reflect relevant changes to the API and will contact all integrators using the \"Source imports\" API.")
    }

    pub fn cli_migrations_get_commit_authors() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("A user ID. Only return users with an ID greater than this ID.")) . about ("Get commit authors\n\nEach type of source control system represents authors in a different way. For example, a Git commit author has a display name and an email address, but a Subversion commit author just has a username. The GitHub Importer will make the author information valid, but the author might not be correct. For example, it will change the bare Subversion username `hubot` into something like `hubot <hubot@12341234-abab-fefe-8787-fedcba987654>`.\n\nThis endpoint and the [Map a commit author](https://docs.github.com/rest/migrations/source-imports#map-a-commit-author) endpoint allow you to provide correct Git author information.\n\n**Warning:** Support for importing Mercurial, Subversion and Team Foundation Version Control repositories will end\non October 17, 2023. For more details, see [changelog](https://gh.io/github-importer-non-git-eol). In the coming weeks, we will update\nthese docs to reflect relevant changes to the API and will contact all integrators using the \"Source imports\" API.")
    }

    pub fn cli_migrations_map_commit_author() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("author-id") . long ("author-id") . required (true) . value_parser (clap :: value_parser ! (i64))) . arg (clap :: Arg :: new ("email") . long ("email") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The new Git author email.")) . arg (clap :: Arg :: new ("name") . long ("name") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The new Git author name.")) . about ("Map a commit author\n\nUpdate an author's identity for the import. Your application can continue updating authors any time before you push\nnew commits to the repository.\n\n**Warning:** Support for importing Mercurial, Subversion and Team Foundation Version Control repositories will end\non October 17, 2023. For more details, see [changelog](https://gh.io/github-importer-non-git-eol). In the coming weeks, we will update\nthese docs to reflect relevant changes to the API and will contact all integrators using the \"Source imports\" API.\n")
    }

    pub fn cli_migrations_get_large_files() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Get large files\n\nList files larger than 100MB found during the import\n\n**Warning:** Support for importing Mercurial, Subversion and Team Foundation Version Control repositories will end\non October 17, 2023. For more details, see [changelog](https://gh.io/github-importer-non-git-eol). In the coming weeks, we will update\nthese docs to reflect relevant changes to the API and will contact all integrators using the \"Source imports\" API.\n")
    }

    pub fn cli_migrations_set_lfs_preference() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("use-lfs") . long ("use-lfs") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: MigrationsSetLfsPreferenceBodyUseLfs :: OptIn . to_string () , types :: MigrationsSetLfsPreferenceBodyUseLfs :: OptOut . to_string () ,]) , | s | types :: MigrationsSetLfsPreferenceBodyUseLfs :: try_from (s) . unwrap ())) . help ("Whether to store large files during the import. `opt_in` means large files will be stored using Git LFS. `opt_out` means large files will be removed during the import.")) . about ("Update Git LFS preference\n\nYou can import repositories from Subversion, Mercurial, and TFS that include files larger than 100MB. This ability\nis powered by [Git LFS](https://git-lfs.com).\n\nYou can learn more about our LFS feature and working with large files [on our help\nsite](https://docs.github.com/repositories/working-with-files/managing-large-files).\n\n**Warning:** Support for importing Mercurial, Subversion and Team Foundation Version Control repositories will end\non October 17, 2023. For more details, see [changelog](https://gh.io/github-importer-non-git-eol). In the coming weeks, we will update\nthese docs to reflect relevant changes to the API and will contact all integrators using the \"Source imports\" API.\n")
    }

    pub fn cli_apps_get_repo_installation() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Get a repository installation for the authenticated app\n\nEnables an authenticated GitHub App to find the repository's installation information. The installation's account type will be either an organization or a user account, depending which account the repository belongs to.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_interactions_get_restrictions_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get interaction restrictions for a repository\n\nShows which type of GitHub user \
                 can interact with this repository and when the restriction expires. If there are \
                 no restrictions, you will see an empty response.",
            )
    }

    pub fn cli_interactions_set_restrictions_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("expiry")
                    .long("expiry")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::InteractionExpiry::OneDay.to_string(),
                            types::InteractionExpiry::ThreeDays.to_string(),
                            types::InteractionExpiry::OneWeek.to_string(),
                            types::InteractionExpiry::OneMonth.to_string(),
                            types::InteractionExpiry::SixMonths.to_string(),
                        ]),
                        |s| types::InteractionExpiry::try_from(s).unwrap(),
                    )),
            )
            .arg(
                clap::Arg::new("limit")
                    .long("limit")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::InteractionGroup::ExistingUsers.to_string(),
                            types::InteractionGroup::ContributorsOnly.to_string(),
                            types::InteractionGroup::CollaboratorsOnly.to_string(),
                        ]),
                        |s| types::InteractionGroup::try_from(s).unwrap(),
                    )),
            )
            .about(
                "Set interaction restrictions for a repository\n\nTemporarily restricts \
                 interactions to a certain type of GitHub user within the given repository. You \
                 must have owner or admin access to set these restrictions. If an interaction \
                 limit is set for the user or organization that owns this repository, you will \
                 receive a `409 Conflict` response and will not be able to use this endpoint to \
                 change the interaction limit for a single repository.",
            )
    }

    pub fn cli_interactions_remove_restrictions_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Remove interaction restrictions for a repository\n\nRemoves all interaction \
                 restrictions from the given repository. You must have owner or admin access to \
                 remove restrictions. If the interaction limit is set for the user or \
                 organization that owns this repository, you will receive a `409 Conflict` \
                 response and will not be able to use this endpoint to change the interaction \
                 limit for a single repository.",
            )
    }

    pub fn cli_repos_list_invitations() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repository invitations\n\nWhen authenticating as a user with admin rights \
                 to a repository, this endpoint will list all currently open repository \
                 invitations.",
            )
    }

    pub fn cli_repos_delete_invitation() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("invitation-id")
                    .long("invitation-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the invitation."),
            )
            .about("Delete a repository invitation")
    }

    pub fn cli_repos_update_invitation() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("invitation-id")
                    .long("invitation-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the invitation."),
            )
            .arg(
                clap::Arg::new("permissions")
                    .long("permissions")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposUpdateInvitationBodyPermissions::Read.to_string(),
                            types::ReposUpdateInvitationBodyPermissions::Write.to_string(),
                            types::ReposUpdateInvitationBodyPermissions::Maintain.to_string(),
                            types::ReposUpdateInvitationBodyPermissions::Triage.to_string(),
                            types::ReposUpdateInvitationBodyPermissions::Admin.to_string(),
                        ]),
                        |s| types::ReposUpdateInvitationBodyPermissions::try_from(s).unwrap(),
                    ))
                    .help(
                        "The permissions that the associated user will have on the repository. \
                         Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.",
                    ),
            )
            .about("Update a repository invitation")
    }

    pub fn cli_issues_list_for_repo() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("assignee") . long ("assignee") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.")) . arg (clap :: Arg :: new ("creator") . long ("creator") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The user that created the issue.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListForRepoDirection :: Asc . to_string () , types :: IssuesListForRepoDirection :: Desc . to_string () ,]) , | s | types :: IssuesListForRepoDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("labels") . long ("labels") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A list of comma separated label names. Example: `bug,ui,@high`")) . arg (clap :: Arg :: new ("mentioned") . long ("mentioned") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A user that's mentioned in the issue.")) . arg (clap :: Arg :: new ("milestone") . long ("milestone") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListForRepoSort :: Created . to_string () , types :: IssuesListForRepoSort :: Updated . to_string () , types :: IssuesListForRepoSort :: Comments . to_string () ,]) , | s | types :: IssuesListForRepoSort :: try_from (s) . unwrap ())) . help ("What to sort results by.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListForRepoState :: Open . to_string () , types :: IssuesListForRepoState :: Closed . to_string () , types :: IssuesListForRepoState :: All . to_string () ,]) , | s | types :: IssuesListForRepoState :: try_from (s) . unwrap ())) . help ("Indicates the state of the issues to return.")) . about ("List repository issues\n\nList issues in a repository. Only open issues will be listed.\n\n**Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this\nreason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by\nthe `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull\nrequest id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.")
    }

    pub fn cli_issues_create() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("assignee") . long ("assignee") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is deprecated.**_")) . arg (clap :: Arg :: new ("body") . long ("body") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The contents of the issue.")) . arg (clap :: Arg :: new ("milestone") . long ("milestone") . required (false) . value_parser (clap :: value_parser ! (types :: IssuesCreateBodyMilestone))) . arg (clap :: Arg :: new ("title") . long ("title") . required (true) . value_parser (clap :: value_parser ! (types :: IssuesCreateBodyTitle)) . help ("The title of the issue.")) . about ("Create an issue\n\nAny user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.")
    }

    pub fn cli_issues_list_comments_for_repo() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListCommentsForRepoDirection :: Asc . to_string () , types :: IssuesListCommentsForRepoDirection :: Desc . to_string () ,]) , | s | types :: IssuesListCommentsForRepoDirection :: try_from (s) . unwrap ())) . help ("Either `asc` or `desc`. Ignored without the `sort` parameter.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListCommentsForRepoSort :: Created . to_string () , types :: IssuesListCommentsForRepoSort :: Updated . to_string () ,]) , | s | types :: IssuesListCommentsForRepoSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by.")) . about ("List issue comments for a repository\n\nYou can use the REST API to list comments on issues and pull requests for a repository. Every pull request is an issue, but not every issue is a pull request.\n\nBy default, issue comments are ordered by ascending ID.")
    }

    pub fn cli_issues_get_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .about(
                "Get an issue comment\n\nYou can use the REST API to get comments on issues and \
                 pull requests. Every pull request is an issue, but not every issue is a pull \
                 request.",
            )
    }

    pub fn cli_issues_delete_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .about(
                "Delete an issue comment\n\nYou can use the REST API to delete comments on issues \
                 and pull requests. Every pull request is an issue, but not every issue is a pull \
                 request.",
            )
    }

    pub fn cli_issues_update_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .arg(
                clap::Arg::new("body")
                    .long("body")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The contents of the comment."),
            )
            .about(
                "Update an issue comment\n\nYou can use the REST API to update comments on issues \
                 and pull requests. Every pull request is an issue, but not every issue is a pull \
                 request.",
            )
    }

    pub fn cli_reactions_list_for_issue_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("comment-id") . long ("comment-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the comment.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsListForIssueCommentContent :: plus1 . to_string () , types :: ReactionsListForIssueCommentContent :: minus1 . to_string () , types :: ReactionsListForIssueCommentContent :: Laugh . to_string () , types :: ReactionsListForIssueCommentContent :: Confused . to_string () , types :: ReactionsListForIssueCommentContent :: Heart . to_string () , types :: ReactionsListForIssueCommentContent :: Hooray . to_string () , types :: ReactionsListForIssueCommentContent :: Rocket . to_string () , types :: ReactionsListForIssueCommentContent :: Eyes . to_string () ,]) , | s | types :: ReactionsListForIssueCommentContent :: try_from (s) . unwrap ())) . help ("Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue comment.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List reactions for an issue comment\n\nList the reactions to an [issue comment](https://docs.github.com/rest/reference/issues#comments).")
    }

    pub fn cli_reactions_create_for_issue_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("comment-id") . long ("comment-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the comment.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsCreateForIssueCommentBodyContent :: plus1 . to_string () , types :: ReactionsCreateForIssueCommentBodyContent :: minus1 . to_string () , types :: ReactionsCreateForIssueCommentBodyContent :: Laugh . to_string () , types :: ReactionsCreateForIssueCommentBodyContent :: Confused . to_string () , types :: ReactionsCreateForIssueCommentBodyContent :: Heart . to_string () , types :: ReactionsCreateForIssueCommentBodyContent :: Hooray . to_string () , types :: ReactionsCreateForIssueCommentBodyContent :: Rocket . to_string () , types :: ReactionsCreateForIssueCommentBodyContent :: Eyes . to_string () ,]) , | s | types :: ReactionsCreateForIssueCommentBodyContent :: try_from (s) . unwrap ())) . help ("The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the issue comment.")) . about ("Create reaction for an issue comment\n\nCreate a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments). A response with an HTTP `200` status means that you already added the reaction type to this issue comment.")
    }

    pub fn cli_reactions_delete_for_issue_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("comment-id") . long ("comment-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the comment.")) . arg (clap :: Arg :: new ("reaction-id") . long ("reaction-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the reaction.")) . about ("Delete an issue comment reaction\n\n**Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.\n\nDelete a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments).")
    }

    pub fn cli_issues_list_events_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List issue events for a repository")
    }

    pub fn cli_issues_get_event() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("event-id")
                    .long("event-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64)),
            )
            .about("Get an issue event")
    }

    pub fn cli_issues_get() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("issue-number") . long ("issue-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the issue.")) . about ("Get an issue\n\nThe API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was\n[transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If\nthe issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API\nreturns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read\naccess, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe\nto the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.\n\n**Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this\nreason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by\nthe `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull\nrequest id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.")
    }

    pub fn cli_issues_update() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .arg(
                clap::Arg::new("assignee")
                    .long("assignee")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Username to assign to this issue. **This field is deprecated.**"),
            )
            .arg(
                clap::Arg::new("body")
                    .long("body")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The contents of the issue."),
            )
            .arg(
                clap::Arg::new("milestone")
                    .long("milestone")
                    .required(false)
                    .value_parser(clap::value_parser!(types::IssuesUpdateBodyMilestone)),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::IssuesUpdateBodyState::Open.to_string(),
                            types::IssuesUpdateBodyState::Closed.to_string(),
                        ]),
                        |s| types::IssuesUpdateBodyState::try_from(s).unwrap(),
                    ))
                    .help("The open or closed state of the issue."),
            )
            .arg(
                clap::Arg::new("state-reason")
                    .long("state-reason")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::IssuesUpdateBodyStateReason::Completed.to_string(),
                            types::IssuesUpdateBodyStateReason::NotPlanned.to_string(),
                            types::IssuesUpdateBodyStateReason::Reopened.to_string(),
                        ]),
                        |s| types::IssuesUpdateBodyStateReason::try_from(s).unwrap(),
                    ))
                    .help("The reason for the state change. Ignored unless `state` is changed."),
            )
            .arg(
                clap::Arg::new("title")
                    .long("title")
                    .required(false)
                    .value_parser(clap::value_parser!(types::IssuesUpdateBodyTitle))
                    .help("The title of the issue."),
            )
            .about("Update an issue\n\nIssue owners and users with push access can edit an issue.")
    }

    pub fn cli_issues_add_assignees() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .about(
                "Add assignees to an issue\n\nAdds up to 10 assignees to an issue. Users already \
                 assigned to an issue are not replaced.",
            )
    }

    pub fn cli_issues_remove_assignees() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .about("Remove assignees from an issue\n\nRemoves one or more assignees from an issue.")
    }

    pub fn cli_issues_check_user_can_be_assigned_to_issue() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .arg(
                clap::Arg::new("assignee")
                    .long("assignee")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about(
                "Check if a user can be assigned to a issue\n\nChecks if a user has permission to \
                 be assigned to a specific issue.\n\nIf the `assignee` can be assigned to this \
                 issue, a `204` status code with no content is returned.\n\nOtherwise a `404` \
                 status code is returned.",
            )
    }

    pub fn cli_issues_list_comments() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("issue-number") . long ("issue-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the issue.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . about ("List issue comments\n\nYou can use the REST API to list comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.\n\nIssue comments are ordered by ascending ID.")
    }

    pub fn cli_issues_create_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("issue-number") . long ("issue-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the issue.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The contents of the comment.")) . about ("Create an issue comment\n\n\nYou can use the REST API to create comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).\nCreating content too quickly using this endpoint may result in secondary rate limiting.\nSee \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\"\nand \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\"\nfor details.")
    }

    pub fn cli_issues_list_events() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List issue events")
    }

    pub fn cli_issues_list_labels_on_issue() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List labels for an issue")
    }

    pub fn cli_issues_set_labels() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .about(
                "Set labels for an issue\n\nRemoves any previous labels and sets the new labels \
                 for an issue.",
            )
    }

    pub fn cli_issues_add_labels() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .about("Add labels to an issue")
    }

    pub fn cli_issues_remove_all_labels() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .about("Remove all labels from an issue")
    }

    pub fn cli_issues_remove_label() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about(
                "Remove a label from an issue\n\nRemoves the specified label from the issue, and \
                 returns the remaining labels on the issue. This endpoint returns a `404 Not \
                 Found` status if the label does not exist.",
            )
    }

    pub fn cli_issues_lock() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("issue-number") . long ("issue-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the issue.")) . about ("Lock an issue\n\nUsers with push access can lock an issue or pull request's conversation.\n\nNote that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"")
    }

    pub fn cli_issues_unlock() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .about("Unlock an issue\n\nUsers with push access can unlock an issue's conversation.")
    }

    pub fn cli_reactions_list_for_issue() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("issue-number") . long ("issue-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the issue.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsListForIssueContent :: plus1 . to_string () , types :: ReactionsListForIssueContent :: minus1 . to_string () , types :: ReactionsListForIssueContent :: Laugh . to_string () , types :: ReactionsListForIssueContent :: Confused . to_string () , types :: ReactionsListForIssueContent :: Heart . to_string () , types :: ReactionsListForIssueContent :: Hooray . to_string () , types :: ReactionsListForIssueContent :: Rocket . to_string () , types :: ReactionsListForIssueContent :: Eyes . to_string () ,]) , | s | types :: ReactionsListForIssueContent :: try_from (s) . unwrap ())) . help ("Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to an issue.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List reactions for an issue\n\nList the reactions to an [issue](https://docs.github.com/rest/reference/issues).")
    }

    pub fn cli_reactions_create_for_issue() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("issue-number") . long ("issue-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the issue.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsCreateForIssueBodyContent :: plus1 . to_string () , types :: ReactionsCreateForIssueBodyContent :: minus1 . to_string () , types :: ReactionsCreateForIssueBodyContent :: Laugh . to_string () , types :: ReactionsCreateForIssueBodyContent :: Confused . to_string () , types :: ReactionsCreateForIssueBodyContent :: Heart . to_string () , types :: ReactionsCreateForIssueBodyContent :: Hooray . to_string () , types :: ReactionsCreateForIssueBodyContent :: Rocket . to_string () , types :: ReactionsCreateForIssueBodyContent :: Eyes . to_string () ,]) , | s | types :: ReactionsCreateForIssueBodyContent :: try_from (s) . unwrap ())) . help ("The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the issue.")) . about ("Create reaction for an issue\n\nCreate a reaction to an [issue](https://docs.github.com/rest/reference/issues/). A response with an HTTP `200` status means that you already added the reaction type to this issue.")
    }

    pub fn cli_reactions_delete_for_issue() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("issue-number") . long ("issue-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the issue.")) . arg (clap :: Arg :: new ("reaction-id") . long ("reaction-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the reaction.")) . about ("Delete an issue reaction\n\n**Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.\n\nDelete a reaction to an [issue](https://docs.github.com/rest/reference/issues/).")
    }

    pub fn cli_issues_list_events_for_timeline() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("issue-number")
                    .long("issue-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the issue."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List timeline events for an issue")
    }

    pub fn cli_repos_list_deploy_keys() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List deploy keys")
    }

    pub fn cli_repos_create_deploy_key() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("key") . long ("key") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The contents of the key.")) . arg (clap :: Arg :: new ("read-only") . long ("read-only") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  \n  \nDeploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see \"[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)\" and \"[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/).\"")) . arg (clap :: Arg :: new ("title") . long ("title") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A name for the key.")) . about ("Create a deploy key\n\nYou can create a read-only deploy key.")
    }

    pub fn cli_repos_get_deploy_key() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("key-id")
                    .long("key-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the key."),
            )
            .about("Get a deploy key")
    }

    pub fn cli_repos_delete_deploy_key() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("key-id")
                    .long("key-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the key."),
            )
            .about(
                "Delete a deploy key\n\nDeploy keys are immutable. If you need to update a key, \
                 remove the key and create a new one instead.",
            )
    }

    pub fn cli_issues_list_labels_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List labels for a repository")
    }

    pub fn cli_issues_create_label() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("color") . long ("color") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.")) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A short description of the label. Must be 100 characters or fewer.")) . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png \":strawberry:\"). For a full list of available emoji and codes, see \"[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet).\"")) . about ("Create a label")
    }

    pub fn cli_issues_get_label() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about("Get a label")
    }

    pub fn cli_issues_delete_label() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about("Delete a label")
    }

    pub fn cli_issues_update_label() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String))) . arg (clap :: Arg :: new ("color") . long ("color") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.")) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A short description of the label. Must be 100 characters or fewer.")) . arg (clap :: Arg :: new ("new-name") . long ("new-name") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png \":strawberry:\"). For a full list of available emoji and codes, see \"[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet).\"")) . about ("Update a label")
    }

    pub fn cli_repos_list_languages() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "List repository languages\n\nLists languages for the specified repository. The \
                 value shown for each language is the number of bytes of code written in that \
                 language.",
            )
    }

    pub fn cli_repos_enable_lfs_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Enable Git LFS for a repository\n\nEnables Git LFS for a repository. Access \
                 tokens must have the `admin:enterprise` scope.",
            )
    }

    pub fn cli_repos_disable_lfs_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Disable Git LFS for a repository\n\nDisables Git LFS for a repository. Access \
                 tokens must have the `admin:enterprise` scope.",
            )
    }

    pub fn cli_licenses_get_for_repo() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Get the license for a repository\n\nThis method returns the contents of the repository's license file, if one is detected.\n\nSimilar to [Get repository content](https://docs.github.com/rest/reference/repos#get-repository-content), this method also supports [custom media types](https://docs.github.com/rest/overview/media-types) for retrieving the raw license content or rendered license HTML.")
    }

    pub fn cli_repos_merge_upstream() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("branch")
                    .long("branch")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the branch which should be updated to match upstream."),
            )
            .about(
                "Sync a fork branch with the upstream repository\n\nSync a branch of a forked \
                 repository to keep it up-to-date with the upstream repository.",
            )
    }

    pub fn cli_repos_merge() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("base")
                    .long("base")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the base branch that the head will be merged into."),
            )
            .arg(
                clap::Arg::new("commit-message")
                    .long("commit-message")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "Commit message to use for the merge commit. If omitted, a default \
                         message will be used.",
                    ),
            )
            .arg(
                clap::Arg::new("head")
                    .long("head")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The head to merge. This can be a branch name or a commit SHA1."),
            )
            .about("Merge a branch")
    }

    pub fn cli_issues_list_milestones() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("direction")
                    .long("direction")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::IssuesListMilestonesDirection::Asc.to_string(),
                            types::IssuesListMilestonesDirection::Desc.to_string(),
                        ]),
                        |s| types::IssuesListMilestonesDirection::try_from(s).unwrap(),
                    ))
                    .help("The direction of the sort. Either `asc` or `desc`."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("sort")
                    .long("sort")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::IssuesListMilestonesSort::DueOn.to_string(),
                            types::IssuesListMilestonesSort::Completeness.to_string(),
                        ]),
                        |s| types::IssuesListMilestonesSort::try_from(s).unwrap(),
                    ))
                    .help("What to sort results by. Either `due_on` or `completeness`."),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::IssuesListMilestonesState::Open.to_string(),
                            types::IssuesListMilestonesState::Closed.to_string(),
                            types::IssuesListMilestonesState::All.to_string(),
                        ]),
                        |s| types::IssuesListMilestonesState::try_from(s).unwrap(),
                    ))
                    .help("The state of the milestone. Either `open`, `closed`, or `all`."),
            )
            .about("List milestones")
    }

    pub fn cli_issues_create_milestone() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A description of the milestone.")) . arg (clap :: Arg :: new ("due-on") . long ("due-on") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesCreateMilestoneBodyState :: Open . to_string () , types :: IssuesCreateMilestoneBodyState :: Closed . to_string () ,]) , | s | types :: IssuesCreateMilestoneBodyState :: try_from (s) . unwrap ())) . help ("The state of the milestone. Either `open` or `closed`.")) . arg (clap :: Arg :: new ("title") . long ("title") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The title of the milestone.")) . about ("Create a milestone")
    }

    pub fn cli_issues_get_milestone() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("milestone-number")
                    .long("milestone-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the milestone."),
            )
            .about("Get a milestone")
    }

    pub fn cli_issues_delete_milestone() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("milestone-number")
                    .long("milestone-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the milestone."),
            )
            .about("Delete a milestone")
    }

    pub fn cli_issues_update_milestone() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("milestone-number") . long ("milestone-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the milestone.")) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A description of the milestone.")) . arg (clap :: Arg :: new ("due-on") . long ("due-on") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesUpdateMilestoneBodyState :: Open . to_string () , types :: IssuesUpdateMilestoneBodyState :: Closed . to_string () ,]) , | s | types :: IssuesUpdateMilestoneBodyState :: try_from (s) . unwrap ())) . help ("The state of the milestone. Either `open` or `closed`.")) . arg (clap :: Arg :: new ("title") . long ("title") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The title of the milestone.")) . about ("Update a milestone")
    }

    pub fn cli_issues_list_labels_for_milestone() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("milestone-number")
                    .long("milestone-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the milestone."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List labels for issues in a milestone")
    }

    pub fn cli_activity_list_repo_notifications_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("all") . long ("all") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("If `true`, show notifications marked as read.")) . arg (clap :: Arg :: new ("before") . long ("before") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("participating") . long ("participating") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("If `true`, only shows notifications in which the user is directly participating or mentioned.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . about ("List repository notifications for the authenticated user\n\nLists all notifications for the current user in the specified repository.")
    }

    pub fn cli_activity_mark_repo_notifications_as_read() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("last-read-at") . long ("last-read-at") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.")) . about ("Mark repository notifications as read\n\nMarks all notifications in a repository as \"read\" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as \"read.\" To check whether any \"unread\" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.")
    }

    pub fn cli_repos_get_pages() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about("Get a GitHub Pages site")
    }

    pub fn cli_repos_update_information_about_pages_site() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("build-type") . long ("build-type") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposUpdateInformationAboutPagesSiteBodyBuildType :: Legacy . to_string () , types :: ReposUpdateInformationAboutPagesSiteBodyBuildType :: Workflow . to_string () ,]) , | s | types :: ReposUpdateInformationAboutPagesSiteBodyBuildType :: try_from (s) . unwrap ())) . help ("The process by which the GitHub Pages site will be built. `workflow` means that the site is built by a custom GitHub Actions workflow. `legacy` means that the site is built by GitHub when changes are pushed to a specific branch.")) . arg (clap :: Arg :: new ("cname") . long ("cname") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Specify a custom domain for the repository. Sending a `null` value will remove the custom domain. For more about custom domains, see \"[Using a custom domain with GitHub Pages](https://docs.github.com/articles/using-a-custom-domain-with-github-pages/).\"")) . arg (clap :: Arg :: new ("https-enforced") . long ("https-enforced") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Specify whether HTTPS should be enforced for the repository.")) . about ("Update information about a GitHub Pages site\n\nUpdates information for a GitHub Pages site. For more information, see \"[About GitHub Pages](/github/working-with-github-pages/about-github-pages).\n\nTo use this endpoint, you must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission. A token with the `repo` scope or Pages write permission is required. GitHub Apps must have the `administration:write` and `pages:write` permissions.")
    }

    pub fn cli_repos_create_pages_site() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Create a GitHub Pages site\n\nConfigures a GitHub Pages site. For more \
                 information, see \"[About GitHub \
                 Pages](/github/working-with-github-pages/about-github-pages).\"\n\nTo use this \
                 endpoint, you must be a repository administrator, maintainer, or have the \
                 'manage GitHub Pages settings' permission. A token with the `repo` scope or \
                 Pages write permission is required. GitHub Apps must have the \
                 `administration:write` and `pages:write` permissions.",
            )
    }

    pub fn cli_repos_delete_pages_site() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Delete a GitHub Pages site\n\nDeletes a GitHub Pages site. For more information, \
                 see \"[About GitHub \
                 Pages](/github/working-with-github-pages/about-github-pages).\n\nTo use this \
                 endpoint, you must be a repository administrator, maintainer, or have the \
                 'manage GitHub Pages settings' permission. A token with the `repo` scope or \
                 Pages write permission is required. GitHub Apps must have the \
                 `administration:write` and `pages:write` permissions.",
            )
    }

    pub fn cli_repos_list_pages_builds() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List GitHub Pages builds")
    }

    pub fn cli_repos_request_pages_build() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Request a GitHub Pages build\n\nYou can request that your site be built from the \
                 latest revision on the default branch. This has the same effect as pushing a \
                 commit to your default branch, but does not require an additional commit. \
                 Manually triggering page builds can be helpful when diagnosing build warnings \
                 and failures.\n\nBuild requests are limited to one concurrent build per \
                 repository and one concurrent build per requester. If you request a build while \
                 another is still in progress, the second request will be queued until the first \
                 completes.",
            )
    }

    pub fn cli_repos_get_latest_pages_build() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about("Get latest Pages build")
    }

    pub fn cli_repos_get_pages_build() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("build-id")
                    .long("build-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64)),
            )
            .about("Get GitHub Pages build")
    }

    pub fn cli_repos_create_pages_deployment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("artifact-url")
                    .long("artifact-url")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The URL of an artifact that contains the .zip or .tar of static assets \
                         to deploy. The artifact belongs to the repository.",
                    ),
            )
            .arg(
                clap::Arg::new("environment")
                    .long("environment")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The target environment for this GitHub Pages deployment."),
            )
            .arg(
                clap::Arg::new("oidc-token")
                    .long("oidc-token")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The OIDC token issued by GitHub Actions certifying the origin of the \
                         deployment.",
                    ),
            )
            .arg(
                clap::Arg::new("pages-build-version")
                    .long("pages-build-version")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "A unique string that represents the version of the build for this \
                         deployment.",
                    ),
            )
            .about(
                "Create a GitHub Pages deployment\n\nCreate a GitHub Pages deployment for a \
                 repository.\n\nUsers must have write permissions. GitHub Apps must have the \
                 `pages:write` permission to use this endpoint.",
            )
    }

    pub fn cli_repos_get_pages_health_check() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get a DNS health check for GitHub Pages\n\nGets a health check of the DNS \
                 settings for the `CNAME` record configured for a repository's GitHub \
                 Pages.\n\nThe first request to this endpoint returns a `202 Accepted` status and \
                 starts an asynchronous background task to get the results for the domain. After \
                 the background task completes, subsequent requests to this endpoint return a \
                 `200 OK` status with the health check results in the response.\n\nTo use this \
                 endpoint, you must be a repository administrator, maintainer, or have the \
                 'manage GitHub Pages settings' permission. A token with the `repo` scope or \
                 Pages write permission is required. GitHub Apps must have the \
                 `administrative:write` and `pages:write` permissions.",
            )
    }

    pub fn cli_projects_list_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ProjectsListForRepoState::Open.to_string(),
                            types::ProjectsListForRepoState::Closed.to_string(),
                            types::ProjectsListForRepoState::All.to_string(),
                        ]),
                        |s| types::ProjectsListForRepoState::try_from(s).unwrap(),
                    ))
                    .help("Indicates the state of the projects to return."),
            )
            .about(
                "List repository projects\n\nLists the projects in a repository. Returns a `404 \
                 Not Found` status if projects are disabled in the repository. If you do not have \
                 sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` \
                 status is returned.",
            )
    }

    pub fn cli_projects_create_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("body")
                    .long("body")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The description of the project."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the project."),
            )
            .about(
                "Create a repository project\n\nCreates a repository project board. Returns a \
                 `410 Gone` status if projects are disabled in the repository or if the \
                 repository does not have existing classic projects. If you do not have \
                 sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` \
                 status is returned.",
            )
    }

    pub fn cli_pulls_list() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("base") . long ("base") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Filter pulls by base branch name. Example: `gh-pages`.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsListDirection :: Asc . to_string () , types :: PullsListDirection :: Desc . to_string () ,]) , | s | types :: PullsListDirection :: try_from (s) . unwrap ())) . help ("The direction of the sort. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`.")) . arg (clap :: Arg :: new ("head") . long ("head") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsListSort :: Created . to_string () , types :: PullsListSort :: Updated . to_string () , types :: PullsListSort :: Popularity . to_string () , types :: PullsListSort :: LongRunning . to_string () ,]) , | s | types :: PullsListSort :: try_from (s) . unwrap ())) . help ("What to sort results by. `popularity` will sort by the number of comments. `long-running` will sort by date created and will limit the results to pull requests that have been open for more than a month and have had activity within the past month.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsListState :: Open . to_string () , types :: PullsListState :: Closed . to_string () , types :: PullsListState :: All . to_string () ,]) , | s | types :: PullsListState :: try_from (s) . unwrap ())) . help ("Either `open`, `closed`, or `all` to filter by state.")) . about ("List pull requests\n\nDraft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.")
    }

    pub fn cli_pulls_create() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("base") . long ("base") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The contents of the pull request.")) . arg (clap :: Arg :: new ("draft") . long ("draft") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Indicates whether the pull request is a draft. See \"[Draft Pull Requests](https://docs.github.com/articles/about-pull-requests#draft-pull-requests)\" in the GitHub Help documentation to learn more.")) . arg (clap :: Arg :: new ("head") . long ("head") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`.")) . arg (clap :: Arg :: new ("head-repo") . long ("head-repo") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization.")) . arg (clap :: Arg :: new ("issue") . long ("issue") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified.")) . arg (clap :: Arg :: new ("maintainer-can-modify") . long ("maintainer-can-modify") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.")) . arg (clap :: Arg :: new ("title") . long ("title") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The title of the new pull request. Required unless `issue` is specified.")) . about ("Create a pull request\n\nDraft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nTo open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)\" for details.")
    }

    pub fn cli_pulls_list_review_comments_for_repo() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsListReviewCommentsForRepoDirection :: Asc . to_string () , types :: PullsListReviewCommentsForRepoDirection :: Desc . to_string () ,]) , | s | types :: PullsListReviewCommentsForRepoDirection :: try_from (s) . unwrap ())) . help ("The direction to sort results. Ignored without `sort` parameter.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsListReviewCommentsForRepoSort :: Created . to_string () , types :: PullsListReviewCommentsForRepoSort :: Updated . to_string () , types :: PullsListReviewCommentsForRepoSort :: CreatedAt . to_string () ,]) , | s | types :: PullsListReviewCommentsForRepoSort :: try_from (s) . unwrap ()))) . about ("List review comments in a repository\n\nLists review comments for all pull requests in a repository. By default, review comments are in ascending order by ID.")
    }

    pub fn cli_pulls_get_review_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .about(
                "Get a review comment for a pull request\n\nProvides details for a review comment.",
            )
    }

    pub fn cli_pulls_delete_review_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .about("Delete a review comment for a pull request\n\nDeletes a review comment.")
    }

    pub fn cli_pulls_update_review_comment() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("comment-id")
                    .long("comment-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the comment."),
            )
            .arg(
                clap::Arg::new("body")
                    .long("body")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The text of the reply to the review comment."),
            )
            .about(
                "Update a review comment for a pull request\n\nEnables you to edit a review \
                 comment.",
            )
    }

    pub fn cli_reactions_list_for_pull_request_review_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("comment-id") . long ("comment-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the comment.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsListForPullRequestReviewCommentContent :: plus1 . to_string () , types :: ReactionsListForPullRequestReviewCommentContent :: minus1 . to_string () , types :: ReactionsListForPullRequestReviewCommentContent :: Laugh . to_string () , types :: ReactionsListForPullRequestReviewCommentContent :: Confused . to_string () , types :: ReactionsListForPullRequestReviewCommentContent :: Heart . to_string () , types :: ReactionsListForPullRequestReviewCommentContent :: Hooray . to_string () , types :: ReactionsListForPullRequestReviewCommentContent :: Rocket . to_string () , types :: ReactionsListForPullRequestReviewCommentContent :: Eyes . to_string () ,]) , | s | types :: ReactionsListForPullRequestReviewCommentContent :: try_from (s) . unwrap ())) . help ("Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a pull request review comment.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List reactions for a pull request review comment\n\nList the reactions to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments).")
    }

    pub fn cli_reactions_create_for_pull_request_review_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("comment-id") . long ("comment-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the comment.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsCreateForPullRequestReviewCommentBodyContent :: plus1 . to_string () , types :: ReactionsCreateForPullRequestReviewCommentBodyContent :: minus1 . to_string () , types :: ReactionsCreateForPullRequestReviewCommentBodyContent :: Laugh . to_string () , types :: ReactionsCreateForPullRequestReviewCommentBodyContent :: Confused . to_string () , types :: ReactionsCreateForPullRequestReviewCommentBodyContent :: Heart . to_string () , types :: ReactionsCreateForPullRequestReviewCommentBodyContent :: Hooray . to_string () , types :: ReactionsCreateForPullRequestReviewCommentBodyContent :: Rocket . to_string () , types :: ReactionsCreateForPullRequestReviewCommentBodyContent :: Eyes . to_string () ,]) , | s | types :: ReactionsCreateForPullRequestReviewCommentBodyContent :: try_from (s) . unwrap ())) . help ("The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the pull request review comment.")) . about ("Create reaction for a pull request review comment\n\nCreate a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already added the reaction type to this pull request review comment.")
    }

    pub fn cli_reactions_delete_for_pull_request_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("comment-id") . long ("comment-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the comment.")) . arg (clap :: Arg :: new ("reaction-id") . long ("reaction-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the reaction.")) . about ("Delete a pull request comment reaction\n\n**Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`\n\nDelete a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments).")
    }

    pub fn cli_pulls_get() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . about ("Get a pull request\n\nDraft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nLists details of a pull request by providing its number.\n\nWhen you get, [create](https://docs.github.com/rest/reference/pulls/#create-a-pull-request), or [edit](https://docs.github.com/rest/reference/pulls#update-a-pull-request) a pull request, GitHub creates a merge commit to test whether the pull request can be automatically merged into the base branch. This test commit is not added to the base branch or the head branch. You can review the status of the test commit using the `mergeable` key. For more information, see \"[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)\".\n\nThe value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`, then GitHub has started a background job to compute the mergeability. After giving the job time to complete, resubmit the request. When the job finishes, you will see a non-`null` value for the `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be the SHA of the _test_ merge commit.\n\nThe value of the `merge_commit_sha` attribute changes depending on the state of the pull request. Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how you merged the pull request:\n\n*   If merged as a [merge commit](https://docs.github.com/articles/about-merge-methods-on-github/), `merge_commit_sha` represents the SHA of the merge commit.\n*   If merged via a [squash](https://docs.github.com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha` represents the SHA of the squashed commit on the base branch.\n*   If [rebased](https://docs.github.com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha` represents the commit that the base branch was updated to.\n\nPass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.")
    }

    pub fn cli_pulls_update() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . arg (clap :: Arg :: new ("base") . long ("base") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The contents of the pull request.")) . arg (clap :: Arg :: new ("maintainer-can-modify") . long ("maintainer-can-modify") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsUpdateBodyState :: Open . to_string () , types :: PullsUpdateBodyState :: Closed . to_string () ,]) , | s | types :: PullsUpdateBodyState :: try_from (s) . unwrap ())) . help ("State of this Pull Request. Either `open` or `closed`.")) . arg (clap :: Arg :: new ("title") . long ("title") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The title of the pull request.")) . about ("Update a pull request\n\nDraft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nTo open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.")
    }

    pub fn cli_codespaces_create_with_pr_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pull-number")
                    .long("pull-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the pull request."),
            )
            .about(
                "Create a codespace from a pull request\n\nCreates a codespace owned by the \
                 authenticated user for the specified pull request.\n\nYou must authenticate \
                 using an access token with the `codespace` scope to use this endpoint.\n\nGitHub \
                 Apps must have write access to the `codespaces` repository permission to use \
                 this endpoint.",
            )
    }

    pub fn cli_pulls_list_review_comments() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsListReviewCommentsDirection :: Asc . to_string () , types :: PullsListReviewCommentsDirection :: Desc . to_string () ,]) , | s | types :: PullsListReviewCommentsDirection :: try_from (s) . unwrap ())) . help ("The direction to sort results. Ignored without `sort` parameter.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsListReviewCommentsSort :: Created . to_string () , types :: PullsListReviewCommentsSort :: Updated . to_string () ,]) , | s | types :: PullsListReviewCommentsSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by.")) . about ("List review comments on a pull request\n\nLists all review comments for a pull request. By default, review comments are in ascending order by ID.")
    }

    pub fn cli_pulls_create_review_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The text of the review comment.")) . arg (clap :: Arg :: new ("commit-id") . long ("commit-id") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`.")) . arg (clap :: Arg :: new ("in-reply-to") . long ("in-reply-to") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The ID of the review comment to reply to. To find the ID of a review comment with [\"List review comments on a pull request\"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored.")) . arg (clap :: Arg :: new ("line") . long ("line") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to.")) . arg (clap :: Arg :: new ("path") . long ("path") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The relative path to the file that necessitates a comment.")) . arg (clap :: Arg :: new ("position") . long ("position") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("**This parameter is deprecated. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. For help finding the position value, read the note above.")) . arg (clap :: Arg :: new ("side") . long ("side") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsCreateReviewCommentBodySide :: Left . to_string () , types :: PullsCreateReviewCommentBodySide :: Right . to_string () ,]) , | s | types :: PullsCreateReviewCommentBodySide :: try_from (s) . unwrap ())) . help ("In a split diff view, the side of the diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see \"[Diff view options](https://docs.github.com/articles/about-comparing-branches-in-pull-requests#diff-view-options)\" in the GitHub Help documentation.")) . arg (clap :: Arg :: new ("start-line") . long ("start-line") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("**Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see \"[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)\" in the GitHub Help documentation.")) . arg (clap :: Arg :: new ("start-side") . long ("start-side") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsCreateReviewCommentBodyStartSide :: Left . to_string () , types :: PullsCreateReviewCommentBodyStartSide :: Right . to_string () , types :: PullsCreateReviewCommentBodyStartSide :: Side . to_string () ,]) , | s | types :: PullsCreateReviewCommentBodyStartSide :: try_from (s) . unwrap ())) . help ("**Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see \"[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)\" in the GitHub Help documentation. See `side` in this table for additional context.")) . arg (clap :: Arg :: new ("subject-type") . long ("subject-type") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsCreateReviewCommentBodySubjectType :: Line . to_string () , types :: PullsCreateReviewCommentBodySubjectType :: File . to_string () ,]) , | s | types :: PullsCreateReviewCommentBodySubjectType :: try_from (s) . unwrap ())) . help ("The level at which the comment is targeted.")) . about ("Create a review comment for a pull request\n\n\nCreates a review comment in the pull request diff. To add a regular comment to a pull request timeline, see \"[Create an issue comment](https://docs.github.com/rest/reference/issues#create-an-issue-comment).\" We recommend creating a review comment using `line`, `side`, and optionally `start_line` and `start_side` if your comment applies to more than one line in the pull request diff.\n\nThe `position` parameter is deprecated. If you use `position`, the `line`, `side`, `start_line`, and `start_side` parameters are not required.\n\n**Note:** The position value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment. The line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.")
    }

    pub fn cli_pulls_create_reply_for_review_comment() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . arg (clap :: Arg :: new ("comment-id") . long ("comment-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the comment.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The text of the review comment.")) . about ("Create a reply for a review comment\n\nCreates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of the review comment you are replying to. This must be the ID of a _top-level review comment_, not a reply to that comment. Replies to replies are not supported.\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.")
    }

    pub fn cli_pulls_list_commits() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List commits on a pull request\n\nLists a maximum of 250 commits for a pull request. To receive a complete commit list for pull requests with more than 250 commits, use the [List commits](https://docs.github.com/rest/reference/repos#list-commits) endpoint.")
    }

    pub fn cli_pulls_list_files() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pull-number")
                    .long("pull-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the pull request."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List pull requests files\n\n**Note:** Responses include a maximum of 3000 files. \
                 The paginated response returns 30 files per page by default.",
            )
    }

    pub fn cli_pulls_check_if_merged() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pull-number")
                    .long("pull-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the pull request."),
            )
            .about("Check if a pull request has been merged")
    }

    pub fn cli_pulls_merge() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . about ("Merge a pull request\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.")
    }

    pub fn cli_pulls_list_requested_reviewers() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . about ("Get all requested reviewers for a pull request\n\nGets the users or teams whose review is requested for a pull request. Once a requested reviewer submits a review, they are no longer considered a requested reviewer. Their review will instead be returned by the [List reviews for a pull request](https://docs.github.com/rest/pulls/reviews#list-reviews-for-a-pull-request) operation.")
    }

    pub fn cli_pulls_request_reviewers() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . about ("Request reviewers for a pull request\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.")
    }

    pub fn cli_pulls_remove_requested_reviewers() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pull-number")
                    .long("pull-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the pull request."),
            )
            .about("Remove requested reviewers from a pull request")
    }

    pub fn cli_pulls_list_reviews() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pull-number")
                    .long("pull-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the pull request."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List reviews for a pull request\n\nThe list of reviews returns in chronological \
                 order.",
            )
    }

    pub fn cli_pulls_create_review() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("**Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review.")) . arg (clap :: Arg :: new ("commit-id") . long ("commit-id") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value.")) . arg (clap :: Arg :: new ("event") . long ("event") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsCreateReviewBodyEvent :: Approve . to_string () , types :: PullsCreateReviewBodyEvent :: RequestChanges . to_string () , types :: PullsCreateReviewBodyEvent :: Comment . to_string () ,]) , | s | types :: PullsCreateReviewBodyEvent :: try_from (s) . unwrap ())) . help ("The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls#submit-a-review-for-a-pull-request) when you are ready.")) . about ("Create a review for a pull request\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.\n\nPull request reviews created in the `PENDING` state are not submitted and therefore do not include the `submitted_at` property in the response. To create a pending review for a pull request, leave the `event` parameter blank. For more information about submitting a `PENDING` review, see \"[Submit a review for a pull request](https://docs.github.com/rest/pulls#submit-a-review-for-a-pull-request).\"\n\n**Note:** To comment on a specific line in a file, you need to first determine the _position_ of that line in the diff. The GitHub REST API offers the `application/vnd.github.v3.diff` [media type](https://docs.github.com/rest/overview/media-types#commits-commit-comparison-and-pull-requests). To see a pull request diff, add this media type to the `Accept` header of a call to the [single pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) endpoint.\n\nThe `position` value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment. The line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.")
    }

    pub fn cli_pulls_get_review() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pull-number")
                    .long("pull-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the pull request."),
            )
            .arg(
                clap::Arg::new("review-id")
                    .long("review-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the review."),
            )
            .about("Get a review for a pull request")
    }

    pub fn cli_pulls_update_review() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pull-number")
                    .long("pull-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the pull request."),
            )
            .arg(
                clap::Arg::new("review-id")
                    .long("review-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the review."),
            )
            .arg(
                clap::Arg::new("body")
                    .long("body")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The body text of the pull request review."),
            )
            .about(
                "Update a review for a pull request\n\nUpdate the review summary comment with new \
                 text.",
            )
    }

    pub fn cli_pulls_delete_pending_review() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pull-number")
                    .long("pull-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the pull request."),
            )
            .arg(
                clap::Arg::new("review-id")
                    .long("review-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the review."),
            )
            .about("Delete a pending review for a pull request")
    }

    pub fn cli_pulls_list_comments_for_review() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pull-number")
                    .long("pull-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the pull request."),
            )
            .arg(
                clap::Arg::new("review-id")
                    .long("review-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the review."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List comments for a pull request review\n\nList comments for a specific pull \
                 request review.",
            )
    }

    pub fn cli_pulls_dismiss_review() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . arg (clap :: Arg :: new ("review-id") . long ("review-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the review.")) . arg (clap :: Arg :: new ("event") . long ("event") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsDismissReviewBodyEvent :: Dismiss . to_string () ,]) , | s | types :: PullsDismissReviewBodyEvent :: try_from (s) . unwrap ()))) . arg (clap :: Arg :: new ("message") . long ("message") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The message for the pull request review dismissal")) . about ("Dismiss a review for a pull request\n\n**Note:** To dismiss a pull request review on a [protected branch](https://docs.github.com/rest/reference/repos#branches), you must be a repository administrator or be included in the list of people or teams who can dismiss pull request reviews.")
    }

    pub fn cli_pulls_submit_review() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("pull-number") . long ("pull-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the pull request.")) . arg (clap :: Arg :: new ("review-id") . long ("review-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the review.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The body text of the pull request review")) . arg (clap :: Arg :: new ("event") . long ("event") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PullsSubmitReviewBodyEvent :: Approve . to_string () , types :: PullsSubmitReviewBodyEvent :: RequestChanges . to_string () , types :: PullsSubmitReviewBodyEvent :: Comment . to_string () ,]) , | s | types :: PullsSubmitReviewBodyEvent :: try_from (s) . unwrap ())) . help ("The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.")) . about ("Submit a review for a pull request\n\nSubmits a pending review for a pull request. For more information about creating a pending review for a pull request, see \"[Create a review for a pull request](https://docs.github.com/rest/pulls#create-a-review-for-a-pull-request).\"")
    }

    pub fn cli_pulls_update_branch() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pull-number")
                    .long("pull-number")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number that identifies the pull request."),
            )
            .about(
                "Update a pull request branch\n\nUpdates the pull request branch with the latest \
                 upstream changes by merging HEAD from the base branch into the pull request \
                 branch.",
            )
    }

    pub fn cli_repos_get_readme() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("ref") . long ("ref") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the commit/branch/tag. Default: the repositorys default branch.")) . about ("Get a repository README\n\nGets the preferred README for a repository.\n\nREADMEs support [custom media types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.")
    }

    pub fn cli_repos_get_readme_in_directory() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("dir") . long ("dir") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The alternate path to look for a README file")) . arg (clap :: Arg :: new ("ref") . long ("ref") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the commit/branch/tag. Default: the repositorys default branch.")) . about ("Get a repository README for a directory\n\nGets the README from a repository directory.\n\nREADMEs support [custom media types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.")
    }

    pub fn cli_activity_list_repos_watched_by_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List repositories watched by a user\n\nLists repositories a user is watching.")
    }

    pub fn cli_repos_get_release_asset() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("asset-id") . long ("asset-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the asset.")) . about ("Get a release asset\n\nTo download the asset's binary content, set the `Accept` header of the request to [`application/octet-stream`](https://docs.github.com/rest/overview/media-types). The API will either redirect the client to the location, or stream it directly if possible. API clients should handle both a `200` or `302` response.")
    }

    pub fn cli_repos_delete_release_asset() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("asset-id")
                    .long("asset-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the asset."),
            )
            .about("Delete a release asset")
    }

    pub fn cli_repos_update_release_asset() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("asset-id")
                    .long("asset-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the asset."),
            )
            .arg(
                clap::Arg::new("label")
                    .long("label")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "An alternate short description of the asset. Used in place of the \
                         filename.",
                    ),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The file name of the asset."),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(false)
                    .value_parser(clap::value_parser!(String)),
            )
            .about(
                "Update a release asset\n\nUsers with push access to the repository can edit a \
                 release asset.",
            )
    }

    pub fn cli_repos_generate_release_notes() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("configuration-file-path") . long ("configuration-file-path") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used.")) . arg (clap :: Arg :: new ("previous-tag-name") . long ("previous-tag-name") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.")) . arg (clap :: Arg :: new ("tag-name") . long ("tag-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The tag name for the release. This can be an existing tag or a new one.")) . arg (clap :: Arg :: new ("target-commitish") . long ("target-commitish") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists.")) . about ("Generate release notes content for a release\n\nGenerate a name and body describing a [release](https://docs.github.com/rest/reference/repos#releases). The body content will be markdown formatted and contain information like the changes since last release and users who contributed. The generated release notes are not saved anywhere. They are intended to be generated and used when creating a new release.")
    }

    pub fn cli_repos_get_latest_release() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get the latest release\n\nView the latest published full release for the \
                 repository.\n\nThe latest release is the most recent non-prerelease, non-draft \
                 release, sorted by the `created_at` attribute. The `created_at` attribute is the \
                 date of the commit used for the release, and not the date when the release was \
                 drafted or published.",
            )
    }

    pub fn cli_repos_get_release_by_tag() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("tag")
                    .long("tag")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("tag parameter"),
            )
            .about("Get a release by tag name\n\nGet a published release with the specified tag.")
    }

    pub fn cli_activity_list_repos_starred_by_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActivityListReposStarredByUserDirection :: Asc . to_string () , types :: ActivityListReposStarredByUserDirection :: Desc . to_string () ,]) , | s | types :: ActivityListReposStarredByUserDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActivityListReposStarredByUserSort :: Created . to_string () , types :: ActivityListReposStarredByUserSort :: Updated . to_string () ,]) , | s | types :: ActivityListReposStarredByUserSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.")) . about ("List repositories starred by a user\n\nLists repositories a user has starred.\n\nYou can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header: `application/vnd.github.star+json`.")
    }

    pub fn cli_repos_list_release_assets() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("release-id")
                    .long("release-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the release."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List release assets")
    }

    pub fn cli_repos_upload_release_asset() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("release-id") . long ("release-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the release.")) . arg (clap :: Arg :: new ("label") . long ("label") . required (false) . value_parser (clap :: value_parser ! (String))) . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String))) . about ("Upload a release asset\n\nThis endpoint makes use of [a Hypermedia relation](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia) to determine which URL to access. The endpoint you call to upload release assets is specific to your release. Use the `upload_url` returned in\nthe response of the [Create a release endpoint](https://docs.github.com/rest/releases/releases#create-a-release) to upload a release asset.\n\nYou need to use an HTTP client which supports [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.\n\nMost libraries will set the required `Content-Length` header automatically. Use the required `Content-Type` header to provide the media type of the asset. For a list of media types, see [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example: \n\n`application/zip`\n\nGitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset as the request body. Everything else about the endpoint is the same as the rest of the API. For example,\nyou'll still need to pass your authentication to be able to upload an asset.\n\nWhen an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an empty asset with a state of `starter`. It can be safely deleted.\n\n**Notes:**\n*   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods. The \"[List assets for a release](https://docs.github.com/rest/reference/repos#list-assets-for-a-release)\"\nendpoint lists the renamed filenames. For more information and help, contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).\n*   To find the `release_id` query the [`GET /repos/{owner}/{repo}/releases/latest` endpoint](https://docs.github.com/rest/releases/releases#get-the-latest-release). \n*   If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete the old file before you can re-upload the new asset.")
    }

    pub fn cli_reactions_list_for_release() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("release-id") . long ("release-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the release.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsListForReleaseContent :: plus1 . to_string () , types :: ReactionsListForReleaseContent :: Laugh . to_string () , types :: ReactionsListForReleaseContent :: Heart . to_string () , types :: ReactionsListForReleaseContent :: Hooray . to_string () , types :: ReactionsListForReleaseContent :: Rocket . to_string () , types :: ReactionsListForReleaseContent :: Eyes . to_string () ,]) , | s | types :: ReactionsListForReleaseContent :: try_from (s) . unwrap ())) . help ("Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a release.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List reactions for a release\n\nList the reactions to a [release](https://docs.github.com/rest/reference/repos#releases).")
    }

    pub fn cli_reactions_create_for_release() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("release-id") . long ("release-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the release.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsCreateForReleaseBodyContent :: plus1 . to_string () , types :: ReactionsCreateForReleaseBodyContent :: Laugh . to_string () , types :: ReactionsCreateForReleaseBodyContent :: Heart . to_string () , types :: ReactionsCreateForReleaseBodyContent :: Hooray . to_string () , types :: ReactionsCreateForReleaseBodyContent :: Rocket . to_string () , types :: ReactionsCreateForReleaseBodyContent :: Eyes . to_string () ,]) , | s | types :: ReactionsCreateForReleaseBodyContent :: try_from (s) . unwrap ())) . help ("The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the release.")) . about ("Create reaction for a release\n\nCreate a reaction to a [release](https://docs.github.com/rest/reference/repos#releases). A response with a `Status: 200 OK` means that you already added the reaction type to this release.")
    }

    pub fn cli_reactions_delete_for_release() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("release-id") . long ("release-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the release.")) . arg (clap :: Arg :: new ("reaction-id") . long ("reaction-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the reaction.")) . about ("Delete a release reaction\n\n**Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/releases/:release_id/reactions/:reaction_id`.\n\nDelete a reaction to a [release](https://docs.github.com/rest/reference/repos#releases).")
    }

    pub fn cli_repos_get_branch_rules() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("branch") . long ("branch") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).")) . about ("Get rules for a branch\n\nReturns all rules that apply to the specified branch.")
    }

    pub fn cli_repos_get_repo_rulesets() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("includes-parents")
                    .long("includes-parents")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Include rulesets configured at higher levels that apply to this \
                         repository",
                    ),
            )
            .about("Get all repository rulesets\n\nGet all the rulesets for a repository.")
    }

    pub fn cli_repos_create_repo_ruleset() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("bypass-mode")
                    .long("bypass-mode")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposCreateRepoRulesetBodyBypassMode::None.to_string(),
                            types::ReposCreateRepoRulesetBodyBypassMode::Repository.to_string(),
                            types::ReposCreateRepoRulesetBodyBypassMode::Organization.to_string(),
                        ]),
                        |s| types::ReposCreateRepoRulesetBodyBypassMode::try_from(s).unwrap(),
                    ))
                    .help(
                        "The permission level required to bypass this ruleset. \"repository\" \
                         allows those with bypass permission at the repository level to bypass. \
                         \"organization\" allows those with bypass permission at the organization \
                         level to bypass. \"none\" prevents anyone from bypassing.",
                    ),
            )
            .arg(
                clap::Arg::new("enforcement")
                    .long("enforcement")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::RepositoryRuleEnforcement::Disabled.to_string(),
                            types::RepositoryRuleEnforcement::Active.to_string(),
                            types::RepositoryRuleEnforcement::Evaluate.to_string(),
                        ]),
                        |s| types::RepositoryRuleEnforcement::try_from(s).unwrap(),
                    )),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the ruleset."),
            )
            .arg(
                clap::Arg::new("target")
                    .long("target")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposCreateRepoRulesetBodyTarget::Branch.to_string(),
                            types::ReposCreateRepoRulesetBodyTarget::Tag.to_string(),
                        ]),
                        |s| types::ReposCreateRepoRulesetBodyTarget::try_from(s).unwrap(),
                    ))
                    .help("The target of the ruleset."),
            )
            .about("Create a repository ruleset\n\nCreate a ruleset for a repository.")
    }

    pub fn cli_repos_get_repo_ruleset() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ruleset-id")
                    .long("ruleset-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The ID of the ruleset."),
            )
            .arg(
                clap::Arg::new("includes-parents")
                    .long("includes-parents")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Include rulesets configured at higher levels that apply to this \
                         repository",
                    ),
            )
            .about("Get a repository ruleset\n\nGet a ruleset for a repository.")
    }

    pub fn cli_repos_update_repo_ruleset() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ruleset-id")
                    .long("ruleset-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The ID of the ruleset."),
            )
            .arg(
                clap::Arg::new("bypass-mode")
                    .long("bypass-mode")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposUpdateRepoRulesetBodyBypassMode::None.to_string(),
                            types::ReposUpdateRepoRulesetBodyBypassMode::Repository.to_string(),
                            types::ReposUpdateRepoRulesetBodyBypassMode::Organization.to_string(),
                        ]),
                        |s| types::ReposUpdateRepoRulesetBodyBypassMode::try_from(s).unwrap(),
                    ))
                    .help(
                        "The permission level required to bypass this ruleset. \"repository\" \
                         allows those with bypass permission at the repository level to bypass. \
                         \"organization\" allows those with bypass permission at the organization \
                         level to bypass. \"none\" prevents anyone from bypassing.",
                    ),
            )
            .arg(
                clap::Arg::new("enforcement")
                    .long("enforcement")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::RepositoryRuleEnforcement::Disabled.to_string(),
                            types::RepositoryRuleEnforcement::Active.to_string(),
                            types::RepositoryRuleEnforcement::Evaluate.to_string(),
                        ]),
                        |s| types::RepositoryRuleEnforcement::try_from(s).unwrap(),
                    )),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the ruleset."),
            )
            .arg(
                clap::Arg::new("target")
                    .long("target")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposUpdateRepoRulesetBodyTarget::Branch.to_string(),
                            types::ReposUpdateRepoRulesetBodyTarget::Tag.to_string(),
                        ]),
                        |s| types::ReposUpdateRepoRulesetBodyTarget::try_from(s).unwrap(),
                    ))
                    .help("The target of the ruleset."),
            )
            .about("Update a repository ruleset\n\nUpdate a ruleset for a repository.")
    }

    pub fn cli_repos_delete_repo_ruleset() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ruleset-id")
                    .long("ruleset-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The ID of the ruleset."),
            )
            .about("Delete a repository ruleset\n\nDelete a ruleset for a repository.")
    }

    pub fn cli_secret_scanning_list_alerts_for_repo() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("after") . long ("after") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty \"after\" query string.")) . arg (clap :: Arg :: new ("before") . long ("before") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty \"before\" query string.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecretScanningListAlertsForRepoDirection :: Asc . to_string () , types :: SecretScanningListAlertsForRepoDirection :: Desc . to_string () ,]) , | s | types :: SecretScanningListAlertsForRepoDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("resolution") . long ("resolution") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.")) . arg (clap :: Arg :: new ("secret-type") . long ("secret-type") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A comma-separated list of secret types to return. By default all secret types are returned.\nSee \"[Secret scanning patterns](https://docs.github.com/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security)\"\nfor a complete list of secret types.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecretScanningListAlertsForRepoSort :: Created . to_string () , types :: SecretScanningListAlertsForRepoSort :: Updated . to_string () ,]) , | s | types :: SecretScanningListAlertsForRepoSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecretScanningListAlertsForRepoState :: Open . to_string () , types :: SecretScanningListAlertsForRepoState :: Resolved . to_string () ,]) , | s | types :: SecretScanningListAlertsForRepoState :: try_from (s) . unwrap ())) . help ("Set to `open` or `resolved` to only list secret scanning alerts in a specific state.")) . about ("List secret scanning alerts for a repository\n\nLists secret scanning alerts for an eligible repository, from newest to oldest.\nTo use this endpoint, you must be an administrator for the repository or for the organization that owns the repository, and you must use a personal access token with the `repo` scope or `security_events` scope.\nFor public repositories, you may instead use the `public_repo` scope.\n\nGitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.")
    }

    pub fn cli_secret_scanning_get_alert() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("alert-number")
                    .long("alert-number")
                    .required(true)
                    .value_parser(clap::value_parser!(types::AlertNumber))
                    .help(
                        "The number that identifies an alert. You can find this at the end of the \
                         URL for a code scanning alert within GitHub, and in the `number` field \
                         in the response from the `GET \
                         /repos/{owner}/{repo}/code-scanning/alerts` operation.",
                    ),
            )
            .about(
                "Get a secret scanning alert\n\nGets a single secret scanning alert detected in \
                 an eligible repository.\nTo use this endpoint, you must be an administrator for \
                 the repository or for the organization that owns the repository, and you must \
                 use a personal access token with the `repo` scope or `security_events` \
                 scope.\nFor public repositories, you may instead use the `public_repo` \
                 scope.\n\nGitHub Apps must have the `secret_scanning_alerts` read permission to \
                 use this endpoint.",
            )
    }

    pub fn cli_secret_scanning_update_alert() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("alert-number")
                    .long("alert-number")
                    .required(true)
                    .value_parser(clap::value_parser!(types::AlertNumber))
                    .help(
                        "The number that identifies an alert. You can find this at the end of the \
                         URL for a code scanning alert within GitHub, and in the `number` field \
                         in the response from the `GET \
                         /repos/{owner}/{repo}/code-scanning/alerts` operation.",
                    ),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::SecretScanningAlertState::Open.to_string(),
                            types::SecretScanningAlertState::Resolved.to_string(),
                        ]),
                        |s| types::SecretScanningAlertState::try_from(s).unwrap(),
                    )),
            )
            .about(
                "Update a secret scanning alert\n\nUpdates the status of a secret scanning alert \
                 in an eligible repository.\nTo use this endpoint, you must be an administrator \
                 for the repository or for the organization that owns the repository, and you \
                 must use a personal access token with the `repo` scope or `security_events` \
                 scope.\nFor public repositories, you may instead use the `public_repo` \
                 scope.\n\nGitHub Apps must have the `secret_scanning_alerts` write permission to \
                 use this endpoint.",
            )
    }

    pub fn cli_secret_scanning_list_locations_for_alert() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("alert-number")
                    .long("alert-number")
                    .required(true)
                    .value_parser(clap::value_parser!(types::AlertNumber))
                    .help(
                        "The number that identifies an alert. You can find this at the end of the \
                         URL for a code scanning alert within GitHub, and in the `number` field \
                         in the response from the `GET \
                         /repos/{owner}/{repo}/code-scanning/alerts` operation.",
                    ),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List locations for a secret scanning alert\n\nLists all locations for a given \
                 secret scanning alert for an eligible repository.\nTo use this endpoint, you \
                 must be an administrator for the repository or for the organization that owns \
                 the repository, and you must use a personal access token with the `repo` scope \
                 or `security_events` scope.\nFor public repositories, you may instead use the \
                 `public_repo` scope.\n\nGitHub Apps must have the `secret_scanning_alerts` read \
                 permission to use this endpoint.",
            )
    }

    pub fn cli_security_advisories_list_repository_advisories() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("after") . long ("after") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor.")) . arg (clap :: Arg :: new ("before") . long ("before") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecurityAdvisoriesListRepositoryAdvisoriesDirection :: Asc . to_string () , types :: SecurityAdvisoriesListRepositoryAdvisoriesDirection :: Desc . to_string () ,]) , | s | types :: SecurityAdvisoriesListRepositoryAdvisoriesDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Number of advisories to return per page.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecurityAdvisoriesListRepositoryAdvisoriesSort :: Created . to_string () , types :: SecurityAdvisoriesListRepositoryAdvisoriesSort :: Updated . to_string () , types :: SecurityAdvisoriesListRepositoryAdvisoriesSort :: Published . to_string () ,]) , | s | types :: SecurityAdvisoriesListRepositoryAdvisoriesSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SecurityAdvisoriesListRepositoryAdvisoriesState :: Triage . to_string () , types :: SecurityAdvisoriesListRepositoryAdvisoriesState :: Draft . to_string () , types :: SecurityAdvisoriesListRepositoryAdvisoriesState :: Published . to_string () , types :: SecurityAdvisoriesListRepositoryAdvisoriesState :: Closed . to_string () ,]) , | s | types :: SecurityAdvisoriesListRepositoryAdvisoriesState :: try_from (s) . unwrap ())) . help ("Filter by state of the repository advisories. Only advisories of this state will be returned.")) . about ("List repository security advisories\n\nLists security advisories in a repository.\nYou must authenticate using an access token with the `repo` scope or `repository_advisories:read` permission\nin order to get published security advisories in a private repository, or any unpublished security advisories that you have access to.\n\nYou can access unpublished security advisories from a repository if you are a security manager or administrator of that repository, or if you are a collaborator on any security advisory.")
    }

    pub fn cli_security_advisories_create_repository_advisory() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("cve-id")
                    .long("cve-id")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The Common Vulnerabilities and Exposures (CVE) ID."),
            )
            .arg(
                clap::Arg::new("cvss-vector-string")
                    .long("cvss-vector-string")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The CVSS vector that calculates the severity of the advisory. You must \
                         choose between setting this field or `severity`.",
                    ),
            )
            .arg(
                clap::Arg::new("description")
                    .long("description")
                    .required(true)
                    .value_parser(clap::value_parser!(
                        types::RepositoryAdvisoryCreateDescription
                    ))
                    .help("A detailed description of what the advisory impacts."),
            )
            .arg(
                clap::Arg::new("severity")
                    .long("severity")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::RepositoryAdvisoryCreateSeverity::Critical.to_string(),
                            types::RepositoryAdvisoryCreateSeverity::High.to_string(),
                            types::RepositoryAdvisoryCreateSeverity::Medium.to_string(),
                            types::RepositoryAdvisoryCreateSeverity::Low.to_string(),
                        ]),
                        |s| types::RepositoryAdvisoryCreateSeverity::try_from(s).unwrap(),
                    ))
                    .help(
                        "The severity of the advisory. You must choose between setting this field \
                         or `cvss_vector_string`.",
                    ),
            )
            .arg(
                clap::Arg::new("summary")
                    .long("summary")
                    .required(true)
                    .value_parser(clap::value_parser!(types::RepositoryAdvisoryCreateSummary))
                    .help("A short summary of the advisory."),
            )
            .about(
                "Create a repository security advisory\n\nCreates a new repository security \
                 advisory.\nYou must authenticate using an access token with the `repo` scope or \
                 `repository_advisories:write` permission to use this endpoint.\n\nIn order to \
                 create a draft repository security advisory, you must be a security manager or \
                 administrator of that repository.",
            )
    }

    pub fn cli_security_advisories_create_private_vulnerability_report() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("cvss-vector-string") . long ("cvss-vector-string") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.")) . arg (clap :: Arg :: new ("description") . long ("description") . required (true) . value_parser (clap :: value_parser ! (types :: PrivateVulnerabilityReportCreateDescription)) . help ("A detailed description of what the advisory impacts.")) . arg (clap :: Arg :: new ("severity") . long ("severity") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PrivateVulnerabilityReportCreateSeverity :: Critical . to_string () , types :: PrivateVulnerabilityReportCreateSeverity :: High . to_string () , types :: PrivateVulnerabilityReportCreateSeverity :: Medium . to_string () , types :: PrivateVulnerabilityReportCreateSeverity :: Low . to_string () ,]) , | s | types :: PrivateVulnerabilityReportCreateSeverity :: try_from (s) . unwrap ())) . help ("The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.")) . arg (clap :: Arg :: new ("summary") . long ("summary") . required (true) . value_parser (clap :: value_parser ! (types :: PrivateVulnerabilityReportCreateSummary)) . help ("A short summary of the advisory.")) . about ("Privately report a security vulnerability\n\nReport a security vulnerability to the maintainers of the repository.\nSee \"[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)\" for more information about private vulnerability reporting.")
    }

    pub fn cli_security_advisories_get_repository_advisory() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ghsa-id")
                    .long("ghsa-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The GHSA (GitHub Security Advisory) identifier of the advisory."),
            )
            .about(
                "Get a repository security advisory\n\nGet a repository security advisory using \
                 its GitHub Security Advisory (GHSA) identifier.\nYou can access any published \
                 security advisory on a public repository.\nYou must authenticate using an access \
                 token with the `repo` scope or `repository_advisories:read` permission\nin order \
                 to get a published security advisory in a private repository, or any unpublished \
                 security advisory that you have access to.\n\nYou can access an unpublished \
                 security advisory from a repository if you are a security manager or \
                 administrator of that repository, or if you are a\ncollaborator on the security \
                 advisory.",
            )
    }

    pub fn cli_security_advisories_update_repository_advisory() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ghsa-id")
                    .long("ghsa-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The GHSA (GitHub Security Advisory) identifier of the advisory."),
            )
            .arg(
                clap::Arg::new("cve-id")
                    .long("cve-id")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The Common Vulnerabilities and Exposures (CVE) ID."),
            )
            .arg(
                clap::Arg::new("cvss-vector-string")
                    .long("cvss-vector-string")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The CVSS vector that calculates the severity of the advisory. You must \
                         choose between setting this field or `severity`.",
                    ),
            )
            .arg(
                clap::Arg::new("description")
                    .long("description")
                    .required(false)
                    .value_parser(clap::value_parser!(
                        types::RepositoryAdvisoryUpdateDescription
                    ))
                    .help("A detailed description of what the advisory impacts."),
            )
            .arg(
                clap::Arg::new("severity")
                    .long("severity")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::RepositoryAdvisoryUpdateSeverity::Critical.to_string(),
                            types::RepositoryAdvisoryUpdateSeverity::High.to_string(),
                            types::RepositoryAdvisoryUpdateSeverity::Medium.to_string(),
                            types::RepositoryAdvisoryUpdateSeverity::Low.to_string(),
                        ]),
                        |s| types::RepositoryAdvisoryUpdateSeverity::try_from(s).unwrap(),
                    ))
                    .help(
                        "The severity of the advisory. You must choose between setting this field \
                         or `cvss_vector_string`.",
                    ),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::RepositoryAdvisoryUpdateState::Published.to_string(),
                            types::RepositoryAdvisoryUpdateState::Closed.to_string(),
                            types::RepositoryAdvisoryUpdateState::Draft.to_string(),
                        ]),
                        |s| types::RepositoryAdvisoryUpdateState::try_from(s).unwrap(),
                    ))
                    .help("The state of the advisory."),
            )
            .arg(
                clap::Arg::new("summary")
                    .long("summary")
                    .required(false)
                    .value_parser(clap::value_parser!(types::RepositoryAdvisoryUpdateSummary))
                    .help("A short summary of the advisory."),
            )
            .about(
                "Update a repository security advisory\n\nUpdate a repository security advisory \
                 using its GitHub Security Advisory (GHSA) identifier.\nYou must authenticate \
                 using an access token with the `repo` scope or `repository_advisories:write` \
                 permission to use this endpoint.\n\nIn order to update any security advisory, \
                 you must be a security manager or administrator of that repository,\nor a \
                 collaborator on the repository security advisory.",
            )
    }

    pub fn cli_activity_list_stargazers_for_repo() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List stargazers\n\nLists the people that have starred the repository.\n\nYou can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header: `application/vnd.github.star+json`.")
    }

    pub fn cli_repos_get_code_frequency_stats() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get the weekly commit activity\n\nReturns a weekly aggregate of the number of \
                 additions and deletions pushed to a repository.",
            )
    }

    pub fn cli_repos_get_commit_activity_stats() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get the last year of commit activity\n\nReturns the last year of commit activity \
                 grouped by week. The `days` array is a group of commits per day, starting on \
                 `Sunday`.",
            )
    }

    pub fn cli_repos_get_contributors_stats() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Get all contributor commit activity\n\n\nReturns the `total` number of commits authored by the contributor. In addition, the response includes a Weekly Hash (`weeks` array) with the following information:\n\n*   `w` - Start of the week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).\n*   `a` - Number of additions\n*   `d` - Number of deletions\n*   `c` - Number of commits")
    }

    pub fn cli_repos_get_participation_stats() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get the weekly commit count\n\nReturns the total commit counts for the `owner` \
                 and total commit counts in `all`. `all` is everyone combined, including the \
                 `owner` in the last 52 weeks. If you'd like to get the commit counts for \
                 non-owners, you can subtract `owner` from `all`.\n\nThe array order is oldest \
                 week (index 0) to most recent week.",
            )
    }

    pub fn cli_repos_get_punch_card_stats() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get the hourly commit count for each day\n\nEach array contains the day number, \
                 hour number, and number of commits:\n\n*   `0-6`: Sunday - Saturday\n*   `0-23`: \
                 Hour of day\n*   Number of commits\n\nFor example, `[2, 14, 25]` indicates that \
                 there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are \
                 based on the time zone of individual commits.",
            )
    }

    pub fn cli_repos_create_commit_status() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("sha") . long ("sha") . required (true) . value_parser (clap :: value_parser ! (String))) . arg (clap :: Arg :: new ("context") . long ("context") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A string label to differentiate this status from the status of other systems. This field is case-insensitive.")) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A short description of the status.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposCreateCommitStatusBodyState :: Error . to_string () , types :: ReposCreateCommitStatusBodyState :: Failure . to_string () , types :: ReposCreateCommitStatusBodyState :: Pending . to_string () , types :: ReposCreateCommitStatusBodyState :: Success . to_string () ,]) , | s | types :: ReposCreateCommitStatusBodyState :: try_from (s) . unwrap ())) . help ("The state of the status.")) . arg (clap :: Arg :: new ("target-url") . long ("target-url") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  \nFor example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:  \n`http://ci.example.com/user/repo/build/sha`")) . about ("Create a commit status\n\nUsers with push access in a repository can create commit statuses for a given SHA.\n\nNote: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to create more than 1000 statuses will result in a validation error.")
    }

    pub fn cli_activity_list_watchers_for_repo() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List watchers\n\nLists the people watching the specified repository.")
    }

    pub fn cli_activity_get_repo_subscription() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about("Get a repository subscription")
    }

    pub fn cli_activity_set_repo_subscription() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("ignored") . long ("ignored") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Determines if all notifications should be blocked from this repository.")) . arg (clap :: Arg :: new ("subscribed") . long ("subscribed") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Determines if notifications should be received from this repository.")) . about ("Set a repository subscription\n\nIf you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/rest/reference/activity#delete-a-repository-subscription) completely.")
    }

    pub fn cli_activity_delete_repo_subscription() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Delete a repository subscription\n\nThis endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription).")
    }

    pub fn cli_repos_list_tags() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List repository tags")
    }

    pub fn cli_repos_list_tag_protection() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "List tag protection states for a repository\n\nThis returns the tag protection \
                 states of a repository.\n\nThis information is only available to repository \
                 administrators.",
            )
    }

    pub fn cli_repos_create_tag_protection() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("pattern")
                    .long("pattern")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "An optional glob pattern to match against when enforcing tag protection.",
                    ),
            )
            .about(
                "Create a tag protection state for a repository\n\nThis creates a tag protection \
                 state for a repository.\nThis endpoint is only available to repository \
                 administrators.",
            )
    }

    pub fn cli_repos_delete_tag_protection() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("tag-protection-id")
                    .long("tag-protection-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the tag protection."),
            )
            .about(
                "Delete a tag protection state for a repository\n\nThis deletes a tag protection \
                 state for a repository.\nThis endpoint is only available to repository \
                 administrators.",
            )
    }

    pub fn cli_repos_download_tarball_archive() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about(
                "Download a repository archive (tar)\n\nGets a redirect URL to download a tar \
                 archive for a repository. If you omit `:ref`, the repositorys default branch \
                 (usually\n`main`) will be used. Please make sure your HTTP framework is \
                 configured to follow redirects or you will need to use\nthe `Location` header to \
                 make a second `GET` request.\n**Note**: For private repositories, these links \
                 are temporary and expire after five minutes.",
            )
    }

    pub fn cli_repos_list_teams() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List repository teams")
    }

    pub fn cli_repos_get_all_topics() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("Get all repository topics")
    }

    pub fn cli_repos_replace_all_topics() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about("Replace all repository topics")
    }

    pub fn cli_repos_get_clones() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("per")
                    .long("per")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposGetClonesPer::Day.to_string(),
                            types::ReposGetClonesPer::Week.to_string(),
                        ]),
                        |s| types::ReposGetClonesPer::try_from(s).unwrap(),
                    ))
                    .help("The time frame to display results for."),
            )
            .about(
                "Get repository clones\n\nGet the total number of clones and breakdown per day or \
                 week for the last 14 days. Timestamps are aligned to UTC midnight of the \
                 beginning of the day or week. Week begins on Monday.",
            )
    }

    pub fn cli_repos_get_top_paths() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about(
                "Get top referral paths\n\nGet the top 10 popular contents over the last 14 days.",
            )
    }

    pub fn cli_repos_get_top_referrers() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about("Get top referral sources\n\nGet the top 10 referrers over the last 14 days.")
    }

    pub fn cli_repos_get_views() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("per")
                    .long("per")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposGetViewsPer::Day.to_string(),
                            types::ReposGetViewsPer::Week.to_string(),
                        ]),
                        |s| types::ReposGetViewsPer::try_from(s).unwrap(),
                    ))
                    .help("The time frame to display results for."),
            )
            .about(
                "Get page views\n\nGet the total number of views and breakdown per day or week \
                 for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of \
                 the day or week. Week begins on Monday.",
            )
    }

    pub fn cli_repos_transfer() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("new-name") . long ("new-name") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The new name to be given to the repository.")) . arg (clap :: Arg :: new ("new-owner") . long ("new-owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The username or organization name the repository will be transferred to.")) . about ("Transfer a repository\n\nA transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://docs.github.com/articles/about-repository-transfers/).")
    }

    pub fn cli_repos_check_vulnerability_alerts() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Check if vulnerability alerts are enabled for a repository\n\nShows whether dependency alerts are enabled or disabled for a repository. The authenticated user must have admin read access to the repository. For more information, see \"[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)\".")
    }

    pub fn cli_repos_enable_vulnerability_alerts() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Enable vulnerability alerts\n\nEnables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see \"[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)\".")
    }

    pub fn cli_repos_disable_vulnerability_alerts() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Disable vulnerability alerts\n\nDisables dependency alerts and the dependency graph for a repository.\nThe authenticated user must have admin access to the repository. For more information,\nsee \"[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)\".")
    }

    pub fn cli_repos_download_zipball_archive() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("ref")
                    .long("ref")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about(
                "Download a repository archive (zip)\n\nGets a redirect URL to download a zip \
                 archive for a repository. If you omit `:ref`, the repositorys default branch \
                 (usually\n`main`) will be used. Please make sure your HTTP framework is \
                 configured to follow redirects or you will need to use\nthe `Location` header to \
                 make a second `GET` request.\n\n**Note**: For private repositories, these links \
                 are temporary and expire after five minutes. If the repository is empty, you \
                 will receive a 404 when you follow the redirect.",
            )
    }

    pub fn cli_repos_create_using_template() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("template-owner") . long ("template-owner") . required (true) . value_parser (clap :: value_parser ! (String))) . arg (clap :: Arg :: new ("template-repo") . long ("template-repo") . required (true) . value_parser (clap :: value_parser ! (String))) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A short description of the new repository.")) . arg (clap :: Arg :: new ("include-all-branches") . long ("include-all-branches") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.")) . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the new repository.")) . arg (clap :: Arg :: new ("owner") . long ("owner") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.")) . arg (clap :: Arg :: new ("private") . long ("private") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Either `true` to create a new private repository or `false` to create a new public one.")) . about ("Create a repository using a template\n\nCreates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. If the repository is not public, the authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.\n\n**OAuth scope requirements**\n\nWhen using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:\n\n*   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.\n*   `repo` scope to create a private repository")
    }

    pub fn cli_repos_list_public() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("A repository ID. Only return repositories with an ID greater than this ID.")) . about ("List public repositories\n\nLists all public repositories in the order that they were created.\n\nNote:\n- For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.\n- Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of repositories.")
    }

    pub fn cli_actions_list_environment_secrets() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the repository."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List environment secrets\n\nLists all secrets available in an environment \
                 without revealing their encrypted values. You must authenticate using an access \
                 token with the `repo` scope to use this endpoint. GitHub Apps must have the \
                 `secrets` repository permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_environment_public_key() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the repository."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .about(
                "Get an environment public key\n\nGet the public key for an environment, which \
                 you need to encrypt environment secrets. You need to encrypt a secret before you \
                 can create or update secrets. Anyone with read access to the repository can use \
                 this endpoint. If the repository is private you must use an access token with \
                 the `repo` scope. GitHub Apps must have the `secrets` repository permission to \
                 use this endpoint.",
            )
    }

    pub fn cli_actions_get_environment_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the repository."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Get an environment secret\n\nGets a single environment secret without revealing \
                 its encrypted value. You must authenticate using an access token with the `repo` \
                 scope to use this endpoint. GitHub Apps must have the `secrets` repository \
                 permission to use this endpoint.",
            )
    }

    pub fn cli_actions_create_or_update_environment_secret() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the repository.")) . arg (clap :: Arg :: new ("environment-name") . long ("environment-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the environment.")) . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("encrypted-value") . long ("encrypted-value") . required (true) . value_parser (clap :: value_parser ! (types :: ActionsCreateOrUpdateEnvironmentSecretBodyEncryptedValue)) . help ("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/rest/reference/actions#get-an-environment-public-key) endpoint.")) . arg (clap :: Arg :: new ("key-id") . long ("key-id") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("ID of the key you used to encrypt the secret.")) . about ("Create or update an environment secret\n\nCreates or updates an environment secret with an encrypted value. Encrypt your secret using\n[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access\ntoken with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use\nthis endpoint.\n\n#### Example encrypting a secret using Node.js\n\nEncrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.\n\n```\nconst sodium = require('libsodium-wrappers')\nconst secret = 'plain-text-secret' // replace with the secret you want to encrypt\nconst key = 'base64-encoded-public-key' // replace with the Base64 encoded public key\n\n//Check if libsodium is ready and then proceed.\nsodium.ready.then(() => {\n  // Convert Secret & Base64 key to Uint8Array.\n  let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)\n  let binsec = sodium.from_string(secret)\n\n  //Encrypt the secret using LibSodium\n  let encBytes = sodium.crypto_box_seal(binsec, binkey)\n\n  // Convert encrypted Uint8Array to Base64\n  let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)\n\n  console.log(output)\n});\n```\n\n#### Example encrypting a secret using Python\n\nEncrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.\n\n```\nfrom base64 import b64encode\nfrom nacl import encoding, public\n\ndef encrypt(public_key: str, secret_value: str) -> str:\n  \"\"\"Encrypt a Unicode string using the public key.\"\"\"\n  public_key = public.PublicKey(public_key.encode(\"utf-8\"), encoding.Base64Encoder())\n  sealed_box = public.SealedBox(public_key)\n  encrypted = sealed_box.encrypt(secret_value.encode(\"utf-8\"))\n  return b64encode(encrypted).decode(\"utf-8\")\n```\n\n#### Example encrypting a secret using C#\n\nEncrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.\n\n```\nvar secretValue = System.Text.Encoding.UTF8.GetBytes(\"mySecret\");\nvar publicKey = Convert.FromBase64String(\"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=\");\n\nvar sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);\n\nConsole.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));\n```\n\n#### Example encrypting a secret using Ruby\n\nEncrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.\n\n```ruby\nrequire \"rbnacl\"\nrequire \"base64\"\n\nkey = Base64.decode64(\"+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=\")\npublic_key = RbNaCl::PublicKey.new(key)\n\nbox = RbNaCl::Boxes::Sealed.from_public_key(public_key)\nencrypted_secret = box.encrypt(\"my_secret\")\n\n# Print the base64 encoded secret\nputs Base64.strict_encode64(encrypted_secret)\n```")
    }

    pub fn cli_actions_delete_environment_secret() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the repository."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Delete an environment secret\n\nDeletes a secret in an environment using the \
                 secret name. You must authenticate using an access token with the `repo` scope \
                 to use this endpoint. GitHub Apps must have the `secrets` repository permission \
                 to use this endpoint.",
            )
    }

    pub fn cli_actions_list_environment_variables() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the repository."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 30)."),
            )
            .about(
                "List environment variables\n\nLists all environment variables. You must \
                 authenticate using an access token with the `repo` scope to use this endpoint. \
                 GitHub Apps must have the `environments:read` repository permission to use this \
                 endpoint.",
            )
    }

    pub fn cli_actions_create_environment_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the repository."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("value")
                    .long("value")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The value of the variable."),
            )
            .about(
                "Create an environment variable\n\nCreate an environment variable that you can \
                 reference in a GitHub Actions workflow.\nYou must authenticate using an access \
                 token with the `repo` scope to use this endpoint.\nGitHub Apps must have the \
                 `environment:write` repository permission to use this endpoint.",
            )
    }

    pub fn cli_actions_get_environment_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the repository."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .about(
                "Get an environment variable\n\nGets a specific variable in an environment. You \
                 must authenticate using an access token with the `repo` scope to use this \
                 endpoint. GitHub Apps must have the `environments:read` repository permission to \
                 use this endpoint.",
            )
    }

    pub fn cli_actions_delete_environment_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the repository."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .about(
                "Delete an environment variable\n\nDeletes an environment variable using the \
                 variable name.\nYou must authenticate using an access token with the `repo` \
                 scope to use this endpoint.\nGitHub Apps must have the `environment:write` \
                 repository permission to use this endpoint.",
            )
    }

    pub fn cli_actions_update_environment_variable() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the repository."),
            )
            .arg(
                clap::Arg::new("environment-name")
                    .long("environment-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the environment."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the variable."),
            )
            .arg(
                clap::Arg::new("value")
                    .long("value")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The value of the variable."),
            )
            .about(
                "Update an environment variable\n\nUpdates an environment variable that you can \
                 reference in a GitHub Actions workflow.\nYou must authenticate using an access \
                 token with the `repo` scope to use this endpoint.\nGitHub Apps must have the \
                 `environment:write` repository permission to use this endpoint.",
            )
    }

    pub fn cli_search_code() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("order") . long ("order") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchCodeOrder :: Desc . to_string () , types :: SearchCodeOrder :: Asc . to_string () ,]) , | s | types :: SearchCodeOrder :: try_from (s) . unwrap ())) . help ("**This field is deprecated.** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. ")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("q") . long ("q") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query). See \"[Searching code](https://docs.github.com/search-github/searching-on-github/searching-code)\" for a detailed list of qualifiers.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchCodeSort :: Indexed . to_string () ,]) , | s | types :: SearchCodeSort :: try_from (s) . unwrap ())) . help ("**This field is deprecated.** Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)")) . about ("Search code\n\nSearches for query terms inside of a file. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).\n\nWhen searching for code, you can get text match metadata for the file **content** and file **path** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).\n\nFor example, if you want to find the definition of the `addClass` function inside [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:\n\n`q=addClass+in:file+language:js+repo:jquery/jquery`\n\nThis query searches for the keyword `addClass` within a file's contents. The query limits the search to files where the language is JavaScript in the `jquery/jquery` repository.\n\n#### Considerations for code search\n\nDue to the complexity of searching code, there are a few restrictions on how searches are performed:\n\n*   Only the _default branch_ is considered. In most cases, this will be the `master` branch.\n*   Only files smaller than 384 KB are searchable.\n*   You must always include at least one search term when searching source code. For example, searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code) is not valid, while [`amazing\nlanguage:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.\n\nThis endpoint requires you to authenticate and limits you to 10 requests per minute.")
    }

    pub fn cli_search_commits() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("order") . long ("order") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchCommitsOrder :: Desc . to_string () , types :: SearchCommitsOrder :: Asc . to_string () ,]) , | s | types :: SearchCommitsOrder :: try_from (s) . unwrap ())) . help ("Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("q") . long ("q") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query). See \"[Searching commits](https://docs.github.com/search-github/searching-on-github/searching-commits)\" for a detailed list of qualifiers.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchCommitsSort :: AuthorDate . to_string () , types :: SearchCommitsSort :: CommitterDate . to_string () ,]) , | s | types :: SearchCommitsSort :: try_from (s) . unwrap ())) . help ("Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)")) . about ("Search commits\n\nFind commits via various criteria on the default branch (usually `main`). This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).\n\nWhen searching for commits, you can get text match metadata for the **message** field when you provide the `text-match` media type. For more details about how to receive highlighted search results, see [Text match\nmetadata](https://docs.github.com/rest/reference/search#text-match-metadata).\n\nFor example, if you want to find commits related to CSS in the [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look something like this:\n\n`q=repo:octocat/Spoon-Knife+css`")
    }

    pub fn cli_search_issues_and_pull_requests() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("order") . long ("order") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchIssuesAndPullRequestsOrder :: Desc . to_string () , types :: SearchIssuesAndPullRequestsOrder :: Asc . to_string () ,]) , | s | types :: SearchIssuesAndPullRequestsOrder :: try_from (s) . unwrap ())) . help ("Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("q") . long ("q") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query). See \"[Searching issues and pull requests](https://docs.github.com/search-github/searching-on-github/searching-issues-and-pull-requests)\" for a detailed list of qualifiers.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchIssuesAndPullRequestsSort :: Comments . to_string () , types :: SearchIssuesAndPullRequestsSort :: Reactions . to_string () , types :: SearchIssuesAndPullRequestsSort :: Reactions1 . to_string () , types :: SearchIssuesAndPullRequestsSort :: Reactions1 . to_string () , types :: SearchIssuesAndPullRequestsSort :: ReactionsSmile . to_string () , types :: SearchIssuesAndPullRequestsSort :: ReactionsThinkingFace . to_string () , types :: SearchIssuesAndPullRequestsSort :: ReactionsHeart . to_string () , types :: SearchIssuesAndPullRequestsSort :: ReactionsTada . to_string () , types :: SearchIssuesAndPullRequestsSort :: Interactions . to_string () , types :: SearchIssuesAndPullRequestsSort :: Created . to_string () , types :: SearchIssuesAndPullRequestsSort :: Updated . to_string () ,]) , | s | types :: SearchIssuesAndPullRequestsSort :: try_from (s) . unwrap ())) . help ("Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)")) . about ("Search issues and pull requests\n\nFind issues by state and keyword. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).\n\nWhen searching for issues, you can get text match metadata for the issue **title**, issue **body**, and issue **comment body** fields when you pass the `text-match` media type. For more details about how to receive highlighted\nsearch results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).\n\nFor example, if you want to find the oldest unresolved Python bugs on Windows. Your query might look something like this.\n\n`q=windows+label:bug+language:python+state:open&sort=created&order=asc`\n\nThis query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The search runs across repositories whose primary language is Python. The results are sorted by creation date in ascending order, which means the oldest issues appear first in the search results.\n\n**Note:** For [user-to-server](https://docs.github.com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests) GitHub App requests, you can't retrieve a combination of issues and pull requests in a single query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you must send separate queries for issues and pull requests. For more information about the `is` qualifier, see \"[Searching only issues or pull requests](https://docs.github.com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests).\"")
    }

    pub fn cli_search_labels() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("order") . long ("order") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchLabelsOrder :: Desc . to_string () , types :: SearchLabelsOrder :: Asc . to_string () ,]) , | s | types :: SearchLabelsOrder :: try_from (s) . unwrap ())) . help ("Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("q") . long ("q") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query).")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The id of the repository.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchLabelsSort :: Created . to_string () , types :: SearchLabelsSort :: Updated . to_string () ,]) , | s | types :: SearchLabelsSort :: try_from (s) . unwrap ())) . help ("Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)")) . about ("Search labels\n\nFind labels in a repository with names or descriptions that match search keywords. Returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).\n\nWhen searching for labels, you can get text match metadata for the label **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).\n\nFor example, if you want to find labels in the `linguist` repository that match `bug`, `defect`, or `enhancement`. Your query might look like this:\n\n`q=bug+defect+enhancement&repository_id=64778136`\n\nThe labels that best match the query appear first in the search results.")
    }

    pub fn cli_search_repos() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("order") . long ("order") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchReposOrder :: Desc . to_string () , types :: SearchReposOrder :: Asc . to_string () ,]) , | s | types :: SearchReposOrder :: try_from (s) . unwrap ())) . help ("Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("q") . long ("q") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query). See \"[Searching for repositories](https://docs.github.com/articles/searching-for-repositories/)\" for a detailed list of qualifiers.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchReposSort :: Stars . to_string () , types :: SearchReposSort :: Forks . to_string () , types :: SearchReposSort :: HelpWantedIssues . to_string () , types :: SearchReposSort :: Updated . to_string () ,]) , | s | types :: SearchReposSort :: try_from (s) . unwrap ())) . help ("Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)")) . about ("Search repositories\n\nFind repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).\n\nWhen searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).\n\nFor example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:\n\n`q=tetris+language:assembly&sort=stars&order=desc`\n\nThis query searches for repositories with the word `tetris` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.")
    }

    pub fn cli_search_topics() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("q") . long ("q") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query).")) . about ("Search topics\n\nFind topics via various criteria. Results are sorted by best match. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination). See \"[Searching topics](https://docs.github.com/articles/searching-topics/)\" for a detailed list of qualifiers.\n\nWhen searching for topics, you can get text match metadata for the topic's **short\\_description**, **description**, **name**, or **display\\_name** field when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).\n\nFor example, if you want to search for topics related to Ruby that are featured on https://github.com/topics. Your query might look like this:\n\n`q=ruby+is:featured`\n\nThis query searches for topics with the keyword `ruby` and limits the results to find only topics that are featured. The topics that are the best match for the query appear first in the search results.")
    }

    pub fn cli_search_users() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("order") . long ("order") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchUsersOrder :: Desc . to_string () , types :: SearchUsersOrder :: Asc . to_string () ,]) , | s | types :: SearchUsersOrder :: try_from (s) . unwrap ())) . help ("Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("q") . long ("q") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as the web interface for GitHub. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/rest/reference/search#constructing-a-search-query). See \"[Searching users](https://docs.github.com/search-github/searching-on-github/searching-users)\" for a detailed list of qualifiers.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: SearchUsersSort :: Followers . to_string () , types :: SearchUsersSort :: Repositories . to_string () , types :: SearchUsersSort :: Joined . to_string () ,]) , | s | types :: SearchUsersSort :: try_from (s) . unwrap ())) . help ("Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub. Default: [best match](https://docs.github.com/rest/reference/search#ranking-search-results)")) . about ("Search users\n\nFind users via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).\n\nWhen searching for users, you can get text match metadata for the issue **login**, public **email**, and **name** fields when you pass the `text-match` media type. For more details about highlighting search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata). For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).\n\nFor example, if you're looking for a list of popular users, you might try this query:\n\n`q=tom+repos:%3E42+followers:%3E1000`\n\nThis query searches for users with the name `tom`. The results are restricted to users with more than 42 repositories and over 1,000 followers.")
    }

    pub fn cli_teams_get_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . about ("Get a team (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the [Get a team by name](https://docs.github.com/rest/reference/teams#get-a-team-by-name) endpoint.")
    }

    pub fn cli_teams_delete_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . about ("Delete a team (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a team](https://docs.github.com/rest/reference/teams#delete-a-team) endpoint.\n\nTo delete a team, the authenticated user must be an organization owner or team maintainer.\n\nIf you are an organization owner, deleting a parent team will delete all of its child teams as well.")
    }

    pub fn cli_teams_update_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The description of the team.")) . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the team.")) . arg (clap :: Arg :: new ("notification-setting") . long ("notification-setting") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsUpdateLegacyBodyNotificationSetting :: NotificationsEnabled . to_string () , types :: TeamsUpdateLegacyBodyNotificationSetting :: NotificationsDisabled . to_string () ,]) , | s | types :: TeamsUpdateLegacyBodyNotificationSetting :: try_from (s) . unwrap ())) . help ("The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are: \n * `notifications_enabled` - team members receive notifications when the team is @mentioned.  \n * `notifications_disabled` - no one receives notifications.")) . arg (clap :: Arg :: new ("parent-team-id") . long ("parent-team-id") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The ID of a team to set as the parent team.")) . arg (clap :: Arg :: new ("permission") . long ("permission") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsUpdateLegacyBodyPermission :: Pull . to_string () , types :: TeamsUpdateLegacyBodyPermission :: Push . to_string () , types :: TeamsUpdateLegacyBodyPermission :: Admin . to_string () ,]) , | s | types :: TeamsUpdateLegacyBodyPermission :: try_from (s) . unwrap ())) . help ("**Deprecated**. The permission that new repositories will be added to the team with when none is specified.")) . arg (clap :: Arg :: new ("privacy") . long ("privacy") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsUpdateLegacyBodyPrivacy :: Secret . to_string () , types :: TeamsUpdateLegacyBodyPrivacy :: Closed . to_string () ,]) , | s | types :: TeamsUpdateLegacyBodyPrivacy :: try_from (s) . unwrap ())) . help ("The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:  \n**For a non-nested team:**  \n * `secret` - only visible to organization owners and members of this team.  \n * `closed` - visible to all members of this organization.  \n**For a parent or child team:**  \n * `closed` - visible to all members of this organization.")) . about ("Update a team (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a team](https://docs.github.com/rest/reference/teams#update-a-team) endpoint.\n\nTo edit a team, the authenticated user must either be an organization owner or a team maintainer.\n\n**Note:** With nested teams, the `privacy` for parent teams cannot be `secret`.")
    }

    pub fn cli_teams_list_discussions_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsListDiscussionsLegacyDirection :: Asc . to_string () , types :: TeamsListDiscussionsLegacyDirection :: Desc . to_string () ,]) , | s | types :: TeamsListDiscussionsLegacyDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List discussions (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.com/rest/reference/teams#list-discussions) endpoint.\n\nList all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_teams_create_discussion_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The discussion post's body text.")) . arg (clap :: Arg :: new ("private") . long ("private") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.")) . arg (clap :: Arg :: new ("title") . long ("title") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The discussion post's title.")) . about ("Create a discussion (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.github.com/rest/reference/teams#create-a-discussion) endpoint.\n\nCreates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.")
    }

    pub fn cli_teams_get_discussion_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . about ("Get a discussion (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.com/rest/reference/teams#get-a-discussion) endpoint.\n\nGet a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_teams_delete_discussion_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . about ("Delete a discussion (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.github.com/rest/reference/teams#delete-a-discussion) endpoint.\n\nDelete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_teams_update_discussion_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The discussion post's body text.")) . arg (clap :: Arg :: new ("title") . long ("title") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The discussion post's title.")) . about ("Update a discussion (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.com/rest/reference/teams#update-a-discussion) endpoint.\n\nEdits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_teams_list_discussion_comments_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsListDiscussionCommentsLegacyDirection :: Asc . to_string () , types :: TeamsListDiscussionCommentsLegacyDirection :: Desc . to_string () ,]) , | s | types :: TeamsListDiscussionCommentsLegacyDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List discussion comments (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List discussion comments](https://docs.github.com/rest/reference/teams#list-discussion-comments) endpoint.\n\nList all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_teams_create_discussion_comment_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The discussion comment's body text.")) . about ("Create a discussion comment (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Create a discussion comment](https://docs.github.com/rest/reference/teams#create-a-discussion-comment) endpoint.\n\nCreates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\n\nThis endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See \"[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)\" and \"[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)\" for details.")
    }

    pub fn cli_teams_get_discussion_comment_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("comment-number") . long ("comment-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the comment.")) . about ("Get a discussion comment (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.github.com/rest/reference/teams#get-a-discussion-comment) endpoint.\n\nGet a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_teams_delete_discussion_comment_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("comment-number") . long ("comment-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the comment.")) . about ("Delete a discussion comment (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a discussion comment](https://docs.github.com/rest/reference/teams#delete-a-discussion-comment) endpoint.\n\nDeletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_teams_update_discussion_comment_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("comment-number") . long ("comment-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the comment.")) . arg (clap :: Arg :: new ("body") . long ("body") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The discussion comment's body text.")) . about ("Update a discussion comment (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion comment](https://docs.github.com/rest/reference/teams#update-a-discussion-comment) endpoint.\n\nEdits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_reactions_list_for_team_discussion_comment_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("comment-number") . long ("comment-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the comment.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsListForTeamDiscussionCommentLegacyContent :: plus1 . to_string () , types :: ReactionsListForTeamDiscussionCommentLegacyContent :: minus1 . to_string () , types :: ReactionsListForTeamDiscussionCommentLegacyContent :: Laugh . to_string () , types :: ReactionsListForTeamDiscussionCommentLegacyContent :: Confused . to_string () , types :: ReactionsListForTeamDiscussionCommentLegacyContent :: Heart . to_string () , types :: ReactionsListForTeamDiscussionCommentLegacyContent :: Hooray . to_string () , types :: ReactionsListForTeamDiscussionCommentLegacyContent :: Rocket . to_string () , types :: ReactionsListForTeamDiscussionCommentLegacyContent :: Eyes . to_string () ,]) , | s | types :: ReactionsListForTeamDiscussionCommentLegacyContent :: try_from (s) . unwrap ())) . help ("Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion comment.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List reactions for a team discussion comment (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion comment`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.\n\nList the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_reactions_create_for_team_discussion_comment_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("comment-number") . long ("comment-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the comment.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsCreateForTeamDiscussionCommentLegacyBodyContent :: plus1 . to_string () , types :: ReactionsCreateForTeamDiscussionCommentLegacyBodyContent :: minus1 . to_string () , types :: ReactionsCreateForTeamDiscussionCommentLegacyBodyContent :: Laugh . to_string () , types :: ReactionsCreateForTeamDiscussionCommentLegacyBodyContent :: Confused . to_string () , types :: ReactionsCreateForTeamDiscussionCommentLegacyBodyContent :: Heart . to_string () , types :: ReactionsCreateForTeamDiscussionCommentLegacyBodyContent :: Hooray . to_string () , types :: ReactionsCreateForTeamDiscussionCommentLegacyBodyContent :: Rocket . to_string () , types :: ReactionsCreateForTeamDiscussionCommentLegacyBodyContent :: Eyes . to_string () ,]) , | s | types :: ReactionsCreateForTeamDiscussionCommentLegacyBodyContent :: try_from (s) . unwrap ())) . help ("The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion comment.")) . about ("Create reaction for a team discussion comment (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new \"[Create reaction for a team discussion comment](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)\" endpoint.\n\nCreate a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.")
    }

    pub fn cli_reactions_list_for_team_discussion_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsListForTeamDiscussionLegacyContent :: plus1 . to_string () , types :: ReactionsListForTeamDiscussionLegacyContent :: minus1 . to_string () , types :: ReactionsListForTeamDiscussionLegacyContent :: Laugh . to_string () , types :: ReactionsListForTeamDiscussionLegacyContent :: Confused . to_string () , types :: ReactionsListForTeamDiscussionLegacyContent :: Heart . to_string () , types :: ReactionsListForTeamDiscussionLegacyContent :: Hooray . to_string () , types :: ReactionsListForTeamDiscussionLegacyContent :: Rocket . to_string () , types :: ReactionsListForTeamDiscussionLegacyContent :: Eyes . to_string () ,]) , | s | types :: ReactionsListForTeamDiscussionLegacyContent :: try_from (s) . unwrap ())) . help ("Returns a single [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types). Omit this parameter to list all reactions to a team discussion.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List reactions for a team discussion (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.\n\nList the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_reactions_create_for_team_discussion_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("discussion-number") . long ("discussion-number") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The number that identifies the discussion.")) . arg (clap :: Arg :: new ("content") . long ("content") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReactionsCreateForTeamDiscussionLegacyBodyContent :: plus1 . to_string () , types :: ReactionsCreateForTeamDiscussionLegacyBodyContent :: minus1 . to_string () , types :: ReactionsCreateForTeamDiscussionLegacyBodyContent :: Laugh . to_string () , types :: ReactionsCreateForTeamDiscussionLegacyBodyContent :: Confused . to_string () , types :: ReactionsCreateForTeamDiscussionLegacyBodyContent :: Heart . to_string () , types :: ReactionsCreateForTeamDiscussionLegacyBodyContent :: Hooray . to_string () , types :: ReactionsCreateForTeamDiscussionLegacyBodyContent :: Rocket . to_string () , types :: ReactionsCreateForTeamDiscussionLegacyBodyContent :: Eyes . to_string () ,]) , | s | types :: ReactionsCreateForTeamDiscussionLegacyBodyContent :: try_from (s) . unwrap ())) . help ("The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion.")) . about ("Create reaction for a team discussion (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create reaction for a team discussion`](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.\n\nCreate a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.")
    }

    pub fn cli_teams_list_pending_invitations_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List pending team invitations (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List pending team invitations`](https://docs.github.com/rest/reference/teams#list-pending-team-invitations) endpoint.\n\nThe return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.")
    }

    pub fn cli_teams_list_members_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("role") . long ("role") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsListMembersLegacyRole :: Member . to_string () , types :: TeamsListMembersLegacyRole :: Maintainer . to_string () , types :: TeamsListMembersLegacyRole :: All . to_string () ,]) , | s | types :: TeamsListMembersLegacyRole :: try_from (s) . unwrap ())) . help ("Filters members returned by their role in the team.")) . about ("List team members (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team members`](https://docs.github.com/rest/reference/teams#list-team-members) endpoint.\n\nTeam members will include the members of child teams.")
    }

    pub fn cli_teams_get_member_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Get team member (Legacy)\n\nThe \"Get team member\" endpoint (described below) is deprecated.\n\nWe recommend using the [Get team membership for a user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint instead. It allows you to get both active and pending memberships.\n\nTo list members in a team, the team must be visible to the authenticated user.")
    }

    pub fn cli_teams_add_member_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Add team member (Legacy)\n\nThe \"Add team member\" endpoint (described below) is deprecated.\n\nWe recommend using the [Add or update team membership for a user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint instead. It allows you to invite new organization members to your teams.\n\nTeam synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nTo add someone to a team, the authenticated user must be an organization owner or a team maintainer in the team they're changing. The person being added to the team must be a member of the team's organization.\n\n**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see \"[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/).\"\n\nNote that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"")
    }

    pub fn cli_teams_remove_member_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Remove team member (Legacy)\n\nThe \"Remove team member\" endpoint (described below) is deprecated.\n\nWe recommend using the [Remove team membership for a user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint instead. It allows you to remove both active and pending memberships.\n\nTeam synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nTo remove a team member, the authenticated user must have 'admin' permissions to the team or be an owner of the org that the team is associated with. Removing a team member does not delete the user, it just removes them from the team.\n\n**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see \"[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/).\"")
    }

    pub fn cli_teams_get_membership_for_user_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Get team membership for a user (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get team membership for a user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint.\n\nTeam members will include the members of child teams.\n\nTo get a user's membership with a team, the team must be visible to the authenticated user.\n\n**Note:**\nThe response contains the `state` of the membership and the member's `role`.\n\nThe `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).")
    }

    pub fn cli_teams_add_or_update_membership_for_user_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("role") . long ("role") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsAddOrUpdateMembershipForUserLegacyBodyRole :: Member . to_string () , types :: TeamsAddOrUpdateMembershipForUserLegacyBodyRole :: Maintainer . to_string () ,]) , | s | types :: TeamsAddOrUpdateMembershipForUserLegacyBodyRole :: try_from (s) . unwrap ())) . help ("The role that this user should have in the team.")) . about ("Add or update team membership for a user (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team membership for a user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint.\n\nTeam synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nIf the user is already a member of the team's organization, this endpoint will add the user to the team. To add a membership between an organization member and a team, the authenticated user must be an organization owner or a team maintainer.\n\n**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see \"[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/).\"\n\nIf the user is unaffiliated with the team's organization, this endpoint will send an invitation to the user via email. This newly-created membership will be in the \"pending\" state until the user accepts the invitation, at which point the membership will transition to the \"active\" state and the user will be added as a member of the team. To add a membership between an unaffiliated user and a team, the authenticated user must be an organization owner.\n\nIf the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.")
    }

    pub fn cli_teams_remove_membership_for_user_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Remove team membership for a user (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove team membership for a user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint.\n\nTeam synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.\n\nTo remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.\n\n**Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see \"[Synchronizing teams between your identity provider and GitHub](https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/).\"")
    }

    pub fn cli_teams_list_projects_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List team projects (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team projects`](https://docs.github.com/rest/reference/teams#list-team-projects) endpoint.\n\nLists the organization projects for a team.")
    }

    pub fn cli_teams_check_permissions_for_project_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("project-id") . long ("project-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the project.")) . about ("Check team permissions for a project (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a project](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project) endpoint.\n\nChecks whether a team has `read`, `write`, or `admin` permissions for an organization project. The response includes projects inherited from a parent team.")
    }

    pub fn cli_teams_add_or_update_project_permissions_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("project-id") . long ("project-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the project.")) . arg (clap :: Arg :: new ("permission") . long ("permission") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsAddOrUpdateProjectPermissionsLegacyBodyPermission :: Read . to_string () , types :: TeamsAddOrUpdateProjectPermissionsLegacyBodyPermission :: Write . to_string () , types :: TeamsAddOrUpdateProjectPermissionsLegacyBodyPermission :: Admin . to_string () ,]) , | s | types :: TeamsAddOrUpdateProjectPermissionsLegacyBodyPermission :: try_from (s) . unwrap ())) . help ("The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"")) . about ("Add or update team project permissions (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team project permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions) endpoint.\n\nAdds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated user must have `admin` permissions for the project. The project and team must be part of the same organization.")
    }

    pub fn cli_teams_remove_project_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("project-id") . long ("project-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the project.")) . about ("Remove a project from a team (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a project from a team](https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team) endpoint.\n\nRemoves an organization project from a team. An organization owner or a team maintainer can remove any project from the team. To remove a project from a team as an organization member, the authenticated user must have `read` access to both the team and project, or `admin` access to the team or project. **Note:** This endpoint removes the project from the team, but does not delete it.")
    }

    pub fn cli_teams_list_repos_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List team repositories (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List team repositories](https://docs.github.com/rest/reference/teams#list-team-repositories) endpoint.")
    }

    pub fn cli_teams_check_permissions_for_repo_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Check team permissions for a repository (Legacy)\n\n**Note**: Repositories inherited through a parent team will also be checked.\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-repository) endpoint.\n\nYou can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:")
    }

    pub fn cli_teams_add_or_update_repo_permissions_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("permission") . long ("permission") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: TeamsAddOrUpdateRepoPermissionsLegacyBodyPermission :: Pull . to_string () , types :: TeamsAddOrUpdateRepoPermissionsLegacyBodyPermission :: Push . to_string () , types :: TeamsAddOrUpdateRepoPermissionsLegacyBodyPermission :: Admin . to_string () ,]) , | s | types :: TeamsAddOrUpdateRepoPermissionsLegacyBodyPermission :: try_from (s) . unwrap ())) . help ("The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.")) . about ("Add or update team repository permissions (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new \"[Add or update team repository permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-repository-permissions)\" endpoint.\n\nTo add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization.\n\nNote that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"")
    }

    pub fn cli_teams_remove_repo_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Remove a repository from a team (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a repository from a team](https://docs.github.com/rest/reference/teams#remove-a-repository-from-a-team) endpoint.\n\nIf the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. NOTE: This does not delete the repository, it just removes it from the team.")
    }

    pub fn cli_teams_list_child_legacy() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the team.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List child teams (Legacy)\n\n**Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.com/rest/reference/teams#list-child-teams) endpoint.")
    }

    pub fn cli_users_get_authenticated() -> clap::Command {
        clap::Command::new("").about(
            "Get the authenticated user\n\nIf the authenticated user is authenticated through \
             basic authentication or OAuth with the `user` scope, then the response lists public \
             and private profile information.\n\nIf the authenticated user is authenticated \
             through OAuth without the `user` scope, then the response lists only public profile \
             information.",
        )
    }

    pub fn cli_users_update_authenticated() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("bio")
                    .long("bio")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The new short biography of the user."),
            )
            .arg(
                clap::Arg::new("blog")
                    .long("blog")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The new blog URL of the user."),
            )
            .arg(
                clap::Arg::new("company")
                    .long("company")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The new company of the user."),
            )
            .arg(
                clap::Arg::new("email")
                    .long("email")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The publicly visible email address of the user."),
            )
            .arg(
                clap::Arg::new("hireable")
                    .long("hireable")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help("The new hiring availability of the user."),
            )
            .arg(
                clap::Arg::new("location")
                    .long("location")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The new location of the user."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The new name of the user."),
            )
            .arg(
                clap::Arg::new("twitter-username")
                    .long("twitter-username")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("The new Twitter username of the user."),
            )
            .about(
                "Update the authenticated user\n\n**Note:** If your email is set to private and \
                 you send an `email` parameter as part of this request to update your profile, \
                 your privacy settings are still enforced: the email address will not be \
                 displayed on your public profile or via the API.",
            )
    }

    pub fn cli_users_list_blocked_by_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List users blocked by the authenticated user\n\nList the users you've blocked on \
                 your personal account.",
            )
    }

    pub fn cli_users_check_blocked() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about("Check if a user is blocked by the authenticated user")
    }

    pub fn cli_users_block() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about("Block a user")
    }

    pub fn cli_users_unblock() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about("Unblock a user")
    }

    pub fn cli_codespaces_list_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("ID of the Repository to filter on"),
            )
            .about(
                "List codespaces for the authenticated user\n\nLists the authenticated user's \
                 codespaces.\n\nYou must authenticate using an access token with the `codespace` \
                 scope to use this endpoint.\n\nGitHub Apps must have read access to the \
                 `codespaces` repository permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_create_for_authenticated_user() -> clap::Command {
        clap::Command::new("").about(
            "Create a codespace for the authenticated user\n\nCreates a new codespace, owned by \
             the authenticated user.\n\nThis endpoint requires either a `repository_id` OR a \
             `pull_request` but not both.\n\nYou must authenticate using an access token with the \
             `codespace` scope to use this endpoint.\n\nGitHub Apps must have write access to the \
             `codespaces` repository permission to use this endpoint.",
        )
    }

    pub fn cli_codespaces_list_secrets_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List secrets for the authenticated user\n\nLists all secrets available for a \
                 user's Codespaces without revealing their\nencrypted values.\n\nYou must \
                 authenticate using an access token with the `codespace` or `codespace:secrets` \
                 scope to use this endpoint. User must have Codespaces access to use this \
                 endpoint.\n\nGitHub Apps must have read access to the `codespaces_user_secrets` \
                 user permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_get_public_key_for_authenticated_user() -> clap::Command {
        clap::Command::new("").about(
            "Get public key for the authenticated user\n\nGets your public key, which you need to \
             encrypt secrets. You need to encrypt a secret before you can create or update \
             secrets.\n\nYou must authenticate using an access token with the `codespace` or \
             `codespace:secrets` scope to use this endpoint. User must have Codespaces access to \
             use this endpoint.\n\nGitHub Apps must have read access to the \
             `codespaces_user_secrets` user permission to use this endpoint.",
        )
    }

    pub fn cli_codespaces_get_secret_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Get a secret for the authenticated user\n\nGets a secret available to a user's \
                 codespaces without revealing its encrypted value.\n\nYou must authenticate using \
                 an access token with the `codespace` or `codespace:secrets` scope to use this \
                 endpoint. User must have Codespaces access to use this endpoint.\n\nGitHub Apps \
                 must have read access to the `codespaces_user_secrets` user permission to use \
                 this endpoint.",
            )
    }

    pub fn cli_codespaces_create_or_update_secret_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("secret-name") . long ("secret-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the secret.")) . arg (clap :: Arg :: new ("encrypted-value") . long ("encrypted-value") . required (false) . value_parser (clap :: value_parser ! (types :: CodespacesCreateOrUpdateSecretForAuthenticatedUserBodyEncryptedValue)) . help ("Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get the public key for the authenticated user](https://docs.github.com/rest/reference/codespaces#get-the-public-key-for-the-authenticated-user) endpoint.")) . arg (clap :: Arg :: new ("key-id") . long ("key-id") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("ID of the key you used to encrypt the secret.")) . about ("Create or update a secret for the authenticated user\n\nCreates or updates a secret for a user's codespace with an encrypted value. Encrypt your secret using\n[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages).\n\nYou must authenticate using an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User must also have Codespaces access to use this endpoint.\n\nGitHub Apps must have write access to the `codespaces_user_secrets` user permission and `codespaces_secrets` repository permission on all referenced repositories to use this endpoint.\n\n#### Example encrypting a secret using Node.js\n\nEncrypt your secret using the [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library.\n\n```\nconst sodium = require('libsodium-wrappers')\nconst secret = 'plain-text-secret' // replace with the secret you want to encrypt\nconst key = 'base64-encoded-public-key' // replace with the Base64 encoded public key\n\n//Check if libsodium is ready and then proceed.\nsodium.ready.then(() => {\n  // Convert Secret & Base64 key to Uint8Array.\n  let binkey = sodium.from_base64(key, sodium.base64_variants.ORIGINAL)\n  let binsec = sodium.from_string(secret)\n\n  //Encrypt the secret using LibSodium\n  let encBytes = sodium.crypto_box_seal(binsec, binkey)\n\n  // Convert encrypted Uint8Array to Base64\n  let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)\n\n  console.log(output)\n});\n```\n\n#### Example encrypting a secret using Python\n\nEncrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with Python 3.\n\n```\nfrom base64 import b64encode\nfrom nacl import encoding, public\n\ndef encrypt(public_key: str, secret_value: str) -> str:\n  \"\"\"Encrypt a Unicode string using the public key.\"\"\"\n  public_key = public.PublicKey(public_key.encode(\"utf-8\"), encoding.Base64Encoder())\n  sealed_box = public.SealedBox(public_key)\n  encrypted = sealed_box.encrypt(secret_value.encode(\"utf-8\"))\n  return b64encode(encrypted).decode(\"utf-8\")\n```\n\n#### Example encrypting a secret using C#\n\nEncrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.\n\n```\nvar secretValue = System.Text.Encoding.UTF8.GetBytes(\"mySecret\");\nvar publicKey = Convert.FromBase64String(\"2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=\");\n\nvar sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);\n\nConsole.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));\n```\n\n#### Example encrypting a secret using Ruby\n\nEncrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.\n\n```ruby\nrequire \"rbnacl\"\nrequire \"base64\"\n\nkey = Base64.decode64(\"+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=\")\npublic_key = RbNaCl::PublicKey.new(key)\n\nbox = RbNaCl::Boxes::Sealed.from_public_key(public_key)\nencrypted_secret = box.encrypt(\"my_secret\")\n\n# Print the base64 encoded secret\nputs Base64.strict_encode64(encrypted_secret)\n```")
    }

    pub fn cli_codespaces_delete_secret_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Delete a secret for the authenticated user\n\nDeletes a secret from a user's \
                 codespaces using the secret name. Deleting the secret will remove access from \
                 all codespaces that were allowed to access the secret.\n\nYou must authenticate \
                 using an access token with the `codespace` or `codespace:secrets` scope to use \
                 this endpoint. User must have Codespaces access to use this endpoint.\n\nGitHub \
                 Apps must have write access to the `codespaces_user_secrets` user permission to \
                 use this endpoint.",
            )
    }

    pub fn cli_codespaces_list_repositories_for_secret_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "List selected repositories for a user secret\n\nList the repositories that have \
                 been granted the ability to use a user's codespace secret.\n\nYou must \
                 authenticate using an access token with the `codespace` or `codespace:secrets` \
                 scope to use this endpoint. User must have Codespaces access to use this \
                 endpoint.\n\nGitHub Apps must have read access to the `codespaces_user_secrets` \
                 user permission and write access to the `codespaces_secrets` repository \
                 permission on all referenced repositories to use this endpoint.",
            )
    }

    pub fn cli_codespaces_set_repositories_for_secret_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .about(
                "Set selected repositories for a user secret\n\nSelect the repositories that will \
                 use a user's codespace secret.\n\nYou must authenticate using an access token \
                 with the `codespace` or `codespace:secrets` scope to use this endpoint. User \
                 must have Codespaces access to use this endpoint.\n\nGitHub Apps must have write \
                 access to the `codespaces_user_secrets` user permission and write access to the \
                 `codespaces_secrets` repository permission on all referenced repositories to use \
                 this endpoint.",
            )
    }

    pub fn cli_codespaces_add_repository_for_secret_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64)),
            )
            .about(
                "Add a selected repository to a user secret\n\nAdds a repository to the selected \
                 repositories for a user's codespace secret.\nYou must authenticate using an \
                 access token with the `codespace` or `codespace:secrets` scope to use this \
                 endpoint. User must have Codespaces access to use this endpoint.\nGitHub Apps \
                 must have write access to the `codespaces_user_secrets` user permission and \
                 write access to the `codespaces_secrets` repository permission on the referenced \
                 repository to use this endpoint.",
            )
    }

    pub fn cli_codespaces_remove_repository_for_secret_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("secret-name")
                    .long("secret-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the secret."),
            )
            .arg(
                clap::Arg::new("repository-id")
                    .long("repository-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64)),
            )
            .about(
                "Remove a selected repository from a user secret\n\nRemoves a repository from the \
                 selected repositories for a user's codespace secret.\nYou must authenticate \
                 using an access token with the `codespace` or `codespace:secrets` scope to use \
                 this endpoint. User must have Codespaces access to use this endpoint.\nGitHub \
                 Apps must have write access to the `codespaces_user_secrets` user permission to \
                 use this endpoint.",
            )
    }

    pub fn cli_codespaces_get_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("codespace-name")
                    .long("codespace-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the codespace."),
            )
            .about(
                "Get a codespace for the authenticated user\n\nGets information about a user's \
                 codespace.\n\nYou must authenticate using an access token with the `codespace` \
                 scope to use this endpoint.\n\nGitHub Apps must have read access to the \
                 `codespaces` repository permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_delete_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("codespace-name")
                    .long("codespace-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the codespace."),
            )
            .about(
                "Delete a codespace for the authenticated user\n\nDeletes a user's \
                 codespace.\n\nYou must authenticate using an access token with the `codespace` \
                 scope to use this endpoint.\n\nGitHub Apps must have write access to the \
                 `codespaces` repository permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_update_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("codespace-name")
                    .long("codespace-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the codespace."),
            )
            .arg(
                clap::Arg::new("display-name")
                    .long("display-name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Display name for this codespace"),
            )
            .arg(
                clap::Arg::new("machine")
                    .long("machine")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("A valid machine to transition this codespace to."),
            )
            .about(
                "Update a codespace for the authenticated user\n\nUpdates a codespace owned by \
                 the authenticated user. Currently only the codespace's machine type and recent \
                 folders can be modified using this endpoint.\n\nIf you specify a new machine \
                 type it will be applied the next time your codespace is started.\n\nYou must \
                 authenticate using an access token with the `codespace` scope to use this \
                 endpoint.\n\nGitHub Apps must have write access to the `codespaces` repository \
                 permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_export_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("codespace-name")
                    .long("codespace-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the codespace."),
            )
            .about(
                "Export a codespace for the authenticated user\n\nTriggers an export of the \
                 specified codespace and returns a URL and ID where the status of the export can \
                 be monitored.\n\nIf changes cannot be pushed to the codespace's repository, they \
                 will be pushed to a new or previously-existing fork instead.\n\nYou must \
                 authenticate using a personal access token with the `codespace` scope to use \
                 this endpoint.\n\nGitHub Apps must have write access to the \
                 `codespaces_lifecycle_admin` repository permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_get_export_details_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("codespace-name")
                    .long("codespace-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the codespace."),
            )
            .arg(
                clap::Arg::new("export-id")
                    .long("export-id")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help(
                        "The ID of the export operation, or `latest`. Currently only `latest` is \
                         currently supported.",
                    ),
            )
            .about(
                "Get details about a codespace export\n\nGets information about an export of a \
                 codespace.\n\nYou must authenticate using a personal access token with the \
                 `codespace` scope to use this endpoint.\n\nGitHub Apps must have read access to \
                 the `codespaces_lifecycle_admin` repository permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_codespace_machines_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("codespace-name")
                    .long("codespace-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the codespace."),
            )
            .about(
                "List machine types for a codespace\n\nList the machine types a codespace can \
                 transition to use.\n\nYou must authenticate using an access token with the \
                 `codespace` scope to use this endpoint.\n\nGitHub Apps must have read access to \
                 the `codespaces_metadata` repository permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_publish_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("codespace-name")
                    .long("codespace-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the codespace."),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("A name for the new repository."),
            )
            .arg(
                clap::Arg::new("private")
                    .long("private")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help("Whether the new repository should be private."),
            )
            .about(
                "Create a repository from an unpublished codespace\n\nPublishes an unpublished \
                 codespace, creating a new repository and assigning it to the codespace.\n\nThe \
                 codespace's token is granted write permissions to the repository, allowing the \
                 user to push their changes.\n\nThis will fail for a codespace that is already \
                 published, meaning it has an associated repository.\n\nYou must authenticate \
                 using a personal access token with the `codespace` scope to use this \
                 endpoint.\n\nGitHub Apps must have write access to the `codespaces` repository \
                 permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_start_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("codespace-name")
                    .long("codespace-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the codespace."),
            )
            .about(
                "Start a codespace for the authenticated user\n\nStarts a user's \
                 codespace.\n\nYou must authenticate using an access token with the `codespace` \
                 scope to use this endpoint.\n\nGitHub Apps must have write access to the \
                 `codespaces_lifecycle_admin` repository permission to use this endpoint.",
            )
    }

    pub fn cli_codespaces_stop_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("codespace-name")
                    .long("codespace-name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the codespace."),
            )
            .about(
                "Stop a codespace for the authenticated user\n\nStops a user's codespace.\n\nYou \
                 must authenticate using an access token with the `codespace` scope to use this \
                 endpoint.\n\nGitHub Apps must have write access to the \
                 `codespaces_lifecycle_admin` repository permission to use this endpoint.",
            )
    }

    pub fn cli_packages_list_docker_migration_conflicting_packages_for_authenticated_user(
    ) -> clap::Command {
        clap::Command::new("").about(
            "Get list of conflicting packages during Docker migration for \
             authenticated-user\n\nLists all packages that are owned by the authenticated user \
             within the user's namespace, and that encountered a conflict during a Docker \
             migration.\nTo use this endpoint, you must authenticate using an access token with \
             the `read:packages` scope.",
        )
    }

    pub fn cli_users_set_primary_email_visibility_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("visibility") . long ("visibility") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: UsersSetPrimaryEmailVisibilityForAuthenticatedUserBodyVisibility :: Public . to_string () , types :: UsersSetPrimaryEmailVisibilityForAuthenticatedUserBodyVisibility :: Private . to_string () ,]) , | s | types :: UsersSetPrimaryEmailVisibilityForAuthenticatedUserBodyVisibility :: try_from (s) . unwrap ())) . help ("Denotes whether an email is publicly visible.")) . about ("Set primary email visibility for the authenticated user\n\nSets the visibility for your primary email addresses.")
    }

    pub fn cli_users_list_emails_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List email addresses for the authenticated user\n\nLists all of your email \
                 addresses, and specifies which one is visible to the public. This endpoint is \
                 accessible with the `user:email` scope.",
            )
    }

    pub fn cli_users_add_email_for_authenticated_user() -> clap::Command {
        clap::Command::new("").about(
            "Add an email address for the authenticated user\n\nThis endpoint is accessible with \
             the `user` scope.",
        )
    }

    pub fn cli_users_delete_email_for_authenticated_user() -> clap::Command {
        clap::Command::new("").about(
            "Delete an email address for the authenticated user\n\nThis endpoint is accessible \
             with the `user` scope.",
        )
    }

    pub fn cli_users_list_followers_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List followers of the authenticated user\n\nLists the people following the \
                 authenticated user.",
            )
    }

    pub fn cli_users_list_followed_by_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List the people the authenticated user follows\n\nLists the people who the \
                 authenticated user follows.",
            )
    }

    pub fn cli_users_check_person_is_followed_by_authenticated() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about("Check if a person is followed by the authenticated user")
    }

    pub fn cli_users_follow() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Follow a user\n\nNote that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"\n\nFollowing a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.")
    }

    pub fn cli_users_unfollow() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Unfollow a user\n\nUnfollowing a user requires the user to be logged in and \
                 authenticated with basic auth or OAuth with the `user:follow` scope.",
            )
    }

    pub fn cli_users_list_gpg_keys_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List GPG keys for the authenticated user\n\nLists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_users_create_gpg_key_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("armored-public-key") . long ("armored-public-key") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("A GPG key in ASCII-armored format.")) . arg (clap :: Arg :: new ("name") . long ("name") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A descriptive name for the new key.")) . about ("Create a GPG key for the authenticated user\n\nAdds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_users_get_gpg_key_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("gpg-key-id") . long ("gpg-key-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the GPG key.")) . about ("Get a GPG key for the authenticated user\n\nView extended details for a single GPG key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_users_delete_gpg_key_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("gpg-key-id") . long ("gpg-key-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the GPG key.")) . about ("Delete a GPG key for the authenticated user\n\nRemoves a GPG key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_apps_list_installations_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List app installations accessible to the user access token\n\nLists installations of your GitHub App that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.\n\nYou must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.\n\nThe authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.\n\nYou can find the permissions for the installation under the `permissions` key.")
    }

    pub fn cli_apps_list_installation_repos_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("installation-id") . long ("installation-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the installation.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List repositories accessible to the user access token\n\nList repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access for an installation.\n\nThe authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.\n\nYou must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.\n\nThe access the user has to each repository is included in the hash under the `permissions` key.")
    }

    pub fn cli_apps_add_repo_to_installation_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("installation-id") . long ("installation-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the installation.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the repository.")) . about ("Add a repository to an app installation\n\nAdd a single repository to an installation. The authenticated user must have admin access to the repository.\n\nYou must use a personal access token (which you can create via the [command line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.")
    }

    pub fn cli_apps_remove_repo_from_installation_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("installation-id") . long ("installation-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the installation.")) . arg (clap :: Arg :: new ("repository-id") . long ("repository-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the repository.")) . about ("Remove a repository from an app installation\n\nRemove a single repository from an installation. The authenticated user must have admin access to the repository.\n\nYou must use a personal access token (which you can create via the [command line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.")
    }

    pub fn cli_interactions_get_restrictions_for_authenticated_user() -> clap::Command {
        clap::Command::new("").about(
            "Get interaction restrictions for your public repositories\n\nShows which type of \
             GitHub user can interact with your public repositories and when the restriction \
             expires.",
        )
    }

    pub fn cli_interactions_set_restrictions_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("expiry")
                    .long("expiry")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::InteractionExpiry::OneDay.to_string(),
                            types::InteractionExpiry::ThreeDays.to_string(),
                            types::InteractionExpiry::OneWeek.to_string(),
                            types::InteractionExpiry::OneMonth.to_string(),
                            types::InteractionExpiry::SixMonths.to_string(),
                        ]),
                        |s| types::InteractionExpiry::try_from(s).unwrap(),
                    )),
            )
            .arg(
                clap::Arg::new("limit")
                    .long("limit")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::InteractionGroup::ExistingUsers.to_string(),
                            types::InteractionGroup::ContributorsOnly.to_string(),
                            types::InteractionGroup::CollaboratorsOnly.to_string(),
                        ]),
                        |s| types::InteractionGroup::try_from(s).unwrap(),
                    )),
            )
            .about(
                "Set interaction restrictions for your public repositories\n\nTemporarily \
                 restricts which type of GitHub user can interact with your public repositories. \
                 Setting the interaction limit at the user level will overwrite any interaction \
                 limits that are set for individual repositories owned by the user.",
            )
    }

    pub fn cli_interactions_remove_restrictions_for_authenticated_user() -> clap::Command {
        clap::Command::new("").about(
            "Remove interaction restrictions from your public repositories\n\nRemoves any \
             interaction restrictions from your public repositories.",
        )
    }

    pub fn cli_issues_list_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListForAuthenticatedUserDirection :: Asc . to_string () , types :: IssuesListForAuthenticatedUserDirection :: Desc . to_string () ,]) , | s | types :: IssuesListForAuthenticatedUserDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("filter") . long ("filter") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListForAuthenticatedUserFilter :: Assigned . to_string () , types :: IssuesListForAuthenticatedUserFilter :: Created . to_string () , types :: IssuesListForAuthenticatedUserFilter :: Mentioned . to_string () , types :: IssuesListForAuthenticatedUserFilter :: Subscribed . to_string () , types :: IssuesListForAuthenticatedUserFilter :: Repos . to_string () , types :: IssuesListForAuthenticatedUserFilter :: All . to_string () ,]) , | s | types :: IssuesListForAuthenticatedUserFilter :: try_from (s) . unwrap ())) . help ("Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.")) . arg (clap :: Arg :: new ("labels") . long ("labels") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A list of comma separated label names. Example: `bug,ui,@high`")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListForAuthenticatedUserSort :: Created . to_string () , types :: IssuesListForAuthenticatedUserSort :: Updated . to_string () , types :: IssuesListForAuthenticatedUserSort :: Comments . to_string () ,]) , | s | types :: IssuesListForAuthenticatedUserSort :: try_from (s) . unwrap ())) . help ("What to sort results by.")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: IssuesListForAuthenticatedUserState :: Open . to_string () , types :: IssuesListForAuthenticatedUserState :: Closed . to_string () , types :: IssuesListForAuthenticatedUserState :: All . to_string () ,]) , | s | types :: IssuesListForAuthenticatedUserState :: try_from (s) . unwrap ())) . help ("Indicates the state of the issues to return.")) . about ("List user account issues assigned to the authenticated user\n\nList issues across owned and member repositories assigned to the authenticated user.\n\n**Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this\nreason, \"Issues\" endpoints may return both issues and pull requests in the response. You can identify pull requests by\nthe `pull_request` key. Be aware that the `id` of a pull request returned from \"Issues\" endpoints will be an _issue id_. To find out the pull\nrequest id, use the \"[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)\" endpoint.")
    }

    pub fn cli_users_list_public_ssh_keys_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List public SSH keys for the authenticated user\n\nLists the public SSH keys for the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_users_create_public_ssh_key_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("key") . long ("key") . required (true) . value_parser (clap :: value_parser ! (types :: UsersCreatePublicSshKeyForAuthenticatedUserBodyKey)) . help ("The public SSH key to add to your GitHub account.")) . arg (clap :: Arg :: new ("title") . long ("title") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A descriptive name for the new key.")) . about ("Create a public SSH key for the authenticated user\n\nAdds a public SSH key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_users_get_public_ssh_key_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("key-id") . long ("key-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the key.")) . about ("Get a public SSH key for the authenticated user\n\nView extended details for a single public SSH key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_users_delete_public_ssh_key_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("key-id") . long ("key-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the key.")) . about ("Delete a public SSH key for the authenticated user\n\nRemoves a public SSH key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).")
    }

    pub fn cli_apps_list_subscriptions_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List subscriptions for the authenticated user\n\nLists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).")
    }

    pub fn cli_apps_list_subscriptions_for_authenticated_user_stubbed() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List subscriptions for the authenticated user (stubbed)\n\nLists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).")
    }

    pub fn cli_orgs_list_memberships_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::OrgsListMembershipsForAuthenticatedUserState::Active.to_string(),
                            types::OrgsListMembershipsForAuthenticatedUserState::Pending
                                .to_string(),
                        ]),
                        |s| {
                            types::OrgsListMembershipsForAuthenticatedUserState::try_from(s)
                                .unwrap()
                        },
                    ))
                    .help(
                        "Indicates the state of the memberships to return. If not specified, the \
                         API returns both active and pending memberships.",
                    ),
            )
            .about("List organization memberships for the authenticated user")
    }

    pub fn cli_orgs_get_membership_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .about("Get an organization membership for the authenticated user")
    }

    pub fn cli_orgs_update_membership_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(true)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::OrgsUpdateMembershipForAuthenticatedUserBodyState::Active
                                .to_string(),
                        ]),
                        |s| {
                            types::OrgsUpdateMembershipForAuthenticatedUserBodyState::try_from(s)
                                .unwrap()
                        },
                    ))
                    .help(
                        "The state that the membership should be in. Only `\"active\"` will be \
                         accepted.",
                    ),
            )
            .about("Update an organization membership for the authenticated user")
    }

    pub fn cli_migrations_list_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List user migrations\n\nLists all migrations a user has started.")
    }

    pub fn cli_migrations_start_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("exclude-attachments")
                    .long("exclude-attachments")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help("Do not include attachments in the migration"),
            )
            .arg(
                clap::Arg::new("exclude-git-data")
                    .long("exclude-git-data")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether the repository git data should be excluded from the \
                         migration.",
                    ),
            )
            .arg(
                clap::Arg::new("exclude-metadata")
                    .long("exclude-metadata")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether metadata should be excluded and only git source should \
                         be included for the migration.",
                    ),
            )
            .arg(
                clap::Arg::new("exclude-owner-projects")
                    .long("exclude-owner-projects")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether projects owned by the organization or users should be \
                         excluded.",
                    ),
            )
            .arg(
                clap::Arg::new("exclude-releases")
                    .long("exclude-releases")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help("Do not include releases in the migration"),
            )
            .arg(
                clap::Arg::new("lock-repositories")
                    .long("lock-repositories")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help("Lock the repositories being migrated at the start of the migration"),
            )
            .arg(
                clap::Arg::new("org-metadata-only")
                    .long("org-metadata-only")
                    .required(false)
                    .value_parser(clap::value_parser!(bool))
                    .help(
                        "Indicates whether this should only include organization metadata \
                         (repositories array should be empty and will ignore other flags).",
                    ),
            )
            .about(
                "Start a user migration\n\nInitiates the generation of a user migration archive.",
            )
    }

    pub fn cli_migrations_get_status_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("migration-id") . long ("migration-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the migration.")) . arg (clap :: Arg :: new ("exclude") . long ("exclude") . required (false) . value_parser (clap :: value_parser ! (Vec < String >))) . about ("Get a user migration status\n\nFetches a single user migration. The response includes the `state` of the migration, which can be one of the following values:\n\n*   `pending` - the migration hasn't started yet.\n*   `exporting` - the migration is in progress.\n*   `exported` - the migration finished successfully.\n*   `failed` - the migration failed.\n\nOnce the migration has been `exported` you can [download the migration archive](https://docs.github.com/rest/migrations/users#download-a-user-migration-archive).")
    }

    pub fn cli_migrations_get_archive_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("migration-id")
                    .long("migration-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the migration."),
            )
            .about(
                "Download a user migration archive\n\nFetches the URL to download the migration \
                 archive as a `tar.gz` file. Depending on the resources your repository uses, the \
                 migration archive can contain JSON files with data for these objects:\n\n*   \
                 attachments\n*   bases\n*   commit\\_comments\n*   issue\\_comments\n*   \
                 issue\\_events\n*   issues\n*   milestones\n*   organizations\n*   projects\n*   \
                 protected\\_branches\n*   pull\\_request\\_reviews\n*   pull\\_requests\n*   \
                 releases\n*   repositories\n*   review\\_comments\n*   schema\n*   users\n\nThe \
                 archive will also contain an `attachments` directory that includes all \
                 attachment files uploaded to GitHub.com and a `repositories` directory that \
                 contains the repository's Git data.",
            )
    }

    pub fn cli_migrations_delete_archive_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("migration-id") . long ("migration-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the migration.")) . about ("Delete a user migration archive\n\nDeletes a previous migration archive. Downloadable migration archives are automatically deleted after seven days. Migration metadata, which is returned in the [List user migrations](https://docs.github.com/rest/migrations/users#list-user-migrations) and [Get a user migration status](https://docs.github.com/rest/migrations/users#get-a-user-migration-status) endpoints, will continue to be available even after an archive is deleted.")
    }

    pub fn cli_migrations_unlock_repo_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("migration-id") . long ("migration-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the migration.")) . arg (clap :: Arg :: new ("repo-name") . long ("repo-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("repo_name parameter")) . about ("Unlock a user repository\n\nUnlocks a repository. You can lock repositories when you [start a user migration](https://docs.github.com/rest/migrations/users#start-a-user-migration). Once the migration is complete you can unlock each repository to begin using it again or [delete the repository](https://docs.github.com/rest/repos/repos#delete-a-repository) if you no longer need the source data. Returns a status of `404 Not Found` if the repository is not locked.")
    }

    pub fn cli_migrations_list_repos_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("migration-id")
                    .long("migration-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the migration."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repositories for a user migration\n\nLists all the repositories for this \
                 user migration.",
            )
    }

    pub fn cli_orgs_list_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List organizations for the authenticated user\n\nList organizations for the \
                 authenticated user.\n\n**OAuth scope requirements**\n\nThis only lists \
                 organizations that your authorization allows you to operate on in some way \
                 (e.g., you can list teams with `read:org` scope, you can publicize your \
                 organization membership with `user` scope, etc.). Therefore, this API requires \
                 at least `user` or `read:org` scope. OAuth requests with insufficient scope \
                 receive a `403 Forbidden` response.",
            )
    }

    pub fn cli_packages_list_packages_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesListPackagesForAuthenticatedUserPackageType :: Npm . to_string () , types :: PackagesListPackagesForAuthenticatedUserPackageType :: Maven . to_string () , types :: PackagesListPackagesForAuthenticatedUserPackageType :: Rubygems . to_string () , types :: PackagesListPackagesForAuthenticatedUserPackageType :: Docker . to_string () , types :: PackagesListPackagesForAuthenticatedUserPackageType :: Nuget . to_string () , types :: PackagesListPackagesForAuthenticatedUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesListPackagesForAuthenticatedUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("visibility") . long ("visibility") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesListPackagesForAuthenticatedUserVisibility :: Public . to_string () , types :: PackagesListPackagesForAuthenticatedUserVisibility :: Private . to_string () , types :: PackagesListPackagesForAuthenticatedUserVisibility :: Internal . to_string () ,]) , | s | types :: PackagesListPackagesForAuthenticatedUserVisibility :: try_from (s) . unwrap ())) . help ("The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")) . about ("List packages for the authenticated user's namespace\n\nLists packages owned by the authenticated user within the user's namespace.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_get_package_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesGetPackageForAuthenticatedUserPackageType :: Npm . to_string () , types :: PackagesGetPackageForAuthenticatedUserPackageType :: Maven . to_string () , types :: PackagesGetPackageForAuthenticatedUserPackageType :: Rubygems . to_string () , types :: PackagesGetPackageForAuthenticatedUserPackageType :: Docker . to_string () , types :: PackagesGetPackageForAuthenticatedUserPackageType :: Nuget . to_string () , types :: PackagesGetPackageForAuthenticatedUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesGetPackageForAuthenticatedUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . about ("Get a package for the authenticated user\n\nGets a specific package for a package owned by the authenticated user.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_delete_package_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesDeletePackageForAuthenticatedUserPackageType :: Npm . to_string () , types :: PackagesDeletePackageForAuthenticatedUserPackageType :: Maven . to_string () , types :: PackagesDeletePackageForAuthenticatedUserPackageType :: Rubygems . to_string () , types :: PackagesDeletePackageForAuthenticatedUserPackageType :: Docker . to_string () , types :: PackagesDeletePackageForAuthenticatedUserPackageType :: Nuget . to_string () , types :: PackagesDeletePackageForAuthenticatedUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesDeletePackageForAuthenticatedUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . about ("Delete a package for the authenticated user\n\nDeletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` and `delete:packages` scopes.\nIf the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_restore_package_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesRestorePackageForAuthenticatedUserPackageType :: Npm . to_string () , types :: PackagesRestorePackageForAuthenticatedUserPackageType :: Maven . to_string () , types :: PackagesRestorePackageForAuthenticatedUserPackageType :: Rubygems . to_string () , types :: PackagesRestorePackageForAuthenticatedUserPackageType :: Docker . to_string () , types :: PackagesRestorePackageForAuthenticatedUserPackageType :: Nuget . to_string () , types :: PackagesRestorePackageForAuthenticatedUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesRestorePackageForAuthenticatedUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("token") . long ("token") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("package token")) . about ("Restore a package for the authenticated user\n\nRestores a package owned by the authenticated user.\n\nYou can restore a deleted package under the following conditions:\n  - The package was deleted within the last 30 days.\n  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` and `write:packages` scopes. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_get_all_package_versions_for_package_owned_by_authenticated_user(
    ) -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType :: Npm . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType :: Maven . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType :: Rubygems . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType :: Docker . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType :: Nuget . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("state") . long ("state") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState :: Active . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState :: Deleted . to_string () ,]) , | s | types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState :: try_from (s) . unwrap ())) . help ("The state of the package, either active or deleted.")) . about ("List package versions for a package owned by the authenticated user\n\nLists package versions for a package owned by the authenticated user.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_get_package_version_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesGetPackageVersionForAuthenticatedUserPackageType :: Npm . to_string () , types :: PackagesGetPackageVersionForAuthenticatedUserPackageType :: Maven . to_string () , types :: PackagesGetPackageVersionForAuthenticatedUserPackageType :: Rubygems . to_string () , types :: PackagesGetPackageVersionForAuthenticatedUserPackageType :: Docker . to_string () , types :: PackagesGetPackageVersionForAuthenticatedUserPackageType :: Nuget . to_string () , types :: PackagesGetPackageVersionForAuthenticatedUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesGetPackageVersionForAuthenticatedUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("package-version-id") . long ("package-version-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("Unique identifier of the package version.")) . about ("Get a package version for the authenticated user\n\nGets a specific package version for a package owned by the authenticated user.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_delete_package_version_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesDeletePackageVersionForAuthenticatedUserPackageType :: Npm . to_string () , types :: PackagesDeletePackageVersionForAuthenticatedUserPackageType :: Maven . to_string () , types :: PackagesDeletePackageVersionForAuthenticatedUserPackageType :: Rubygems . to_string () , types :: PackagesDeletePackageVersionForAuthenticatedUserPackageType :: Docker . to_string () , types :: PackagesDeletePackageVersionForAuthenticatedUserPackageType :: Nuget . to_string () , types :: PackagesDeletePackageVersionForAuthenticatedUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesDeletePackageVersionForAuthenticatedUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("package-version-id") . long ("package-version-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("Unique identifier of the package version.")) . about ("Delete a package version for the authenticated user\n\nDeletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.\n\nTo use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `read:packages` and `delete:packages` scopes.\nIf the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_restore_package_version_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesRestorePackageVersionForAuthenticatedUserPackageType :: Npm . to_string () , types :: PackagesRestorePackageVersionForAuthenticatedUserPackageType :: Maven . to_string () , types :: PackagesRestorePackageVersionForAuthenticatedUserPackageType :: Rubygems . to_string () , types :: PackagesRestorePackageVersionForAuthenticatedUserPackageType :: Docker . to_string () , types :: PackagesRestorePackageVersionForAuthenticatedUserPackageType :: Nuget . to_string () , types :: PackagesRestorePackageVersionForAuthenticatedUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesRestorePackageVersionForAuthenticatedUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("package-version-id") . long ("package-version-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("Unique identifier of the package version.")) . about ("Restore a package version for the authenticated user\n\nRestores a package version owned by the authenticated user.\n\nYou can restore a deleted package version under the following conditions:\n  - The package was deleted within the last 30 days.\n  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` and `write:packages` scopes. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_projects_create_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("body")
                    .long("body")
                    .required(false)
                    .value_parser(clap::value_parser!(String))
                    .help("Body of the project"),
            )
            .arg(
                clap::Arg::new("name")
                    .long("name")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("Name of the project"),
            )
            .about(
                "Create a user project\n\nCreates a user project board. Returns a `410 Gone` \
                 status if the user does not have existing classic projects. If you do not have \
                 sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` \
                 status is returned.",
            )
    }

    pub fn cli_users_list_public_emails_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List public email addresses for the authenticated user\n\nLists your publicly visible email address, which you can set with the [Set primary email visibility for the authenticated user](https://docs.github.com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This endpoint is accessible with the `user:email` scope.")
    }

    pub fn cli_repos_list_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("affiliation") . long ("affiliation") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Comma-separated list of values. Can include:  \n * `owner`: Repositories that are owned by the authenticated user.  \n * `collaborator`: Repositories that the user has been added to as a collaborator.  \n * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.")) . arg (clap :: Arg :: new ("before") . long ("before") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposListForAuthenticatedUserDirection :: Asc . to_string () , types :: ReposListForAuthenticatedUserDirection :: Desc . to_string () ,]) , | s | types :: ReposListForAuthenticatedUserDirection :: try_from (s) . unwrap ())) . help ("The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposListForAuthenticatedUserSort :: Created . to_string () , types :: ReposListForAuthenticatedUserSort :: Updated . to_string () , types :: ReposListForAuthenticatedUserSort :: Pushed . to_string () , types :: ReposListForAuthenticatedUserSort :: FullName . to_string () ,]) , | s | types :: ReposListForAuthenticatedUserSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by.")) . arg (clap :: Arg :: new ("type") . long ("type") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposListForAuthenticatedUserType :: All . to_string () , types :: ReposListForAuthenticatedUserType :: Owner . to_string () , types :: ReposListForAuthenticatedUserType :: Public . to_string () , types :: ReposListForAuthenticatedUserType :: Private . to_string () , types :: ReposListForAuthenticatedUserType :: Member . to_string () ,]) , | s | types :: ReposListForAuthenticatedUserType :: try_from (s) . unwrap ())) . help ("Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.")) . arg (clap :: Arg :: new ("visibility") . long ("visibility") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposListForAuthenticatedUserVisibility :: All . to_string () , types :: ReposListForAuthenticatedUserVisibility :: Public . to_string () , types :: ReposListForAuthenticatedUserVisibility :: Private . to_string () ,]) , | s | types :: ReposListForAuthenticatedUserVisibility :: try_from (s) . unwrap ())) . help ("Limit results to repositories with the specified visibility.")) . about ("List repositories for the authenticated user\n\nLists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.\n\nThe authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.")
    }

    pub fn cli_repos_create_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("allow-auto-merge") . long ("allow-auto-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether to allow Auto-merge to be used on pull requests.")) . arg (clap :: Arg :: new ("allow-merge-commit") . long ("allow-merge-commit") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether to allow merge commits for pull requests.")) . arg (clap :: Arg :: new ("allow-rebase-merge") . long ("allow-rebase-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether to allow rebase merges for pull requests.")) . arg (clap :: Arg :: new ("allow-squash-merge") . long ("allow-squash-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether to allow squash merges for pull requests.")) . arg (clap :: Arg :: new ("auto-init") . long ("auto-init") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether the repository is initialized with a minimal README.")) . arg (clap :: Arg :: new ("delete-branch-on-merge") . long ("delete-branch-on-merge") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether to delete head branches when pull requests are merged")) . arg (clap :: Arg :: new ("description") . long ("description") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A short description of the repository.")) . arg (clap :: Arg :: new ("gitignore-template") . long ("gitignore-template") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The desired language or platform to apply to the .gitignore.")) . arg (clap :: Arg :: new ("has-discussions") . long ("has-discussions") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether discussions are enabled.")) . arg (clap :: Arg :: new ("has-downloads") . long ("has-downloads") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether downloads are enabled.")) . arg (clap :: Arg :: new ("has-issues") . long ("has-issues") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether issues are enabled.")) . arg (clap :: Arg :: new ("has-projects") . long ("has-projects") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether projects are enabled.")) . arg (clap :: Arg :: new ("has-wiki") . long ("has-wiki") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether the wiki is enabled.")) . arg (clap :: Arg :: new ("homepage") . long ("homepage") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A URL with more information about the repository.")) . arg (clap :: Arg :: new ("is-template") . long ("is-template") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether this repository acts as a template that can be used to generate new repositories.")) . arg (clap :: Arg :: new ("license-template") . long ("license-template") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("The license keyword of the open source license for this repository.")) . arg (clap :: Arg :: new ("merge-commit-message") . long ("merge-commit-message") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposCreateForAuthenticatedUserBodyMergeCommitMessage :: PrBody . to_string () , types :: ReposCreateForAuthenticatedUserBodyMergeCommitMessage :: PrTitle . to_string () , types :: ReposCreateForAuthenticatedUserBodyMergeCommitMessage :: Blank . to_string () ,]) , | s | types :: ReposCreateForAuthenticatedUserBodyMergeCommitMessage :: try_from (s) . unwrap ())) . help ("The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message.")) . arg (clap :: Arg :: new ("merge-commit-title") . long ("merge-commit-title") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposCreateForAuthenticatedUserBodyMergeCommitTitle :: PrTitle . to_string () , types :: ReposCreateForAuthenticatedUserBodyMergeCommitTitle :: MergeMessage . to_string () ,]) , | s | types :: ReposCreateForAuthenticatedUserBodyMergeCommitTitle :: try_from (s) . unwrap ())) . help ("The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).")) . arg (clap :: Arg :: new ("name") . long ("name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository.")) . arg (clap :: Arg :: new ("private") . long ("private") . required (false) . value_parser (clap :: value_parser ! (bool)) . help ("Whether the repository is private.")) . arg (clap :: Arg :: new ("squash-merge-commit-message") . long ("squash-merge-commit-message") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposCreateForAuthenticatedUserBodySquashMergeCommitMessage :: PrBody . to_string () , types :: ReposCreateForAuthenticatedUserBodySquashMergeCommitMessage :: CommitMessages . to_string () , types :: ReposCreateForAuthenticatedUserBodySquashMergeCommitMessage :: Blank . to_string () ,]) , | s | types :: ReposCreateForAuthenticatedUserBodySquashMergeCommitMessage :: try_from (s) . unwrap ())) . help ("The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message.")) . arg (clap :: Arg :: new ("squash-merge-commit-title") . long ("squash-merge-commit-title") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ReposCreateForAuthenticatedUserBodySquashMergeCommitTitle :: PrTitle . to_string () , types :: ReposCreateForAuthenticatedUserBodySquashMergeCommitTitle :: CommitOrPrTitle . to_string () ,]) , | s | types :: ReposCreateForAuthenticatedUserBodySquashMergeCommitTitle :: try_from (s) . unwrap ())) . help ("The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).")) . arg (clap :: Arg :: new ("team-id") . long ("team-id") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.")) . about ("Create a repository for the authenticated user\n\nCreates a new repository for the authenticated user.\n\n**OAuth scope requirements**\n\nWhen using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:\n\n*   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.\n*   `repo` scope to create a private repository.")
    }

    pub fn cli_repos_list_invitations_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repository invitations for the authenticated user\n\nWhen authenticating as \
                 a user, this endpoint will list all currently open repository invitations for \
                 that user.",
            )
    }

    pub fn cli_repos_decline_invitation_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("invitation-id")
                    .long("invitation-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the invitation."),
            )
            .about("Decline a repository invitation")
    }

    pub fn cli_repos_accept_invitation_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("invitation-id")
                    .long("invitation-id")
                    .required(true)
                    .value_parser(clap::value_parser!(i64))
                    .help("The unique identifier of the invitation."),
            )
            .about("Accept a repository invitation")
    }

    pub fn cli_users_list_social_accounts_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List social accounts for the authenticated user\n\nLists all of your social \
                 accounts.",
            )
    }

    pub fn cli_users_add_social_account_for_authenticated_user() -> clap::Command {
        clap::Command::new("").about(
            "Add social accounts for the authenticated user\n\nAdd one or more social accounts to \
             the authenticated user's profile. This endpoint is accessible with the `user` scope.",
        )
    }

    pub fn cli_users_delete_social_account_for_authenticated_user() -> clap::Command {
        clap::Command::new("").about(
            "Delete social accounts for the authenticated user\n\nDeletes one or more social \
             accounts from the authenticated user's profile. This endpoint is accessible with the \
             `user` scope.",
        )
    }

    pub fn cli_users_list_ssh_signing_keys_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List SSH signing keys for the authenticated user\n\nLists the SSH signing keys for the authenticated user's GitHub account. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `read:ssh_signing_key` scope. For more information, see \"[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\"")
    }

    pub fn cli_users_create_ssh_signing_key_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("key") . long ("key") . required (true) . value_parser (clap :: value_parser ! (types :: UsersCreateSshSigningKeyForAuthenticatedUserBodyKey)) . help ("The public SSH key to add to your GitHub account. For more information, see \"[Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys).\"")) . arg (clap :: Arg :: new ("title") . long ("title") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("A descriptive name for the new key.")) . about ("Create a SSH signing key for the authenticated user\n\nCreates an SSH signing key for the authenticated user's GitHub account. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `write:ssh_signing_key` scope. For more information, see \"[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\"")
    }

    pub fn cli_users_get_ssh_signing_key_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("ssh-signing-key-id") . long ("ssh-signing-key-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the SSH signing key.")) . about ("Get an SSH signing key for the authenticated user\n\nGets extended details for an SSH signing key. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `read:ssh_signing_key` scope. For more information, see \"[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\"")
    }

    pub fn cli_users_delete_ssh_signing_key_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("ssh-signing-key-id") . long ("ssh-signing-key-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("The unique identifier of the SSH signing key.")) . about ("Delete an SSH signing key for the authenticated user\n\nDeletes an SSH signing key from the authenticated user's GitHub account. You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least `admin:ssh_signing_key` scope. For more information, see \"[Understanding scopes for OAuth apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).\"")
    }

    pub fn cli_activity_list_repos_starred_by_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("direction") . long ("direction") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActivityListReposStarredByAuthenticatedUserDirection :: Asc . to_string () , types :: ActivityListReposStarredByAuthenticatedUserDirection :: Desc . to_string () ,]) , | s | types :: ActivityListReposStarredByAuthenticatedUserDirection :: try_from (s) . unwrap ())) . help ("The direction to sort the results by.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("sort") . long ("sort") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: ActivityListReposStarredByAuthenticatedUserSort :: Created . to_string () , types :: ActivityListReposStarredByAuthenticatedUserSort :: Updated . to_string () ,]) , | s | types :: ActivityListReposStarredByAuthenticatedUserSort :: try_from (s) . unwrap ())) . help ("The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.")) . about ("List repositories starred by the authenticated user\n\nLists repositories the authenticated user has starred.\n\nYou can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header: `application/vnd.github.star+json`.")
    }

    pub fn cli_activity_check_repo_is_starred_by_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about("Check if a repository is starred by the authenticated user")
    }

    pub fn cli_activity_star_repo_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("owner") . long ("owner") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The account owner of the repository. The name is not case sensitive.")) . arg (clap :: Arg :: new ("repo") . long ("repo") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the repository. The name is not case sensitive.")) . about ("Star a repository for the authenticated user\n\nNote that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see \"[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).\"")
    }

    pub fn cli_activity_unstar_repo_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("owner")
                    .long("owner")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The account owner of the repository. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("repo")
                    .long("repo")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The name of the repository. The name is not case sensitive."),
            )
            .about("Unstar a repository for the authenticated user")
    }

    pub fn cli_activity_list_watched_repos_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List repositories watched by the authenticated user\n\nLists repositories the \
                 authenticated user is watching.",
            )
    }

    pub fn cli_teams_list_for_authenticated_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List teams for the authenticated user\n\nList all of the teams across all of the organizations to which the authenticated user belongs. This method requires `user`, `repo`, or `read:org` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/) when authenticating via [OAuth](https://docs.github.com/apps/building-oauth-apps/). When using a fine-grained personal access token, the resource owner of the token [must be a single organization](https://docs.github.com/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token#fine-grained-personal-access-tokens), and have at least read-only member organization permissions. The response payload only contains the teams from a single organization when using a fine-grained personal access token.")
    }

    pub fn cli_users_list() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("A user ID. Only return users with an ID greater than this ID.")) . about ("List users\n\nLists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.\n\nNote: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of users.")
    }

    pub fn cli_users_get_by_username() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Get a user\n\nProvides publicly available information about someone with a GitHub account.\n\nGitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a user's GitHub plan. The GitHub App must be authenticated as a user. See \"[Identifying and authorizing users for GitHub Apps](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)\" for details about authentication. For an example response, see 'Response with GitHub plan information' below\"\n\nThe `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be public which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).\n\nThe Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see \"[Emails API](https://docs.github.com/rest/reference/users#emails)\".")
    }

    pub fn cli_packages_list_docker_migration_conflicting_packages_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .about(
                "Get list of conflicting packages during Docker migration for user\n\nLists all \
                 packages that are in a specific user's namespace, that the requesting user has \
                 access to, and that encountered a conflict during Docker migration.\nTo use this \
                 endpoint, you must authenticate using an access token with the `read:packages` \
                 scope.",
            )
    }

    pub fn cli_activity_list_events_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List events for the authenticated user\n\nIf you are authenticated as the given \
                 user, you will see your private events. Otherwise, you'll only see public events.",
            )
    }

    pub fn cli_activity_list_org_events_for_authenticated_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("org")
                    .long("org")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The organization name. The name is not case sensitive."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List organization events for the authenticated user\n\nThis is the user's \
                 organization dashboard. You must be authenticated as the user to view this.",
            )
    }

    pub fn cli_activity_list_public_events_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List public events for a user")
    }

    pub fn cli_users_list_followers_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List followers of a user\n\nLists the people following the specified user.")
    }

    pub fn cli_users_list_following_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List the people a user follows\n\nLists the people who the specified user \
                 follows.",
            )
    }

    pub fn cli_users_check_following_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("target-user")
                    .long("target-user")
                    .required(true)
                    .value_parser(clap::value_parser!(String)),
            )
            .about("Check if a user follows another user")
    }

    pub fn cli_gists_list_for_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("since") . long ("since") . required (false) . value_parser (clap :: value_parser ! (chrono :: DateTime < chrono :: offset :: Utc >)) . help ("Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.")) . about ("List gists for a user\n\nLists public gists for the specified user:")
    }

    pub fn cli_users_list_gpg_keys_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List GPG keys for a user\n\nLists the GPG keys for a user. This information is \
                 accessible by anyone.",
            )
    }

    pub fn cli_users_get_context_for_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("subject-id") . long ("subject-id") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.")) . arg (clap :: Arg :: new ("subject-type") . long ("subject-type") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: UsersGetContextForUserSubjectType :: Organization . to_string () , types :: UsersGetContextForUserSubjectType :: Repository . to_string () , types :: UsersGetContextForUserSubjectType :: Issue . to_string () , types :: UsersGetContextForUserSubjectType :: PullRequest . to_string () ,]) , | s | types :: UsersGetContextForUserSubjectType :: try_from (s) . unwrap ())) . help ("Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`.")) . about ("Get contextual information for a user\n\nProvides hovercard information when authenticated through basic auth or OAuth with the `repo` scope. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.\n\nThe `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:\n\n```shell\n curl -u username:token\n  https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192\n```")
    }

    pub fn cli_apps_get_user_installation() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Get a user installation for the authenticated app\n\nEnables an authenticated GitHub App to find the users installation information.\n\nYou must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.")
    }

    pub fn cli_users_list_public_keys_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List public keys for a user\n\nLists the _verified_ public SSH keys for a user. \
                 This is accessible by anyone.",
            )
    }

    pub fn cli_orgs_list_for_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . about ("List organizations for a user\n\nList [public organization memberships](https://docs.github.com/articles/publicizing-or-concealing-organization-membership) for the specified user.\n\nThis method only lists _public_ memberships, regardless of authentication. If you need to fetch all of the organization memberships (public and private) for the authenticated user, use the [List organizations for the authenticated user](https://docs.github.com/rest/reference/orgs#list-organizations-for-the-authenticated-user) API instead.")
    }

    pub fn cli_packages_list_packages_for_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesListPackagesForUserPackageType :: Npm . to_string () , types :: PackagesListPackagesForUserPackageType :: Maven . to_string () , types :: PackagesListPackagesForUserPackageType :: Rubygems . to_string () , types :: PackagesListPackagesForUserPackageType :: Docker . to_string () , types :: PackagesListPackagesForUserPackageType :: Nuget . to_string () , types :: PackagesListPackagesForUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesListPackagesForUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("page") . long ("page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("Page number of the results to fetch.")) . arg (clap :: Arg :: new ("per-page") . long ("per-page") . required (false) . value_parser (clap :: value_parser ! (i64)) . help ("The number of results per page (max 100).")) . arg (clap :: Arg :: new ("visibility") . long ("visibility") . required (false) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesListPackagesForUserVisibility :: Public . to_string () , types :: PackagesListPackagesForUserVisibility :: Private . to_string () , types :: PackagesListPackagesForUserVisibility :: Internal . to_string () ,]) , | s | types :: PackagesListPackagesForUserVisibility :: try_from (s) . unwrap ())) . help ("The selected visibility of the packages.  This parameter is optional and only filters an existing result set.\n\nThe `internal` visibility is only supported for GitHub Packages registries that allow for granular permissions. For other ecosystems `internal` is synonymous with `private`.\nFor the list of GitHub Packages registries that support granular permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")) . about ("List packages for a user\n\nLists all packages in a user's namespace for which the requesting user has access.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_get_package_for_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesGetPackageForUserPackageType :: Npm . to_string () , types :: PackagesGetPackageForUserPackageType :: Maven . to_string () , types :: PackagesGetPackageForUserPackageType :: Rubygems . to_string () , types :: PackagesGetPackageForUserPackageType :: Docker . to_string () , types :: PackagesGetPackageForUserPackageType :: Nuget . to_string () , types :: PackagesGetPackageForUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesGetPackageForUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . about ("Get a package for a user\n\nGets a specific package metadata for a public package owned by a user.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_delete_package_for_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesDeletePackageForUserPackageType :: Npm . to_string () , types :: PackagesDeletePackageForUserPackageType :: Maven . to_string () , types :: PackagesDeletePackageForUserPackageType :: Rubygems . to_string () , types :: PackagesDeletePackageForUserPackageType :: Docker . to_string () , types :: PackagesDeletePackageForUserPackageType :: Nuget . to_string () , types :: PackagesDeletePackageForUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesDeletePackageForUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . about ("Delete a package for a user\n\nDeletes an entire package for a user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` and `delete:packages` scopes. In addition:\n- If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"\n- If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to delete. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")
    }

    pub fn cli_packages_restore_package_for_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesRestorePackageForUserPackageType :: Npm . to_string () , types :: PackagesRestorePackageForUserPackageType :: Maven . to_string () , types :: PackagesRestorePackageForUserPackageType :: Rubygems . to_string () , types :: PackagesRestorePackageForUserPackageType :: Docker . to_string () , types :: PackagesRestorePackageForUserPackageType :: Nuget . to_string () , types :: PackagesRestorePackageForUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesRestorePackageForUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("token") . long ("token") . required (false) . value_parser (clap :: value_parser ! (String)) . help ("package token")) . about ("Restore a package for a user\n\nRestores an entire package for a user.\n\nYou can restore a deleted package under the following conditions:\n  - The package was deleted within the last 30 days.\n  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` and `write:packages` scopes. In addition:\n- If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"\n- If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package you want to restore. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")
    }

    pub fn cli_packages_get_all_package_versions_for_package_owned_by_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType :: Npm . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType :: Maven . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType :: Rubygems . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType :: Docker . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType :: Nuget . to_string () , types :: PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . about ("List package versions for a package owned by a user\n\nLists package versions for a public package owned by a specified user.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_get_package_version_for_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesGetPackageVersionForUserPackageType :: Npm . to_string () , types :: PackagesGetPackageVersionForUserPackageType :: Maven . to_string () , types :: PackagesGetPackageVersionForUserPackageType :: Rubygems . to_string () , types :: PackagesGetPackageVersionForUserPackageType :: Docker . to_string () , types :: PackagesGetPackageVersionForUserPackageType :: Nuget . to_string () , types :: PackagesGetPackageVersionForUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesGetPackageVersionForUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("package-version-id") . long ("package-version-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("Unique identifier of the package version.")) . about ("Get a package version for a user\n\nGets a specific package version for a public package owned by a specified user.\n\nAt this time, to use this endpoint, you must authenticate using an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of GitHub Packages registries that only support repository-scoped permissions, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"")
    }

    pub fn cli_packages_delete_package_version_for_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesDeletePackageVersionForUserPackageType :: Npm . to_string () , types :: PackagesDeletePackageVersionForUserPackageType :: Maven . to_string () , types :: PackagesDeletePackageVersionForUserPackageType :: Rubygems . to_string () , types :: PackagesDeletePackageVersionForUserPackageType :: Docker . to_string () , types :: PackagesDeletePackageVersionForUserPackageType :: Nuget . to_string () , types :: PackagesDeletePackageVersionForUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesDeletePackageVersionForUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("package-version-id") . long ("package-version-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("Unique identifier of the package version.")) . about ("Delete package version for a user\n\nDeletes a specific package version for a user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` and `delete:packages` scopes. In addition:\n- If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"\n- If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to delete. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")
    }

    pub fn cli_packages_restore_package_version_for_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . arg (clap :: Arg :: new ("package-type") . long ("package-type") . required (true) . value_parser (clap :: builder :: TypedValueParser :: map (clap :: builder :: PossibleValuesParser :: new ([types :: PackagesRestorePackageVersionForUserPackageType :: Npm . to_string () , types :: PackagesRestorePackageVersionForUserPackageType :: Maven . to_string () , types :: PackagesRestorePackageVersionForUserPackageType :: Rubygems . to_string () , types :: PackagesRestorePackageVersionForUserPackageType :: Docker . to_string () , types :: PackagesRestorePackageVersionForUserPackageType :: Nuget . to_string () , types :: PackagesRestorePackageVersionForUserPackageType :: Container . to_string () ,]) , | s | types :: PackagesRestorePackageVersionForUserPackageType :: try_from (s) . unwrap ())) . help ("The type of supported package. Packages in GitHub's Gradle registry have the type `maven`. Docker images pushed to GitHub's Container registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even if these have now been migrated to the Container registry.")) . arg (clap :: Arg :: new ("package-name") . long ("package-name") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The name of the package.")) . arg (clap :: Arg :: new ("package-version-id") . long ("package-version-id") . required (true) . value_parser (clap :: value_parser ! (i64)) . help ("Unique identifier of the package version.")) . about ("Restore package version for a user\n\nRestores a specific package version for a user.\n\nYou can restore a deleted package under the following conditions:\n  - The package was deleted within the last 30 days.\n  - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.\n\nTo use this endpoint, you must authenticate using an access token with the `read:packages` and `write:packages` scopes. In addition:\n- If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token must also include the `repo` scope. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).\"\n- If the `package_type` belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions to the package whose version you want to restore. For the list of these registries, see \"[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).\"")
    }

    pub fn cli_projects_list_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("state")
                    .long("state")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ProjectsListForUserState::Open.to_string(),
                            types::ProjectsListForUserState::Closed.to_string(),
                            types::ProjectsListForUserState::All.to_string(),
                        ]),
                        |s| types::ProjectsListForUserState::try_from(s).unwrap(),
                    ))
                    .help("Indicates the state of the projects to return."),
            )
            .about("List user projects")
    }

    pub fn cli_activity_list_received_events_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List events received by the authenticated user\n\nThese are events that you've \
                 received by watching repos and following users. If you are authenticated as the \
                 given user, you will see private events. Otherwise, you'll only see public \
                 events.",
            )
    }

    pub fn cli_activity_list_received_public_events_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about("List public events received by a user")
    }

    pub fn cli_repos_list_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("direction")
                    .long("direction")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposListForUserDirection::Asc.to_string(),
                            types::ReposListForUserDirection::Desc.to_string(),
                        ]),
                        |s| types::ReposListForUserDirection::try_from(s).unwrap(),
                    ))
                    .help(
                        "The order to sort by. Default: `asc` when using `full_name`, otherwise \
                         `desc`.",
                    ),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .arg(
                clap::Arg::new("sort")
                    .long("sort")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposListForUserSort::Created.to_string(),
                            types::ReposListForUserSort::Updated.to_string(),
                            types::ReposListForUserSort::Pushed.to_string(),
                            types::ReposListForUserSort::FullName.to_string(),
                        ]),
                        |s| types::ReposListForUserSort::try_from(s).unwrap(),
                    ))
                    .help("The property to sort the results by."),
            )
            .arg(
                clap::Arg::new("type")
                    .long("type")
                    .required(false)
                    .value_parser(clap::builder::TypedValueParser::map(
                        clap::builder::PossibleValuesParser::new([
                            types::ReposListForUserType::All.to_string(),
                            types::ReposListForUserType::Owner.to_string(),
                            types::ReposListForUserType::Member.to_string(),
                        ]),
                        |s| types::ReposListForUserType::try_from(s).unwrap(),
                    ))
                    .help("Limit results to repositories of the specified type."),
            )
            .about(
                "List repositories for a user\n\nLists public repositories for the specified \
                 user. Note: For GitHub AE, this endpoint will list internal repositories for the \
                 specified user.",
            )
    }

    pub fn cli_billing_get_github_actions_billing_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Get GitHub Actions billing for a user\n\nGets the summary of the free and paid GitHub Actions minutes used.\n\nPaid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see \"[Managing billing for GitHub Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)\".\n\nAccess tokens must have the `user` scope.")
    }

    pub fn cli_billing_get_github_packages_billing_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Get GitHub Packages billing for a user\n\nGets the free and paid storage used for GitHub Packages in gigabytes.\n\nPaid minutes only apply to packages stored for private repositories. For more information, see \"[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages).\"\n\nAccess tokens must have the `user` scope.")
    }

    pub fn cli_billing_get_shared_storage_billing_user() -> clap::Command {
        clap :: Command :: new ("") . arg (clap :: Arg :: new ("username") . long ("username") . required (true) . value_parser (clap :: value_parser ! (String)) . help ("The handle for the GitHub user account.")) . about ("Get shared storage billing for a user\n\nGets the estimated paid and estimated total storage used for GitHub Actions and GitHub Packages.\n\nPaid minutes only apply to packages stored for private repositories. For more information, see \"[Managing billing for GitHub Packages](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages).\"\n\nAccess tokens must have the `user` scope.")
    }

    pub fn cli_users_list_social_accounts_for_user() -> clap::Command {
        clap::Command::new("")
            .arg(
                clap::Arg::new("username")
                    .long("username")
                    .required(true)
                    .value_parser(clap::value_parser!(String))
                    .help("The handle for the GitHub user account."),
            )
            .arg(
                clap::Arg::new("page")
                    .long("page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("Page number of the results to fetch."),
            )
            .arg(
                clap::Arg::new("per-page")
                    .long("per-page")
                    .required(false)
                    .value_parser(clap::value_parser!(i64))
                    .help("The number of results per page (max 100)."),
            )
            .about(
                "List social accounts for a user\n\nLists social media accounts for a user. This \
                 endpoint is accessible by anyone.",
            )
    }
}

impl<T: CliOverride> Cli<T> {
    pub fn new_with_override(client: sdk::Client, over: T) -> Self {
        Self { client, over }
    }

    pub async fn execute(&self, cmd: CliCommand, matches: &clap::ArgMatches) {
        match cmd {
            CliCommand::MetaRoot => {
                self.execute_meta_root(matches).await;
            }
            CliCommand::AppsGetAuthenticated => {
                self.execute_apps_get_authenticated(matches).await;
            }
            CliCommand::AppsCreateFromManifest => {
                self.execute_apps_create_from_manifest(matches).await;
            }
            CliCommand::AppsGetWebhookConfigForApp => {
                self.execute_apps_get_webhook_config_for_app(matches).await;
            }
            CliCommand::AppsUpdateWebhookConfigForApp => {
                self.execute_apps_update_webhook_config_for_app(matches)
                    .await;
            }
            CliCommand::AppsListWebhookDeliveries => {
                self.execute_apps_list_webhook_deliveries(matches).await;
            }
            CliCommand::AppsGetWebhookDelivery => {
                self.execute_apps_get_webhook_delivery(matches).await;
            }
            CliCommand::AppsRedeliverWebhookDelivery => {
                self.execute_apps_redeliver_webhook_delivery(matches).await;
            }
            CliCommand::AppsListInstallationRequestsForAuthenticatedApp => {
                self.execute_apps_list_installation_requests_for_authenticated_app(matches)
                    .await;
            }
            CliCommand::AppsListInstallations => {
                self.execute_apps_list_installations(matches).await;
            }
            CliCommand::AppsGetInstallation => {
                self.execute_apps_get_installation(matches).await;
            }
            CliCommand::AppsDeleteInstallation => {
                self.execute_apps_delete_installation(matches).await;
            }
            CliCommand::AppsCreateInstallationAccessToken => {
                self.execute_apps_create_installation_access_token(matches)
                    .await;
            }
            CliCommand::AppsSuspendInstallation => {
                self.execute_apps_suspend_installation(matches).await;
            }
            CliCommand::AppsUnsuspendInstallation => {
                self.execute_apps_unsuspend_installation(matches).await;
            }
            CliCommand::AppsDeleteAuthorization => {
                self.execute_apps_delete_authorization(matches).await;
            }
            CliCommand::AppsCheckToken => {
                self.execute_apps_check_token(matches).await;
            }
            CliCommand::AppsDeleteToken => {
                self.execute_apps_delete_token(matches).await;
            }
            CliCommand::AppsResetToken => {
                self.execute_apps_reset_token(matches).await;
            }
            CliCommand::AppsScopeToken => {
                self.execute_apps_scope_token(matches).await;
            }
            CliCommand::AppsGetBySlug => {
                self.execute_apps_get_by_slug(matches).await;
            }
            CliCommand::CodesOfConductGetAllCodesOfConduct => {
                self.execute_codes_of_conduct_get_all_codes_of_conduct(matches)
                    .await;
            }
            CliCommand::CodesOfConductGetConductCode => {
                self.execute_codes_of_conduct_get_conduct_code(matches)
                    .await;
            }
            CliCommand::EmojisGet => {
                self.execute_emojis_get(matches).await;
            }
            CliCommand::DependabotListAlertsForEnterprise => {
                self.execute_dependabot_list_alerts_for_enterprise(matches)
                    .await;
            }
            CliCommand::SecretScanningListAlertsForEnterprise => {
                self.execute_secret_scanning_list_alerts_for_enterprise(matches)
                    .await;
            }
            CliCommand::ActivityListPublicEvents => {
                self.execute_activity_list_public_events(matches).await;
            }
            CliCommand::ActivityGetFeeds => {
                self.execute_activity_get_feeds(matches).await;
            }
            CliCommand::GistsList => {
                self.execute_gists_list(matches).await;
            }
            CliCommand::GistsCreate => {
                self.execute_gists_create(matches).await;
            }
            CliCommand::GistsListPublic => {
                self.execute_gists_list_public(matches).await;
            }
            CliCommand::GistsListStarred => {
                self.execute_gists_list_starred(matches).await;
            }
            CliCommand::GistsGet => {
                self.execute_gists_get(matches).await;
            }
            CliCommand::GistsDelete => {
                self.execute_gists_delete(matches).await;
            }
            CliCommand::GistsUpdate => {
                self.execute_gists_update(matches).await;
            }
            CliCommand::GistsListComments => {
                self.execute_gists_list_comments(matches).await;
            }
            CliCommand::GistsCreateComment => {
                self.execute_gists_create_comment(matches).await;
            }
            CliCommand::GistsGetComment => {
                self.execute_gists_get_comment(matches).await;
            }
            CliCommand::GistsDeleteComment => {
                self.execute_gists_delete_comment(matches).await;
            }
            CliCommand::GistsUpdateComment => {
                self.execute_gists_update_comment(matches).await;
            }
            CliCommand::GistsListCommits => {
                self.execute_gists_list_commits(matches).await;
            }
            CliCommand::GistsListForks => {
                self.execute_gists_list_forks(matches).await;
            }
            CliCommand::GistsFork => {
                self.execute_gists_fork(matches).await;
            }
            CliCommand::GistsCheckIsStarred => {
                self.execute_gists_check_is_starred(matches).await;
            }
            CliCommand::GistsStar => {
                self.execute_gists_star(matches).await;
            }
            CliCommand::GistsUnstar => {
                self.execute_gists_unstar(matches).await;
            }
            CliCommand::GistsGetRevision => {
                self.execute_gists_get_revision(matches).await;
            }
            CliCommand::GitignoreGetAllTemplates => {
                self.execute_gitignore_get_all_templates(matches).await;
            }
            CliCommand::GitignoreGetTemplate => {
                self.execute_gitignore_get_template(matches).await;
            }
            CliCommand::AppsListReposAccessibleToInstallation => {
                self.execute_apps_list_repos_accessible_to_installation(matches)
                    .await;
            }
            CliCommand::AppsRevokeInstallationAccessToken => {
                self.execute_apps_revoke_installation_access_token(matches)
                    .await;
            }
            CliCommand::IssuesList => {
                self.execute_issues_list(matches).await;
            }
            CliCommand::LicensesGetAllCommonlyUsed => {
                self.execute_licenses_get_all_commonly_used(matches).await;
            }
            CliCommand::LicensesGet => {
                self.execute_licenses_get(matches).await;
            }
            CliCommand::MarkdownRender => {
                self.execute_markdown_render(matches).await;
            }
            CliCommand::MetaGetAllVersions => {
                self.execute_meta_get_all_versions(matches).await;
            }
            CliCommand::AppsGetSubscriptionPlanForAccount => {
                self.execute_apps_get_subscription_plan_for_account(matches)
                    .await;
            }
            CliCommand::AppsListPlans => {
                self.execute_apps_list_plans(matches).await;
            }
            CliCommand::AppsListAccountsForPlan => {
                self.execute_apps_list_accounts_for_plan(matches).await;
            }
            CliCommand::AppsGetSubscriptionPlanForAccountStubbed => {
                self.execute_apps_get_subscription_plan_for_account_stubbed(matches)
                    .await;
            }
            CliCommand::AppsListPlansStubbed => {
                self.execute_apps_list_plans_stubbed(matches).await;
            }
            CliCommand::AppsListAccountsForPlanStubbed => {
                self.execute_apps_list_accounts_for_plan_stubbed(matches)
                    .await;
            }
            CliCommand::MetaGet => {
                self.execute_meta_get(matches).await;
            }
            CliCommand::ActivityListPublicEventsForRepoNetwork => {
                self.execute_activity_list_public_events_for_repo_network(matches)
                    .await;
            }
            CliCommand::ActivityListNotificationsForAuthenticatedUser => {
                self.execute_activity_list_notifications_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ActivityMarkNotificationsAsRead => {
                self.execute_activity_mark_notifications_as_read(matches)
                    .await;
            }
            CliCommand::ActivityGetThread => {
                self.execute_activity_get_thread(matches).await;
            }
            CliCommand::ActivityMarkThreadAsRead => {
                self.execute_activity_mark_thread_as_read(matches).await;
            }
            CliCommand::ActivityGetThreadSubscriptionForAuthenticatedUser => {
                self.execute_activity_get_thread_subscription_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ActivitySetThreadSubscription => {
                self.execute_activity_set_thread_subscription(matches).await;
            }
            CliCommand::ActivityDeleteThreadSubscription => {
                self.execute_activity_delete_thread_subscription(matches)
                    .await;
            }
            CliCommand::MetaGetOctocat => {
                self.execute_meta_get_octocat(matches).await;
            }
            CliCommand::OrgsList => {
                self.execute_orgs_list(matches).await;
            }
            CliCommand::OrgsListPatGrantRequests => {
                self.execute_orgs_list_pat_grant_requests(matches).await;
            }
            CliCommand::OrgsReviewPatGrantRequestsInBulk => {
                self.execute_orgs_review_pat_grant_requests_in_bulk(matches)
                    .await;
            }
            CliCommand::OrgsReviewPatGrantRequest => {
                self.execute_orgs_review_pat_grant_request(matches).await;
            }
            CliCommand::OrgsListPatGrantRequestRepositories => {
                self.execute_orgs_list_pat_grant_request_repositories(matches)
                    .await;
            }
            CliCommand::OrgsListPatGrants => {
                self.execute_orgs_list_pat_grants(matches).await;
            }
            CliCommand::OrgsUpdatePatAccesses => {
                self.execute_orgs_update_pat_accesses(matches).await;
            }
            CliCommand::OrgsUpdatePatAccess => {
                self.execute_orgs_update_pat_access(matches).await;
            }
            CliCommand::OrgsListPatGrantRepositories => {
                self.execute_orgs_list_pat_grant_repositories(matches).await;
            }
            CliCommand::MetaGetZen => {
                self.execute_meta_get_zen(matches).await;
            }
            CliCommand::ActionsGetActionsCacheUsageForOrg => {
                self.execute_actions_get_actions_cache_usage_for_org(matches)
                    .await;
            }
            CliCommand::ActionsGetActionsCacheUsageByRepoForOrg => {
                self.execute_actions_get_actions_cache_usage_by_repo_for_org(matches)
                    .await;
            }
            CliCommand::OidcGetOidcCustomSubTemplateForOrg => {
                self.execute_oidc_get_oidc_custom_sub_template_for_org(matches)
                    .await;
            }
            CliCommand::OidcUpdateOidcCustomSubTemplateForOrg => {
                self.execute_oidc_update_oidc_custom_sub_template_for_org(matches)
                    .await;
            }
            CliCommand::ActionsGetGithubActionsPermissionsOrganization => {
                self.execute_actions_get_github_actions_permissions_organization(matches)
                    .await;
            }
            CliCommand::ActionsSetGithubActionsPermissionsOrganization => {
                self.execute_actions_set_github_actions_permissions_organization(matches)
                    .await;
            }
            CliCommand::ActionsListSelectedRepositoriesEnabledGithubActionsOrganization => {
                self . execute_actions_list_selected_repositories_enabled_github_actions_organization (matches) . await ;
            }
            CliCommand::ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization => {
                self.execute_actions_set_selected_repositories_enabled_github_actions_organization(
                    matches,
                )
                .await;
            }
            CliCommand::ActionsEnableSelectedRepositoryGithubActionsOrganization => {
                self.execute_actions_enable_selected_repository_github_actions_organization(
                    matches,
                )
                .await;
            }
            CliCommand::ActionsDisableSelectedRepositoryGithubActionsOrganization => {
                self.execute_actions_disable_selected_repository_github_actions_organization(
                    matches,
                )
                .await;
            }
            CliCommand::ActionsGetAllowedActionsOrganization => {
                self.execute_actions_get_allowed_actions_organization(matches)
                    .await;
            }
            CliCommand::ActionsSetAllowedActionsOrganization => {
                self.execute_actions_set_allowed_actions_organization(matches)
                    .await;
            }
            CliCommand::ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization => {
                self.execute_actions_get_github_actions_default_workflow_permissions_organization(
                    matches,
                )
                .await;
            }
            CliCommand::ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization => {
                self.execute_actions_set_github_actions_default_workflow_permissions_organization(
                    matches,
                )
                .await;
            }
            CliCommand::ActionsListRequiredWorkflows => {
                self.execute_actions_list_required_workflows(matches).await;
            }
            CliCommand::ActionsCreateRequiredWorkflow => {
                self.execute_actions_create_required_workflow(matches).await;
            }
            CliCommand::ActionsGetRequiredWorkflow => {
                self.execute_actions_get_required_workflow(matches).await;
            }
            CliCommand::ActionsDeleteRequiredWorkflow => {
                self.execute_actions_delete_required_workflow(matches).await;
            }
            CliCommand::ActionsUpdateRequiredWorkflow => {
                self.execute_actions_update_required_workflow(matches).await;
            }
            CliCommand::ActionsListSelectedRepositoriesRequiredWorkflow => {
                self.execute_actions_list_selected_repositories_required_workflow(matches)
                    .await;
            }
            CliCommand::ActionsSetSelectedReposToRequiredWorkflow => {
                self.execute_actions_set_selected_repos_to_required_workflow(matches)
                    .await;
            }
            CliCommand::ActionsAddSelectedRepoToRequiredWorkflow => {
                self.execute_actions_add_selected_repo_to_required_workflow(matches)
                    .await;
            }
            CliCommand::ActionsRemoveSelectedRepoFromRequiredWorkflow => {
                self.execute_actions_remove_selected_repo_from_required_workflow(matches)
                    .await;
            }
            CliCommand::ActionsListSelfHostedRunnersForOrg => {
                self.execute_actions_list_self_hosted_runners_for_org(matches)
                    .await;
            }
            CliCommand::ActionsListRunnerApplicationsForOrg => {
                self.execute_actions_list_runner_applications_for_org(matches)
                    .await;
            }
            CliCommand::ActionsCreateRegistrationTokenForOrg => {
                self.execute_actions_create_registration_token_for_org(matches)
                    .await;
            }
            CliCommand::ActionsCreateRemoveTokenForOrg => {
                self.execute_actions_create_remove_token_for_org(matches)
                    .await;
            }
            CliCommand::ActionsGetSelfHostedRunnerForOrg => {
                self.execute_actions_get_self_hosted_runner_for_org(matches)
                    .await;
            }
            CliCommand::ActionsDeleteSelfHostedRunnerFromOrg => {
                self.execute_actions_delete_self_hosted_runner_from_org(matches)
                    .await;
            }
            CliCommand::ActionsListLabelsForSelfHostedRunnerForOrg => {
                self.execute_actions_list_labels_for_self_hosted_runner_for_org(matches)
                    .await;
            }
            CliCommand::ActionsSetCustomLabelsForSelfHostedRunnerForOrg => {
                self.execute_actions_set_custom_labels_for_self_hosted_runner_for_org(matches)
                    .await;
            }
            CliCommand::ActionsAddCustomLabelsToSelfHostedRunnerForOrg => {
                self.execute_actions_add_custom_labels_to_self_hosted_runner_for_org(matches)
                    .await;
            }
            CliCommand::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg => {
                self.execute_actions_remove_all_custom_labels_from_self_hosted_runner_for_org(
                    matches,
                )
                .await;
            }
            CliCommand::ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg => {
                self.execute_actions_remove_custom_label_from_self_hosted_runner_for_org(matches)
                    .await;
            }
            CliCommand::ActionsListOrgSecrets => {
                self.execute_actions_list_org_secrets(matches).await;
            }
            CliCommand::ActionsGetOrgPublicKey => {
                self.execute_actions_get_org_public_key(matches).await;
            }
            CliCommand::ActionsGetOrgSecret => {
                self.execute_actions_get_org_secret(matches).await;
            }
            CliCommand::ActionsCreateOrUpdateOrgSecret => {
                self.execute_actions_create_or_update_org_secret(matches)
                    .await;
            }
            CliCommand::ActionsDeleteOrgSecret => {
                self.execute_actions_delete_org_secret(matches).await;
            }
            CliCommand::ActionsListSelectedReposForOrgSecret => {
                self.execute_actions_list_selected_repos_for_org_secret(matches)
                    .await;
            }
            CliCommand::ActionsSetSelectedReposForOrgSecret => {
                self.execute_actions_set_selected_repos_for_org_secret(matches)
                    .await;
            }
            CliCommand::ActionsAddSelectedRepoToOrgSecret => {
                self.execute_actions_add_selected_repo_to_org_secret(matches)
                    .await;
            }
            CliCommand::ActionsRemoveSelectedRepoFromOrgSecret => {
                self.execute_actions_remove_selected_repo_from_org_secret(matches)
                    .await;
            }
            CliCommand::ActionsListOrgVariables => {
                self.execute_actions_list_org_variables(matches).await;
            }
            CliCommand::ActionsCreateOrgVariable => {
                self.execute_actions_create_org_variable(matches).await;
            }
            CliCommand::ActionsGetOrgVariable => {
                self.execute_actions_get_org_variable(matches).await;
            }
            CliCommand::ActionsDeleteOrgVariable => {
                self.execute_actions_delete_org_variable(matches).await;
            }
            CliCommand::ActionsUpdateOrgVariable => {
                self.execute_actions_update_org_variable(matches).await;
            }
            CliCommand::ActionsListSelectedReposForOrgVariable => {
                self.execute_actions_list_selected_repos_for_org_variable(matches)
                    .await;
            }
            CliCommand::ActionsSetSelectedReposForOrgVariable => {
                self.execute_actions_set_selected_repos_for_org_variable(matches)
                    .await;
            }
            CliCommand::ActionsAddSelectedRepoToOrgVariable => {
                self.execute_actions_add_selected_repo_to_org_variable(matches)
                    .await;
            }
            CliCommand::ActionsRemoveSelectedRepoFromOrgVariable => {
                self.execute_actions_remove_selected_repo_from_org_variable(matches)
                    .await;
            }
            CliCommand::OrgsListBlockedUsers => {
                self.execute_orgs_list_blocked_users(matches).await;
            }
            CliCommand::OrgsCheckBlockedUser => {
                self.execute_orgs_check_blocked_user(matches).await;
            }
            CliCommand::OrgsBlockUser => {
                self.execute_orgs_block_user(matches).await;
            }
            CliCommand::OrgsUnblockUser => {
                self.execute_orgs_unblock_user(matches).await;
            }
            CliCommand::CodeScanningListAlertsForOrg => {
                self.execute_code_scanning_list_alerts_for_org(matches)
                    .await;
            }
            CliCommand::CodespacesListInOrganization => {
                self.execute_codespaces_list_in_organization(matches).await;
            }
            CliCommand::CodespacesSetCodespacesBilling => {
                self.execute_codespaces_set_codespaces_billing(matches)
                    .await;
            }
            CliCommand::CodespacesSetCodespacesBillingUsers => {
                self.execute_codespaces_set_codespaces_billing_users(matches)
                    .await;
            }
            CliCommand::CodespacesDeleteCodespacesBillingUsers => {
                self.execute_codespaces_delete_codespaces_billing_users(matches)
                    .await;
            }
            CliCommand::CodespacesListOrgSecrets => {
                self.execute_codespaces_list_org_secrets(matches).await;
            }
            CliCommand::CodespacesGetOrgPublicKey => {
                self.execute_codespaces_get_org_public_key(matches).await;
            }
            CliCommand::CodespacesGetOrgSecret => {
                self.execute_codespaces_get_org_secret(matches).await;
            }
            CliCommand::CodespacesCreateOrUpdateOrgSecret => {
                self.execute_codespaces_create_or_update_org_secret(matches)
                    .await;
            }
            CliCommand::CodespacesDeleteOrgSecret => {
                self.execute_codespaces_delete_org_secret(matches).await;
            }
            CliCommand::CodespacesListSelectedReposForOrgSecret => {
                self.execute_codespaces_list_selected_repos_for_org_secret(matches)
                    .await;
            }
            CliCommand::CodespacesSetSelectedReposForOrgSecret => {
                self.execute_codespaces_set_selected_repos_for_org_secret(matches)
                    .await;
            }
            CliCommand::CodespacesAddSelectedRepoToOrgSecret => {
                self.execute_codespaces_add_selected_repo_to_org_secret(matches)
                    .await;
            }
            CliCommand::CodespacesRemoveSelectedRepoFromOrgSecret => {
                self.execute_codespaces_remove_selected_repo_from_org_secret(matches)
                    .await;
            }
            CliCommand::DependabotListAlertsForOrg => {
                self.execute_dependabot_list_alerts_for_org(matches).await;
            }
            CliCommand::DependabotListOrgSecrets => {
                self.execute_dependabot_list_org_secrets(matches).await;
            }
            CliCommand::DependabotGetOrgPublicKey => {
                self.execute_dependabot_get_org_public_key(matches).await;
            }
            CliCommand::DependabotGetOrgSecret => {
                self.execute_dependabot_get_org_secret(matches).await;
            }
            CliCommand::DependabotCreateOrUpdateOrgSecret => {
                self.execute_dependabot_create_or_update_org_secret(matches)
                    .await;
            }
            CliCommand::DependabotDeleteOrgSecret => {
                self.execute_dependabot_delete_org_secret(matches).await;
            }
            CliCommand::DependabotListSelectedReposForOrgSecret => {
                self.execute_dependabot_list_selected_repos_for_org_secret(matches)
                    .await;
            }
            CliCommand::DependabotSetSelectedReposForOrgSecret => {
                self.execute_dependabot_set_selected_repos_for_org_secret(matches)
                    .await;
            }
            CliCommand::DependabotAddSelectedRepoToOrgSecret => {
                self.execute_dependabot_add_selected_repo_to_org_secret(matches)
                    .await;
            }
            CliCommand::DependabotRemoveSelectedRepoFromOrgSecret => {
                self.execute_dependabot_remove_selected_repo_from_org_secret(matches)
                    .await;
            }
            CliCommand::PackagesListDockerMigrationConflictingPackagesForOrganization => {
                self.execute_packages_list_docker_migration_conflicting_packages_for_organization(
                    matches,
                )
                .await;
            }
            CliCommand::ActivityListPublicOrgEvents => {
                self.execute_activity_list_public_org_events(matches).await;
            }
            CliCommand::OrgsListFailedInvitations => {
                self.execute_orgs_list_failed_invitations(matches).await;
            }
            CliCommand::OrgsListWebhooks => {
                self.execute_orgs_list_webhooks(matches).await;
            }
            CliCommand::OrgsCreateWebhook => {
                self.execute_orgs_create_webhook(matches).await;
            }
            CliCommand::OrgsGetWebhook => {
                self.execute_orgs_get_webhook(matches).await;
            }
            CliCommand::OrgsDeleteWebhook => {
                self.execute_orgs_delete_webhook(matches).await;
            }
            CliCommand::OrgsUpdateWebhook => {
                self.execute_orgs_update_webhook(matches).await;
            }
            CliCommand::OrgsGetWebhookConfigForOrg => {
                self.execute_orgs_get_webhook_config_for_org(matches).await;
            }
            CliCommand::OrgsUpdateWebhookConfigForOrg => {
                self.execute_orgs_update_webhook_config_for_org(matches)
                    .await;
            }
            CliCommand::OrgsListWebhookDeliveries => {
                self.execute_orgs_list_webhook_deliveries(matches).await;
            }
            CliCommand::OrgsGetWebhookDelivery => {
                self.execute_orgs_get_webhook_delivery(matches).await;
            }
            CliCommand::OrgsRedeliverWebhookDelivery => {
                self.execute_orgs_redeliver_webhook_delivery(matches).await;
            }
            CliCommand::OrgsPingWebhook => {
                self.execute_orgs_ping_webhook(matches).await;
            }
            CliCommand::AppsGetOrgInstallation => {
                self.execute_apps_get_org_installation(matches).await;
            }
            CliCommand::OrgsListAppInstallations => {
                self.execute_orgs_list_app_installations(matches).await;
            }
            CliCommand::InteractionsGetRestrictionsForOrg => {
                self.execute_interactions_get_restrictions_for_org(matches)
                    .await;
            }
            CliCommand::InteractionsSetRestrictionsForOrg => {
                self.execute_interactions_set_restrictions_for_org(matches)
                    .await;
            }
            CliCommand::InteractionsRemoveRestrictionsForOrg => {
                self.execute_interactions_remove_restrictions_for_org(matches)
                    .await;
            }
            CliCommand::OrgsListPendingInvitations => {
                self.execute_orgs_list_pending_invitations(matches).await;
            }
            CliCommand::OrgsCreateInvitation => {
                self.execute_orgs_create_invitation(matches).await;
            }
            CliCommand::OrgsCancelInvitation => {
                self.execute_orgs_cancel_invitation(matches).await;
            }
            CliCommand::OrgsListInvitationTeams => {
                self.execute_orgs_list_invitation_teams(matches).await;
            }
            CliCommand::IssuesListForOrg => {
                self.execute_issues_list_for_org(matches).await;
            }
            CliCommand::OrgsListMembers => {
                self.execute_orgs_list_members(matches).await;
            }
            CliCommand::OrgsCheckMembershipForUser => {
                self.execute_orgs_check_membership_for_user(matches).await;
            }
            CliCommand::OrgsRemoveMember => {
                self.execute_orgs_remove_member(matches).await;
            }
            CliCommand::CodespacesGetCodespacesForUserInOrg => {
                self.execute_codespaces_get_codespaces_for_user_in_org(matches)
                    .await;
            }
            CliCommand::CodespacesDeleteFromOrganization => {
                self.execute_codespaces_delete_from_organization(matches)
                    .await;
            }
            CliCommand::CodespacesStopInOrganization => {
                self.execute_codespaces_stop_in_organization(matches).await;
            }
            CliCommand::OrgsGetMembershipForUser => {
                self.execute_orgs_get_membership_for_user(matches).await;
            }
            CliCommand::OrgsSetMembershipForUser => {
                self.execute_orgs_set_membership_for_user(matches).await;
            }
            CliCommand::OrgsRemoveMembershipForUser => {
                self.execute_orgs_remove_membership_for_user(matches).await;
            }
            CliCommand::MigrationsListForOrg => {
                self.execute_migrations_list_for_org(matches).await;
            }
            CliCommand::MigrationsStartForOrg => {
                self.execute_migrations_start_for_org(matches).await;
            }
            CliCommand::MigrationsGetStatusForOrg => {
                self.execute_migrations_get_status_for_org(matches).await;
            }
            CliCommand::MigrationsDownloadArchiveForOrg => {
                self.execute_migrations_download_archive_for_org(matches)
                    .await;
            }
            CliCommand::MigrationsDeleteArchiveForOrg => {
                self.execute_migrations_delete_archive_for_org(matches)
                    .await;
            }
            CliCommand::MigrationsUnlockRepoForOrg => {
                self.execute_migrations_unlock_repo_for_org(matches).await;
            }
            CliCommand::MigrationsListReposForOrg => {
                self.execute_migrations_list_repos_for_org(matches).await;
            }
            CliCommand::OrgsListOutsideCollaborators => {
                self.execute_orgs_list_outside_collaborators(matches).await;
            }
            CliCommand::OrgsConvertMemberToOutsideCollaborator => {
                self.execute_orgs_convert_member_to_outside_collaborator(matches)
                    .await;
            }
            CliCommand::OrgsRemoveOutsideCollaborator => {
                self.execute_orgs_remove_outside_collaborator(matches).await;
            }
            CliCommand::PackagesListPackagesForOrganization => {
                self.execute_packages_list_packages_for_organization(matches)
                    .await;
            }
            CliCommand::PackagesGetPackageForOrganization => {
                self.execute_packages_get_package_for_organization(matches)
                    .await;
            }
            CliCommand::PackagesDeletePackageForOrg => {
                self.execute_packages_delete_package_for_org(matches).await;
            }
            CliCommand::PackagesRestorePackageForOrg => {
                self.execute_packages_restore_package_for_org(matches).await;
            }
            CliCommand::PackagesGetAllPackageVersionsForPackageOwnedByOrg => {
                self.execute_packages_get_all_package_versions_for_package_owned_by_org(matches)
                    .await;
            }
            CliCommand::PackagesGetPackageVersionForOrganization => {
                self.execute_packages_get_package_version_for_organization(matches)
                    .await;
            }
            CliCommand::PackagesDeletePackageVersionForOrg => {
                self.execute_packages_delete_package_version_for_org(matches)
                    .await;
            }
            CliCommand::PackagesRestorePackageVersionForOrg => {
                self.execute_packages_restore_package_version_for_org(matches)
                    .await;
            }
            CliCommand::ProjectsListForOrg => {
                self.execute_projects_list_for_org(matches).await;
            }
            CliCommand::ProjectsCreateForOrg => {
                self.execute_projects_create_for_org(matches).await;
            }
            CliCommand::OrgsListPublicMembers => {
                self.execute_orgs_list_public_members(matches).await;
            }
            CliCommand::OrgsCheckPublicMembershipForUser => {
                self.execute_orgs_check_public_membership_for_user(matches)
                    .await;
            }
            CliCommand::OrgsSetPublicMembershipForAuthenticatedUser => {
                self.execute_orgs_set_public_membership_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::OrgsRemovePublicMembershipForAuthenticatedUser => {
                self.execute_orgs_remove_public_membership_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ReposListForOrg => {
                self.execute_repos_list_for_org(matches).await;
            }
            CliCommand::ReposCreateInOrg => {
                self.execute_repos_create_in_org(matches).await;
            }
            CliCommand::ReposGetOrgRulesets => {
                self.execute_repos_get_org_rulesets(matches).await;
            }
            CliCommand::ReposCreateOrgRuleset => {
                self.execute_repos_create_org_ruleset(matches).await;
            }
            CliCommand::ReposGetOrgRuleset => {
                self.execute_repos_get_org_ruleset(matches).await;
            }
            CliCommand::ReposUpdateOrgRuleset => {
                self.execute_repos_update_org_ruleset(matches).await;
            }
            CliCommand::ReposDeleteOrgRuleset => {
                self.execute_repos_delete_org_ruleset(matches).await;
            }
            CliCommand::SecretScanningListAlertsForOrg => {
                self.execute_secret_scanning_list_alerts_for_org(matches)
                    .await;
            }
            CliCommand::OrgsListSecurityManagerTeams => {
                self.execute_orgs_list_security_manager_teams(matches).await;
            }
            CliCommand::OrgsAddSecurityManagerTeam => {
                self.execute_orgs_add_security_manager_team(matches).await;
            }
            CliCommand::OrgsRemoveSecurityManagerTeam => {
                self.execute_orgs_remove_security_manager_team(matches)
                    .await;
            }
            CliCommand::BillingGetGithubActionsBillingOrg => {
                self.execute_billing_get_github_actions_billing_org(matches)
                    .await;
            }
            CliCommand::BillingGetGithubPackagesBillingOrg => {
                self.execute_billing_get_github_packages_billing_org(matches)
                    .await;
            }
            CliCommand::BillingGetSharedStorageBillingOrg => {
                self.execute_billing_get_shared_storage_billing_org(matches)
                    .await;
            }
            CliCommand::TeamsList => {
                self.execute_teams_list(matches).await;
            }
            CliCommand::TeamsCreate => {
                self.execute_teams_create(matches).await;
            }
            CliCommand::TeamsGetByName => {
                self.execute_teams_get_by_name(matches).await;
            }
            CliCommand::TeamsDeleteInOrg => {
                self.execute_teams_delete_in_org(matches).await;
            }
            CliCommand::TeamsUpdateInOrg => {
                self.execute_teams_update_in_org(matches).await;
            }
            CliCommand::TeamsListDiscussionsInOrg => {
                self.execute_teams_list_discussions_in_org(matches).await;
            }
            CliCommand::TeamsCreateDiscussionInOrg => {
                self.execute_teams_create_discussion_in_org(matches).await;
            }
            CliCommand::TeamsGetDiscussionInOrg => {
                self.execute_teams_get_discussion_in_org(matches).await;
            }
            CliCommand::TeamsDeleteDiscussionInOrg => {
                self.execute_teams_delete_discussion_in_org(matches).await;
            }
            CliCommand::TeamsUpdateDiscussionInOrg => {
                self.execute_teams_update_discussion_in_org(matches).await;
            }
            CliCommand::TeamsListDiscussionCommentsInOrg => {
                self.execute_teams_list_discussion_comments_in_org(matches)
                    .await;
            }
            CliCommand::TeamsCreateDiscussionCommentInOrg => {
                self.execute_teams_create_discussion_comment_in_org(matches)
                    .await;
            }
            CliCommand::TeamsGetDiscussionCommentInOrg => {
                self.execute_teams_get_discussion_comment_in_org(matches)
                    .await;
            }
            CliCommand::TeamsDeleteDiscussionCommentInOrg => {
                self.execute_teams_delete_discussion_comment_in_org(matches)
                    .await;
            }
            CliCommand::TeamsUpdateDiscussionCommentInOrg => {
                self.execute_teams_update_discussion_comment_in_org(matches)
                    .await;
            }
            CliCommand::ReactionsListForTeamDiscussionCommentInOrg => {
                self.execute_reactions_list_for_team_discussion_comment_in_org(matches)
                    .await;
            }
            CliCommand::ReactionsCreateForTeamDiscussionCommentInOrg => {
                self.execute_reactions_create_for_team_discussion_comment_in_org(matches)
                    .await;
            }
            CliCommand::ReactionsDeleteForTeamDiscussionComment => {
                self.execute_reactions_delete_for_team_discussion_comment(matches)
                    .await;
            }
            CliCommand::ReactionsListForTeamDiscussionInOrg => {
                self.execute_reactions_list_for_team_discussion_in_org(matches)
                    .await;
            }
            CliCommand::ReactionsCreateForTeamDiscussionInOrg => {
                self.execute_reactions_create_for_team_discussion_in_org(matches)
                    .await;
            }
            CliCommand::ReactionsDeleteForTeamDiscussion => {
                self.execute_reactions_delete_for_team_discussion(matches)
                    .await;
            }
            CliCommand::TeamsListPendingInvitationsInOrg => {
                self.execute_teams_list_pending_invitations_in_org(matches)
                    .await;
            }
            CliCommand::TeamsListMembersInOrg => {
                self.execute_teams_list_members_in_org(matches).await;
            }
            CliCommand::TeamsGetMembershipForUserInOrg => {
                self.execute_teams_get_membership_for_user_in_org(matches)
                    .await;
            }
            CliCommand::TeamsAddOrUpdateMembershipForUserInOrg => {
                self.execute_teams_add_or_update_membership_for_user_in_org(matches)
                    .await;
            }
            CliCommand::TeamsRemoveMembershipForUserInOrg => {
                self.execute_teams_remove_membership_for_user_in_org(matches)
                    .await;
            }
            CliCommand::TeamsListProjectsInOrg => {
                self.execute_teams_list_projects_in_org(matches).await;
            }
            CliCommand::TeamsCheckPermissionsForProjectInOrg => {
                self.execute_teams_check_permissions_for_project_in_org(matches)
                    .await;
            }
            CliCommand::TeamsAddOrUpdateProjectPermissionsInOrg => {
                self.execute_teams_add_or_update_project_permissions_in_org(matches)
                    .await;
            }
            CliCommand::TeamsRemoveProjectInOrg => {
                self.execute_teams_remove_project_in_org(matches).await;
            }
            CliCommand::TeamsListReposInOrg => {
                self.execute_teams_list_repos_in_org(matches).await;
            }
            CliCommand::TeamsCheckPermissionsForRepoInOrg => {
                self.execute_teams_check_permissions_for_repo_in_org(matches)
                    .await;
            }
            CliCommand::TeamsAddOrUpdateRepoPermissionsInOrg => {
                self.execute_teams_add_or_update_repo_permissions_in_org(matches)
                    .await;
            }
            CliCommand::TeamsRemoveRepoInOrg => {
                self.execute_teams_remove_repo_in_org(matches).await;
            }
            CliCommand::TeamsListChildInOrg => {
                self.execute_teams_list_child_in_org(matches).await;
            }
            CliCommand::OrgsEnableOrDisableSecurityProductOnAllOrgRepos => {
                self.execute_orgs_enable_or_disable_security_product_on_all_org_repos(matches)
                    .await;
            }
            CliCommand::ProjectsGetCard => {
                self.execute_projects_get_card(matches).await;
            }
            CliCommand::ProjectsDeleteCard => {
                self.execute_projects_delete_card(matches).await;
            }
            CliCommand::ProjectsUpdateCard => {
                self.execute_projects_update_card(matches).await;
            }
            CliCommand::ProjectsMoveCard => {
                self.execute_projects_move_card(matches).await;
            }
            CliCommand::ProjectsGetColumn => {
                self.execute_projects_get_column(matches).await;
            }
            CliCommand::ProjectsDeleteColumn => {
                self.execute_projects_delete_column(matches).await;
            }
            CliCommand::ProjectsUpdateColumn => {
                self.execute_projects_update_column(matches).await;
            }
            CliCommand::UsersListSshSigningKeysForUser => {
                self.execute_users_list_ssh_signing_keys_for_user(matches)
                    .await;
            }
            CliCommand::ProjectsMoveColumn => {
                self.execute_projects_move_column(matches).await;
            }
            CliCommand::ProjectsGet => {
                self.execute_projects_get(matches).await;
            }
            CliCommand::ProjectsDelete => {
                self.execute_projects_delete(matches).await;
            }
            CliCommand::ProjectsUpdate => {
                self.execute_projects_update(matches).await;
            }
            CliCommand::ProjectsListCollaborators => {
                self.execute_projects_list_collaborators(matches).await;
            }
            CliCommand::ProjectsAddCollaborator => {
                self.execute_projects_add_collaborator(matches).await;
            }
            CliCommand::ProjectsRemoveCollaborator => {
                self.execute_projects_remove_collaborator(matches).await;
            }
            CliCommand::ProjectsGetPermissionForUser => {
                self.execute_projects_get_permission_for_user(matches).await;
            }
            CliCommand::ProjectsListColumns => {
                self.execute_projects_list_columns(matches).await;
            }
            CliCommand::ProjectsCreateColumn => {
                self.execute_projects_create_column(matches).await;
            }
            CliCommand::RateLimitGet => {
                self.execute_rate_limit_get(matches).await;
            }
            CliCommand::ActionsListRepoRequiredWorkflows => {
                self.execute_actions_list_repo_required_workflows(matches)
                    .await;
            }
            CliCommand::ActionsGetRepoRequiredWorkflow => {
                self.execute_actions_get_repo_required_workflow(matches)
                    .await;
            }
            CliCommand::ActionsGetRepoRequiredWorkflowUsage => {
                self.execute_actions_get_repo_required_workflow_usage(matches)
                    .await;
            }
            CliCommand::ReposGet => {
                self.execute_repos_get(matches).await;
            }
            CliCommand::ReposDelete => {
                self.execute_repos_delete(matches).await;
            }
            CliCommand::ReposUpdate => {
                self.execute_repos_update(matches).await;
            }
            CliCommand::ActionsListArtifactsForRepo => {
                self.execute_actions_list_artifacts_for_repo(matches).await;
            }
            CliCommand::ActionsGetArtifact => {
                self.execute_actions_get_artifact(matches).await;
            }
            CliCommand::ActionsDeleteArtifact => {
                self.execute_actions_delete_artifact(matches).await;
            }
            CliCommand::ActionsDownloadArtifact => {
                self.execute_actions_download_artifact(matches).await;
            }
            CliCommand::ActionsGetActionsCacheUsage => {
                self.execute_actions_get_actions_cache_usage(matches).await;
            }
            CliCommand::ActionsGetActionsCacheList => {
                self.execute_actions_get_actions_cache_list(matches).await;
            }
            CliCommand::ActionsDeleteActionsCacheByKey => {
                self.execute_actions_delete_actions_cache_by_key(matches)
                    .await;
            }
            CliCommand::ActionsDeleteActionsCacheById => {
                self.execute_actions_delete_actions_cache_by_id(matches)
                    .await;
            }
            CliCommand::ActionsGetJobForWorkflowRun => {
                self.execute_actions_get_job_for_workflow_run(matches).await;
            }
            CliCommand::ActionsDownloadJobLogsForWorkflowRun => {
                self.execute_actions_download_job_logs_for_workflow_run(matches)
                    .await;
            }
            CliCommand::ActionsReRunJobForWorkflowRun => {
                self.execute_actions_re_run_job_for_workflow_run(matches)
                    .await;
            }
            CliCommand::ActionsGetCustomOidcSubClaimForRepo => {
                self.execute_actions_get_custom_oidc_sub_claim_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsSetCustomOidcSubClaimForRepo => {
                self.execute_actions_set_custom_oidc_sub_claim_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsListRepoOrganizationSecrets => {
                self.execute_actions_list_repo_organization_secrets(matches)
                    .await;
            }
            CliCommand::ActionsListRepoOrganizationVariables => {
                self.execute_actions_list_repo_organization_variables(matches)
                    .await;
            }
            CliCommand::ActionsGetGithubActionsPermissionsRepository => {
                self.execute_actions_get_github_actions_permissions_repository(matches)
                    .await;
            }
            CliCommand::ActionsSetGithubActionsPermissionsRepository => {
                self.execute_actions_set_github_actions_permissions_repository(matches)
                    .await;
            }
            CliCommand::ActionsGetWorkflowAccessToRepository => {
                self.execute_actions_get_workflow_access_to_repository(matches)
                    .await;
            }
            CliCommand::ActionsSetWorkflowAccessToRepository => {
                self.execute_actions_set_workflow_access_to_repository(matches)
                    .await;
            }
            CliCommand::ActionsGetAllowedActionsRepository => {
                self.execute_actions_get_allowed_actions_repository(matches)
                    .await;
            }
            CliCommand::ActionsSetAllowedActionsRepository => {
                self.execute_actions_set_allowed_actions_repository(matches)
                    .await;
            }
            CliCommand::ActionsGetGithubActionsDefaultWorkflowPermissionsRepository => {
                self.execute_actions_get_github_actions_default_workflow_permissions_repository(
                    matches,
                )
                .await;
            }
            CliCommand::ActionsSetGithubActionsDefaultWorkflowPermissionsRepository => {
                self.execute_actions_set_github_actions_default_workflow_permissions_repository(
                    matches,
                )
                .await;
            }
            CliCommand::ActionsListRequiredWorkflowRuns => {
                self.execute_actions_list_required_workflow_runs(matches)
                    .await;
            }
            CliCommand::ActionsListSelfHostedRunnersForRepo => {
                self.execute_actions_list_self_hosted_runners_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsListRunnerApplicationsForRepo => {
                self.execute_actions_list_runner_applications_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsCreateRegistrationTokenForRepo => {
                self.execute_actions_create_registration_token_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsCreateRemoveTokenForRepo => {
                self.execute_actions_create_remove_token_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsGetSelfHostedRunnerForRepo => {
                self.execute_actions_get_self_hosted_runner_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsDeleteSelfHostedRunnerFromRepo => {
                self.execute_actions_delete_self_hosted_runner_from_repo(matches)
                    .await;
            }
            CliCommand::ActionsListLabelsForSelfHostedRunnerForRepo => {
                self.execute_actions_list_labels_for_self_hosted_runner_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsSetCustomLabelsForSelfHostedRunnerForRepo => {
                self.execute_actions_set_custom_labels_for_self_hosted_runner_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsAddCustomLabelsToSelfHostedRunnerForRepo => {
                self.execute_actions_add_custom_labels_to_self_hosted_runner_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo => {
                self.execute_actions_remove_all_custom_labels_from_self_hosted_runner_for_repo(
                    matches,
                )
                .await;
            }
            CliCommand::ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo => {
                self.execute_actions_remove_custom_label_from_self_hosted_runner_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsListWorkflowRunsForRepo => {
                self.execute_actions_list_workflow_runs_for_repo(matches)
                    .await;
            }
            CliCommand::ActionsGetWorkflowRun => {
                self.execute_actions_get_workflow_run(matches).await;
            }
            CliCommand::ActionsDeleteWorkflowRun => {
                self.execute_actions_delete_workflow_run(matches).await;
            }
            CliCommand::ActionsGetReviewsForRun => {
                self.execute_actions_get_reviews_for_run(matches).await;
            }
            CliCommand::ActionsApproveWorkflowRun => {
                self.execute_actions_approve_workflow_run(matches).await;
            }
            CliCommand::ActionsListWorkflowRunArtifacts => {
                self.execute_actions_list_workflow_run_artifacts(matches)
                    .await;
            }
            CliCommand::ActionsGetWorkflowRunAttempt => {
                self.execute_actions_get_workflow_run_attempt(matches).await;
            }
            CliCommand::ActionsListJobsForWorkflowRunAttempt => {
                self.execute_actions_list_jobs_for_workflow_run_attempt(matches)
                    .await;
            }
            CliCommand::ActionsDownloadWorkflowRunAttemptLogs => {
                self.execute_actions_download_workflow_run_attempt_logs(matches)
                    .await;
            }
            CliCommand::ActionsCancelWorkflowRun => {
                self.execute_actions_cancel_workflow_run(matches).await;
            }
            CliCommand::ActionsReviewCustomGatesForRun => {
                self.execute_actions_review_custom_gates_for_run(matches)
                    .await;
            }
            CliCommand::ActionsListJobsForWorkflowRun => {
                self.execute_actions_list_jobs_for_workflow_run(matches)
                    .await;
            }
            CliCommand::ActionsDownloadWorkflowRunLogs => {
                self.execute_actions_download_workflow_run_logs(matches)
                    .await;
            }
            CliCommand::ActionsDeleteWorkflowRunLogs => {
                self.execute_actions_delete_workflow_run_logs(matches).await;
            }
            CliCommand::ActionsGetPendingDeploymentsForRun => {
                self.execute_actions_get_pending_deployments_for_run(matches)
                    .await;
            }
            CliCommand::ActionsReviewPendingDeploymentsForRun => {
                self.execute_actions_review_pending_deployments_for_run(matches)
                    .await;
            }
            CliCommand::ActionsReRunWorkflow => {
                self.execute_actions_re_run_workflow(matches).await;
            }
            CliCommand::ActionsReRunWorkflowFailedJobs => {
                self.execute_actions_re_run_workflow_failed_jobs(matches)
                    .await;
            }
            CliCommand::ActionsGetWorkflowRunUsage => {
                self.execute_actions_get_workflow_run_usage(matches).await;
            }
            CliCommand::ActionsListRepoSecrets => {
                self.execute_actions_list_repo_secrets(matches).await;
            }
            CliCommand::ActionsGetRepoPublicKey => {
                self.execute_actions_get_repo_public_key(matches).await;
            }
            CliCommand::ActionsGetRepoSecret => {
                self.execute_actions_get_repo_secret(matches).await;
            }
            CliCommand::ActionsCreateOrUpdateRepoSecret => {
                self.execute_actions_create_or_update_repo_secret(matches)
                    .await;
            }
            CliCommand::ActionsDeleteRepoSecret => {
                self.execute_actions_delete_repo_secret(matches).await;
            }
            CliCommand::ActionsListRepoVariables => {
                self.execute_actions_list_repo_variables(matches).await;
            }
            CliCommand::ActionsCreateRepoVariable => {
                self.execute_actions_create_repo_variable(matches).await;
            }
            CliCommand::ActionsGetRepoVariable => {
                self.execute_actions_get_repo_variable(matches).await;
            }
            CliCommand::ActionsDeleteRepoVariable => {
                self.execute_actions_delete_repo_variable(matches).await;
            }
            CliCommand::ActionsUpdateRepoVariable => {
                self.execute_actions_update_repo_variable(matches).await;
            }
            CliCommand::ActionsListRepoWorkflows => {
                self.execute_actions_list_repo_workflows(matches).await;
            }
            CliCommand::ActionsGetWorkflow => {
                self.execute_actions_get_workflow(matches).await;
            }
            CliCommand::ActionsDisableWorkflow => {
                self.execute_actions_disable_workflow(matches).await;
            }
            CliCommand::ActionsCreateWorkflowDispatch => {
                self.execute_actions_create_workflow_dispatch(matches).await;
            }
            CliCommand::ActionsEnableWorkflow => {
                self.execute_actions_enable_workflow(matches).await;
            }
            CliCommand::ActionsListWorkflowRuns => {
                self.execute_actions_list_workflow_runs(matches).await;
            }
            CliCommand::ActionsGetWorkflowUsage => {
                self.execute_actions_get_workflow_usage(matches).await;
            }
            CliCommand::IssuesListAssignees => {
                self.execute_issues_list_assignees(matches).await;
            }
            CliCommand::IssuesCheckUserCanBeAssigned => {
                self.execute_issues_check_user_can_be_assigned(matches)
                    .await;
            }
            CliCommand::ReposListAutolinks => {
                self.execute_repos_list_autolinks(matches).await;
            }
            CliCommand::ReposCreateAutolink => {
                self.execute_repos_create_autolink(matches).await;
            }
            CliCommand::ReposGetAutolink => {
                self.execute_repos_get_autolink(matches).await;
            }
            CliCommand::ReposDeleteAutolink => {
                self.execute_repos_delete_autolink(matches).await;
            }
            CliCommand::ReposEnableAutomatedSecurityFixes => {
                self.execute_repos_enable_automated_security_fixes(matches)
                    .await;
            }
            CliCommand::ReposDisableAutomatedSecurityFixes => {
                self.execute_repos_disable_automated_security_fixes(matches)
                    .await;
            }
            CliCommand::ReposListBranches => {
                self.execute_repos_list_branches(matches).await;
            }
            CliCommand::ReposGetBranch => {
                self.execute_repos_get_branch(matches).await;
            }
            CliCommand::ReposGetBranchProtection => {
                self.execute_repos_get_branch_protection(matches).await;
            }
            CliCommand::ReposUpdateBranchProtection => {
                self.execute_repos_update_branch_protection(matches).await;
            }
            CliCommand::ReposDeleteBranchProtection => {
                self.execute_repos_delete_branch_protection(matches).await;
            }
            CliCommand::ReposGetAdminBranchProtection => {
                self.execute_repos_get_admin_branch_protection(matches)
                    .await;
            }
            CliCommand::ReposSetAdminBranchProtection => {
                self.execute_repos_set_admin_branch_protection(matches)
                    .await;
            }
            CliCommand::ReposDeleteAdminBranchProtection => {
                self.execute_repos_delete_admin_branch_protection(matches)
                    .await;
            }
            CliCommand::ReposGetPullRequestReviewProtection => {
                self.execute_repos_get_pull_request_review_protection(matches)
                    .await;
            }
            CliCommand::ReposDeletePullRequestReviewProtection => {
                self.execute_repos_delete_pull_request_review_protection(matches)
                    .await;
            }
            CliCommand::ReposUpdatePullRequestReviewProtection => {
                self.execute_repos_update_pull_request_review_protection(matches)
                    .await;
            }
            CliCommand::ReposGetCommitSignatureProtection => {
                self.execute_repos_get_commit_signature_protection(matches)
                    .await;
            }
            CliCommand::ReposCreateCommitSignatureProtection => {
                self.execute_repos_create_commit_signature_protection(matches)
                    .await;
            }
            CliCommand::ReposDeleteCommitSignatureProtection => {
                self.execute_repos_delete_commit_signature_protection(matches)
                    .await;
            }
            CliCommand::ReposGetStatusChecksProtection => {
                self.execute_repos_get_status_checks_protection(matches)
                    .await;
            }
            CliCommand::ReposRemoveStatusCheckProtection => {
                self.execute_repos_remove_status_check_protection(matches)
                    .await;
            }
            CliCommand::ReposUpdateStatusCheckProtection => {
                self.execute_repos_update_status_check_protection(matches)
                    .await;
            }
            CliCommand::ReposGetAllStatusCheckContexts => {
                self.execute_repos_get_all_status_check_contexts(matches)
                    .await;
            }
            CliCommand::ReposSetStatusCheckContexts => {
                self.execute_repos_set_status_check_contexts(matches).await;
            }
            CliCommand::ReposAddStatusCheckContexts => {
                self.execute_repos_add_status_check_contexts(matches).await;
            }
            CliCommand::ReposRemoveStatusCheckContexts => {
                self.execute_repos_remove_status_check_contexts(matches)
                    .await;
            }
            CliCommand::ReposGetAccessRestrictions => {
                self.execute_repos_get_access_restrictions(matches).await;
            }
            CliCommand::ReposDeleteAccessRestrictions => {
                self.execute_repos_delete_access_restrictions(matches).await;
            }
            CliCommand::ReposGetAppsWithAccessToProtectedBranch => {
                self.execute_repos_get_apps_with_access_to_protected_branch(matches)
                    .await;
            }
            CliCommand::ReposSetAppAccessRestrictions => {
                self.execute_repos_set_app_access_restrictions(matches)
                    .await;
            }
            CliCommand::ReposAddAppAccessRestrictions => {
                self.execute_repos_add_app_access_restrictions(matches)
                    .await;
            }
            CliCommand::ReposRemoveAppAccessRestrictions => {
                self.execute_repos_remove_app_access_restrictions(matches)
                    .await;
            }
            CliCommand::ReposGetTeamsWithAccessToProtectedBranch => {
                self.execute_repos_get_teams_with_access_to_protected_branch(matches)
                    .await;
            }
            CliCommand::ReposSetTeamAccessRestrictions => {
                self.execute_repos_set_team_access_restrictions(matches)
                    .await;
            }
            CliCommand::ReposAddTeamAccessRestrictions => {
                self.execute_repos_add_team_access_restrictions(matches)
                    .await;
            }
            CliCommand::ReposRemoveTeamAccessRestrictions => {
                self.execute_repos_remove_team_access_restrictions(matches)
                    .await;
            }
            CliCommand::ReposGetUsersWithAccessToProtectedBranch => {
                self.execute_repos_get_users_with_access_to_protected_branch(matches)
                    .await;
            }
            CliCommand::ReposSetUserAccessRestrictions => {
                self.execute_repos_set_user_access_restrictions(matches)
                    .await;
            }
            CliCommand::ReposAddUserAccessRestrictions => {
                self.execute_repos_add_user_access_restrictions(matches)
                    .await;
            }
            CliCommand::ReposRemoveUserAccessRestrictions => {
                self.execute_repos_remove_user_access_restrictions(matches)
                    .await;
            }
            CliCommand::ReposRenameBranch => {
                self.execute_repos_rename_branch(matches).await;
            }
            CliCommand::ChecksCreate => {
                self.execute_checks_create(matches).await;
            }
            CliCommand::ChecksGet => {
                self.execute_checks_get(matches).await;
            }
            CliCommand::ChecksUpdate => {
                self.execute_checks_update(matches).await;
            }
            CliCommand::ChecksListAnnotations => {
                self.execute_checks_list_annotations(matches).await;
            }
            CliCommand::ChecksRerequestRun => {
                self.execute_checks_rerequest_run(matches).await;
            }
            CliCommand::ChecksCreateSuite => {
                self.execute_checks_create_suite(matches).await;
            }
            CliCommand::ChecksSetSuitesPreferences => {
                self.execute_checks_set_suites_preferences(matches).await;
            }
            CliCommand::ChecksGetSuite => {
                self.execute_checks_get_suite(matches).await;
            }
            CliCommand::ChecksListForSuite => {
                self.execute_checks_list_for_suite(matches).await;
            }
            CliCommand::ChecksRerequestSuite => {
                self.execute_checks_rerequest_suite(matches).await;
            }
            CliCommand::CodeScanningListAlertsForRepo => {
                self.execute_code_scanning_list_alerts_for_repo(matches)
                    .await;
            }
            CliCommand::CodeScanningGetAlert => {
                self.execute_code_scanning_get_alert(matches).await;
            }
            CliCommand::CodeScanningUpdateAlert => {
                self.execute_code_scanning_update_alert(matches).await;
            }
            CliCommand::CodeScanningListAlertInstances => {
                self.execute_code_scanning_list_alert_instances(matches)
                    .await;
            }
            CliCommand::CodeScanningListRecentAnalyses => {
                self.execute_code_scanning_list_recent_analyses(matches)
                    .await;
            }
            CliCommand::CodeScanningGetAnalysis => {
                self.execute_code_scanning_get_analysis(matches).await;
            }
            CliCommand::CodeScanningDeleteAnalysis => {
                self.execute_code_scanning_delete_analysis(matches).await;
            }
            CliCommand::CodeScanningListCodeqlDatabases => {
                self.execute_code_scanning_list_codeql_databases(matches)
                    .await;
            }
            CliCommand::CodeScanningGetCodeqlDatabase => {
                self.execute_code_scanning_get_codeql_database(matches)
                    .await;
            }
            CliCommand::CodeScanningGetDefaultSetup => {
                self.execute_code_scanning_get_default_setup(matches).await;
            }
            CliCommand::CodeScanningUpdateDefaultSetup => {
                self.execute_code_scanning_update_default_setup(matches)
                    .await;
            }
            CliCommand::CodeScanningUploadSarif => {
                self.execute_code_scanning_upload_sarif(matches).await;
            }
            CliCommand::CodeScanningGetSarif => {
                self.execute_code_scanning_get_sarif(matches).await;
            }
            CliCommand::ReposCodeownersErrors => {
                self.execute_repos_codeowners_errors(matches).await;
            }
            CliCommand::CodespacesListInRepositoryForAuthenticatedUser => {
                self.execute_codespaces_list_in_repository_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesCreateWithRepoForAuthenticatedUser => {
                self.execute_codespaces_create_with_repo_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesListDevcontainersInRepositoryForAuthenticatedUser => {
                self.execute_codespaces_list_devcontainers_in_repository_for_authenticated_user(
                    matches,
                )
                .await;
            }
            CliCommand::CodespacesRepoMachinesForAuthenticatedUser => {
                self.execute_codespaces_repo_machines_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesPreFlightWithRepoForAuthenticatedUser => {
                self.execute_codespaces_pre_flight_with_repo_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesListRepoSecrets => {
                self.execute_codespaces_list_repo_secrets(matches).await;
            }
            CliCommand::CodespacesGetRepoPublicKey => {
                self.execute_codespaces_get_repo_public_key(matches).await;
            }
            CliCommand::CodespacesGetRepoSecret => {
                self.execute_codespaces_get_repo_secret(matches).await;
            }
            CliCommand::CodespacesCreateOrUpdateRepoSecret => {
                self.execute_codespaces_create_or_update_repo_secret(matches)
                    .await;
            }
            CliCommand::CodespacesDeleteRepoSecret => {
                self.execute_codespaces_delete_repo_secret(matches).await;
            }
            CliCommand::ReposListCollaborators => {
                self.execute_repos_list_collaborators(matches).await;
            }
            CliCommand::ReposCheckCollaborator => {
                self.execute_repos_check_collaborator(matches).await;
            }
            CliCommand::ReposAddCollaborator => {
                self.execute_repos_add_collaborator(matches).await;
            }
            CliCommand::ReposRemoveCollaborator => {
                self.execute_repos_remove_collaborator(matches).await;
            }
            CliCommand::ReposGetCollaboratorPermissionLevel => {
                self.execute_repos_get_collaborator_permission_level(matches)
                    .await;
            }
            CliCommand::ReposListCommitCommentsForRepo => {
                self.execute_repos_list_commit_comments_for_repo(matches)
                    .await;
            }
            CliCommand::ReposGetCommitComment => {
                self.execute_repos_get_commit_comment(matches).await;
            }
            CliCommand::ReposDeleteCommitComment => {
                self.execute_repos_delete_commit_comment(matches).await;
            }
            CliCommand::ReposUpdateCommitComment => {
                self.execute_repos_update_commit_comment(matches).await;
            }
            CliCommand::ReactionsListForCommitComment => {
                self.execute_reactions_list_for_commit_comment(matches)
                    .await;
            }
            CliCommand::ReactionsCreateForCommitComment => {
                self.execute_reactions_create_for_commit_comment(matches)
                    .await;
            }
            CliCommand::ReactionsDeleteForCommitComment => {
                self.execute_reactions_delete_for_commit_comment(matches)
                    .await;
            }
            CliCommand::ReposListCommits => {
                self.execute_repos_list_commits(matches).await;
            }
            CliCommand::ReposListBranchesForHeadCommit => {
                self.execute_repos_list_branches_for_head_commit(matches)
                    .await;
            }
            CliCommand::ReposListCommentsForCommit => {
                self.execute_repos_list_comments_for_commit(matches).await;
            }
            CliCommand::ReposCreateCommitComment => {
                self.execute_repos_create_commit_comment(matches).await;
            }
            CliCommand::ReposListPullRequestsAssociatedWithCommit => {
                self.execute_repos_list_pull_requests_associated_with_commit(matches)
                    .await;
            }
            CliCommand::ReposGetCommit => {
                self.execute_repos_get_commit(matches).await;
            }
            CliCommand::ChecksListForRef => {
                self.execute_checks_list_for_ref(matches).await;
            }
            CliCommand::ChecksListSuitesForRef => {
                self.execute_checks_list_suites_for_ref(matches).await;
            }
            CliCommand::ReposGetCombinedStatusForRef => {
                self.execute_repos_get_combined_status_for_ref(matches)
                    .await;
            }
            CliCommand::ReposListCommitStatusesForRef => {
                self.execute_repos_list_commit_statuses_for_ref(matches)
                    .await;
            }
            CliCommand::ReposGetCommunityProfileMetrics => {
                self.execute_repos_get_community_profile_metrics(matches)
                    .await;
            }
            CliCommand::ReposCompareCommits => {
                self.execute_repos_compare_commits(matches).await;
            }
            CliCommand::ReposGetContent => {
                self.execute_repos_get_content(matches).await;
            }
            CliCommand::ReposCreateOrUpdateFileContents => {
                self.execute_repos_create_or_update_file_contents(matches)
                    .await;
            }
            CliCommand::ReposDeleteFile => {
                self.execute_repos_delete_file(matches).await;
            }
            CliCommand::ReposListContributors => {
                self.execute_repos_list_contributors(matches).await;
            }
            CliCommand::DependabotListAlertsForRepo => {
                self.execute_dependabot_list_alerts_for_repo(matches).await;
            }
            CliCommand::DependabotGetAlert => {
                self.execute_dependabot_get_alert(matches).await;
            }
            CliCommand::DependabotUpdateAlert => {
                self.execute_dependabot_update_alert(matches).await;
            }
            CliCommand::DependabotListRepoSecrets => {
                self.execute_dependabot_list_repo_secrets(matches).await;
            }
            CliCommand::DependabotGetRepoPublicKey => {
                self.execute_dependabot_get_repo_public_key(matches).await;
            }
            CliCommand::DependabotGetRepoSecret => {
                self.execute_dependabot_get_repo_secret(matches).await;
            }
            CliCommand::DependabotCreateOrUpdateRepoSecret => {
                self.execute_dependabot_create_or_update_repo_secret(matches)
                    .await;
            }
            CliCommand::DependabotDeleteRepoSecret => {
                self.execute_dependabot_delete_repo_secret(matches).await;
            }
            CliCommand::DependencyGraphDiffRange => {
                self.execute_dependency_graph_diff_range(matches).await;
            }
            CliCommand::DependencyGraphExportSbom => {
                self.execute_dependency_graph_export_sbom(matches).await;
            }
            CliCommand::DependencyGraphCreateRepositorySnapshot => {
                self.execute_dependency_graph_create_repository_snapshot(matches)
                    .await;
            }
            CliCommand::ReposListDeployments => {
                self.execute_repos_list_deployments(matches).await;
            }
            CliCommand::ReposCreateDeployment => {
                self.execute_repos_create_deployment(matches).await;
            }
            CliCommand::ReposGetDeployment => {
                self.execute_repos_get_deployment(matches).await;
            }
            CliCommand::ReposDeleteDeployment => {
                self.execute_repos_delete_deployment(matches).await;
            }
            CliCommand::ReposListDeploymentStatuses => {
                self.execute_repos_list_deployment_statuses(matches).await;
            }
            CliCommand::ReposCreateDeploymentStatus => {
                self.execute_repos_create_deployment_status(matches).await;
            }
            CliCommand::ReposGetDeploymentStatus => {
                self.execute_repos_get_deployment_status(matches).await;
            }
            CliCommand::ReposCreateDispatchEvent => {
                self.execute_repos_create_dispatch_event(matches).await;
            }
            CliCommand::ReposGetAllEnvironments => {
                self.execute_repos_get_all_environments(matches).await;
            }
            CliCommand::ReposGetEnvironment => {
                self.execute_repos_get_environment(matches).await;
            }
            CliCommand::ReposCreateOrUpdateEnvironment => {
                self.execute_repos_create_or_update_environment(matches)
                    .await;
            }
            CliCommand::ReposDeleteAnEnvironment => {
                self.execute_repos_delete_an_environment(matches).await;
            }
            CliCommand::ReposListDeploymentBranchPolicies => {
                self.execute_repos_list_deployment_branch_policies(matches)
                    .await;
            }
            CliCommand::ReposCreateDeploymentBranchPolicy => {
                self.execute_repos_create_deployment_branch_policy(matches)
                    .await;
            }
            CliCommand::ReposGetDeploymentBranchPolicy => {
                self.execute_repos_get_deployment_branch_policy(matches)
                    .await;
            }
            CliCommand::ReposUpdateDeploymentBranchPolicy => {
                self.execute_repos_update_deployment_branch_policy(matches)
                    .await;
            }
            CliCommand::ReposDeleteDeploymentBranchPolicy => {
                self.execute_repos_delete_deployment_branch_policy(matches)
                    .await;
            }
            CliCommand::ReposGetAllDeploymentProtectionRules => {
                self.execute_repos_get_all_deployment_protection_rules(matches)
                    .await;
            }
            CliCommand::ReposCreateDeploymentProtectionRule => {
                self.execute_repos_create_deployment_protection_rule(matches)
                    .await;
            }
            CliCommand::ReposListCustomDeploymentRuleIntegrations => {
                self.execute_repos_list_custom_deployment_rule_integrations(matches)
                    .await;
            }
            CliCommand::ReposGetCustomDeploymentProtectionRule => {
                self.execute_repos_get_custom_deployment_protection_rule(matches)
                    .await;
            }
            CliCommand::ReposDisableDeploymentProtectionRule => {
                self.execute_repos_disable_deployment_protection_rule(matches)
                    .await;
            }
            CliCommand::ActivityListRepoEvents => {
                self.execute_activity_list_repo_events(matches).await;
            }
            CliCommand::ReposListForks => {
                self.execute_repos_list_forks(matches).await;
            }
            CliCommand::ReposCreateFork => {
                self.execute_repos_create_fork(matches).await;
            }
            CliCommand::GitCreateBlob => {
                self.execute_git_create_blob(matches).await;
            }
            CliCommand::GitGetBlob => {
                self.execute_git_get_blob(matches).await;
            }
            CliCommand::GitCreateCommit => {
                self.execute_git_create_commit(matches).await;
            }
            CliCommand::GitGetCommit => {
                self.execute_git_get_commit(matches).await;
            }
            CliCommand::GitListMatchingRefs => {
                self.execute_git_list_matching_refs(matches).await;
            }
            CliCommand::GitGetRef => {
                self.execute_git_get_ref(matches).await;
            }
            CliCommand::GitCreateRef => {
                self.execute_git_create_ref(matches).await;
            }
            CliCommand::GitDeleteRef => {
                self.execute_git_delete_ref(matches).await;
            }
            CliCommand::GitUpdateRef => {
                self.execute_git_update_ref(matches).await;
            }
            CliCommand::GitCreateTag => {
                self.execute_git_create_tag(matches).await;
            }
            CliCommand::GitGetTag => {
                self.execute_git_get_tag(matches).await;
            }
            CliCommand::GitCreateTree => {
                self.execute_git_create_tree(matches).await;
            }
            CliCommand::GitGetTree => {
                self.execute_git_get_tree(matches).await;
            }
            CliCommand::ReposListWebhooks => {
                self.execute_repos_list_webhooks(matches).await;
            }
            CliCommand::ReposCreateWebhook => {
                self.execute_repos_create_webhook(matches).await;
            }
            CliCommand::ReposGetWebhook => {
                self.execute_repos_get_webhook(matches).await;
            }
            CliCommand::ReposDeleteWebhook => {
                self.execute_repos_delete_webhook(matches).await;
            }
            CliCommand::ReposUpdateWebhook => {
                self.execute_repos_update_webhook(matches).await;
            }
            CliCommand::ReposGetWebhookConfigForRepo => {
                self.execute_repos_get_webhook_config_for_repo(matches)
                    .await;
            }
            CliCommand::ReposUpdateWebhookConfigForRepo => {
                self.execute_repos_update_webhook_config_for_repo(matches)
                    .await;
            }
            CliCommand::ReposListWebhookDeliveries => {
                self.execute_repos_list_webhook_deliveries(matches).await;
            }
            CliCommand::ReposGetWebhookDelivery => {
                self.execute_repos_get_webhook_delivery(matches).await;
            }
            CliCommand::ReposRedeliverWebhookDelivery => {
                self.execute_repos_redeliver_webhook_delivery(matches).await;
            }
            CliCommand::ReposPingWebhook => {
                self.execute_repos_ping_webhook(matches).await;
            }
            CliCommand::ReposTestPushWebhook => {
                self.execute_repos_test_push_webhook(matches).await;
            }
            CliCommand::MigrationsGetImportStatus => {
                self.execute_migrations_get_import_status(matches).await;
            }
            CliCommand::MigrationsStartImport => {
                self.execute_migrations_start_import(matches).await;
            }
            CliCommand::MigrationsCancelImport => {
                self.execute_migrations_cancel_import(matches).await;
            }
            CliCommand::MigrationsUpdateImport => {
                self.execute_migrations_update_import(matches).await;
            }
            CliCommand::MigrationsGetCommitAuthors => {
                self.execute_migrations_get_commit_authors(matches).await;
            }
            CliCommand::MigrationsMapCommitAuthor => {
                self.execute_migrations_map_commit_author(matches).await;
            }
            CliCommand::MigrationsGetLargeFiles => {
                self.execute_migrations_get_large_files(matches).await;
            }
            CliCommand::MigrationsSetLfsPreference => {
                self.execute_migrations_set_lfs_preference(matches).await;
            }
            CliCommand::AppsGetRepoInstallation => {
                self.execute_apps_get_repo_installation(matches).await;
            }
            CliCommand::InteractionsGetRestrictionsForRepo => {
                self.execute_interactions_get_restrictions_for_repo(matches)
                    .await;
            }
            CliCommand::InteractionsSetRestrictionsForRepo => {
                self.execute_interactions_set_restrictions_for_repo(matches)
                    .await;
            }
            CliCommand::InteractionsRemoveRestrictionsForRepo => {
                self.execute_interactions_remove_restrictions_for_repo(matches)
                    .await;
            }
            CliCommand::ReposListInvitations => {
                self.execute_repos_list_invitations(matches).await;
            }
            CliCommand::ReposDeleteInvitation => {
                self.execute_repos_delete_invitation(matches).await;
            }
            CliCommand::ReposUpdateInvitation => {
                self.execute_repos_update_invitation(matches).await;
            }
            CliCommand::IssuesListForRepo => {
                self.execute_issues_list_for_repo(matches).await;
            }
            CliCommand::IssuesCreate => {
                self.execute_issues_create(matches).await;
            }
            CliCommand::IssuesListCommentsForRepo => {
                self.execute_issues_list_comments_for_repo(matches).await;
            }
            CliCommand::IssuesGetComment => {
                self.execute_issues_get_comment(matches).await;
            }
            CliCommand::IssuesDeleteComment => {
                self.execute_issues_delete_comment(matches).await;
            }
            CliCommand::IssuesUpdateComment => {
                self.execute_issues_update_comment(matches).await;
            }
            CliCommand::ReactionsListForIssueComment => {
                self.execute_reactions_list_for_issue_comment(matches).await;
            }
            CliCommand::ReactionsCreateForIssueComment => {
                self.execute_reactions_create_for_issue_comment(matches)
                    .await;
            }
            CliCommand::ReactionsDeleteForIssueComment => {
                self.execute_reactions_delete_for_issue_comment(matches)
                    .await;
            }
            CliCommand::IssuesListEventsForRepo => {
                self.execute_issues_list_events_for_repo(matches).await;
            }
            CliCommand::IssuesGetEvent => {
                self.execute_issues_get_event(matches).await;
            }
            CliCommand::IssuesGet => {
                self.execute_issues_get(matches).await;
            }
            CliCommand::IssuesUpdate => {
                self.execute_issues_update(matches).await;
            }
            CliCommand::IssuesAddAssignees => {
                self.execute_issues_add_assignees(matches).await;
            }
            CliCommand::IssuesRemoveAssignees => {
                self.execute_issues_remove_assignees(matches).await;
            }
            CliCommand::IssuesCheckUserCanBeAssignedToIssue => {
                self.execute_issues_check_user_can_be_assigned_to_issue(matches)
                    .await;
            }
            CliCommand::IssuesListComments => {
                self.execute_issues_list_comments(matches).await;
            }
            CliCommand::IssuesCreateComment => {
                self.execute_issues_create_comment(matches).await;
            }
            CliCommand::IssuesListEvents => {
                self.execute_issues_list_events(matches).await;
            }
            CliCommand::IssuesListLabelsOnIssue => {
                self.execute_issues_list_labels_on_issue(matches).await;
            }
            CliCommand::IssuesSetLabels => {
                self.execute_issues_set_labels(matches).await;
            }
            CliCommand::IssuesAddLabels => {
                self.execute_issues_add_labels(matches).await;
            }
            CliCommand::IssuesRemoveAllLabels => {
                self.execute_issues_remove_all_labels(matches).await;
            }
            CliCommand::IssuesRemoveLabel => {
                self.execute_issues_remove_label(matches).await;
            }
            CliCommand::IssuesLock => {
                self.execute_issues_lock(matches).await;
            }
            CliCommand::IssuesUnlock => {
                self.execute_issues_unlock(matches).await;
            }
            CliCommand::ReactionsListForIssue => {
                self.execute_reactions_list_for_issue(matches).await;
            }
            CliCommand::ReactionsCreateForIssue => {
                self.execute_reactions_create_for_issue(matches).await;
            }
            CliCommand::ReactionsDeleteForIssue => {
                self.execute_reactions_delete_for_issue(matches).await;
            }
            CliCommand::IssuesListEventsForTimeline => {
                self.execute_issues_list_events_for_timeline(matches).await;
            }
            CliCommand::ReposListDeployKeys => {
                self.execute_repos_list_deploy_keys(matches).await;
            }
            CliCommand::ReposCreateDeployKey => {
                self.execute_repos_create_deploy_key(matches).await;
            }
            CliCommand::ReposGetDeployKey => {
                self.execute_repos_get_deploy_key(matches).await;
            }
            CliCommand::ReposDeleteDeployKey => {
                self.execute_repos_delete_deploy_key(matches).await;
            }
            CliCommand::IssuesListLabelsForRepo => {
                self.execute_issues_list_labels_for_repo(matches).await;
            }
            CliCommand::IssuesCreateLabel => {
                self.execute_issues_create_label(matches).await;
            }
            CliCommand::IssuesGetLabel => {
                self.execute_issues_get_label(matches).await;
            }
            CliCommand::IssuesDeleteLabel => {
                self.execute_issues_delete_label(matches).await;
            }
            CliCommand::IssuesUpdateLabel => {
                self.execute_issues_update_label(matches).await;
            }
            CliCommand::ReposListLanguages => {
                self.execute_repos_list_languages(matches).await;
            }
            CliCommand::ReposEnableLfsForRepo => {
                self.execute_repos_enable_lfs_for_repo(matches).await;
            }
            CliCommand::ReposDisableLfsForRepo => {
                self.execute_repos_disable_lfs_for_repo(matches).await;
            }
            CliCommand::LicensesGetForRepo => {
                self.execute_licenses_get_for_repo(matches).await;
            }
            CliCommand::ReposMergeUpstream => {
                self.execute_repos_merge_upstream(matches).await;
            }
            CliCommand::ReposMerge => {
                self.execute_repos_merge(matches).await;
            }
            CliCommand::IssuesListMilestones => {
                self.execute_issues_list_milestones(matches).await;
            }
            CliCommand::IssuesCreateMilestone => {
                self.execute_issues_create_milestone(matches).await;
            }
            CliCommand::IssuesGetMilestone => {
                self.execute_issues_get_milestone(matches).await;
            }
            CliCommand::IssuesDeleteMilestone => {
                self.execute_issues_delete_milestone(matches).await;
            }
            CliCommand::IssuesUpdateMilestone => {
                self.execute_issues_update_milestone(matches).await;
            }
            CliCommand::IssuesListLabelsForMilestone => {
                self.execute_issues_list_labels_for_milestone(matches).await;
            }
            CliCommand::ActivityListRepoNotificationsForAuthenticatedUser => {
                self.execute_activity_list_repo_notifications_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ActivityMarkRepoNotificationsAsRead => {
                self.execute_activity_mark_repo_notifications_as_read(matches)
                    .await;
            }
            CliCommand::ReposGetPages => {
                self.execute_repos_get_pages(matches).await;
            }
            CliCommand::ReposUpdateInformationAboutPagesSite => {
                self.execute_repos_update_information_about_pages_site(matches)
                    .await;
            }
            CliCommand::ReposCreatePagesSite => {
                self.execute_repos_create_pages_site(matches).await;
            }
            CliCommand::ReposDeletePagesSite => {
                self.execute_repos_delete_pages_site(matches).await;
            }
            CliCommand::ReposListPagesBuilds => {
                self.execute_repos_list_pages_builds(matches).await;
            }
            CliCommand::ReposRequestPagesBuild => {
                self.execute_repos_request_pages_build(matches).await;
            }
            CliCommand::ReposGetLatestPagesBuild => {
                self.execute_repos_get_latest_pages_build(matches).await;
            }
            CliCommand::ReposGetPagesBuild => {
                self.execute_repos_get_pages_build(matches).await;
            }
            CliCommand::ReposCreatePagesDeployment => {
                self.execute_repos_create_pages_deployment(matches).await;
            }
            CliCommand::ReposGetPagesHealthCheck => {
                self.execute_repos_get_pages_health_check(matches).await;
            }
            CliCommand::ProjectsListForRepo => {
                self.execute_projects_list_for_repo(matches).await;
            }
            CliCommand::ProjectsCreateForRepo => {
                self.execute_projects_create_for_repo(matches).await;
            }
            CliCommand::PullsList => {
                self.execute_pulls_list(matches).await;
            }
            CliCommand::PullsCreate => {
                self.execute_pulls_create(matches).await;
            }
            CliCommand::PullsListReviewCommentsForRepo => {
                self.execute_pulls_list_review_comments_for_repo(matches)
                    .await;
            }
            CliCommand::PullsGetReviewComment => {
                self.execute_pulls_get_review_comment(matches).await;
            }
            CliCommand::PullsDeleteReviewComment => {
                self.execute_pulls_delete_review_comment(matches).await;
            }
            CliCommand::PullsUpdateReviewComment => {
                self.execute_pulls_update_review_comment(matches).await;
            }
            CliCommand::ReactionsListForPullRequestReviewComment => {
                self.execute_reactions_list_for_pull_request_review_comment(matches)
                    .await;
            }
            CliCommand::ReactionsCreateForPullRequestReviewComment => {
                self.execute_reactions_create_for_pull_request_review_comment(matches)
                    .await;
            }
            CliCommand::ReactionsDeleteForPullRequestComment => {
                self.execute_reactions_delete_for_pull_request_comment(matches)
                    .await;
            }
            CliCommand::PullsGet => {
                self.execute_pulls_get(matches).await;
            }
            CliCommand::PullsUpdate => {
                self.execute_pulls_update(matches).await;
            }
            CliCommand::CodespacesCreateWithPrForAuthenticatedUser => {
                self.execute_codespaces_create_with_pr_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::PullsListReviewComments => {
                self.execute_pulls_list_review_comments(matches).await;
            }
            CliCommand::PullsCreateReviewComment => {
                self.execute_pulls_create_review_comment(matches).await;
            }
            CliCommand::PullsCreateReplyForReviewComment => {
                self.execute_pulls_create_reply_for_review_comment(matches)
                    .await;
            }
            CliCommand::PullsListCommits => {
                self.execute_pulls_list_commits(matches).await;
            }
            CliCommand::PullsListFiles => {
                self.execute_pulls_list_files(matches).await;
            }
            CliCommand::PullsCheckIfMerged => {
                self.execute_pulls_check_if_merged(matches).await;
            }
            CliCommand::PullsMerge => {
                self.execute_pulls_merge(matches).await;
            }
            CliCommand::PullsListRequestedReviewers => {
                self.execute_pulls_list_requested_reviewers(matches).await;
            }
            CliCommand::PullsRequestReviewers => {
                self.execute_pulls_request_reviewers(matches).await;
            }
            CliCommand::PullsRemoveRequestedReviewers => {
                self.execute_pulls_remove_requested_reviewers(matches).await;
            }
            CliCommand::PullsListReviews => {
                self.execute_pulls_list_reviews(matches).await;
            }
            CliCommand::PullsCreateReview => {
                self.execute_pulls_create_review(matches).await;
            }
            CliCommand::PullsGetReview => {
                self.execute_pulls_get_review(matches).await;
            }
            CliCommand::PullsUpdateReview => {
                self.execute_pulls_update_review(matches).await;
            }
            CliCommand::PullsDeletePendingReview => {
                self.execute_pulls_delete_pending_review(matches).await;
            }
            CliCommand::PullsListCommentsForReview => {
                self.execute_pulls_list_comments_for_review(matches).await;
            }
            CliCommand::PullsDismissReview => {
                self.execute_pulls_dismiss_review(matches).await;
            }
            CliCommand::PullsSubmitReview => {
                self.execute_pulls_submit_review(matches).await;
            }
            CliCommand::PullsUpdateBranch => {
                self.execute_pulls_update_branch(matches).await;
            }
            CliCommand::ReposGetReadme => {
                self.execute_repos_get_readme(matches).await;
            }
            CliCommand::ReposGetReadmeInDirectory => {
                self.execute_repos_get_readme_in_directory(matches).await;
            }
            CliCommand::ActivityListReposWatchedByUser => {
                self.execute_activity_list_repos_watched_by_user(matches)
                    .await;
            }
            CliCommand::ReposGetReleaseAsset => {
                self.execute_repos_get_release_asset(matches).await;
            }
            CliCommand::ReposDeleteReleaseAsset => {
                self.execute_repos_delete_release_asset(matches).await;
            }
            CliCommand::ReposUpdateReleaseAsset => {
                self.execute_repos_update_release_asset(matches).await;
            }
            CliCommand::ReposGenerateReleaseNotes => {
                self.execute_repos_generate_release_notes(matches).await;
            }
            CliCommand::ReposGetLatestRelease => {
                self.execute_repos_get_latest_release(matches).await;
            }
            CliCommand::ReposGetReleaseByTag => {
                self.execute_repos_get_release_by_tag(matches).await;
            }
            CliCommand::ActivityListReposStarredByUser => {
                self.execute_activity_list_repos_starred_by_user(matches)
                    .await;
            }
            CliCommand::ReposListReleaseAssets => {
                self.execute_repos_list_release_assets(matches).await;
            }
            CliCommand::ReposUploadReleaseAsset => {
                self.execute_repos_upload_release_asset(matches).await;
            }
            CliCommand::ReactionsListForRelease => {
                self.execute_reactions_list_for_release(matches).await;
            }
            CliCommand::ReactionsCreateForRelease => {
                self.execute_reactions_create_for_release(matches).await;
            }
            CliCommand::ReactionsDeleteForRelease => {
                self.execute_reactions_delete_for_release(matches).await;
            }
            CliCommand::ReposGetBranchRules => {
                self.execute_repos_get_branch_rules(matches).await;
            }
            CliCommand::ReposGetRepoRulesets => {
                self.execute_repos_get_repo_rulesets(matches).await;
            }
            CliCommand::ReposCreateRepoRuleset => {
                self.execute_repos_create_repo_ruleset(matches).await;
            }
            CliCommand::ReposGetRepoRuleset => {
                self.execute_repos_get_repo_ruleset(matches).await;
            }
            CliCommand::ReposUpdateRepoRuleset => {
                self.execute_repos_update_repo_ruleset(matches).await;
            }
            CliCommand::ReposDeleteRepoRuleset => {
                self.execute_repos_delete_repo_ruleset(matches).await;
            }
            CliCommand::SecretScanningListAlertsForRepo => {
                self.execute_secret_scanning_list_alerts_for_repo(matches)
                    .await;
            }
            CliCommand::SecretScanningGetAlert => {
                self.execute_secret_scanning_get_alert(matches).await;
            }
            CliCommand::SecretScanningUpdateAlert => {
                self.execute_secret_scanning_update_alert(matches).await;
            }
            CliCommand::SecretScanningListLocationsForAlert => {
                self.execute_secret_scanning_list_locations_for_alert(matches)
                    .await;
            }
            CliCommand::SecurityAdvisoriesListRepositoryAdvisories => {
                self.execute_security_advisories_list_repository_advisories(matches)
                    .await;
            }
            CliCommand::SecurityAdvisoriesCreateRepositoryAdvisory => {
                self.execute_security_advisories_create_repository_advisory(matches)
                    .await;
            }
            CliCommand::SecurityAdvisoriesCreatePrivateVulnerabilityReport => {
                self.execute_security_advisories_create_private_vulnerability_report(matches)
                    .await;
            }
            CliCommand::SecurityAdvisoriesGetRepositoryAdvisory => {
                self.execute_security_advisories_get_repository_advisory(matches)
                    .await;
            }
            CliCommand::SecurityAdvisoriesUpdateRepositoryAdvisory => {
                self.execute_security_advisories_update_repository_advisory(matches)
                    .await;
            }
            CliCommand::ActivityListStargazersForRepo => {
                self.execute_activity_list_stargazers_for_repo(matches)
                    .await;
            }
            CliCommand::ReposGetCodeFrequencyStats => {
                self.execute_repos_get_code_frequency_stats(matches).await;
            }
            CliCommand::ReposGetCommitActivityStats => {
                self.execute_repos_get_commit_activity_stats(matches).await;
            }
            CliCommand::ReposGetContributorsStats => {
                self.execute_repos_get_contributors_stats(matches).await;
            }
            CliCommand::ReposGetParticipationStats => {
                self.execute_repos_get_participation_stats(matches).await;
            }
            CliCommand::ReposGetPunchCardStats => {
                self.execute_repos_get_punch_card_stats(matches).await;
            }
            CliCommand::ReposCreateCommitStatus => {
                self.execute_repos_create_commit_status(matches).await;
            }
            CliCommand::ActivityListWatchersForRepo => {
                self.execute_activity_list_watchers_for_repo(matches).await;
            }
            CliCommand::ActivityGetRepoSubscription => {
                self.execute_activity_get_repo_subscription(matches).await;
            }
            CliCommand::ActivitySetRepoSubscription => {
                self.execute_activity_set_repo_subscription(matches).await;
            }
            CliCommand::ActivityDeleteRepoSubscription => {
                self.execute_activity_delete_repo_subscription(matches)
                    .await;
            }
            CliCommand::ReposListTags => {
                self.execute_repos_list_tags(matches).await;
            }
            CliCommand::ReposListTagProtection => {
                self.execute_repos_list_tag_protection(matches).await;
            }
            CliCommand::ReposCreateTagProtection => {
                self.execute_repos_create_tag_protection(matches).await;
            }
            CliCommand::ReposDeleteTagProtection => {
                self.execute_repos_delete_tag_protection(matches).await;
            }
            CliCommand::ReposDownloadTarballArchive => {
                self.execute_repos_download_tarball_archive(matches).await;
            }
            CliCommand::ReposListTeams => {
                self.execute_repos_list_teams(matches).await;
            }
            CliCommand::ReposGetAllTopics => {
                self.execute_repos_get_all_topics(matches).await;
            }
            CliCommand::ReposReplaceAllTopics => {
                self.execute_repos_replace_all_topics(matches).await;
            }
            CliCommand::ReposGetClones => {
                self.execute_repos_get_clones(matches).await;
            }
            CliCommand::ReposGetTopPaths => {
                self.execute_repos_get_top_paths(matches).await;
            }
            CliCommand::ReposGetTopReferrers => {
                self.execute_repos_get_top_referrers(matches).await;
            }
            CliCommand::ReposGetViews => {
                self.execute_repos_get_views(matches).await;
            }
            CliCommand::ReposTransfer => {
                self.execute_repos_transfer(matches).await;
            }
            CliCommand::ReposCheckVulnerabilityAlerts => {
                self.execute_repos_check_vulnerability_alerts(matches).await;
            }
            CliCommand::ReposEnableVulnerabilityAlerts => {
                self.execute_repos_enable_vulnerability_alerts(matches)
                    .await;
            }
            CliCommand::ReposDisableVulnerabilityAlerts => {
                self.execute_repos_disable_vulnerability_alerts(matches)
                    .await;
            }
            CliCommand::ReposDownloadZipballArchive => {
                self.execute_repos_download_zipball_archive(matches).await;
            }
            CliCommand::ReposCreateUsingTemplate => {
                self.execute_repos_create_using_template(matches).await;
            }
            CliCommand::ReposListPublic => {
                self.execute_repos_list_public(matches).await;
            }
            CliCommand::ActionsListEnvironmentSecrets => {
                self.execute_actions_list_environment_secrets(matches).await;
            }
            CliCommand::ActionsGetEnvironmentPublicKey => {
                self.execute_actions_get_environment_public_key(matches)
                    .await;
            }
            CliCommand::ActionsGetEnvironmentSecret => {
                self.execute_actions_get_environment_secret(matches).await;
            }
            CliCommand::ActionsCreateOrUpdateEnvironmentSecret => {
                self.execute_actions_create_or_update_environment_secret(matches)
                    .await;
            }
            CliCommand::ActionsDeleteEnvironmentSecret => {
                self.execute_actions_delete_environment_secret(matches)
                    .await;
            }
            CliCommand::ActionsListEnvironmentVariables => {
                self.execute_actions_list_environment_variables(matches)
                    .await;
            }
            CliCommand::ActionsCreateEnvironmentVariable => {
                self.execute_actions_create_environment_variable(matches)
                    .await;
            }
            CliCommand::ActionsGetEnvironmentVariable => {
                self.execute_actions_get_environment_variable(matches).await;
            }
            CliCommand::ActionsDeleteEnvironmentVariable => {
                self.execute_actions_delete_environment_variable(matches)
                    .await;
            }
            CliCommand::ActionsUpdateEnvironmentVariable => {
                self.execute_actions_update_environment_variable(matches)
                    .await;
            }
            CliCommand::SearchCode => {
                self.execute_search_code(matches).await;
            }
            CliCommand::SearchCommits => {
                self.execute_search_commits(matches).await;
            }
            CliCommand::SearchIssuesAndPullRequests => {
                self.execute_search_issues_and_pull_requests(matches).await;
            }
            CliCommand::SearchLabels => {
                self.execute_search_labels(matches).await;
            }
            CliCommand::SearchRepos => {
                self.execute_search_repos(matches).await;
            }
            CliCommand::SearchTopics => {
                self.execute_search_topics(matches).await;
            }
            CliCommand::SearchUsers => {
                self.execute_search_users(matches).await;
            }
            CliCommand::TeamsGetLegacy => {
                self.execute_teams_get_legacy(matches).await;
            }
            CliCommand::TeamsDeleteLegacy => {
                self.execute_teams_delete_legacy(matches).await;
            }
            CliCommand::TeamsUpdateLegacy => {
                self.execute_teams_update_legacy(matches).await;
            }
            CliCommand::TeamsListDiscussionsLegacy => {
                self.execute_teams_list_discussions_legacy(matches).await;
            }
            CliCommand::TeamsCreateDiscussionLegacy => {
                self.execute_teams_create_discussion_legacy(matches).await;
            }
            CliCommand::TeamsGetDiscussionLegacy => {
                self.execute_teams_get_discussion_legacy(matches).await;
            }
            CliCommand::TeamsDeleteDiscussionLegacy => {
                self.execute_teams_delete_discussion_legacy(matches).await;
            }
            CliCommand::TeamsUpdateDiscussionLegacy => {
                self.execute_teams_update_discussion_legacy(matches).await;
            }
            CliCommand::TeamsListDiscussionCommentsLegacy => {
                self.execute_teams_list_discussion_comments_legacy(matches)
                    .await;
            }
            CliCommand::TeamsCreateDiscussionCommentLegacy => {
                self.execute_teams_create_discussion_comment_legacy(matches)
                    .await;
            }
            CliCommand::TeamsGetDiscussionCommentLegacy => {
                self.execute_teams_get_discussion_comment_legacy(matches)
                    .await;
            }
            CliCommand::TeamsDeleteDiscussionCommentLegacy => {
                self.execute_teams_delete_discussion_comment_legacy(matches)
                    .await;
            }
            CliCommand::TeamsUpdateDiscussionCommentLegacy => {
                self.execute_teams_update_discussion_comment_legacy(matches)
                    .await;
            }
            CliCommand::ReactionsListForTeamDiscussionCommentLegacy => {
                self.execute_reactions_list_for_team_discussion_comment_legacy(matches)
                    .await;
            }
            CliCommand::ReactionsCreateForTeamDiscussionCommentLegacy => {
                self.execute_reactions_create_for_team_discussion_comment_legacy(matches)
                    .await;
            }
            CliCommand::ReactionsListForTeamDiscussionLegacy => {
                self.execute_reactions_list_for_team_discussion_legacy(matches)
                    .await;
            }
            CliCommand::ReactionsCreateForTeamDiscussionLegacy => {
                self.execute_reactions_create_for_team_discussion_legacy(matches)
                    .await;
            }
            CliCommand::TeamsListPendingInvitationsLegacy => {
                self.execute_teams_list_pending_invitations_legacy(matches)
                    .await;
            }
            CliCommand::TeamsListMembersLegacy => {
                self.execute_teams_list_members_legacy(matches).await;
            }
            CliCommand::TeamsGetMemberLegacy => {
                self.execute_teams_get_member_legacy(matches).await;
            }
            CliCommand::TeamsAddMemberLegacy => {
                self.execute_teams_add_member_legacy(matches).await;
            }
            CliCommand::TeamsRemoveMemberLegacy => {
                self.execute_teams_remove_member_legacy(matches).await;
            }
            CliCommand::TeamsGetMembershipForUserLegacy => {
                self.execute_teams_get_membership_for_user_legacy(matches)
                    .await;
            }
            CliCommand::TeamsAddOrUpdateMembershipForUserLegacy => {
                self.execute_teams_add_or_update_membership_for_user_legacy(matches)
                    .await;
            }
            CliCommand::TeamsRemoveMembershipForUserLegacy => {
                self.execute_teams_remove_membership_for_user_legacy(matches)
                    .await;
            }
            CliCommand::TeamsListProjectsLegacy => {
                self.execute_teams_list_projects_legacy(matches).await;
            }
            CliCommand::TeamsCheckPermissionsForProjectLegacy => {
                self.execute_teams_check_permissions_for_project_legacy(matches)
                    .await;
            }
            CliCommand::TeamsAddOrUpdateProjectPermissionsLegacy => {
                self.execute_teams_add_or_update_project_permissions_legacy(matches)
                    .await;
            }
            CliCommand::TeamsRemoveProjectLegacy => {
                self.execute_teams_remove_project_legacy(matches).await;
            }
            CliCommand::TeamsListReposLegacy => {
                self.execute_teams_list_repos_legacy(matches).await;
            }
            CliCommand::TeamsCheckPermissionsForRepoLegacy => {
                self.execute_teams_check_permissions_for_repo_legacy(matches)
                    .await;
            }
            CliCommand::TeamsAddOrUpdateRepoPermissionsLegacy => {
                self.execute_teams_add_or_update_repo_permissions_legacy(matches)
                    .await;
            }
            CliCommand::TeamsRemoveRepoLegacy => {
                self.execute_teams_remove_repo_legacy(matches).await;
            }
            CliCommand::TeamsListChildLegacy => {
                self.execute_teams_list_child_legacy(matches).await;
            }
            CliCommand::UsersGetAuthenticated => {
                self.execute_users_get_authenticated(matches).await;
            }
            CliCommand::UsersUpdateAuthenticated => {
                self.execute_users_update_authenticated(matches).await;
            }
            CliCommand::UsersListBlockedByAuthenticatedUser => {
                self.execute_users_list_blocked_by_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersCheckBlocked => {
                self.execute_users_check_blocked(matches).await;
            }
            CliCommand::UsersBlock => {
                self.execute_users_block(matches).await;
            }
            CliCommand::UsersUnblock => {
                self.execute_users_unblock(matches).await;
            }
            CliCommand::CodespacesListForAuthenticatedUser => {
                self.execute_codespaces_list_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesCreateForAuthenticatedUser => {
                self.execute_codespaces_create_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesListSecretsForAuthenticatedUser => {
                self.execute_codespaces_list_secrets_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesGetPublicKeyForAuthenticatedUser => {
                self.execute_codespaces_get_public_key_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesGetSecretForAuthenticatedUser => {
                self.execute_codespaces_get_secret_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesCreateOrUpdateSecretForAuthenticatedUser => {
                self.execute_codespaces_create_or_update_secret_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesDeleteSecretForAuthenticatedUser => {
                self.execute_codespaces_delete_secret_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesListRepositoriesForSecretForAuthenticatedUser => {
                self.execute_codespaces_list_repositories_for_secret_for_authenticated_user(
                    matches,
                )
                .await;
            }
            CliCommand::CodespacesSetRepositoriesForSecretForAuthenticatedUser => {
                self.execute_codespaces_set_repositories_for_secret_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesAddRepositoryForSecretForAuthenticatedUser => {
                self.execute_codespaces_add_repository_for_secret_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesRemoveRepositoryForSecretForAuthenticatedUser => {
                self.execute_codespaces_remove_repository_for_secret_for_authenticated_user(
                    matches,
                )
                .await;
            }
            CliCommand::CodespacesGetForAuthenticatedUser => {
                self.execute_codespaces_get_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesDeleteForAuthenticatedUser => {
                self.execute_codespaces_delete_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesUpdateForAuthenticatedUser => {
                self.execute_codespaces_update_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesExportForAuthenticatedUser => {
                self.execute_codespaces_export_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesGetExportDetailsForAuthenticatedUser => {
                self.execute_codespaces_get_export_details_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesCodespaceMachinesForAuthenticatedUser => {
                self.execute_codespaces_codespace_machines_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesPublishForAuthenticatedUser => {
                self.execute_codespaces_publish_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesStartForAuthenticatedUser => {
                self.execute_codespaces_start_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::CodespacesStopForAuthenticatedUser => {
                self.execute_codespaces_stop_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::PackagesListDockerMigrationConflictingPackagesForAuthenticatedUser => {
                self . execute_packages_list_docker_migration_conflicting_packages_for_authenticated_user (matches) . await ;
            }
            CliCommand::UsersSetPrimaryEmailVisibilityForAuthenticatedUser => {
                self.execute_users_set_primary_email_visibility_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersListEmailsForAuthenticatedUser => {
                self.execute_users_list_emails_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersAddEmailForAuthenticatedUser => {
                self.execute_users_add_email_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersDeleteEmailForAuthenticatedUser => {
                self.execute_users_delete_email_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersListFollowersForAuthenticatedUser => {
                self.execute_users_list_followers_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersListFollowedByAuthenticatedUser => {
                self.execute_users_list_followed_by_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersCheckPersonIsFollowedByAuthenticated => {
                self.execute_users_check_person_is_followed_by_authenticated(matches)
                    .await;
            }
            CliCommand::UsersFollow => {
                self.execute_users_follow(matches).await;
            }
            CliCommand::UsersUnfollow => {
                self.execute_users_unfollow(matches).await;
            }
            CliCommand::UsersListGpgKeysForAuthenticatedUser => {
                self.execute_users_list_gpg_keys_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersCreateGpgKeyForAuthenticatedUser => {
                self.execute_users_create_gpg_key_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersGetGpgKeyForAuthenticatedUser => {
                self.execute_users_get_gpg_key_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersDeleteGpgKeyForAuthenticatedUser => {
                self.execute_users_delete_gpg_key_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::AppsListInstallationsForAuthenticatedUser => {
                self.execute_apps_list_installations_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::AppsListInstallationReposForAuthenticatedUser => {
                self.execute_apps_list_installation_repos_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::AppsAddRepoToInstallationForAuthenticatedUser => {
                self.execute_apps_add_repo_to_installation_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::AppsRemoveRepoFromInstallationForAuthenticatedUser => {
                self.execute_apps_remove_repo_from_installation_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::InteractionsGetRestrictionsForAuthenticatedUser => {
                self.execute_interactions_get_restrictions_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::InteractionsSetRestrictionsForAuthenticatedUser => {
                self.execute_interactions_set_restrictions_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::InteractionsRemoveRestrictionsForAuthenticatedUser => {
                self.execute_interactions_remove_restrictions_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::IssuesListForAuthenticatedUser => {
                self.execute_issues_list_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersListPublicSshKeysForAuthenticatedUser => {
                self.execute_users_list_public_ssh_keys_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersCreatePublicSshKeyForAuthenticatedUser => {
                self.execute_users_create_public_ssh_key_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersGetPublicSshKeyForAuthenticatedUser => {
                self.execute_users_get_public_ssh_key_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersDeletePublicSshKeyForAuthenticatedUser => {
                self.execute_users_delete_public_ssh_key_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::AppsListSubscriptionsForAuthenticatedUser => {
                self.execute_apps_list_subscriptions_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::AppsListSubscriptionsForAuthenticatedUserStubbed => {
                self.execute_apps_list_subscriptions_for_authenticated_user_stubbed(matches)
                    .await;
            }
            CliCommand::OrgsListMembershipsForAuthenticatedUser => {
                self.execute_orgs_list_memberships_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::OrgsGetMembershipForAuthenticatedUser => {
                self.execute_orgs_get_membership_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::OrgsUpdateMembershipForAuthenticatedUser => {
                self.execute_orgs_update_membership_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::MigrationsListForAuthenticatedUser => {
                self.execute_migrations_list_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::MigrationsStartForAuthenticatedUser => {
                self.execute_migrations_start_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::MigrationsGetStatusForAuthenticatedUser => {
                self.execute_migrations_get_status_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::MigrationsGetArchiveForAuthenticatedUser => {
                self.execute_migrations_get_archive_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::MigrationsDeleteArchiveForAuthenticatedUser => {
                self.execute_migrations_delete_archive_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::MigrationsUnlockRepoForAuthenticatedUser => {
                self.execute_migrations_unlock_repo_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::MigrationsListReposForAuthenticatedUser => {
                self.execute_migrations_list_repos_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::OrgsListForAuthenticatedUser => {
                self.execute_orgs_list_for_authenticated_user(matches).await;
            }
            CliCommand::PackagesListPackagesForAuthenticatedUser => {
                self.execute_packages_list_packages_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::PackagesGetPackageForAuthenticatedUser => {
                self.execute_packages_get_package_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::PackagesDeletePackageForAuthenticatedUser => {
                self.execute_packages_delete_package_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::PackagesRestorePackageForAuthenticatedUser => {
                self.execute_packages_restore_package_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser => {
                self . execute_packages_get_all_package_versions_for_package_owned_by_authenticated_user (matches) . await ;
            }
            CliCommand::PackagesGetPackageVersionForAuthenticatedUser => {
                self.execute_packages_get_package_version_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::PackagesDeletePackageVersionForAuthenticatedUser => {
                self.execute_packages_delete_package_version_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::PackagesRestorePackageVersionForAuthenticatedUser => {
                self.execute_packages_restore_package_version_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ProjectsCreateForAuthenticatedUser => {
                self.execute_projects_create_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersListPublicEmailsForAuthenticatedUser => {
                self.execute_users_list_public_emails_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ReposListForAuthenticatedUser => {
                self.execute_repos_list_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ReposCreateForAuthenticatedUser => {
                self.execute_repos_create_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ReposListInvitationsForAuthenticatedUser => {
                self.execute_repos_list_invitations_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ReposDeclineInvitationForAuthenticatedUser => {
                self.execute_repos_decline_invitation_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ReposAcceptInvitationForAuthenticatedUser => {
                self.execute_repos_accept_invitation_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersListSocialAccountsForAuthenticatedUser => {
                self.execute_users_list_social_accounts_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersAddSocialAccountForAuthenticatedUser => {
                self.execute_users_add_social_account_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersDeleteSocialAccountForAuthenticatedUser => {
                self.execute_users_delete_social_account_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersListSshSigningKeysForAuthenticatedUser => {
                self.execute_users_list_ssh_signing_keys_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersCreateSshSigningKeyForAuthenticatedUser => {
                self.execute_users_create_ssh_signing_key_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersGetSshSigningKeyForAuthenticatedUser => {
                self.execute_users_get_ssh_signing_key_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersDeleteSshSigningKeyForAuthenticatedUser => {
                self.execute_users_delete_ssh_signing_key_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ActivityListReposStarredByAuthenticatedUser => {
                self.execute_activity_list_repos_starred_by_authenticated_user(matches)
                    .await;
            }
            CliCommand::ActivityCheckRepoIsStarredByAuthenticatedUser => {
                self.execute_activity_check_repo_is_starred_by_authenticated_user(matches)
                    .await;
            }
            CliCommand::ActivityStarRepoForAuthenticatedUser => {
                self.execute_activity_star_repo_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ActivityUnstarRepoForAuthenticatedUser => {
                self.execute_activity_unstar_repo_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ActivityListWatchedReposForAuthenticatedUser => {
                self.execute_activity_list_watched_repos_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::TeamsListForAuthenticatedUser => {
                self.execute_teams_list_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::UsersList => {
                self.execute_users_list(matches).await;
            }
            CliCommand::UsersGetByUsername => {
                self.execute_users_get_by_username(matches).await;
            }
            CliCommand::PackagesListDockerMigrationConflictingPackagesForUser => {
                self.execute_packages_list_docker_migration_conflicting_packages_for_user(matches)
                    .await;
            }
            CliCommand::ActivityListEventsForAuthenticatedUser => {
                self.execute_activity_list_events_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ActivityListOrgEventsForAuthenticatedUser => {
                self.execute_activity_list_org_events_for_authenticated_user(matches)
                    .await;
            }
            CliCommand::ActivityListPublicEventsForUser => {
                self.execute_activity_list_public_events_for_user(matches)
                    .await;
            }
            CliCommand::UsersListFollowersForUser => {
                self.execute_users_list_followers_for_user(matches).await;
            }
            CliCommand::UsersListFollowingForUser => {
                self.execute_users_list_following_for_user(matches).await;
            }
            CliCommand::UsersCheckFollowingForUser => {
                self.execute_users_check_following_for_user(matches).await;
            }
            CliCommand::GistsListForUser => {
                self.execute_gists_list_for_user(matches).await;
            }
            CliCommand::UsersListGpgKeysForUser => {
                self.execute_users_list_gpg_keys_for_user(matches).await;
            }
            CliCommand::UsersGetContextForUser => {
                self.execute_users_get_context_for_user(matches).await;
            }
            CliCommand::AppsGetUserInstallation => {
                self.execute_apps_get_user_installation(matches).await;
            }
            CliCommand::UsersListPublicKeysForUser => {
                self.execute_users_list_public_keys_for_user(matches).await;
            }
            CliCommand::OrgsListForUser => {
                self.execute_orgs_list_for_user(matches).await;
            }
            CliCommand::PackagesListPackagesForUser => {
                self.execute_packages_list_packages_for_user(matches).await;
            }
            CliCommand::PackagesGetPackageForUser => {
                self.execute_packages_get_package_for_user(matches).await;
            }
            CliCommand::PackagesDeletePackageForUser => {
                self.execute_packages_delete_package_for_user(matches).await;
            }
            CliCommand::PackagesRestorePackageForUser => {
                self.execute_packages_restore_package_for_user(matches)
                    .await;
            }
            CliCommand::PackagesGetAllPackageVersionsForPackageOwnedByUser => {
                self.execute_packages_get_all_package_versions_for_package_owned_by_user(matches)
                    .await;
            }
            CliCommand::PackagesGetPackageVersionForUser => {
                self.execute_packages_get_package_version_for_user(matches)
                    .await;
            }
            CliCommand::PackagesDeletePackageVersionForUser => {
                self.execute_packages_delete_package_version_for_user(matches)
                    .await;
            }
            CliCommand::PackagesRestorePackageVersionForUser => {
                self.execute_packages_restore_package_version_for_user(matches)
                    .await;
            }
            CliCommand::ProjectsListForUser => {
                self.execute_projects_list_for_user(matches).await;
            }
            CliCommand::ActivityListReceivedEventsForUser => {
                self.execute_activity_list_received_events_for_user(matches)
                    .await;
            }
            CliCommand::ActivityListReceivedPublicEventsForUser => {
                self.execute_activity_list_received_public_events_for_user(matches)
                    .await;
            }
            CliCommand::ReposListForUser => {
                self.execute_repos_list_for_user(matches).await;
            }
            CliCommand::BillingGetGithubActionsBillingUser => {
                self.execute_billing_get_github_actions_billing_user(matches)
                    .await;
            }
            CliCommand::BillingGetGithubPackagesBillingUser => {
                self.execute_billing_get_github_packages_billing_user(matches)
                    .await;
            }
            CliCommand::BillingGetSharedStorageBillingUser => {
                self.execute_billing_get_shared_storage_billing_user(matches)
                    .await;
            }
            CliCommand::UsersListSocialAccountsForUser => {
                self.execute_users_list_social_accounts_for_user(matches)
                    .await;
            }
        }
    }

    pub async fn execute_meta_root(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.meta_root();
        self.over.execute_meta_root(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_get_authenticated(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_get_authenticated();
        self.over
            .execute_apps_get_authenticated(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_create_from_manifest(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_create_from_manifest();
        if let Some(value) = matches.get_one::<String>("code") {
            request = request.code(value.clone());
        }

        self.over
            .execute_apps_create_from_manifest(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_get_webhook_config_for_app(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_get_webhook_config_for_app();
        self.over
            .execute_apps_get_webhook_config_for_app(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_update_webhook_config_for_app(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_update_webhook_config_for_app();
        if let Some(value) = matches.get_one::<types::WebhookConfigContentType>("content-type") {
            request = request.body_map(|body| body.content_type(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::WebhookConfigInsecureSsl>("insecure-ssl") {
            request = request.body_map(|body| body.insecure_ssl(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::WebhookConfigSecret>("secret") {
            request = request.body_map(|body| body.secret(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::WebhookConfigUrl>("url") {
            request = request.body_map(|body| body.url(value.clone()))
        }

        self.over
            .execute_apps_update_webhook_config_for_app(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_webhook_deliveries(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_list_webhook_deliveries();
        if let Some(value) = matches.get_one::<String>("cursor") {
            request = request.cursor(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("redelivery") {
            request = request.redelivery(value.clone());
        }

        self.over
            .execute_apps_list_webhook_deliveries(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_get_webhook_delivery(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_get_webhook_delivery();
        if let Some(value) = matches.get_one::<i64>("delivery-id") {
            request = request.delivery_id(value.clone());
        }

        self.over
            .execute_apps_get_webhook_delivery(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_redeliver_webhook_delivery(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_redeliver_webhook_delivery();
        if let Some(value) = matches.get_one::<i64>("delivery-id") {
            request = request.delivery_id(value.clone());
        }

        self.over
            .execute_apps_redeliver_webhook_delivery(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_installation_requests_for_authenticated_app(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .apps_list_installation_requests_for_authenticated_app();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_apps_list_installation_requests_for_authenticated_app(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_installations(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_list_installations();
        if let Some(value) = matches.get_one::<String>("outdated") {
            request = request.outdated(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        self.over
            .execute_apps_list_installations(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_get_installation(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_get_installation();
        if let Some(value) = matches.get_one::<i64>("installation-id") {
            request = request.installation_id(value.clone());
        }

        self.over
            .execute_apps_get_installation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_delete_installation(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_delete_installation();
        if let Some(value) = matches.get_one::<i64>("installation-id") {
            request = request.installation_id(value.clone());
        }

        self.over
            .execute_apps_delete_installation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_create_installation_access_token(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_create_installation_access_token();
        if let Some(value) = matches.get_one::<i64>("installation-id") {
            request = request.installation_id(value.clone());
        }

        self.over
            .execute_apps_create_installation_access_token(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_suspend_installation(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_suspend_installation();
        if let Some(value) = matches.get_one::<i64>("installation-id") {
            request = request.installation_id(value.clone());
        }

        self.over
            .execute_apps_suspend_installation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_unsuspend_installation(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_unsuspend_installation();
        if let Some(value) = matches.get_one::<i64>("installation-id") {
            request = request.installation_id(value.clone());
        }

        self.over
            .execute_apps_unsuspend_installation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_delete_authorization(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_delete_authorization();
        if let Some(value) = matches.get_one::<String>("client-id") {
            request = request.client_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("access-token") {
            request = request.body_map(|body| body.access_token(value.clone()))
        }

        self.over
            .execute_apps_delete_authorization(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_check_token(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_check_token();
        if let Some(value) = matches.get_one::<String>("client-id") {
            request = request.client_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("access-token") {
            request = request.body_map(|body| body.access_token(value.clone()))
        }

        self.over
            .execute_apps_check_token(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_delete_token(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_delete_token();
        if let Some(value) = matches.get_one::<String>("client-id") {
            request = request.client_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("access-token") {
            request = request.body_map(|body| body.access_token(value.clone()))
        }

        self.over
            .execute_apps_delete_token(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_reset_token(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_reset_token();
        if let Some(value) = matches.get_one::<String>("client-id") {
            request = request.client_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("access-token") {
            request = request.body_map(|body| body.access_token(value.clone()))
        }

        self.over
            .execute_apps_reset_token(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_scope_token(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_scope_token();
        if let Some(value) = matches.get_one::<String>("client-id") {
            request = request.client_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("access-token") {
            request = request.body_map(|body| body.access_token(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("target") {
            request = request.body_map(|body| body.target(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("target-id") {
            request = request.body_map(|body| body.target_id(value.clone()))
        }

        self.over
            .execute_apps_scope_token(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_get_by_slug(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_get_by_slug();
        if let Some(value) = matches.get_one::<String>("app-slug") {
            request = request.app_slug(value.clone());
        }

        self.over
            .execute_apps_get_by_slug(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codes_of_conduct_get_all_codes_of_conduct(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codes_of_conduct_get_all_codes_of_conduct();
        self.over
            .execute_codes_of_conduct_get_all_codes_of_conduct(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codes_of_conduct_get_conduct_code(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codes_of_conduct_get_conduct_code();
        if let Some(value) = matches.get_one::<String>("key") {
            request = request.key(value.clone());
        }

        self.over
            .execute_codes_of_conduct_get_conduct_code(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_emojis_get(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.emojis_get();
        self.over.execute_emojis_get(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_list_alerts_for_enterprise(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_list_alerts_for_enterprise();
        if let Some(value) = matches.get_one::<String>("enterprise") {
            request = request.enterprise(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("after") {
            request = request.after(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("before") {
            request = request.before(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::DependabotListAlertsForEnterpriseDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ecosystem") {
            request = request.ecosystem(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("first") {
            request = request.first(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("last") {
            request = request.last(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package") {
            request = request.package(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::DependabotListAlertsForEnterpriseScope>("scope")
        {
            request = request.scope(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("severity") {
            request = request.severity(value.clone());
        }

        if let Some(value) = matches.get_one::<types::DependabotListAlertsForEnterpriseSort>("sort")
        {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("state") {
            request = request.state(value.clone());
        }

        self.over
            .execute_dependabot_list_alerts_for_enterprise(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_secret_scanning_list_alerts_for_enterprise(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.secret_scanning_list_alerts_for_enterprise();
        if let Some(value) = matches.get_one::<String>("enterprise") {
            request = request.enterprise(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("after") {
            request = request.after(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("before") {
            request = request.before(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::SecretScanningListAlertsForEnterpriseDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("resolution") {
            request = request.resolution(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-type") {
            request = request.secret_type(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::SecretScanningListAlertsForEnterpriseSort>("sort")
        {
            request = request.sort(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::SecretScanningListAlertsForEnterpriseState>("state")
        {
            request = request.state(value.clone());
        }

        self.over
            .execute_secret_scanning_list_alerts_for_enterprise(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_public_events(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_list_public_events();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_public_events(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_get_feeds(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_get_feeds();
        self.over
            .execute_activity_get_feeds(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_list(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_list();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        self.over.execute_gists_list(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_create(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_create();
        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::GistsCreateBodyPublic>("public") {
            request = request.body_map(|body| body.public(value.clone()))
        }

        self.over
            .execute_gists_create(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_list_public(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_list_public();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        self.over
            .execute_gists_list_public(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_list_starred(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_list_starred();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        self.over
            .execute_gists_list_starred(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_get(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_get();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        self.over.execute_gists_get(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_delete(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_delete();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        self.over
            .execute_gists_delete(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_update(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_update();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        self.over
            .execute_gists_update(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_list_comments(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_list_comments();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_gists_list_comments(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_create_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_create_comment();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::GistsCreateCommentBodyBody>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_gists_create_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_get_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_get_comment();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        self.over
            .execute_gists_get_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_delete_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_delete_comment();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        self.over
            .execute_gists_delete_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_update_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_update_comment();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::GistsUpdateCommentBodyBody>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_gists_update_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_list_commits(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_list_commits();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_gists_list_commits(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_list_forks(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_list_forks();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_gists_list_forks(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_fork(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_fork();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        self.over.execute_gists_fork(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_check_is_starred(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_check_is_starred();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        self.over
            .execute_gists_check_is_starred(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_star(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_star();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        self.over.execute_gists_star(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_unstar(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_unstar();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        self.over
            .execute_gists_unstar(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_get_revision(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_get_revision();
        if let Some(value) = matches.get_one::<String>("gist-id") {
            request = request.gist_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("sha") {
            request = request.sha(value.clone());
        }

        self.over
            .execute_gists_get_revision(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gitignore_get_all_templates(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gitignore_get_all_templates();
        self.over
            .execute_gitignore_get_all_templates(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gitignore_get_template(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gitignore_get_template();
        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_gitignore_get_template(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_repos_accessible_to_installation(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.apps_list_repos_accessible_to_installation();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_apps_list_repos_accessible_to_installation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_revoke_installation_access_token(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_revoke_installation_access_token();
        self.over
            .execute_apps_revoke_installation_access_token(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list();
        if let Some(value) = matches.get_one::<bool>("collab") {
            request = request.collab(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListDirection>("direction") {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListFilter>("filter") {
            request = request.filter(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("labels") {
            request = request.labels(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("orgs") {
            request = request.orgs(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("owned") {
            request = request.owned(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("pulls") {
            request = request.pulls(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListState>("state") {
            request = request.state(value.clone());
        }

        self.over
            .execute_issues_list(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_licenses_get_all_commonly_used(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.licenses_get_all_commonly_used();
        if let Some(value) = matches.get_one::<bool>("featured") {
            request = request.featured(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_licenses_get_all_commonly_used(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_licenses_get(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.licenses_get();
        if let Some(value) = matches.get_one::<String>("license") {
            request = request.license(value.clone());
        }

        self.over
            .execute_licenses_get(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_markdown_render(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.markdown_render();
        if let Some(value) = matches.get_one::<String>("context") {
            request = request.body_map(|body| body.context(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::MarkdownRenderBodyMode>("mode") {
            request = request.body_map(|body| body.mode(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("text") {
            request = request.body_map(|body| body.text(value.clone()))
        }

        self.over
            .execute_markdown_render(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                todo!()
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_meta_get_all_versions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.meta_get_all_versions();
        self.over
            .execute_meta_get_all_versions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_get_subscription_plan_for_account(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_get_subscription_plan_for_account();
        if let Some(value) = matches.get_one::<i64>("account-id") {
            request = request.account_id(value.clone());
        }

        self.over
            .execute_apps_get_subscription_plan_for_account(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_plans(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_list_plans();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_apps_list_plans(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_accounts_for_plan(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_list_accounts_for_plan();
        if let Some(value) = matches.get_one::<i64>("plan-id") {
            request = request.plan_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AppsListAccountsForPlanDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AppsListAccountsForPlanSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_apps_list_accounts_for_plan(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_get_subscription_plan_for_account_stubbed(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.apps_get_subscription_plan_for_account_stubbed();
        if let Some(value) = matches.get_one::<i64>("account-id") {
            request = request.account_id(value.clone());
        }

        self.over
            .execute_apps_get_subscription_plan_for_account_stubbed(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_plans_stubbed(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_list_plans_stubbed();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_apps_list_plans_stubbed(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_accounts_for_plan_stubbed(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_list_accounts_for_plan_stubbed();
        if let Some(value) = matches.get_one::<i64>("plan-id") {
            request = request.plan_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::AppsListAccountsForPlanStubbedDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AppsListAccountsForPlanStubbedSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_apps_list_accounts_for_plan_stubbed(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_meta_get(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.meta_get();
        self.over.execute_meta_get(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_public_events_for_repo_network(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.activity_list_public_events_for_repo_network();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_public_events_for_repo_network(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_notifications_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .activity_list_notifications_for_authenticated_user();
        if let Some(value) = matches.get_one::<bool>("all") {
            request = request.all(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("before") {
            request = request.before(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("participating") {
            request = request.participating(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        self.over
            .execute_activity_list_notifications_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_mark_notifications_as_read(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_mark_notifications_as_read();
        if let Some(value) =
            matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("last-read-at")
        {
            request = request.body_map(|body| body.last_read_at(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("read") {
            request = request.body_map(|body| body.read(value.clone()))
        }

        self.over
            .execute_activity_mark_notifications_as_read(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_get_thread(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_get_thread();
        if let Some(value) = matches.get_one::<i64>("thread-id") {
            request = request.thread_id(value.clone());
        }

        self.over
            .execute_activity_get_thread(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_mark_thread_as_read(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_mark_thread_as_read();
        if let Some(value) = matches.get_one::<i64>("thread-id") {
            request = request.thread_id(value.clone());
        }

        self.over
            .execute_activity_mark_thread_as_read(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_get_thread_subscription_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .activity_get_thread_subscription_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("thread-id") {
            request = request.thread_id(value.clone());
        }

        self.over
            .execute_activity_get_thread_subscription_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_set_thread_subscription(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_set_thread_subscription();
        if let Some(value) = matches.get_one::<i64>("thread-id") {
            request = request.thread_id(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("ignored") {
            request = request.body_map(|body| body.ignored(value.clone()))
        }

        self.over
            .execute_activity_set_thread_subscription(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_delete_thread_subscription(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_delete_thread_subscription();
        if let Some(value) = matches.get_one::<i64>("thread-id") {
            request = request.thread_id(value.clone());
        }

        self.over
            .execute_activity_delete_thread_subscription(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_meta_get_octocat(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.meta_get_octocat();
        if let Some(value) = matches.get_one::<String>("s") {
            request = request.s(value.clone());
        }

        self.over
            .execute_meta_get_octocat(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                todo!()
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list();
        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("since") {
            request = request.since(value.clone());
        }

        self.over.execute_orgs_list(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_pat_grant_requests(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_pat_grant_requests();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::OrgsListPatGrantRequestsDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) =
            matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("last-used-after")
        {
            request = request.last_used_after(value.clone());
        }

        if let Some(value) =
            matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("last-used-before")
        {
            request = request.last_used_before(value.clone());
        }

        if let Some(value) = matches.get_one::<Vec<String>>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("permission") {
            request = request.permission(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repository") {
            request = request.repository(value.clone());
        }

        if let Some(value) = matches.get_one::<types::OrgsListPatGrantRequestsSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_orgs_list_pat_grant_requests(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_review_pat_grant_requests_in_bulk(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_review_pat_grant_requests_in_bulk();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::OrgsReviewPatGrantRequestsInBulkBodyAction>("action")
        {
            request = request.body_map(|body| body.action(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::OrgsReviewPatGrantRequestsInBulkBodyReason>("reason")
        {
            request = request.body_map(|body| body.reason(value.clone()))
        }

        self.over
            .execute_orgs_review_pat_grant_requests_in_bulk(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_review_pat_grant_request(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_review_pat_grant_request();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pat-request-id") {
            request = request.pat_request_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::OrgsReviewPatGrantRequestBodyAction>("action")
        {
            request = request.body_map(|body| body.action(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::OrgsReviewPatGrantRequestBodyReason>("reason")
        {
            request = request.body_map(|body| body.reason(value.clone()))
        }

        self.over
            .execute_orgs_review_pat_grant_request(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_pat_grant_request_repositories(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.orgs_list_pat_grant_request_repositories();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pat-request-id") {
            request = request.pat_request_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_orgs_list_pat_grant_request_repositories(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_pat_grants(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_pat_grants();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<types::OrgsListPatGrantsDirection>("direction") {
            request = request.direction(value.clone());
        }

        if let Some(value) =
            matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("last-used-after")
        {
            request = request.last_used_after(value.clone());
        }

        if let Some(value) =
            matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("last-used-before")
        {
            request = request.last_used_before(value.clone());
        }

        if let Some(value) = matches.get_one::<Vec<String>>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("permission") {
            request = request.permission(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repository") {
            request = request.repository(value.clone());
        }

        if let Some(value) = matches.get_one::<types::OrgsListPatGrantsSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_orgs_list_pat_grants(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_update_pat_accesses(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_update_pat_accesses();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<types::OrgsUpdatePatAccessesBodyAction>("action") {
            request = request.body_map(|body| body.action(value.clone()))
        }

        self.over
            .execute_orgs_update_pat_accesses(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_update_pat_access(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_update_pat_access();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pat-id") {
            request = request.pat_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::OrgsUpdatePatAccessBodyAction>("action") {
            request = request.body_map(|body| body.action(value.clone()))
        }

        self.over
            .execute_orgs_update_pat_access(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_pat_grant_repositories(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_pat_grant_repositories();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pat-id") {
            request = request.pat_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_orgs_list_pat_grant_repositories(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_meta_get_zen(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.meta_get_zen();
        self.over
            .execute_meta_get_zen(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                todo!()
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_actions_cache_usage_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_get_actions_cache_usage_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_actions_get_actions_cache_usage_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_actions_cache_usage_by_repo_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_get_actions_cache_usage_by_repo_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_get_actions_cache_usage_by_repo_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_oidc_get_oidc_custom_sub_template_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.oidc_get_oidc_custom_sub_template_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_oidc_get_oidc_custom_sub_template_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_oidc_update_oidc_custom_sub_template_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.oidc_update_oidc_custom_sub_template_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_oidc_update_oidc_custom_sub_template_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_github_actions_permissions_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_get_github_actions_permissions_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_actions_get_github_actions_permissions_organization(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_github_actions_permissions_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_set_github_actions_permissions_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AllowedActions>("allowed-actions") {
            request = request.body_map(|body| body.allowed_actions(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::EnabledRepositories>("enabled-repositories") {
            request = request.body_map(|body| body.enabled_repositories(value.clone()))
        }

        self.over
            .execute_actions_set_github_actions_permissions_organization(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_selected_repositories_enabled_github_actions_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_list_selected_repositories_enabled_github_actions_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_selected_repositories_enabled_github_actions_organization(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_selected_repositories_enabled_github_actions_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_set_selected_repositories_enabled_github_actions_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_actions_set_selected_repositories_enabled_github_actions_organization(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_enable_selected_repository_github_actions_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_enable_selected_repository_github_actions_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_actions_enable_selected_repository_github_actions_organization(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_disable_selected_repository_github_actions_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_disable_selected_repository_github_actions_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_actions_disable_selected_repository_github_actions_organization(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_allowed_actions_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_get_allowed_actions_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_actions_get_allowed_actions_organization(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_allowed_actions_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_set_allowed_actions_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("github-owned-allowed") {
            request = request.body_map(|body| body.github_owned_allowed(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("verified-allowed") {
            request = request.body_map(|body| body.verified_allowed(value.clone()))
        }

        self.over
            .execute_actions_set_allowed_actions_organization(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_github_actions_default_workflow_permissions_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_get_github_actions_default_workflow_permissions_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_actions_get_github_actions_default_workflow_permissions_organization(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_github_actions_default_workflow_permissions_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_set_github_actions_default_workflow_permissions_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ActionsCanApprovePullRequestReviews>(
            "can-approve-pull-request-reviews",
        ) {
            request = request.body_map(|body| body.can_approve_pull_request_reviews(value.clone()))
        }

        if let Some(value) = matches
            .get_one::<types::ActionsDefaultWorkflowPermissions>("default-workflow-permissions")
        {
            request = request.body_map(|body| body.default_workflow_permissions(value.clone()))
        }

        self.over
            .execute_actions_set_github_actions_default_workflow_permissions_organization(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_required_workflows(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_required_workflows();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_required_workflows(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_required_workflow(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_create_required_workflow();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repository-id") {
            request = request.body_map(|body| body.repository_id(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::ActionsCreateRequiredWorkflowBodyScope>("scope")
        {
            request = request.body_map(|body| body.scope(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("workflow-file-path") {
            request = request.body_map(|body| body.workflow_file_path(value.clone()))
        }

        self.over
            .execute_actions_create_required_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_required_workflow(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_required_workflow();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("required-workflow-id") {
            request = request.required_workflow_id(value.clone());
        }

        self.over
            .execute_actions_get_required_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_required_workflow(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_required_workflow();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("required-workflow-id") {
            request = request.required_workflow_id(value.clone());
        }

        self.over
            .execute_actions_delete_required_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_update_required_workflow(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_update_required_workflow();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("required-workflow-id") {
            request = request.required_workflow_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repository-id") {
            request = request.body_map(|body| body.repository_id(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::ActionsUpdateRequiredWorkflowBodyScope>("scope")
        {
            request = request.body_map(|body| body.scope(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("workflow-file-path") {
            request = request.body_map(|body| body.workflow_file_path(value.clone()))
        }

        self.over
            .execute_actions_update_required_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_selected_repositories_required_workflow(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_list_selected_repositories_required_workflow();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("required-workflow-id") {
            request = request.required_workflow_id(value.clone());
        }

        self.over
            .execute_actions_list_selected_repositories_required_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_selected_repos_to_required_workflow(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_set_selected_repos_to_required_workflow();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("required-workflow-id") {
            request = request.required_workflow_id(value.clone());
        }

        self.over
            .execute_actions_set_selected_repos_to_required_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_add_selected_repo_to_required_workflow(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_add_selected_repo_to_required_workflow();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("required-workflow-id") {
            request = request.required_workflow_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_actions_add_selected_repo_to_required_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_remove_selected_repo_from_required_workflow(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_remove_selected_repo_from_required_workflow();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("required-workflow-id") {
            request = request.required_workflow_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_actions_remove_selected_repo_from_required_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_self_hosted_runners_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_list_self_hosted_runners_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_self_hosted_runners_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_runner_applications_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_list_runner_applications_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_actions_list_runner_applications_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_registration_token_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_create_registration_token_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_actions_create_registration_token_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_remove_token_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_create_remove_token_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_actions_create_remove_token_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_self_hosted_runner_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_self_hosted_runner_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_get_self_hosted_runner_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_self_hosted_runner_from_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_delete_self_hosted_runner_from_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_delete_self_hosted_runner_from_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_labels_for_self_hosted_runner_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_list_labels_for_self_hosted_runner_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_list_labels_for_self_hosted_runner_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_custom_labels_for_self_hosted_runner_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_set_custom_labels_for_self_hosted_runner_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_set_custom_labels_for_self_hosted_runner_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_add_custom_labels_to_self_hosted_runner_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_add_custom_labels_to_self_hosted_runner_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_add_custom_labels_to_self_hosted_runner_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_remove_all_custom_labels_from_self_hosted_runner_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_remove_all_custom_labels_from_self_hosted_runner_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_remove_all_custom_labels_from_self_hosted_runner_for_org(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_remove_custom_label_from_self_hosted_runner_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_remove_custom_label_from_self_hosted_runner_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_actions_remove_custom_label_from_self_hosted_runner_for_org(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_org_secrets(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_org_secrets();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_org_secrets(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_org_public_key(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_org_public_key();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_actions_get_org_public_key(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_org_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_actions_get_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_or_update_org_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_create_or_update_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::ActionsCreateOrUpdateOrgSecretBodyEncryptedValue>("encrypted-value")
        {
            request = request.body_map(|body| body.encrypted_value(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("key-id") {
            request = request.body_map(|body| body.key_id(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::ActionsCreateOrUpdateOrgSecretBodyVisibility>("visibility")
        {
            request = request.body_map(|body| body.visibility(value.clone()))
        }

        self.over
            .execute_actions_create_or_update_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_org_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_actions_delete_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_list_selected_repos_for_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_selected_repos_for_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_set_selected_repos_for_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_actions_set_selected_repos_for_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_add_selected_repo_to_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_add_selected_repo_to_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_actions_add_selected_repo_to_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_remove_selected_repo_from_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_remove_selected_repo_from_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_actions_remove_selected_repo_from_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_org_variables(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_org_variables();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_org_variables(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_org_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_create_org_variable();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("value") {
            request = request.body_map(|body| body.value(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::ActionsCreateOrgVariableBodyVisibility>("visibility")
        {
            request = request.body_map(|body| body.visibility(value.clone()))
        }

        self.over
            .execute_actions_create_org_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_org_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_org_variable();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_actions_get_org_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_org_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_org_variable();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_actions_delete_org_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_update_org_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_update_org_variable();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("value") {
            request = request.body_map(|body| body.value(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::ActionsUpdateOrgVariableBodyVisibility>("visibility")
        {
            request = request.body_map(|body| body.visibility(value.clone()))
        }

        self.over
            .execute_actions_update_org_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_selected_repos_for_org_variable(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_list_selected_repos_for_org_variable();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_selected_repos_for_org_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_selected_repos_for_org_variable(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_set_selected_repos_for_org_variable();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_actions_set_selected_repos_for_org_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_add_selected_repo_to_org_variable(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_add_selected_repo_to_org_variable();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_actions_add_selected_repo_to_org_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_remove_selected_repo_from_org_variable(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_remove_selected_repo_from_org_variable();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_actions_remove_selected_repo_from_org_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_blocked_users(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_blocked_users();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_orgs_list_blocked_users(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_check_blocked_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_check_blocked_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_orgs_check_blocked_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_block_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_block_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_orgs_block_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_unblock_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_unblock_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_orgs_unblock_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_list_alerts_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_list_alerts_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("after") {
            request = request.after(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("before") {
            request = request.before(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::CodeScanningListAlertsForOrgDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAlertSeverity>("severity") {
            request = request.severity(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningListAlertsForOrgSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAlertState>("state") {
            request = request.state(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAnalysisToolGuid>("tool-guid") {
            request = request.tool_guid(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAnalysisToolName>("tool-name") {
            request = request.tool_name(value.clone());
        }

        self.over
            .execute_code_scanning_list_alerts_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_list_in_organization(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_list_in_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_codespaces_list_in_organization(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_set_codespaces_billing(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_set_codespaces_billing();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::CodespacesSetCodespacesBillingBodyVisibility>("visibility")
        {
            request = request.body_map(|body| body.visibility(value.clone()))
        }

        self.over
            .execute_codespaces_set_codespaces_billing(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_set_codespaces_billing_users(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_set_codespaces_billing_users();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_codespaces_set_codespaces_billing_users(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_delete_codespaces_billing_users(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_delete_codespaces_billing_users();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_codespaces_delete_codespaces_billing_users(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_list_org_secrets(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_list_org_secrets();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_codespaces_list_org_secrets(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_get_org_public_key(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_get_org_public_key();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_codespaces_get_org_public_key(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_get_org_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_get_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_codespaces_get_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_create_or_update_org_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_create_or_update_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::CodespacesCreateOrUpdateOrgSecretBodyEncryptedValue>(
                "encrypted-value",
            )
        {
            request = request.body_map(|body| body.encrypted_value(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("key-id") {
            request = request.body_map(|body| body.key_id(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::CodespacesCreateOrUpdateOrgSecretBodyVisibility>("visibility")
        {
            request = request.body_map(|body| body.visibility(value.clone()))
        }

        self.over
            .execute_codespaces_create_or_update_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_delete_org_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_delete_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_codespaces_delete_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_list_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_list_selected_repos_for_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_codespaces_list_selected_repos_for_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_set_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_set_selected_repos_for_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_codespaces_set_selected_repos_for_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_add_selected_repo_to_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_add_selected_repo_to_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_codespaces_add_selected_repo_to_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_remove_selected_repo_from_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_remove_selected_repo_from_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_codespaces_remove_selected_repo_from_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_list_alerts_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_list_alerts_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("after") {
            request = request.after(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("before") {
            request = request.before(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::DependabotListAlertsForOrgDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ecosystem") {
            request = request.ecosystem(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("first") {
            request = request.first(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("last") {
            request = request.last(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package") {
            request = request.package(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::DependabotListAlertsForOrgScope>("scope") {
            request = request.scope(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("severity") {
            request = request.severity(value.clone());
        }

        if let Some(value) = matches.get_one::<types::DependabotListAlertsForOrgSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("state") {
            request = request.state(value.clone());
        }

        self.over
            .execute_dependabot_list_alerts_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_list_org_secrets(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_list_org_secrets();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_dependabot_list_org_secrets(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_get_org_public_key(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_get_org_public_key();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_dependabot_get_org_public_key(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_get_org_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_get_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_dependabot_get_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_create_or_update_org_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_create_or_update_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::DependabotCreateOrUpdateOrgSecretBodyEncryptedValue>(
                "encrypted-value",
            )
        {
            request = request.body_map(|body| body.encrypted_value(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("key-id") {
            request = request.body_map(|body| body.key_id(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::DependabotCreateOrUpdateOrgSecretBodyVisibility>("visibility")
        {
            request = request.body_map(|body| body.visibility(value.clone()))
        }

        self.over
            .execute_dependabot_create_or_update_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_delete_org_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_delete_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_dependabot_delete_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_list_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.dependabot_list_selected_repos_for_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_dependabot_list_selected_repos_for_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_set_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.dependabot_set_selected_repos_for_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_dependabot_set_selected_repos_for_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_add_selected_repo_to_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.dependabot_add_selected_repo_to_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_dependabot_add_selected_repo_to_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_remove_selected_repo_from_org_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .dependabot_remove_selected_repo_from_org_secret();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_dependabot_remove_selected_repo_from_org_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_list_docker_migration_conflicting_packages_for_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .packages_list_docker_migration_conflicting_packages_for_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_packages_list_docker_migration_conflicting_packages_for_organization(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_public_org_events(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_list_public_org_events();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_public_org_events(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_failed_invitations(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_failed_invitations();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_orgs_list_failed_invitations(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_webhooks(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_webhooks();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_orgs_list_webhooks(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_create_webhook(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_create_webhook();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("active") {
            request = request.body_map(|body| body.active(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_orgs_create_webhook(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_get_webhook(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_get_webhook();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        self.over
            .execute_orgs_get_webhook(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_delete_webhook(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_delete_webhook();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        self.over
            .execute_orgs_delete_webhook(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_update_webhook(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_update_webhook();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("active") {
            request = request.body_map(|body| body.active(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_orgs_update_webhook(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_get_webhook_config_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_get_webhook_config_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        self.over
            .execute_orgs_get_webhook_config_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_update_webhook_config_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_update_webhook_config_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::WebhookConfigContentType>("content-type") {
            request = request.body_map(|body| body.content_type(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::WebhookConfigInsecureSsl>("insecure-ssl") {
            request = request.body_map(|body| body.insecure_ssl(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::WebhookConfigSecret>("secret") {
            request = request.body_map(|body| body.secret(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::WebhookConfigUrl>("url") {
            request = request.body_map(|body| body.url(value.clone()))
        }

        self.over
            .execute_orgs_update_webhook_config_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_webhook_deliveries(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_webhook_deliveries();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("cursor") {
            request = request.cursor(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("redelivery") {
            request = request.redelivery(value.clone());
        }

        self.over
            .execute_orgs_list_webhook_deliveries(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_get_webhook_delivery(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_get_webhook_delivery();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("delivery-id") {
            request = request.delivery_id(value.clone());
        }

        self.over
            .execute_orgs_get_webhook_delivery(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_redeliver_webhook_delivery(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_redeliver_webhook_delivery();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("delivery-id") {
            request = request.delivery_id(value.clone());
        }

        self.over
            .execute_orgs_redeliver_webhook_delivery(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_ping_webhook(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_ping_webhook();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        self.over
            .execute_orgs_ping_webhook(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_get_org_installation(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_get_org_installation();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_apps_get_org_installation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_app_installations(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_app_installations();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_orgs_list_app_installations(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_interactions_get_restrictions_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.interactions_get_restrictions_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_interactions_get_restrictions_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_interactions_set_restrictions_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.interactions_set_restrictions_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<types::InteractionExpiry>("expiry") {
            request = request.body_map(|body| body.expiry(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::InteractionGroup>("limit") {
            request = request.body_map(|body| body.limit(value.clone()))
        }

        self.over
            .execute_interactions_set_restrictions_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_interactions_remove_restrictions_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.interactions_remove_restrictions_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_interactions_remove_restrictions_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_pending_invitations(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_pending_invitations();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::OrgsListPendingInvitationsInvitationSource>("invitation-source")
        {
            request = request.invitation_source(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::OrgsListPendingInvitationsRole>("role") {
            request = request.role(value.clone());
        }

        self.over
            .execute_orgs_list_pending_invitations(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_create_invitation(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_create_invitation();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("email") {
            request = request.body_map(|body| body.email(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("invitee-id") {
            request = request.body_map(|body| body.invitee_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::OrgsCreateInvitationBodyRole>("role") {
            request = request.body_map(|body| body.role(value.clone()))
        }

        self.over
            .execute_orgs_create_invitation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_cancel_invitation(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_cancel_invitation();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("invitation-id") {
            request = request.invitation_id(value.clone());
        }

        self.over
            .execute_orgs_cancel_invitation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_invitation_teams(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_invitation_teams();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("invitation-id") {
            request = request.invitation_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_orgs_list_invitation_teams(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListForOrgDirection>("direction") {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListForOrgFilter>("filter") {
            request = request.filter(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("labels") {
            request = request.labels(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListForOrgSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListForOrgState>("state") {
            request = request.state(value.clone());
        }

        self.over
            .execute_issues_list_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_members(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_members();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<types::OrgsListMembersFilter>("filter") {
            request = request.filter(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::OrgsListMembersRole>("role") {
            request = request.role(value.clone());
        }

        self.over
            .execute_orgs_list_members(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_check_membership_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_check_membership_for_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_orgs_check_membership_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_remove_member(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_remove_member();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_orgs_remove_member(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_get_codespaces_for_user_in_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_get_codespaces_for_user_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_codespaces_get_codespaces_for_user_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_delete_from_organization(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_delete_from_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("codespace-name") {
            request = request.codespace_name(value.clone());
        }

        self.over
            .execute_codespaces_delete_from_organization(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_stop_in_organization(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_stop_in_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("codespace-name") {
            request = request.codespace_name(value.clone());
        }

        self.over
            .execute_codespaces_stop_in_organization(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_get_membership_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_get_membership_for_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_orgs_get_membership_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_set_membership_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_set_membership_for_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<types::OrgsSetMembershipForUserBodyRole>("role") {
            request = request.body_map(|body| body.role(value.clone()))
        }

        self.over
            .execute_orgs_set_membership_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_remove_membership_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_remove_membership_for_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_orgs_remove_membership_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_list_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_list_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) =
            matches.get_one::<Vec<types::MigrationsListForOrgExcludeItem>>("exclude")
        {
            request = request.exclude(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_migrations_list_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_start_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_start_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("exclude-attachments") {
            request = request.body_map(|body| body.exclude_attachments(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("exclude-git-data") {
            request = request.body_map(|body| body.exclude_git_data(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("exclude-metadata") {
            request = request.body_map(|body| body.exclude_metadata(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("exclude-owner-projects") {
            request = request.body_map(|body| body.exclude_owner_projects(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("exclude-releases") {
            request = request.body_map(|body| body.exclude_releases(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("lock-repositories") {
            request = request.body_map(|body| body.lock_repositories(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("org-metadata-only") {
            request = request.body_map(|body| body.org_metadata_only(value.clone()))
        }

        self.over
            .execute_migrations_start_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_get_status_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_get_status_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("migration-id") {
            request = request.migration_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<Vec<types::MigrationsGetStatusForOrgExcludeItem>>("exclude")
        {
            request = request.exclude(value.clone());
        }

        self.over
            .execute_migrations_get_status_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_download_archive_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_download_archive_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("migration-id") {
            request = request.migration_id(value.clone());
        }

        self.over
            .execute_migrations_download_archive_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                todo!()
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_delete_archive_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_delete_archive_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("migration-id") {
            request = request.migration_id(value.clone());
        }

        self.over
            .execute_migrations_delete_archive_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_unlock_repo_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_unlock_repo_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("migration-id") {
            request = request.migration_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo-name") {
            request = request.repo_name(value.clone());
        }

        self.over
            .execute_migrations_unlock_repo_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_list_repos_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_list_repos_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("migration-id") {
            request = request.migration_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_migrations_list_repos_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_outside_collaborators(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_outside_collaborators();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<types::OrgsListOutsideCollaboratorsFilter>("filter")
        {
            request = request.filter(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_orgs_list_outside_collaborators(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_convert_member_to_outside_collaborator(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.orgs_convert_member_to_outside_collaborator();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("async") {
            request = request.body_map(|body| body.async_(value.clone()))
        }

        self.over
            .execute_orgs_convert_member_to_outside_collaborator(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_remove_outside_collaborator(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_remove_outside_collaborator();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_orgs_remove_outside_collaborator(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_list_packages_for_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.packages_list_packages_for_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesListPackagesForOrganizationPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesListPackagesForOrganizationVisibility>("visibility")
        {
            request = request.visibility(value.clone());
        }

        self.over
            .execute_packages_list_packages_for_organization(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_get_package_for_organization(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.packages_get_package_for_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesGetPackageForOrganizationPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        self.over
            .execute_packages_get_package_for_organization(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_delete_package_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.packages_delete_package_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesDeletePackageForOrgPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        self.over
            .execute_packages_delete_package_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_restore_package_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.packages_restore_package_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesRestorePackageForOrgPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("token") {
            request = request.token(value.clone());
        }

        self.over
            .execute_packages_restore_package_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_get_all_package_versions_for_package_owned_by_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .packages_get_all_package_versions_for_package_owned_by_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType>(
            "package-type",
        ) {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::PackagesGetAllPackageVersionsForPackageOwnedByOrgState>("state")
        {
            request = request.state(value.clone());
        }

        self.over
            .execute_packages_get_all_package_versions_for_package_owned_by_org(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_get_package_version_for_organization(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.packages_get_package_version_for_organization();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::PackagesGetPackageVersionForOrganizationPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("package-version-id") {
            request = request.package_version_id(value.clone());
        }

        self.over
            .execute_packages_get_package_version_for_organization(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_delete_package_version_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.packages_delete_package_version_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesDeletePackageVersionForOrgPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("package-version-id") {
            request = request.package_version_id(value.clone());
        }

        self.over
            .execute_packages_delete_package_version_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_restore_package_version_for_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.packages_restore_package_version_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesRestorePackageVersionForOrgPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("package-version-id") {
            request = request.package_version_id(value.clone());
        }

        self.over
            .execute_packages_restore_package_version_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_list_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_list_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ProjectsListForOrgState>("state") {
            request = request.state(value.clone());
        }

        self.over
            .execute_projects_list_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_create_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_create_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_projects_create_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_public_members(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_public_members();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_orgs_list_public_members(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_check_public_membership_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_check_public_membership_for_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_orgs_check_public_membership_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_set_public_membership_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .orgs_set_public_membership_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_orgs_set_public_membership_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_remove_public_membership_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .orgs_remove_public_membership_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_orgs_remove_public_membership_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReposListForOrgDirection>("direction") {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReposListForOrgSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReposListForOrgType>("type") {
            request = request.type_(value.clone());
        }

        self.over
            .execute_repos_list_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("allow-auto-merge") {
            request = request.body_map(|body| body.allow_auto_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-merge-commit") {
            request = request.body_map(|body| body.allow_merge_commit(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-rebase-merge") {
            request = request.body_map(|body| body.allow_rebase_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-squash-merge") {
            request = request.body_map(|body| body.allow_squash_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("auto-init") {
            request = request.body_map(|body| body.auto_init(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("delete-branch-on-merge") {
            request = request.body_map(|body| body.delete_branch_on_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("gitignore-template") {
            request = request.body_map(|body| body.gitignore_template(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-downloads") {
            request = request.body_map(|body| body.has_downloads(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-issues") {
            request = request.body_map(|body| body.has_issues(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-projects") {
            request = request.body_map(|body| body.has_projects(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-wiki") {
            request = request.body_map(|body| body.has_wiki(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("homepage") {
            request = request.body_map(|body| body.homepage(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("is-template") {
            request = request.body_map(|body| body.is_template(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("license-template") {
            request = request.body_map(|body| body.license_template(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::ReposCreateInOrgBodyMergeCommitMessage>("merge-commit-message")
        {
            request = request.body_map(|body| body.merge_commit_message(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::ReposCreateInOrgBodyMergeCommitTitle>("merge-commit-title")
        {
            request = request.body_map(|body| body.merge_commit_title(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("private") {
            request = request.body_map(|body| body.private(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ReposCreateInOrgBodySquashMergeCommitMessage>(
            "squash-merge-commit-message",
        ) {
            request = request.body_map(|body| body.squash_merge_commit_message(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ReposCreateInOrgBodySquashMergeCommitTitle>(
            "squash-merge-commit-title",
        ) {
            request = request.body_map(|body| body.squash_merge_commit_title(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.body_map(|body| body.team_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("use-squash-pr-title-as-default") {
            request = request.body_map(|body| body.use_squash_pr_title_as_default(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ReposCreateInOrgBodyVisibility>("visibility")
        {
            request = request.body_map(|body| body.visibility(value.clone()))
        }

        self.over
            .execute_repos_create_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_org_rulesets(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_org_rulesets();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_repos_get_org_rulesets(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_org_ruleset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_org_ruleset();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<types::RepositoryRuleEnforcement>("enforcement") {
            request = request.body_map(|body| body.enforcement(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ReposCreateOrgRulesetBodyTarget>("target") {
            request = request.body_map(|body| body.target(value.clone()))
        }

        self.over
            .execute_repos_create_org_ruleset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_org_ruleset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_org_ruleset();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("ruleset-id") {
            request = request.ruleset_id(value.clone());
        }

        self.over
            .execute_repos_get_org_ruleset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_org_ruleset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_update_org_ruleset();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("ruleset-id") {
            request = request.ruleset_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::RepositoryRuleEnforcement>("enforcement") {
            request = request.body_map(|body| body.enforcement(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ReposUpdateOrgRulesetBodyTarget>("target") {
            request = request.body_map(|body| body.target(value.clone()))
        }

        self.over
            .execute_repos_update_org_ruleset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_org_ruleset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_org_ruleset();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("ruleset-id") {
            request = request.ruleset_id(value.clone());
        }

        self.over
            .execute_repos_delete_org_ruleset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_secret_scanning_list_alerts_for_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.secret_scanning_list_alerts_for_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("after") {
            request = request.after(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("before") {
            request = request.before(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::SecretScanningListAlertsForOrgDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("resolution") {
            request = request.resolution(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-type") {
            request = request.secret_type(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SecretScanningListAlertsForOrgSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SecretScanningListAlertsForOrgState>("state")
        {
            request = request.state(value.clone());
        }

        self.over
            .execute_secret_scanning_list_alerts_for_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_security_manager_teams(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_security_manager_teams();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_orgs_list_security_manager_teams(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_add_security_manager_team(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_add_security_manager_team();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        self.over
            .execute_orgs_add_security_manager_team(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_remove_security_manager_team(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_remove_security_manager_team();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        self.over
            .execute_orgs_remove_security_manager_team(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_billing_get_github_actions_billing_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.billing_get_github_actions_billing_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_billing_get_github_actions_billing_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_billing_get_github_packages_billing_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.billing_get_github_packages_billing_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_billing_get_github_packages_billing_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_billing_get_shared_storage_billing_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.billing_get_shared_storage_billing_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_billing_get_shared_storage_billing_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over.execute_teams_list(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_create(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_create();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::TeamsCreateBodyNotificationSetting>("notification-setting")
        {
            request = request.body_map(|body| body.notification_setting(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("parent-team-id") {
            request = request.body_map(|body| body.parent_team_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::TeamsCreateBodyPermission>("permission") {
            request = request.body_map(|body| body.permission(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::TeamsCreateBodyPrivacy>("privacy") {
            request = request.body_map(|body| body.privacy(value.clone()))
        }

        self.over
            .execute_teams_create(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_get_by_name(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_get_by_name();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        self.over
            .execute_teams_get_by_name(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_delete_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_delete_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        self.over
            .execute_teams_delete_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_update_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_update_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches
            .get_one::<types::TeamsUpdateInOrgBodyNotificationSetting>("notification-setting")
        {
            request = request.body_map(|body| body.notification_setting(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("parent-team-id") {
            request = request.body_map(|body| body.parent_team_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::TeamsUpdateInOrgBodyPermission>("permission")
        {
            request = request.body_map(|body| body.permission(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::TeamsUpdateInOrgBodyPrivacy>("privacy") {
            request = request.body_map(|body| body.privacy(value.clone()))
        }

        self.over
            .execute_teams_update_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_discussions_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_discussions_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::TeamsListDiscussionsInOrgDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("pinned") {
            request = request.pinned(value.clone());
        }

        self.over
            .execute_teams_list_discussions_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_create_discussion_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_create_discussion_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("private") {
            request = request.body_map(|body| body.private(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_teams_create_discussion_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_get_discussion_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_get_discussion_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        self.over
            .execute_teams_get_discussion_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_delete_discussion_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_delete_discussion_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        self.over
            .execute_teams_delete_discussion_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_update_discussion_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_update_discussion_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_teams_update_discussion_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_discussion_comments_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_discussion_comments_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::TeamsListDiscussionCommentsInOrgDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_discussion_comments_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_create_discussion_comment_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_create_discussion_comment_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_teams_create_discussion_comment_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_get_discussion_comment_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_get_discussion_comment_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-number") {
            request = request.comment_number(value.clone());
        }

        self.over
            .execute_teams_get_discussion_comment_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_delete_discussion_comment_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_delete_discussion_comment_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-number") {
            request = request.comment_number(value.clone());
        }

        self.over
            .execute_teams_delete_discussion_comment_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_update_discussion_comment_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_update_discussion_comment_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-number") {
            request = request.comment_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_teams_update_discussion_comment_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_list_for_team_discussion_comment_in_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .reactions_list_for_team_discussion_comment_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-number") {
            request = request.comment_number(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsListForTeamDiscussionCommentInOrgContent>("content")
        {
            request = request.content(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_reactions_list_for_team_discussion_comment_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_create_for_team_discussion_comment_in_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .reactions_create_for_team_discussion_comment_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-number") {
            request = request.comment_number(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::ReactionsCreateForTeamDiscussionCommentInOrgBodyContent>("content")
        {
            request = request.body_map(|body| body.content(value.clone()))
        }

        self.over
            .execute_reactions_create_for_team_discussion_comment_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_delete_for_team_discussion_comment(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.reactions_delete_for_team_discussion_comment();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-number") {
            request = request.comment_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("reaction-id") {
            request = request.reaction_id(value.clone());
        }

        self.over
            .execute_reactions_delete_for_team_discussion_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_list_for_team_discussion_in_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.reactions_list_for_team_discussion_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsListForTeamDiscussionInOrgContent>("content")
        {
            request = request.content(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_reactions_list_for_team_discussion_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_create_for_team_discussion_in_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.reactions_create_for_team_discussion_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsCreateForTeamDiscussionInOrgBodyContent>("content")
        {
            request = request.body_map(|body| body.content(value.clone()))
        }

        self.over
            .execute_reactions_create_for_team_discussion_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_delete_for_team_discussion(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_delete_for_team_discussion();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("reaction-id") {
            request = request.reaction_id(value.clone());
        }

        self.over
            .execute_reactions_delete_for_team_discussion(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_pending_invitations_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_pending_invitations_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_pending_invitations_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_members_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_members_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::TeamsListMembersInOrgRole>("role") {
            request = request.role(value.clone());
        }

        self.over
            .execute_teams_list_members_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_get_membership_for_user_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_get_membership_for_user_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_teams_get_membership_for_user_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_add_or_update_membership_for_user_in_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_add_or_update_membership_for_user_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::TeamsAddOrUpdateMembershipForUserInOrgBodyRole>("role")
        {
            request = request.body_map(|body| body.role(value.clone()))
        }

        self.over
            .execute_teams_add_or_update_membership_for_user_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_remove_membership_for_user_in_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_remove_membership_for_user_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_teams_remove_membership_for_user_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_projects_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_projects_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_projects_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_check_permissions_for_project_in_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_check_permissions_for_project_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        self.over
            .execute_teams_check_permissions_for_project_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_add_or_update_project_permissions_in_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_add_or_update_project_permissions_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        self.over
            .execute_teams_add_or_update_project_permissions_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_remove_project_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_remove_project_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        self.over
            .execute_teams_remove_project_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_repos_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_repos_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_repos_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_check_permissions_for_repo_in_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_check_permissions_for_repo_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_teams_check_permissions_for_repo_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_add_or_update_repo_permissions_in_org(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_add_or_update_repo_permissions_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("permission") {
            request = request.body_map(|body| body.permission(value.clone()))
        }

        self.over
            .execute_teams_add_or_update_repo_permissions_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_remove_repo_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_remove_repo_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_teams_remove_repo_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_child_in_org(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_child_in_org();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("team-slug") {
            request = request.team_slug(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_child_in_org(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_enable_or_disable_security_product_on_all_org_repos(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .orgs_enable_or_disable_security_product_on_all_org_repos();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::OrgsEnableOrDisableSecurityProductOnAllOrgReposSecurityProduct>(
            "security-product",
        ) {
            request = request.security_product(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::OrgsEnableOrDisableSecurityProductOnAllOrgReposEnablement>(
                "enablement",
            )
        {
            request = request.enablement(value.clone());
        }

        self.over
            .execute_orgs_enable_or_disable_security_product_on_all_org_repos(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_get_card(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_get_card();
        if let Some(value) = matches.get_one::<i64>("card-id") {
            request = request.card_id(value.clone());
        }

        self.over
            .execute_projects_get_card(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_delete_card(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_delete_card();
        if let Some(value) = matches.get_one::<i64>("card-id") {
            request = request.card_id(value.clone());
        }

        self.over
            .execute_projects_delete_card(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_update_card(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_update_card();
        if let Some(value) = matches.get_one::<i64>("card-id") {
            request = request.card_id(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("archived") {
            request = request.body_map(|body| body.archived(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("note") {
            request = request.body_map(|body| body.note(value.clone()))
        }

        self.over
            .execute_projects_update_card(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_move_card(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_move_card();
        if let Some(value) = matches.get_one::<i64>("card-id") {
            request = request.card_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("column-id") {
            request = request.body_map(|body| body.column_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ProjectsMoveCardBodyPosition>("position") {
            request = request.body_map(|body| body.position(value.clone()))
        }

        self.over
            .execute_projects_move_card(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_get_column(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_get_column();
        if let Some(value) = matches.get_one::<i64>("column-id") {
            request = request.column_id(value.clone());
        }

        self.over
            .execute_projects_get_column(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_delete_column(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_delete_column();
        if let Some(value) = matches.get_one::<i64>("column-id") {
            request = request.column_id(value.clone());
        }

        self.over
            .execute_projects_delete_column(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_update_column(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_update_column();
        if let Some(value) = matches.get_one::<i64>("column-id") {
            request = request.column_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_projects_update_column(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_ssh_signing_keys_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_list_ssh_signing_keys_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_ssh_signing_keys_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_move_column(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_move_column();
        if let Some(value) = matches.get_one::<i64>("column-id") {
            request = request.column_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ProjectsMoveColumnBodyPosition>("position") {
            request = request.body_map(|body| body.position(value.clone()))
        }

        self.over
            .execute_projects_move_column(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_get(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_get();
        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        self.over
            .execute_projects_get(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_delete(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_delete();
        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        self.over
            .execute_projects_delete(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_update(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_update();
        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches
            .get_one::<types::ProjectsUpdateBodyOrganizationPermission>("organization-permission")
        {
            request = request.body_map(|body| body.organization_permission(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("private") {
            request = request.body_map(|body| body.private(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("state") {
            request = request.body_map(|body| body.state(value.clone()))
        }

        self.over
            .execute_projects_update(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_list_collaborators(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_list_collaborators();
        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ProjectsListCollaboratorsAffiliation>("affiliation")
        {
            request = request.affiliation(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_projects_list_collaborators(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_add_collaborator(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_add_collaborator();
        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_projects_add_collaborator(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_remove_collaborator(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_remove_collaborator();
        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_projects_remove_collaborator(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_get_permission_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_get_permission_for_user();
        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_projects_get_permission_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_list_columns(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_list_columns();
        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_projects_list_columns(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_create_column(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_create_column();
        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_projects_create_column(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_rate_limit_get(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.rate_limit_get();
        self.over
            .execute_rate_limit_get(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_repo_required_workflows(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_repo_required_workflows();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_repo_required_workflows(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_repo_required_workflow(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_repo_required_workflow();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("required-workflow-id-for-repo") {
            request = request.required_workflow_id_for_repo(value.clone());
        }

        self.over
            .execute_actions_get_repo_required_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_repo_required_workflow_usage(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_get_repo_required_workflow_usage();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("required-workflow-id-for-repo") {
            request = request.required_workflow_id_for_repo(value.clone());
        }

        self.over
            .execute_actions_get_repo_required_workflow_usage(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over.execute_repos_get(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_delete(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_update();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("allow-auto-merge") {
            request = request.body_map(|body| body.allow_auto_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-forking") {
            request = request.body_map(|body| body.allow_forking(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-merge-commit") {
            request = request.body_map(|body| body.allow_merge_commit(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-rebase-merge") {
            request = request.body_map(|body| body.allow_rebase_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-squash-merge") {
            request = request.body_map(|body| body.allow_squash_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-update-branch") {
            request = request.body_map(|body| body.allow_update_branch(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("archived") {
            request = request.body_map(|body| body.archived(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("default-branch") {
            request = request.body_map(|body| body.default_branch(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("delete-branch-on-merge") {
            request = request.body_map(|body| body.delete_branch_on_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-issues") {
            request = request.body_map(|body| body.has_issues(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-projects") {
            request = request.body_map(|body| body.has_projects(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-wiki") {
            request = request.body_map(|body| body.has_wiki(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("homepage") {
            request = request.body_map(|body| body.homepage(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("is-template") {
            request = request.body_map(|body| body.is_template(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::ReposUpdateBodyMergeCommitMessage>("merge-commit-message")
        {
            request = request.body_map(|body| body.merge_commit_message(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::ReposUpdateBodyMergeCommitTitle>("merge-commit-title")
        {
            request = request.body_map(|body| body.merge_commit_title(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("private") {
            request = request.body_map(|body| body.private(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ReposUpdateBodySquashMergeCommitMessage>(
            "squash-merge-commit-message",
        ) {
            request = request.body_map(|body| body.squash_merge_commit_message(value.clone()))
        }

        if let Some(value) = matches
            .get_one::<types::ReposUpdateBodySquashMergeCommitTitle>("squash-merge-commit-title")
        {
            request = request.body_map(|body| body.squash_merge_commit_title(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("use-squash-pr-title-as-default") {
            request = request.body_map(|body| body.use_squash_pr_title_as_default(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ReposUpdateBodyVisibility>("visibility") {
            request = request.body_map(|body| body.visibility(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("web-commit-signoff-required") {
            request = request.body_map(|body| body.web_commit_signoff_required(value.clone()))
        }

        self.over
            .execute_repos_update(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_artifacts_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_artifacts_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_artifacts_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_artifact(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_artifact();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("artifact-id") {
            request = request.artifact_id(value.clone());
        }

        self.over
            .execute_actions_get_artifact(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_artifact(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_artifact();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("artifact-id") {
            request = request.artifact_id(value.clone());
        }

        self.over
            .execute_actions_delete_artifact(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_download_artifact(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_download_artifact();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("artifact-id") {
            request = request.artifact_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("archive-format") {
            request = request.archive_format(value.clone());
        }

        self.over
            .execute_actions_download_artifact(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                todo!()
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_actions_cache_usage(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_actions_cache_usage();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_actions_get_actions_cache_usage(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_actions_cache_list(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_actions_cache_list();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ActionsGetActionsCacheListDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("key") {
            request = request.key(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ActionsGetActionsCacheListSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_actions_get_actions_cache_list(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_actions_cache_by_key(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_actions_cache_by_key();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("key") {
            request = request.key(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_actions_delete_actions_cache_by_key(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_actions_cache_by_id(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_actions_cache_by_id();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("cache-id") {
            request = request.cache_id(value.clone());
        }

        self.over
            .execute_actions_delete_actions_cache_by_id(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_job_for_workflow_run(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_job_for_workflow_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("job-id") {
            request = request.job_id(value.clone());
        }

        self.over
            .execute_actions_get_job_for_workflow_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_download_job_logs_for_workflow_run(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_download_job_logs_for_workflow_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("job-id") {
            request = request.job_id(value.clone());
        }

        self.over
            .execute_actions_download_job_logs_for_workflow_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                todo!()
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_re_run_job_for_workflow_run(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_re_run_job_for_workflow_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("job-id") {
            request = request.job_id(value.clone());
        }

        self.over
            .execute_actions_re_run_job_for_workflow_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_custom_oidc_sub_claim_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_get_custom_oidc_sub_claim_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_actions_get_custom_oidc_sub_claim_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_custom_oidc_sub_claim_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_set_custom_oidc_sub_claim_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("use-default") {
            request = request.body_map(|body| body.use_default(value.clone()))
        }

        self.over
            .execute_actions_set_custom_oidc_sub_claim_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_repo_organization_secrets(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_repo_organization_secrets();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_repo_organization_secrets(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_repo_organization_variables(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_list_repo_organization_variables();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_repo_organization_variables(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_github_actions_permissions_repository(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_get_github_actions_permissions_repository();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_actions_get_github_actions_permissions_repository(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_github_actions_permissions_repository(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_set_github_actions_permissions_repository();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AllowedActions>("allowed-actions") {
            request = request.body_map(|body| body.allowed_actions(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ActionsEnabled>("enabled") {
            request = request.body_map(|body| body.enabled(value.clone()))
        }

        self.over
            .execute_actions_set_github_actions_permissions_repository(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_workflow_access_to_repository(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_get_workflow_access_to_repository();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_actions_get_workflow_access_to_repository(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_workflow_access_to_repository(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_set_workflow_access_to_repository();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ActionsWorkflowAccessToRepositoryAccessLevel>("access-level")
        {
            request = request.body_map(|body| body.access_level(value.clone()))
        }

        self.over
            .execute_actions_set_workflow_access_to_repository(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_allowed_actions_repository(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_allowed_actions_repository();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_actions_get_allowed_actions_repository(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_allowed_actions_repository(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_set_allowed_actions_repository();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("github-owned-allowed") {
            request = request.body_map(|body| body.github_owned_allowed(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("verified-allowed") {
            request = request.body_map(|body| body.verified_allowed(value.clone()))
        }

        self.over
            .execute_actions_set_allowed_actions_repository(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_github_actions_default_workflow_permissions_repository(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_get_github_actions_default_workflow_permissions_repository();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_actions_get_github_actions_default_workflow_permissions_repository(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_github_actions_default_workflow_permissions_repository(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_set_github_actions_default_workflow_permissions_repository();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ActionsCanApprovePullRequestReviews>(
            "can-approve-pull-request-reviews",
        ) {
            request = request.body_map(|body| body.can_approve_pull_request_reviews(value.clone()))
        }

        if let Some(value) = matches
            .get_one::<types::ActionsDefaultWorkflowPermissions>("default-workflow-permissions")
        {
            request = request.body_map(|body| body.default_workflow_permissions(value.clone()))
        }

        self.over
            .execute_actions_set_github_actions_default_workflow_permissions_repository(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_required_workflow_runs(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_required_workflow_runs();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("required-workflow-id-for-repo") {
            request = request.required_workflow_id_for_repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("actor") {
            request = request.actor(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("check-suite-id") {
            request = request.check_suite_id(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("created") {
            request = request.created(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("event") {
            request = request.event(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("exclude-pull-requests") {
            request = request.exclude_pull_requests(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("head-sha") {
            request = request.head_sha(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ActionsListRequiredWorkflowRunsStatus>("status")
        {
            request = request.status(value.clone());
        }

        self.over
            .execute_actions_list_required_workflow_runs(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_self_hosted_runners_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_list_self_hosted_runners_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_self_hosted_runners_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_runner_applications_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_list_runner_applications_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_actions_list_runner_applications_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_registration_token_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_create_registration_token_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_actions_create_registration_token_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_remove_token_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_create_remove_token_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_actions_create_remove_token_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_get_self_hosted_runner_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_get_self_hosted_runner_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_self_hosted_runner_from_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_delete_self_hosted_runner_from_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_delete_self_hosted_runner_from_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_labels_for_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_list_labels_for_self_hosted_runner_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_list_labels_for_self_hosted_runner_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_set_custom_labels_for_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_set_custom_labels_for_self_hosted_runner_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_set_custom_labels_for_self_hosted_runner_for_repo(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_add_custom_labels_to_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_add_custom_labels_to_self_hosted_runner_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_add_custom_labels_to_self_hosted_runner_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_remove_all_custom_labels_from_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_remove_all_custom_labels_from_self_hosted_runner_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        self.over
            .execute_actions_remove_all_custom_labels_from_self_hosted_runner_for_repo(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_remove_custom_label_from_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .actions_remove_custom_label_from_self_hosted_runner_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("runner-id") {
            request = request.runner_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_actions_remove_custom_label_from_self_hosted_runner_for_repo(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_workflow_runs_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_workflow_runs_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("actor") {
            request = request.actor(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("check-suite-id") {
            request = request.check_suite_id(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("created") {
            request = request.created(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("event") {
            request = request.event(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("exclude-pull-requests") {
            request = request.exclude_pull_requests(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("head-sha") {
            request = request.head_sha(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ActionsListWorkflowRunsForRepoStatus>("status")
        {
            request = request.status(value.clone());
        }

        self.over
            .execute_actions_list_workflow_runs_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_workflow_run(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_workflow_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("exclude-pull-requests") {
            request = request.exclude_pull_requests(value.clone());
        }

        self.over
            .execute_actions_get_workflow_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_workflow_run(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_workflow_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        self.over
            .execute_actions_delete_workflow_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_reviews_for_run(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_reviews_for_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        self.over
            .execute_actions_get_reviews_for_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_approve_workflow_run(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_approve_workflow_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        self.over
            .execute_actions_approve_workflow_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_workflow_run_artifacts(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_workflow_run_artifacts();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_workflow_run_artifacts(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_workflow_run_attempt(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_workflow_run_attempt();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("attempt-number") {
            request = request.attempt_number(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("exclude-pull-requests") {
            request = request.exclude_pull_requests(value.clone());
        }

        self.over
            .execute_actions_get_workflow_run_attempt(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_jobs_for_workflow_run_attempt(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_list_jobs_for_workflow_run_attempt();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("attempt-number") {
            request = request.attempt_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_jobs_for_workflow_run_attempt(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_download_workflow_run_attempt_logs(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_download_workflow_run_attempt_logs();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("attempt-number") {
            request = request.attempt_number(value.clone());
        }

        self.over
            .execute_actions_download_workflow_run_attempt_logs(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                todo!()
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_cancel_workflow_run(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_cancel_workflow_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        self.over
            .execute_actions_cancel_workflow_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_review_custom_gates_for_run(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_review_custom_gates_for_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        self.over
            .execute_actions_review_custom_gates_for_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_jobs_for_workflow_run(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_jobs_for_workflow_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ActionsListJobsForWorkflowRunFilter>("filter")
        {
            request = request.filter(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_jobs_for_workflow_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_download_workflow_run_logs(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_download_workflow_run_logs();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        self.over
            .execute_actions_download_workflow_run_logs(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                todo!()
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_workflow_run_logs(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_workflow_run_logs();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        self.over
            .execute_actions_delete_workflow_run_logs(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_pending_deployments_for_run(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_get_pending_deployments_for_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        self.over
            .execute_actions_get_pending_deployments_for_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_review_pending_deployments_for_run(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_review_pending_deployments_for_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("comment") {
            request = request.body_map(|body| body.comment(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::ActionsReviewPendingDeploymentsForRunBodyState>("state")
        {
            request = request.body_map(|body| body.state(value.clone()))
        }

        self.over
            .execute_actions_review_pending_deployments_for_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_re_run_workflow(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_re_run_workflow();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        self.over
            .execute_actions_re_run_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_re_run_workflow_failed_jobs(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_re_run_workflow_failed_jobs();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        self.over
            .execute_actions_re_run_workflow_failed_jobs(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_workflow_run_usage(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_workflow_run_usage();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("run-id") {
            request = request.run_id(value.clone());
        }

        self.over
            .execute_actions_get_workflow_run_usage(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_repo_secrets(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_repo_secrets();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_repo_secrets(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_repo_public_key(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_repo_public_key();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_actions_get_repo_public_key(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_repo_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_repo_secret();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_actions_get_repo_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_or_update_repo_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_create_or_update_repo_secret();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::ActionsCreateOrUpdateRepoSecretBodyEncryptedValue>("encrypted-value")
        {
            request = request.body_map(|body| body.encrypted_value(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("key-id") {
            request = request.body_map(|body| body.key_id(value.clone()))
        }

        self.over
            .execute_actions_create_or_update_repo_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_repo_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_repo_secret();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_actions_delete_repo_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_repo_variables(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_repo_variables();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_repo_variables(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_repo_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_create_repo_variable();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("value") {
            request = request.body_map(|body| body.value(value.clone()))
        }

        self.over
            .execute_actions_create_repo_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_repo_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_repo_variable();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_actions_get_repo_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_repo_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_repo_variable();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_actions_delete_repo_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_update_repo_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_update_repo_variable();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("value") {
            request = request.body_map(|body| body.value(value.clone()))
        }

        self.over
            .execute_actions_update_repo_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_repo_workflows(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_repo_workflows();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_repo_workflows(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_workflow(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_workflow();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ActionsGetWorkflowWorkflowId>("workflow-id") {
            request = request.workflow_id(value.clone());
        }

        self.over
            .execute_actions_get_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_disable_workflow(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_disable_workflow();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ActionsDisableWorkflowWorkflowId>("workflow-id")
        {
            request = request.workflow_id(value.clone());
        }

        self.over
            .execute_actions_disable_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_workflow_dispatch(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_create_workflow_dispatch();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ActionsCreateWorkflowDispatchWorkflowId>("workflow-id")
        {
            request = request.workflow_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.body_map(|body| body.ref_(value.clone()))
        }

        self.over
            .execute_actions_create_workflow_dispatch(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_enable_workflow(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_enable_workflow();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ActionsEnableWorkflowWorkflowId>("workflow-id")
        {
            request = request.workflow_id(value.clone());
        }

        self.over
            .execute_actions_enable_workflow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_workflow_runs(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_workflow_runs();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ActionsListWorkflowRunsWorkflowId>("workflow-id")
        {
            request = request.workflow_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("actor") {
            request = request.actor(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("check-suite-id") {
            request = request.check_suite_id(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("created") {
            request = request.created(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("event") {
            request = request.event(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("exclude-pull-requests") {
            request = request.exclude_pull_requests(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("head-sha") {
            request = request.head_sha(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ActionsListWorkflowRunsStatus>("status") {
            request = request.status(value.clone());
        }

        self.over
            .execute_actions_list_workflow_runs(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_workflow_usage(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_workflow_usage();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ActionsGetWorkflowUsageWorkflowId>("workflow-id")
        {
            request = request.workflow_id(value.clone());
        }

        self.over
            .execute_actions_get_workflow_usage(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_assignees(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_assignees();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_issues_list_assignees(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_check_user_can_be_assigned(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_check_user_can_be_assigned();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("assignee") {
            request = request.assignee(value.clone());
        }

        self.over
            .execute_issues_check_user_can_be_assigned(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_autolinks(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_autolinks();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        self.over
            .execute_repos_list_autolinks(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_autolink(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_autolink();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("is-alphanumeric") {
            request = request.body_map(|body| body.is_alphanumeric(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("key-prefix") {
            request = request.body_map(|body| body.key_prefix(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("url-template") {
            request = request.body_map(|body| body.url_template(value.clone()))
        }

        self.over
            .execute_repos_create_autolink(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_autolink(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_autolink();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("autolink-id") {
            request = request.autolink_id(value.clone());
        }

        self.over
            .execute_repos_get_autolink(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_autolink(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_autolink();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("autolink-id") {
            request = request.autolink_id(value.clone());
        }

        self.over
            .execute_repos_delete_autolink(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_enable_automated_security_fixes(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_enable_automated_security_fixes();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_enable_automated_security_fixes(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_disable_automated_security_fixes(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_disable_automated_security_fixes();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_disable_automated_security_fixes(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_branches(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_branches();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("protected") {
            request = request.protected(value.clone());
        }

        self.over
            .execute_repos_list_branches(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_branch(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_branch();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_branch(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_branch_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_branch_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_branch_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_branch_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_update_branch_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("allow-deletions") {
            request = request.body_map(|body| body.allow_deletions(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-force-pushes") {
            request = request.body_map(|body| body.allow_force_pushes(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-fork-syncing") {
            request = request.body_map(|body| body.allow_fork_syncing(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("block-creations") {
            request = request.body_map(|body| body.block_creations(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("enforce-admins") {
            request = request.body_map(|body| body.enforce_admins(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("lock-branch") {
            request = request.body_map(|body| body.lock_branch(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("required-conversation-resolution") {
            request = request.body_map(|body| body.required_conversation_resolution(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("required-linear-history") {
            request = request.body_map(|body| body.required_linear_history(value.clone()))
        }

        self.over
            .execute_repos_update_branch_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_branch_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_branch_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_delete_branch_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_admin_branch_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_admin_branch_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_admin_branch_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_set_admin_branch_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_set_admin_branch_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_set_admin_branch_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_admin_branch_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_admin_branch_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_delete_admin_branch_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_pull_request_review_protection(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_get_pull_request_review_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_pull_request_review_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_pull_request_review_protection(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_delete_pull_request_review_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_delete_pull_request_review_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_pull_request_review_protection(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_update_pull_request_review_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("dismiss-stale-reviews") {
            request = request.body_map(|body| body.dismiss_stale_reviews(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("require-code-owner-reviews") {
            request = request.body_map(|body| body.require_code_owner_reviews(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("require-last-push-approval") {
            request = request.body_map(|body| body.require_last_push_approval(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("required-approving-review-count") {
            request = request.body_map(|body| body.required_approving_review_count(value.clone()))
        }

        self.over
            .execute_repos_update_pull_request_review_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_commit_signature_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_commit_signature_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_commit_signature_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_commit_signature_protection(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_create_commit_signature_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_create_commit_signature_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_commit_signature_protection(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_delete_commit_signature_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_delete_commit_signature_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_status_checks_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_status_checks_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_status_checks_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_remove_status_check_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_remove_status_check_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_remove_status_check_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_status_check_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_update_status_check_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("strict") {
            request = request.body_map(|body| body.strict(value.clone()))
        }

        self.over
            .execute_repos_update_status_check_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_all_status_check_contexts(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_all_status_check_contexts();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_all_status_check_contexts(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_set_status_check_contexts(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_set_status_check_contexts();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_set_status_check_contexts(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_add_status_check_contexts(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_add_status_check_contexts();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_add_status_check_contexts(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_remove_status_check_contexts(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_remove_status_check_contexts();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_remove_status_check_contexts(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_access_restrictions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_access_restrictions();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_access_restrictions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_access_restrictions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_access_restrictions();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_delete_access_restrictions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_apps_with_access_to_protected_branch(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_get_apps_with_access_to_protected_branch();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_apps_with_access_to_protected_branch(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_set_app_access_restrictions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_set_app_access_restrictions();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_set_app_access_restrictions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_add_app_access_restrictions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_add_app_access_restrictions();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_add_app_access_restrictions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_remove_app_access_restrictions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_remove_app_access_restrictions();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_remove_app_access_restrictions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_teams_with_access_to_protected_branch(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .repos_get_teams_with_access_to_protected_branch();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_teams_with_access_to_protected_branch(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_set_team_access_restrictions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_set_team_access_restrictions();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_set_team_access_restrictions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_add_team_access_restrictions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_add_team_access_restrictions();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_add_team_access_restrictions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_remove_team_access_restrictions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_remove_team_access_restrictions();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_remove_team_access_restrictions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_users_with_access_to_protected_branch(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .repos_get_users_with_access_to_protected_branch();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_users_with_access_to_protected_branch(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_set_user_access_restrictions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_set_user_access_restrictions();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_set_user_access_restrictions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_add_user_access_restrictions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_add_user_access_restrictions();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_add_user_access_restrictions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_remove_user_access_restrictions(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_remove_user_access_restrictions();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_remove_user_access_restrictions(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_rename_branch(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_rename_branch();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("new-name") {
            request = request.body_map(|body| body.new_name(value.clone()))
        }

        self.over
            .execute_repos_rename_branch(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_create(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_create();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("completed-at")
        {
            request = request.body_map(|body| body.completed_at(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ChecksCreateBodyConclusion>("conclusion") {
            request = request.body_map(|body| body.conclusion(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("details-url") {
            request = request.body_map(|body| body.details_url(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("external-id") {
            request = request.body_map(|body| body.external_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("head-sha") {
            request = request.body_map(|body| body.head_sha(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("started-at")
        {
            request = request.body_map(|body| body.started_at(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ChecksCreateBodyStatus>("status") {
            request = request.body_map(|body| body.status(value.clone()))
        }

        self.over
            .execute_checks_create(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_get(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_get();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("check-run-id") {
            request = request.check_run_id(value.clone());
        }

        self.over.execute_checks_get(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_update(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_update();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("check-run-id") {
            request = request.check_run_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("completed-at")
        {
            request = request.body_map(|body| body.completed_at(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ChecksUpdateBodyConclusion>("conclusion") {
            request = request.body_map(|body| body.conclusion(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("details-url") {
            request = request.body_map(|body| body.details_url(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("external-id") {
            request = request.body_map(|body| body.external_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("started-at")
        {
            request = request.body_map(|body| body.started_at(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ChecksUpdateBodyStatus>("status") {
            request = request.body_map(|body| body.status(value.clone()))
        }

        self.over
            .execute_checks_update(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_list_annotations(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_list_annotations();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("check-run-id") {
            request = request.check_run_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_checks_list_annotations(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_rerequest_run(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_rerequest_run();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("check-run-id") {
            request = request.check_run_id(value.clone());
        }

        self.over
            .execute_checks_rerequest_run(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_create_suite(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_create_suite();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("head-sha") {
            request = request.body_map(|body| body.head_sha(value.clone()))
        }

        self.over
            .execute_checks_create_suite(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_set_suites_preferences(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_set_suites_preferences();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_checks_set_suites_preferences(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_get_suite(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_get_suite();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("check-suite-id") {
            request = request.check_suite_id(value.clone());
        }

        self.over
            .execute_checks_get_suite(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_list_for_suite(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_list_for_suite();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("check-suite-id") {
            request = request.check_suite_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("check-name") {
            request = request.check_name(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ChecksListForSuiteFilter>("filter") {
            request = request.filter(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ChecksListForSuiteStatus>("status") {
            request = request.status(value.clone());
        }

        self.over
            .execute_checks_list_for_suite(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_rerequest_suite(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_rerequest_suite();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("check-suite-id") {
            request = request.check_suite_id(value.clone());
        }

        self.over
            .execute_checks_rerequest_suite(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_list_alerts_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_list_alerts_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::CodeScanningListAlertsForRepoDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningRef>("ref") {
            request = request.ref_(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAlertSeverity>("severity") {
            request = request.severity(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningListAlertsForRepoSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAlertState>("state") {
            request = request.state(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAnalysisToolGuid>("tool-guid") {
            request = request.tool_guid(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAnalysisToolName>("tool-name") {
            request = request.tool_name(value.clone());
        }

        self.over
            .execute_code_scanning_list_alerts_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_get_alert(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_get_alert();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AlertNumber>("alert-number") {
            request = request.alert_number(value.clone());
        }

        self.over
            .execute_code_scanning_get_alert(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_update_alert(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_update_alert();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AlertNumber>("alert-number") {
            request = request.alert_number(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAlertSetState>("state") {
            request = request.body_map(|body| body.state(value.clone()))
        }

        self.over
            .execute_code_scanning_update_alert(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_list_alert_instances(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_list_alert_instances();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AlertNumber>("alert-number") {
            request = request.alert_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningRef>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_code_scanning_list_alert_instances(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_list_recent_analyses(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_list_recent_analyses();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::CodeScanningListRecentAnalysesDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningRef>("ref") {
            request = request.ref_(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAnalysisSarifId>("sarif-id") {
            request = request.sarif_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningListRecentAnalysesSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAnalysisToolGuid>("tool-guid") {
            request = request.tool_guid(value.clone());
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAnalysisToolName>("tool-name") {
            request = request.tool_name(value.clone());
        }

        self.over
            .execute_code_scanning_list_recent_analyses(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_get_analysis(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_get_analysis();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("analysis-id") {
            request = request.analysis_id(value.clone());
        }

        self.over
            .execute_code_scanning_get_analysis(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_delete_analysis(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_delete_analysis();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("analysis-id") {
            request = request.analysis_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("confirm-delete") {
            request = request.confirm_delete(value.clone());
        }

        self.over
            .execute_code_scanning_delete_analysis(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_list_codeql_databases(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_list_codeql_databases();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_code_scanning_list_codeql_databases(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_get_codeql_database(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_get_codeql_database();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("language") {
            request = request.language(value.clone());
        }

        self.over
            .execute_code_scanning_get_codeql_database(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_get_default_setup(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_get_default_setup();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_code_scanning_get_default_setup(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_update_default_setup(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_update_default_setup();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::CodeScanningDefaultSetupUpdateQuerySuite>("query-suite")
        {
            request = request.body_map(|body| body.query_suite(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::CodeScanningDefaultSetupUpdateState>("state")
        {
            request = request.body_map(|body| body.state(value.clone()))
        }

        self.over
            .execute_code_scanning_update_default_setup(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_upload_sarif(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_upload_sarif();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("checkout-uri") {
            request = request.body_map(|body| body.checkout_uri(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAnalysisCommitSha>("commit-sha") {
            request = request.body_map(|body| body.commit_sha(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::CodeScanningRef>("ref") {
            request = request.body_map(|body| body.ref_(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::CodeScanningAnalysisSarifFile>("sarif") {
            request = request.body_map(|body| body.sarif(value.clone()))
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("started-at")
        {
            request = request.body_map(|body| body.started_at(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("tool-name") {
            request = request.body_map(|body| body.tool_name(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("validate") {
            request = request.body_map(|body| body.validate(value.clone()))
        }

        self.over
            .execute_code_scanning_upload_sarif(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_code_scanning_get_sarif(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.code_scanning_get_sarif();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("sarif-id") {
            request = request.sarif_id(value.clone());
        }

        self.over
            .execute_code_scanning_get_sarif(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_codeowners_errors(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_codeowners_errors();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_repos_codeowners_errors(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_list_in_repository_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_list_in_repository_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_codespaces_list_in_repository_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_create_with_repo_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_create_with_repo_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_codespaces_create_with_repo_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_list_devcontainers_in_repository_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_list_devcontainers_in_repository_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_codespaces_list_devcontainers_in_repository_for_authenticated_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_repo_machines_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_repo_machines_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("client-ip") {
            request = request.client_ip(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("location") {
            request = request.location(value.clone());
        }

        self.over
            .execute_codespaces_repo_machines_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_pre_flight_with_repo_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_pre_flight_with_repo_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("client-ip") {
            request = request.client_ip(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_codespaces_pre_flight_with_repo_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_list_repo_secrets(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_list_repo_secrets();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_codespaces_list_repo_secrets(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_get_repo_public_key(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_get_repo_public_key();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_codespaces_get_repo_public_key(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_get_repo_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_get_repo_secret();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_codespaces_get_repo_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_create_or_update_repo_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_create_or_update_repo_secret();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::CodespacesCreateOrUpdateRepoSecretBodyEncryptedValue>(
                "encrypted-value",
            )
        {
            request = request.body_map(|body| body.encrypted_value(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("key-id") {
            request = request.body_map(|body| body.key_id(value.clone()))
        }

        self.over
            .execute_codespaces_create_or_update_repo_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_delete_repo_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_delete_repo_secret();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_codespaces_delete_repo_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_collaborators(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_collaborators();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReposListCollaboratorsAffiliation>("affiliation")
        {
            request = request.affiliation(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReposListCollaboratorsPermission>("permission")
        {
            request = request.permission(value.clone());
        }

        self.over
            .execute_repos_list_collaborators(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_check_collaborator(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_check_collaborator();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_repos_check_collaborator(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_add_collaborator(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_add_collaborator();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("permission") {
            request = request.body_map(|body| body.permission(value.clone()))
        }

        self.over
            .execute_repos_add_collaborator(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_remove_collaborator(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_remove_collaborator();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_repos_remove_collaborator(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_collaborator_permission_level(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_get_collaborator_permission_level();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_repos_get_collaborator_permission_level(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_commit_comments_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_commit_comments_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_commit_comments_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_commit_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_commit_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        self.over
            .execute_repos_get_commit_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_commit_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_commit_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        self.over
            .execute_repos_delete_commit_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_commit_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_update_commit_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_repos_update_commit_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_list_for_commit_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_list_for_commit_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsListForCommitCommentContent>("content")
        {
            request = request.content(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_reactions_list_for_commit_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_create_for_commit_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_create_for_commit_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsCreateForCommitCommentBodyContent>("content")
        {
            request = request.body_map(|body| body.content(value.clone()))
        }

        self.over
            .execute_reactions_create_for_commit_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_delete_for_commit_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_delete_for_commit_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("reaction-id") {
            request = request.reaction_id(value.clone());
        }

        self.over
            .execute_reactions_delete_for_commit_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_commits(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_commits();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("author") {
            request = request.author(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("committer") {
            request = request.committer(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("path") {
            request = request.path(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("sha") {
            request = request.sha(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("until") {
            request = request.until(value.clone());
        }

        self.over
            .execute_repos_list_commits(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_branches_for_head_commit(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_branches_for_head_commit();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("commit-sha") {
            request = request.commit_sha(value.clone());
        }

        self.over
            .execute_repos_list_branches_for_head_commit(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_comments_for_commit(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_comments_for_commit();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("commit-sha") {
            request = request.commit_sha(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_comments_for_commit(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_commit_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_commit_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("commit-sha") {
            request = request.commit_sha(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("line") {
            request = request.body_map(|body| body.line(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("path") {
            request = request.body_map(|body| body.path(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("position") {
            request = request.body_map(|body| body.position(value.clone()))
        }

        self.over
            .execute_repos_create_commit_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_pull_requests_associated_with_commit(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .repos_list_pull_requests_associated_with_commit();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("commit-sha") {
            request = request.commit_sha(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_pull_requests_associated_with_commit(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_commit(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_commit();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_get_commit(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_list_for_ref(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_list_for_ref();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("app-id") {
            request = request.app_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("check-name") {
            request = request.check_name(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ChecksListForRefFilter>("filter") {
            request = request.filter(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ChecksListForRefStatus>("status") {
            request = request.status(value.clone());
        }

        self.over
            .execute_checks_list_for_ref(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_checks_list_suites_for_ref(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.checks_list_suites_for_ref();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("app-id") {
            request = request.app_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("check-name") {
            request = request.check_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_checks_list_suites_for_ref(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_combined_status_for_ref(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_combined_status_for_ref();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_get_combined_status_for_ref(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_commit_statuses_for_ref(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_commit_statuses_for_ref();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_commit_statuses_for_ref(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_community_profile_metrics(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_community_profile_metrics();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_community_profile_metrics(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_compare_commits(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_compare_commits();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("basehead") {
            request = request.basehead(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_compare_commits(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_content(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_content();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("path") {
            request = request.path(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_repos_get_content(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_or_update_file_contents(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_or_update_file_contents();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("path") {
            request = request.path(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.body_map(|body| body.branch(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("content") {
            request = request.body_map(|body| body.content(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("message") {
            request = request.body_map(|body| body.message(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("sha") {
            request = request.body_map(|body| body.sha(value.clone()))
        }

        self.over
            .execute_repos_create_or_update_file_contents(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_file(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_file();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("path") {
            request = request.path(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.body_map(|body| body.branch(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("message") {
            request = request.body_map(|body| body.message(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("sha") {
            request = request.body_map(|body| body.sha(value.clone()))
        }

        self.over
            .execute_repos_delete_file(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_contributors(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_contributors();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("anon") {
            request = request.anon(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_contributors(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_list_alerts_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_list_alerts_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("after") {
            request = request.after(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("before") {
            request = request.before(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::DependabotListAlertsForRepoDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ecosystem") {
            request = request.ecosystem(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("first") {
            request = request.first(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("last") {
            request = request.last(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("manifest") {
            request = request.manifest(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package") {
            request = request.package(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::DependabotListAlertsForRepoScope>("scope") {
            request = request.scope(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("severity") {
            request = request.severity(value.clone());
        }

        if let Some(value) = matches.get_one::<types::DependabotListAlertsForRepoSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("state") {
            request = request.state(value.clone());
        }

        self.over
            .execute_dependabot_list_alerts_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_get_alert(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_get_alert();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AlertNumber>("alert-number") {
            request = request.alert_number(value.clone());
        }

        self.over
            .execute_dependabot_get_alert(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_update_alert(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_update_alert();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AlertNumber>("alert-number") {
            request = request.alert_number(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::DependabotUpdateAlertBodyDismissedComment>("dismissed-comment")
        {
            request = request.body_map(|body| body.dismissed_comment(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::DependabotUpdateAlertBodyDismissedReason>("dismissed-reason")
        {
            request = request.body_map(|body| body.dismissed_reason(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::DependabotUpdateAlertBodyState>("state") {
            request = request.body_map(|body| body.state(value.clone()))
        }

        self.over
            .execute_dependabot_update_alert(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_list_repo_secrets(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_list_repo_secrets();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_dependabot_list_repo_secrets(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_get_repo_public_key(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_get_repo_public_key();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_dependabot_get_repo_public_key(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_get_repo_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_get_repo_secret();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_dependabot_get_repo_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_create_or_update_repo_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.dependabot_create_or_update_repo_secret();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::DependabotCreateOrUpdateRepoSecretBodyEncryptedValue>(
                "encrypted-value",
            )
        {
            request = request.body_map(|body| body.encrypted_value(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("key-id") {
            request = request.body_map(|body| body.key_id(value.clone()))
        }

        self.over
            .execute_dependabot_create_or_update_repo_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependabot_delete_repo_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependabot_delete_repo_secret();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_dependabot_delete_repo_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependency_graph_diff_range(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependency_graph_diff_range();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("basehead") {
            request = request.basehead(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_dependency_graph_diff_range(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependency_graph_export_sbom(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.dependency_graph_export_sbom();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_dependency_graph_export_sbom(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_dependency_graph_create_repository_snapshot(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.dependency_graph_create_repository_snapshot();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SnapshotRef>("ref") {
            request = request.body_map(|body| body.ref_(value.clone()))
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("scanned") {
            request = request.body_map(|body| body.scanned(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::SnapshotSha>("sha") {
            request = request.body_map(|body| body.sha(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("version") {
            request = request.body_map(|body| body.version(value.clone()))
        }

        self.over
            .execute_dependency_graph_create_repository_snapshot(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_deployments(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_deployments();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment") {
            request = request.environment(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("sha") {
            request = request.sha(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("task") {
            request = request.task(value.clone());
        }

        self.over
            .execute_repos_list_deployments(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_deployment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_deployment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("auto-merge") {
            request = request.body_map(|body| body.auto_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("environment") {
            request = request.body_map(|body| body.environment(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("production-environment") {
            request = request.body_map(|body| body.production_environment(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.body_map(|body| body.ref_(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("task") {
            request = request.body_map(|body| body.task(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("transient-environment") {
            request = request.body_map(|body| body.transient_environment(value.clone()))
        }

        self.over
            .execute_repos_create_deployment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_deployment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_deployment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("deployment-id") {
            request = request.deployment_id(value.clone());
        }

        self.over
            .execute_repos_get_deployment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_deployment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_deployment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("deployment-id") {
            request = request.deployment_id(value.clone());
        }

        self.over
            .execute_repos_delete_deployment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_deployment_statuses(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_deployment_statuses();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("deployment-id") {
            request = request.deployment_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_deployment_statuses(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_deployment_status(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_deployment_status();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("deployment-id") {
            request = request.deployment_id(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("auto-inactive") {
            request = request.body_map(|body| body.auto_inactive(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::ReposCreateDeploymentStatusBodyEnvironment>("environment")
        {
            request = request.body_map(|body| body.environment(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("environment-url") {
            request = request.body_map(|body| body.environment_url(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("log-url") {
            request = request.body_map(|body| body.log_url(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ReposCreateDeploymentStatusBodyState>("state")
        {
            request = request.body_map(|body| body.state(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("target-url") {
            request = request.body_map(|body| body.target_url(value.clone()))
        }

        self.over
            .execute_repos_create_deployment_status(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_deployment_status(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_deployment_status();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("deployment-id") {
            request = request.deployment_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("status-id") {
            request = request.status_id(value.clone());
        }

        self.over
            .execute_repos_get_deployment_status(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_dispatch_event(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_dispatch_event();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReposCreateDispatchEventBodyEventType>("event-type")
        {
            request = request.body_map(|body| body.event_type(value.clone()))
        }

        self.over
            .execute_repos_create_dispatch_event(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_all_environments(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_all_environments();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_get_all_environments(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_environment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_environment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        self.over
            .execute_repos_get_environment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_or_update_environment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_or_update_environment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        self.over
            .execute_repos_create_or_update_environment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_an_environment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_an_environment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        self.over
            .execute_repos_delete_an_environment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_deployment_branch_policies(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_deployment_branch_policies();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_deployment_branch_policies(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_deployment_branch_policy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_deployment_branch_policy();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_repos_create_deployment_branch_policy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_deployment_branch_policy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_deployment_branch_policy();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("branch-policy-id") {
            request = request.branch_policy_id(value.clone());
        }

        self.over
            .execute_repos_get_deployment_branch_policy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_deployment_branch_policy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_update_deployment_branch_policy();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("branch-policy-id") {
            request = request.branch_policy_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_repos_update_deployment_branch_policy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_deployment_branch_policy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_deployment_branch_policy();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("branch-policy-id") {
            request = request.branch_policy_id(value.clone());
        }

        self.over
            .execute_repos_delete_deployment_branch_policy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_all_deployment_protection_rules(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_get_all_deployment_protection_rules();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        self.over
            .execute_repos_get_all_deployment_protection_rules(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_deployment_protection_rule(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_create_deployment_protection_rule();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("integration-id") {
            request = request.body_map(|body| body.integration_id(value.clone()))
        }

        self.over
            .execute_repos_create_deployment_protection_rule(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_custom_deployment_rule_integrations(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_list_custom_deployment_rule_integrations();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_custom_deployment_rule_integrations(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_custom_deployment_protection_rule(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_get_custom_deployment_protection_rule();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("protection-rule-id") {
            request = request.protection_rule_id(value.clone());
        }

        self.over
            .execute_repos_get_custom_deployment_protection_rule(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_disable_deployment_protection_rule(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_disable_deployment_protection_rule();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("protection-rule-id") {
            request = request.protection_rule_id(value.clone());
        }

        self.over
            .execute_repos_disable_deployment_protection_rule(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_repo_events(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_list_repo_events();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_repo_events(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_forks(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_forks();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReposListForksSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_repos_list_forks(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_fork(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_fork();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_create_fork(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_create_blob(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_create_blob();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("content") {
            request = request.body_map(|body| body.content(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("encoding") {
            request = request.body_map(|body| body.encoding(value.clone()))
        }

        self.over
            .execute_git_create_blob(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_get_blob(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_get_blob();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("file-sha") {
            request = request.file_sha(value.clone());
        }

        self.over
            .execute_git_get_blob(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_create_commit(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_create_commit();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("message") {
            request = request.body_map(|body| body.message(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("signature") {
            request = request.body_map(|body| body.signature(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("tree") {
            request = request.body_map(|body| body.tree(value.clone()))
        }

        self.over
            .execute_git_create_commit(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_get_commit(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_get_commit();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("commit-sha") {
            request = request.commit_sha(value.clone());
        }

        self.over
            .execute_git_get_commit(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_list_matching_refs(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_list_matching_refs();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_git_list_matching_refs(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_get_ref(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_get_ref();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_git_get_ref(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_create_ref(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_create_ref();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("key") {
            request = request.body_map(|body| body.key(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.body_map(|body| body.ref_(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("sha") {
            request = request.body_map(|body| body.sha(value.clone()))
        }

        self.over
            .execute_git_create_ref(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_delete_ref(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_delete_ref();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_git_delete_ref(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_update_ref(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_update_ref();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("force") {
            request = request.body_map(|body| body.force(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("sha") {
            request = request.body_map(|body| body.sha(value.clone()))
        }

        self.over
            .execute_git_update_ref(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_create_tag(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_create_tag();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("message") {
            request = request.body_map(|body| body.message(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("object") {
            request = request.body_map(|body| body.object(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("tag") {
            request = request.body_map(|body| body.tag(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::GitCreateTagBodyType>("type") {
            request = request.body_map(|body| body.type_(value.clone()))
        }

        self.over
            .execute_git_create_tag(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_get_tag(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_get_tag();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("tag-sha") {
            request = request.tag_sha(value.clone());
        }

        self.over
            .execute_git_get_tag(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_create_tree(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_create_tree();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("base-tree") {
            request = request.body_map(|body| body.base_tree(value.clone()))
        }

        self.over
            .execute_git_create_tree(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_git_get_tree(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.git_get_tree();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("tree-sha") {
            request = request.tree_sha(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("recursive") {
            request = request.recursive(value.clone());
        }

        self.over
            .execute_git_get_tree(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_webhooks(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_webhooks();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_webhooks(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_webhook(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_webhook();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_create_webhook(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_webhook(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_webhook();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        self.over
            .execute_repos_get_webhook(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_webhook(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_webhook();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        self.over
            .execute_repos_delete_webhook(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_webhook(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_update_webhook();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("active") {
            request = request.body_map(|body| body.active(value.clone()))
        }

        self.over
            .execute_repos_update_webhook(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_webhook_config_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_webhook_config_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        self.over
            .execute_repos_get_webhook_config_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_webhook_config_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_update_webhook_config_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::WebhookConfigContentType>("content-type") {
            request = request.body_map(|body| body.content_type(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::WebhookConfigInsecureSsl>("insecure-ssl") {
            request = request.body_map(|body| body.insecure_ssl(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::WebhookConfigSecret>("secret") {
            request = request.body_map(|body| body.secret(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::WebhookConfigUrl>("url") {
            request = request.body_map(|body| body.url(value.clone()))
        }

        self.over
            .execute_repos_update_webhook_config_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_webhook_deliveries(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_webhook_deliveries();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("cursor") {
            request = request.cursor(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("redelivery") {
            request = request.redelivery(value.clone());
        }

        self.over
            .execute_repos_list_webhook_deliveries(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_webhook_delivery(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_webhook_delivery();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("delivery-id") {
            request = request.delivery_id(value.clone());
        }

        self.over
            .execute_repos_get_webhook_delivery(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_redeliver_webhook_delivery(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_redeliver_webhook_delivery();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("delivery-id") {
            request = request.delivery_id(value.clone());
        }

        self.over
            .execute_repos_redeliver_webhook_delivery(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_ping_webhook(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_ping_webhook();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        self.over
            .execute_repos_ping_webhook(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_test_push_webhook(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_test_push_webhook();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("hook-id") {
            request = request.hook_id(value.clone());
        }

        self.over
            .execute_repos_test_push_webhook(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_get_import_status(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_get_import_status();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_migrations_get_import_status(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_start_import(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_start_import();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("tfvc-project") {
            request = request.body_map(|body| body.tfvc_project(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::MigrationsStartImportBodyVcs>("vcs") {
            request = request.body_map(|body| body.vcs(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("vcs-password") {
            request = request.body_map(|body| body.vcs_password(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("vcs-url") {
            request = request.body_map(|body| body.vcs_url(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("vcs-username") {
            request = request.body_map(|body| body.vcs_username(value.clone()))
        }

        self.over
            .execute_migrations_start_import(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_cancel_import(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_cancel_import();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_migrations_cancel_import(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_update_import(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_update_import();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_migrations_update_import(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_get_commit_authors(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_get_commit_authors();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("since") {
            request = request.since(value.clone());
        }

        self.over
            .execute_migrations_get_commit_authors(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_map_commit_author(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_map_commit_author();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("author-id") {
            request = request.author_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("email") {
            request = request.body_map(|body| body.email(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_migrations_map_commit_author(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_get_large_files(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_get_large_files();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_migrations_get_large_files(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_set_lfs_preference(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_set_lfs_preference();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::MigrationsSetLfsPreferenceBodyUseLfs>("use-lfs")
        {
            request = request.body_map(|body| body.use_lfs(value.clone()))
        }

        self.over
            .execute_migrations_set_lfs_preference(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_get_repo_installation(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_get_repo_installation();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_apps_get_repo_installation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_interactions_get_restrictions_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.interactions_get_restrictions_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_interactions_get_restrictions_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_interactions_set_restrictions_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.interactions_set_restrictions_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::InteractionExpiry>("expiry") {
            request = request.body_map(|body| body.expiry(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::InteractionGroup>("limit") {
            request = request.body_map(|body| body.limit(value.clone()))
        }

        self.over
            .execute_interactions_set_restrictions_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_interactions_remove_restrictions_for_repo(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.interactions_remove_restrictions_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_interactions_remove_restrictions_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_invitations(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_invitations();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_invitations(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_invitation(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_invitation();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("invitation-id") {
            request = request.invitation_id(value.clone());
        }

        self.over
            .execute_repos_delete_invitation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_invitation(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_update_invitation();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("invitation-id") {
            request = request.invitation_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReposUpdateInvitationBodyPermissions>("permissions")
        {
            request = request.body_map(|body| body.permissions(value.clone()))
        }

        self.over
            .execute_repos_update_invitation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("assignee") {
            request = request.assignee(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("creator") {
            request = request.creator(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListForRepoDirection>("direction") {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("labels") {
            request = request.labels(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("mentioned") {
            request = request.mentioned(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("milestone") {
            request = request.milestone(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListForRepoSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListForRepoState>("state") {
            request = request.state(value.clone());
        }

        self.over
            .execute_issues_list_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_create(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_create();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("assignee") {
            request = request.body_map(|body| body.assignee(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::IssuesCreateBodyMilestone>("milestone") {
            request = request.body_map(|body| body.milestone(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::IssuesCreateBodyTitle>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_issues_create(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_comments_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_comments_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::IssuesListCommentsForRepoDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListCommentsForRepoSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_issues_list_comments_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_get_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_get_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        self.over
            .execute_issues_get_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_delete_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_delete_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        self.over
            .execute_issues_delete_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_update_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_update_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_issues_update_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_list_for_issue_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_list_for_issue_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsListForIssueCommentContent>("content")
        {
            request = request.content(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_reactions_list_for_issue_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_create_for_issue_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_create_for_issue_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsCreateForIssueCommentBodyContent>("content")
        {
            request = request.body_map(|body| body.content(value.clone()))
        }

        self.over
            .execute_reactions_create_for_issue_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_delete_for_issue_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_delete_for_issue_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("reaction-id") {
            request = request.reaction_id(value.clone());
        }

        self.over
            .execute_reactions_delete_for_issue_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_events_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_events_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_issues_list_events_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_get_event(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_get_event();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("event-id") {
            request = request.event_id(value.clone());
        }

        self.over
            .execute_issues_get_event(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_get(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_get();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        self.over.execute_issues_get(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_update(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_update();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("assignee") {
            request = request.body_map(|body| body.assignee(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::IssuesUpdateBodyMilestone>("milestone") {
            request = request.body_map(|body| body.milestone(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::IssuesUpdateBodyState>("state") {
            request = request.body_map(|body| body.state(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::IssuesUpdateBodyStateReason>("state-reason") {
            request = request.body_map(|body| body.state_reason(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::IssuesUpdateBodyTitle>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_issues_update(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_add_assignees(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_add_assignees();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        self.over
            .execute_issues_add_assignees(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_remove_assignees(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_remove_assignees();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        self.over
            .execute_issues_remove_assignees(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_check_user_can_be_assigned_to_issue(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.issues_check_user_can_be_assigned_to_issue();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("assignee") {
            request = request.assignee(value.clone());
        }

        self.over
            .execute_issues_check_user_can_be_assigned_to_issue(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_comments(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_comments();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        self.over
            .execute_issues_list_comments(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_create_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_create_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_issues_create_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_events(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_events();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_issues_list_events(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_labels_on_issue(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_labels_on_issue();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_issues_list_labels_on_issue(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_set_labels(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_set_labels();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        self.over
            .execute_issues_set_labels(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_add_labels(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_add_labels();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        self.over
            .execute_issues_add_labels(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_remove_all_labels(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_remove_all_labels();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        self.over
            .execute_issues_remove_all_labels(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_remove_label(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_remove_label();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_issues_remove_label(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_lock(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_lock();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        self.over
            .execute_issues_lock(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_unlock(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_unlock();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        self.over
            .execute_issues_unlock(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_list_for_issue(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_list_for_issue();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReactionsListForIssueContent>("content") {
            request = request.content(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_reactions_list_for_issue(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_create_for_issue(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_create_for_issue();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReactionsCreateForIssueBodyContent>("content")
        {
            request = request.body_map(|body| body.content(value.clone()))
        }

        self.over
            .execute_reactions_create_for_issue(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_delete_for_issue(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_delete_for_issue();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("reaction-id") {
            request = request.reaction_id(value.clone());
        }

        self.over
            .execute_reactions_delete_for_issue(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_events_for_timeline(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_events_for_timeline();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("issue-number") {
            request = request.issue_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_issues_list_events_for_timeline(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_deploy_keys(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_deploy_keys();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_deploy_keys(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_deploy_key(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_deploy_key();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("key") {
            request = request.body_map(|body| body.key(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("read-only") {
            request = request.body_map(|body| body.read_only(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_repos_create_deploy_key(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_deploy_key(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_deploy_key();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("key-id") {
            request = request.key_id(value.clone());
        }

        self.over
            .execute_repos_get_deploy_key(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_deploy_key(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_deploy_key();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("key-id") {
            request = request.key_id(value.clone());
        }

        self.over
            .execute_repos_delete_deploy_key(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_labels_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_labels_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_issues_list_labels_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_create_label(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_create_label();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("color") {
            request = request.body_map(|body| body.color(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_issues_create_label(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_get_label(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_get_label();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_issues_get_label(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_delete_label(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_delete_label();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_issues_delete_label(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_update_label(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_update_label();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("color") {
            request = request.body_map(|body| body.color(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("new-name") {
            request = request.body_map(|body| body.new_name(value.clone()))
        }

        self.over
            .execute_issues_update_label(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_languages(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_languages();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_list_languages(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_enable_lfs_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_enable_lfs_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_enable_lfs_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_disable_lfs_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_disable_lfs_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_disable_lfs_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_licenses_get_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.licenses_get_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_licenses_get_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_merge_upstream(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_merge_upstream();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.body_map(|body| body.branch(value.clone()))
        }

        self.over
            .execute_repos_merge_upstream(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_merge(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_merge();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("base") {
            request = request.body_map(|body| body.base(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("commit-message") {
            request = request.body_map(|body| body.commit_message(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("head") {
            request = request.body_map(|body| body.head(value.clone()))
        }

        self.over
            .execute_repos_merge(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_milestones(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_milestones();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListMilestonesDirection>("direction") {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListMilestonesSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListMilestonesState>("state") {
            request = request.state(value.clone());
        }

        self.over
            .execute_issues_list_milestones(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_create_milestone(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_create_milestone();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("due-on") {
            request = request.body_map(|body| body.due_on(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::IssuesCreateMilestoneBodyState>("state") {
            request = request.body_map(|body| body.state(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_issues_create_milestone(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_get_milestone(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_get_milestone();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("milestone-number") {
            request = request.milestone_number(value.clone());
        }

        self.over
            .execute_issues_get_milestone(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_delete_milestone(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_delete_milestone();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("milestone-number") {
            request = request.milestone_number(value.clone());
        }

        self.over
            .execute_issues_delete_milestone(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_update_milestone(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_update_milestone();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("milestone-number") {
            request = request.milestone_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("due-on") {
            request = request.body_map(|body| body.due_on(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::IssuesUpdateMilestoneBodyState>("state") {
            request = request.body_map(|body| body.state(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_issues_update_milestone(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_labels_for_milestone(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_labels_for_milestone();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("milestone-number") {
            request = request.milestone_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_issues_list_labels_for_milestone(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_repo_notifications_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .activity_list_repo_notifications_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("all") {
            request = request.all(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("before") {
            request = request.before(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("participating") {
            request = request.participating(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        self.over
            .execute_activity_list_repo_notifications_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_mark_repo_notifications_as_read(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.activity_mark_repo_notifications_as_read();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("last-read-at")
        {
            request = request.body_map(|body| body.last_read_at(value.clone()))
        }

        self.over
            .execute_activity_mark_repo_notifications_as_read(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_pages(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_pages();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_pages(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_information_about_pages_site(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_update_information_about_pages_site();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::ReposUpdateInformationAboutPagesSiteBodyBuildType>("build-type")
        {
            request = request.body_map(|body| body.build_type(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("cname") {
            request = request.body_map(|body| body.cname(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("https-enforced") {
            request = request.body_map(|body| body.https_enforced(value.clone()))
        }

        self.over
            .execute_repos_update_information_about_pages_site(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_pages_site(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_pages_site();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_create_pages_site(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_pages_site(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_pages_site();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_delete_pages_site(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_pages_builds(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_pages_builds();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_pages_builds(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_request_pages_build(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_request_pages_build();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_request_pages_build(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_latest_pages_build(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_latest_pages_build();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_latest_pages_build(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_pages_build(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_pages_build();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("build-id") {
            request = request.build_id(value.clone());
        }

        self.over
            .execute_repos_get_pages_build(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_pages_deployment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_pages_deployment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("artifact-url") {
            request = request.body_map(|body| body.artifact_url(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("environment") {
            request = request.body_map(|body| body.environment(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("oidc-token") {
            request = request.body_map(|body| body.oidc_token(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("pages-build-version") {
            request = request.body_map(|body| body.pages_build_version(value.clone()))
        }

        self.over
            .execute_repos_create_pages_deployment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_pages_health_check(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_pages_health_check();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_pages_health_check(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_list_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_list_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ProjectsListForRepoState>("state") {
            request = request.state(value.clone());
        }

        self.over
            .execute_projects_list_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_create_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_create_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_projects_create_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_list(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_list();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("base") {
            request = request.base(value.clone());
        }

        if let Some(value) = matches.get_one::<types::PullsListDirection>("direction") {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("head") {
            request = request.head(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::PullsListSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::PullsListState>("state") {
            request = request.state(value.clone());
        }

        self.over.execute_pulls_list(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_create(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_create();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("base") {
            request = request.body_map(|body| body.base(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("draft") {
            request = request.body_map(|body| body.draft(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("head") {
            request = request.body_map(|body| body.head(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("head-repo") {
            request = request.body_map(|body| body.head_repo(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("issue") {
            request = request.body_map(|body| body.issue(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("maintainer-can-modify") {
            request = request.body_map(|body| body.maintainer_can_modify(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_pulls_create(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_list_review_comments_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_list_review_comments_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PullsListReviewCommentsForRepoDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        if let Some(value) = matches.get_one::<types::PullsListReviewCommentsForRepoSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_pulls_list_review_comments_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_get_review_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_get_review_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        self.over
            .execute_pulls_get_review_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_delete_review_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_delete_review_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        self.over
            .execute_pulls_delete_review_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_update_review_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_update_review_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_pulls_update_review_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_list_for_pull_request_review_comment(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.reactions_list_for_pull_request_review_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsListForPullRequestReviewCommentContent>("content")
        {
            request = request.content(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_reactions_list_for_pull_request_review_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_create_for_pull_request_review_comment(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .reactions_create_for_pull_request_review_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::ReactionsCreateForPullRequestReviewCommentBodyContent>("content")
        {
            request = request.body_map(|body| body.content(value.clone()))
        }

        self.over
            .execute_reactions_create_for_pull_request_review_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_delete_for_pull_request_comment(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.reactions_delete_for_pull_request_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("reaction-id") {
            request = request.reaction_id(value.clone());
        }

        self.over
            .execute_reactions_delete_for_pull_request_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_get(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_get();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        self.over.execute_pulls_get(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_update(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_update();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("base") {
            request = request.body_map(|body| body.base(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("maintainer-can-modify") {
            request = request.body_map(|body| body.maintainer_can_modify(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::PullsUpdateBodyState>("state") {
            request = request.body_map(|body| body.state(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_pulls_update(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_create_with_pr_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_create_with_pr_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        self.over
            .execute_codespaces_create_with_pr_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_list_review_comments(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_list_review_comments();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<types::PullsListReviewCommentsDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        if let Some(value) = matches.get_one::<types::PullsListReviewCommentsSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_pulls_list_review_comments(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_create_review_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_create_review_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("commit-id") {
            request = request.body_map(|body| body.commit_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("in-reply-to") {
            request = request.body_map(|body| body.in_reply_to(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("line") {
            request = request.body_map(|body| body.line(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("path") {
            request = request.body_map(|body| body.path(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("position") {
            request = request.body_map(|body| body.position(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::PullsCreateReviewCommentBodySide>("side") {
            request = request.body_map(|body| body.side(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("start-line") {
            request = request.body_map(|body| body.start_line(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::PullsCreateReviewCommentBodyStartSide>("start-side")
        {
            request = request.body_map(|body| body.start_side(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::PullsCreateReviewCommentBodySubjectType>("subject-type")
        {
            request = request.body_map(|body| body.subject_type(value.clone()))
        }

        self.over
            .execute_pulls_create_review_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_create_reply_for_review_comment(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_create_reply_for_review_comment();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-id") {
            request = request.comment_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_pulls_create_reply_for_review_comment(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_list_commits(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_list_commits();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_pulls_list_commits(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_list_files(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_list_files();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_pulls_list_files(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_check_if_merged(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_check_if_merged();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        self.over
            .execute_pulls_check_if_merged(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_merge(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_merge();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        self.over
            .execute_pulls_merge(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_list_requested_reviewers(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_list_requested_reviewers();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        self.over
            .execute_pulls_list_requested_reviewers(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_request_reviewers(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_request_reviewers();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        self.over
            .execute_pulls_request_reviewers(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_remove_requested_reviewers(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_remove_requested_reviewers();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        self.over
            .execute_pulls_remove_requested_reviewers(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_list_reviews(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_list_reviews();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_pulls_list_reviews(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_create_review(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_create_review();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("commit-id") {
            request = request.body_map(|body| body.commit_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::PullsCreateReviewBodyEvent>("event") {
            request = request.body_map(|body| body.event(value.clone()))
        }

        self.over
            .execute_pulls_create_review(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_get_review(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_get_review();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("review-id") {
            request = request.review_id(value.clone());
        }

        self.over
            .execute_pulls_get_review(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_update_review(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_update_review();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("review-id") {
            request = request.review_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_pulls_update_review(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_delete_pending_review(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_delete_pending_review();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("review-id") {
            request = request.review_id(value.clone());
        }

        self.over
            .execute_pulls_delete_pending_review(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_list_comments_for_review(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_list_comments_for_review();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("review-id") {
            request = request.review_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_pulls_list_comments_for_review(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_dismiss_review(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_dismiss_review();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("review-id") {
            request = request.review_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::PullsDismissReviewBodyEvent>("event") {
            request = request.body_map(|body| body.event(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("message") {
            request = request.body_map(|body| body.message(value.clone()))
        }

        self.over
            .execute_pulls_dismiss_review(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_submit_review(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_submit_review();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("review-id") {
            request = request.review_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::PullsSubmitReviewBodyEvent>("event") {
            request = request.body_map(|body| body.event(value.clone()))
        }

        self.over
            .execute_pulls_submit_review(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_pulls_update_branch(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.pulls_update_branch();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("pull-number") {
            request = request.pull_number(value.clone());
        }

        self.over
            .execute_pulls_update_branch(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_readme(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_readme();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_repos_get_readme(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_readme_in_directory(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_readme_in_directory();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("dir") {
            request = request.dir(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_repos_get_readme_in_directory(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_repos_watched_by_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_list_repos_watched_by_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_repos_watched_by_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_release_asset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_release_asset();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("asset-id") {
            request = request.asset_id(value.clone());
        }

        self.over
            .execute_repos_get_release_asset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_release_asset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_release_asset();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("asset-id") {
            request = request.asset_id(value.clone());
        }

        self.over
            .execute_repos_delete_release_asset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_release_asset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_update_release_asset();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("asset-id") {
            request = request.asset_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("label") {
            request = request.body_map(|body| body.label(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("state") {
            request = request.body_map(|body| body.state(value.clone()))
        }

        self.over
            .execute_repos_update_release_asset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_generate_release_notes(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_generate_release_notes();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("configuration-file-path") {
            request = request.body_map(|body| body.configuration_file_path(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("previous-tag-name") {
            request = request.body_map(|body| body.previous_tag_name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("tag-name") {
            request = request.body_map(|body| body.tag_name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("target-commitish") {
            request = request.body_map(|body| body.target_commitish(value.clone()))
        }

        self.over
            .execute_repos_generate_release_notes(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_latest_release(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_latest_release();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_latest_release(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_release_by_tag(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_release_by_tag();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("tag") {
            request = request.tag(value.clone());
        }

        self.over
            .execute_repos_get_release_by_tag(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_repos_starred_by_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_list_repos_starred_by_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ActivityListReposStarredByUserDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ActivityListReposStarredByUserSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_activity_list_repos_starred_by_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_release_assets(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_release_assets();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("release-id") {
            request = request.release_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_release_assets(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_upload_release_asset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_upload_release_asset();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("release-id") {
            request = request.release_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("label") {
            request = request.label(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_repos_upload_release_asset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_list_for_release(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_list_for_release();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("release-id") {
            request = request.release_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReactionsListForReleaseContent>("content") {
            request = request.content(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_reactions_list_for_release(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_create_for_release(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_create_for_release();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("release-id") {
            request = request.release_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsCreateForReleaseBodyContent>("content")
        {
            request = request.body_map(|body| body.content(value.clone()))
        }

        self.over
            .execute_reactions_create_for_release(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_delete_for_release(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.reactions_delete_for_release();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("release-id") {
            request = request.release_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("reaction-id") {
            request = request.reaction_id(value.clone());
        }

        self.over
            .execute_reactions_delete_for_release(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_branch_rules(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_branch_rules();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("branch") {
            request = request.branch(value.clone());
        }

        self.over
            .execute_repos_get_branch_rules(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_repo_rulesets(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_repo_rulesets();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("includes-parents") {
            request = request.includes_parents(value.clone());
        }

        self.over
            .execute_repos_get_repo_rulesets(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_repo_ruleset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_repo_ruleset();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReposCreateRepoRulesetBodyBypassMode>("bypass-mode")
        {
            request = request.body_map(|body| body.bypass_mode(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::RepositoryRuleEnforcement>("enforcement") {
            request = request.body_map(|body| body.enforcement(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ReposCreateRepoRulesetBodyTarget>("target") {
            request = request.body_map(|body| body.target(value.clone()))
        }

        self.over
            .execute_repos_create_repo_ruleset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_repo_ruleset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_repo_ruleset();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("ruleset-id") {
            request = request.ruleset_id(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("includes-parents") {
            request = request.includes_parents(value.clone());
        }

        self.over
            .execute_repos_get_repo_ruleset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_update_repo_ruleset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_update_repo_ruleset();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("ruleset-id") {
            request = request.ruleset_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReposUpdateRepoRulesetBodyBypassMode>("bypass-mode")
        {
            request = request.body_map(|body| body.bypass_mode(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::RepositoryRuleEnforcement>("enforcement") {
            request = request.body_map(|body| body.enforcement(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ReposUpdateRepoRulesetBodyTarget>("target") {
            request = request.body_map(|body| body.target(value.clone()))
        }

        self.over
            .execute_repos_update_repo_ruleset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_repo_ruleset(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_repo_ruleset();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("ruleset-id") {
            request = request.ruleset_id(value.clone());
        }

        self.over
            .execute_repos_delete_repo_ruleset(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_secret_scanning_list_alerts_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.secret_scanning_list_alerts_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("after") {
            request = request.after(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("before") {
            request = request.before(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::SecretScanningListAlertsForRepoDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("resolution") {
            request = request.resolution(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-type") {
            request = request.secret_type(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SecretScanningListAlertsForRepoSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SecretScanningListAlertsForRepoState>("state")
        {
            request = request.state(value.clone());
        }

        self.over
            .execute_secret_scanning_list_alerts_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_secret_scanning_get_alert(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.secret_scanning_get_alert();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AlertNumber>("alert-number") {
            request = request.alert_number(value.clone());
        }

        self.over
            .execute_secret_scanning_get_alert(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_secret_scanning_update_alert(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.secret_scanning_update_alert();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AlertNumber>("alert-number") {
            request = request.alert_number(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SecretScanningAlertState>("state") {
            request = request.body_map(|body| body.state(value.clone()))
        }

        self.over
            .execute_secret_scanning_update_alert(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_secret_scanning_list_locations_for_alert(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.secret_scanning_list_locations_for_alert();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::AlertNumber>("alert-number") {
            request = request.alert_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_secret_scanning_list_locations_for_alert(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_security_advisories_list_repository_advisories(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.security_advisories_list_repository_advisories();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("after") {
            request = request.after(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("before") {
            request = request.before(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::SecurityAdvisoriesListRepositoryAdvisoriesDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::SecurityAdvisoriesListRepositoryAdvisoriesSort>("sort")
        {
            request = request.sort(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::SecurityAdvisoriesListRepositoryAdvisoriesState>("state")
        {
            request = request.state(value.clone());
        }

        self.over
            .execute_security_advisories_list_repository_advisories(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_security_advisories_create_repository_advisory(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.security_advisories_create_repository_advisory();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("cve-id") {
            request = request.body_map(|body| body.cve_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("cvss-vector-string") {
            request = request.body_map(|body| body.cvss_vector_string(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::RepositoryAdvisoryCreateDescription>("description")
        {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::RepositoryAdvisoryCreateSeverity>("severity")
        {
            request = request.body_map(|body| body.severity(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::RepositoryAdvisoryCreateSummary>("summary") {
            request = request.body_map(|body| body.summary(value.clone()))
        }

        self.over
            .execute_security_advisories_create_repository_advisory(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_security_advisories_create_private_vulnerability_report(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .security_advisories_create_private_vulnerability_report();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("cvss-vector-string") {
            request = request.body_map(|body| body.cvss_vector_string(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::PrivateVulnerabilityReportCreateDescription>("description")
        {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::PrivateVulnerabilityReportCreateSeverity>("severity")
        {
            request = request.body_map(|body| body.severity(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::PrivateVulnerabilityReportCreateSummary>("summary")
        {
            request = request.body_map(|body| body.summary(value.clone()))
        }

        self.over
            .execute_security_advisories_create_private_vulnerability_report(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_security_advisories_get_repository_advisory(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.security_advisories_get_repository_advisory();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ghsa-id") {
            request = request.ghsa_id(value.clone());
        }

        self.over
            .execute_security_advisories_get_repository_advisory(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_security_advisories_update_repository_advisory(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.security_advisories_update_repository_advisory();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ghsa-id") {
            request = request.ghsa_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("cve-id") {
            request = request.body_map(|body| body.cve_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("cvss-vector-string") {
            request = request.body_map(|body| body.cvss_vector_string(value.clone()))
        }

        if let Some(value) =
            matches.get_one::<types::RepositoryAdvisoryUpdateDescription>("description")
        {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::RepositoryAdvisoryUpdateSeverity>("severity")
        {
            request = request.body_map(|body| body.severity(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::RepositoryAdvisoryUpdateState>("state") {
            request = request.body_map(|body| body.state(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::RepositoryAdvisoryUpdateSummary>("summary") {
            request = request.body_map(|body| body.summary(value.clone()))
        }

        self.over
            .execute_security_advisories_update_repository_advisory(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_stargazers_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_list_stargazers_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_stargazers_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_code_frequency_stats(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_code_frequency_stats();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_code_frequency_stats(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_commit_activity_stats(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_commit_activity_stats();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_commit_activity_stats(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_contributors_stats(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_contributors_stats();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_contributors_stats(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_participation_stats(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_participation_stats();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_participation_stats(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_punch_card_stats(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_punch_card_stats();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_punch_card_stats(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_commit_status(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_commit_status();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("sha") {
            request = request.sha(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("context") {
            request = request.body_map(|body| body.context(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::ReposCreateCommitStatusBodyState>("state") {
            request = request.body_map(|body| body.state(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("target-url") {
            request = request.body_map(|body| body.target_url(value.clone()))
        }

        self.over
            .execute_repos_create_commit_status(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_watchers_for_repo(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_list_watchers_for_repo();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_watchers_for_repo(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_get_repo_subscription(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_get_repo_subscription();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_activity_get_repo_subscription(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_set_repo_subscription(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_set_repo_subscription();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<bool>("ignored") {
            request = request.body_map(|body| body.ignored(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("subscribed") {
            request = request.body_map(|body| body.subscribed(value.clone()))
        }

        self.over
            .execute_activity_set_repo_subscription(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_delete_repo_subscription(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_delete_repo_subscription();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_activity_delete_repo_subscription(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_tags(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_tags();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_tags(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_tag_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_tag_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_list_tag_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_tag_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_tag_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("pattern") {
            request = request.body_map(|body| body.pattern(value.clone()))
        }

        self.over
            .execute_repos_create_tag_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_delete_tag_protection(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_delete_tag_protection();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("tag-protection-id") {
            request = request.tag_protection_id(value.clone());
        }

        self.over
            .execute_repos_delete_tag_protection(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_download_tarball_archive(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_download_tarball_archive();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_repos_download_tarball_archive(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                todo!()
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_teams(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_teams();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_teams(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_all_topics(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_all_topics();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_get_all_topics(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_replace_all_topics(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_replace_all_topics();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_replace_all_topics(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_clones(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_clones();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReposGetClonesPer>("per") {
            request = request.per(value.clone());
        }

        self.over
            .execute_repos_get_clones(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_top_paths(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_top_paths();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_top_paths(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_top_referrers(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_top_referrers();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_get_top_referrers(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_get_views(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_get_views();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReposGetViewsPer>("per") {
            request = request.per(value.clone());
        }

        self.over
            .execute_repos_get_views(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_transfer(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_transfer();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("new-name") {
            request = request.body_map(|body| body.new_name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("new-owner") {
            request = request.body_map(|body| body.new_owner(value.clone()))
        }

        self.over
            .execute_repos_transfer(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_check_vulnerability_alerts(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_check_vulnerability_alerts();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_check_vulnerability_alerts(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_enable_vulnerability_alerts(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_enable_vulnerability_alerts();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_enable_vulnerability_alerts(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_disable_vulnerability_alerts(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_disable_vulnerability_alerts();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_repos_disable_vulnerability_alerts(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_download_zipball_archive(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_download_zipball_archive();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("ref") {
            request = request.ref_(value.clone());
        }

        self.over
            .execute_repos_download_zipball_archive(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                todo!()
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_using_template(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_using_template();
        if let Some(value) = matches.get_one::<String>("template-owner") {
            request = request.template_owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("template-repo") {
            request = request.template_repo(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("include-all-branches") {
            request = request.body_map(|body| body.include_all_branches(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.body_map(|body| body.owner(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("private") {
            request = request.body_map(|body| body.private(value.clone()))
        }

        self.over
            .execute_repos_create_using_template(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_public(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_public();
        if let Some(value) = matches.get_one::<i64>("since") {
            request = request.since(value.clone());
        }

        self.over
            .execute_repos_list_public(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_environment_secrets(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_environment_secrets();
        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_environment_secrets(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_environment_public_key(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_environment_public_key();
        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        self.over
            .execute_actions_get_environment_public_key(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_environment_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_environment_secret();
        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_actions_get_environment_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_or_update_environment_secret(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.actions_create_or_update_environment_secret();
        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::ActionsCreateOrUpdateEnvironmentSecretBodyEncryptedValue>(
                "encrypted-value",
            )
        {
            request = request.body_map(|body| body.encrypted_value(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("key-id") {
            request = request.body_map(|body| body.key_id(value.clone()))
        }

        self.over
            .execute_actions_create_or_update_environment_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_environment_secret(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_environment_secret();
        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_actions_delete_environment_secret(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_list_environment_variables(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_list_environment_variables();
        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_actions_list_environment_variables(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_create_environment_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_create_environment_variable();
        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("value") {
            request = request.body_map(|body| body.value(value.clone()))
        }

        self.over
            .execute_actions_create_environment_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_get_environment_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_get_environment_variable();
        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_actions_get_environment_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_delete_environment_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_delete_environment_variable();
        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        self.over
            .execute_actions_delete_environment_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_actions_update_environment_variable(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.actions_update_environment_variable();
        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("environment-name") {
            request = request.environment_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("value") {
            request = request.body_map(|body| body.value(value.clone()))
        }

        self.over
            .execute_actions_update_environment_variable(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_search_code(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.search_code();
        if let Some(value) = matches.get_one::<types::SearchCodeOrder>("order") {
            request = request.order(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("q") {
            request = request.q(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SearchCodeSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_search_code(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_search_commits(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.search_commits();
        if let Some(value) = matches.get_one::<types::SearchCommitsOrder>("order") {
            request = request.order(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("q") {
            request = request.q(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SearchCommitsSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_search_commits(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_search_issues_and_pull_requests(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.search_issues_and_pull_requests();
        if let Some(value) = matches.get_one::<types::SearchIssuesAndPullRequestsOrder>("order") {
            request = request.order(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("q") {
            request = request.q(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SearchIssuesAndPullRequestsSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_search_issues_and_pull_requests(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_search_labels(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.search_labels();
        if let Some(value) = matches.get_one::<types::SearchLabelsOrder>("order") {
            request = request.order(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("q") {
            request = request.q(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SearchLabelsSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_search_labels(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_search_repos(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.search_repos();
        if let Some(value) = matches.get_one::<types::SearchReposOrder>("order") {
            request = request.order(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("q") {
            request = request.q(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SearchReposSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_search_repos(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_search_topics(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.search_topics();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("q") {
            request = request.q(value.clone());
        }

        self.over
            .execute_search_topics(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_search_users(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.search_users();
        if let Some(value) = matches.get_one::<types::SearchUsersOrder>("order") {
            request = request.order(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("q") {
            request = request.q(value.clone());
        }

        if let Some(value) = matches.get_one::<types::SearchUsersSort>("sort") {
            request = request.sort(value.clone());
        }

        self.over
            .execute_search_users(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_get_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_get_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        self.over
            .execute_teams_get_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_delete_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_delete_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        self.over
            .execute_teams_delete_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_update_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_update_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches
            .get_one::<types::TeamsUpdateLegacyBodyNotificationSetting>("notification-setting")
        {
            request = request.body_map(|body| body.notification_setting(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("parent-team-id") {
            request = request.body_map(|body| body.parent_team_id(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::TeamsUpdateLegacyBodyPermission>("permission")
        {
            request = request.body_map(|body| body.permission(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::TeamsUpdateLegacyBodyPrivacy>("privacy") {
            request = request.body_map(|body| body.privacy(value.clone()))
        }

        self.over
            .execute_teams_update_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_discussions_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_discussions_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::TeamsListDiscussionsLegacyDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_discussions_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_create_discussion_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_create_discussion_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("private") {
            request = request.body_map(|body| body.private(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_teams_create_discussion_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_get_discussion_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_get_discussion_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        self.over
            .execute_teams_get_discussion_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_delete_discussion_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_delete_discussion_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        self.over
            .execute_teams_delete_discussion_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_update_discussion_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_update_discussion_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_teams_update_discussion_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_discussion_comments_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_discussion_comments_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::TeamsListDiscussionCommentsLegacyDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_discussion_comments_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_create_discussion_comment_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_create_discussion_comment_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_teams_create_discussion_comment_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_get_discussion_comment_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_get_discussion_comment_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-number") {
            request = request.comment_number(value.clone());
        }

        self.over
            .execute_teams_get_discussion_comment_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_delete_discussion_comment_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_delete_discussion_comment_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-number") {
            request = request.comment_number(value.clone());
        }

        self.over
            .execute_teams_delete_discussion_comment_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_update_discussion_comment_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_update_discussion_comment_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-number") {
            request = request.comment_number(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        self.over
            .execute_teams_update_discussion_comment_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_list_for_team_discussion_comment_legacy(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .reactions_list_for_team_discussion_comment_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-number") {
            request = request.comment_number(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsListForTeamDiscussionCommentLegacyContent>("content")
        {
            request = request.content(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_reactions_list_for_team_discussion_comment_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_create_for_team_discussion_comment_legacy(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .reactions_create_for_team_discussion_comment_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("comment-number") {
            request = request.comment_number(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::ReactionsCreateForTeamDiscussionCommentLegacyBodyContent>("content")
        {
            request = request.body_map(|body| body.content(value.clone()))
        }

        self.over
            .execute_reactions_create_for_team_discussion_comment_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_list_for_team_discussion_legacy(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.reactions_list_for_team_discussion_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsListForTeamDiscussionLegacyContent>("content")
        {
            request = request.content(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_reactions_list_for_team_discussion_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_reactions_create_for_team_discussion_legacy(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.reactions_create_for_team_discussion_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("discussion-number") {
            request = request.discussion_number(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReactionsCreateForTeamDiscussionLegacyBodyContent>("content")
        {
            request = request.body_map(|body| body.content(value.clone()))
        }

        self.over
            .execute_reactions_create_for_team_discussion_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_pending_invitations_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_pending_invitations_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_pending_invitations_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_members_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_members_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::TeamsListMembersLegacyRole>("role") {
            request = request.role(value.clone());
        }

        self.over
            .execute_teams_list_members_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_get_member_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_get_member_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_teams_get_member_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_add_member_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_add_member_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_teams_add_member_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_remove_member_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_remove_member_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_teams_remove_member_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_get_membership_for_user_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_get_membership_for_user_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_teams_get_membership_for_user_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_add_or_update_membership_for_user_legacy(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_add_or_update_membership_for_user_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::TeamsAddOrUpdateMembershipForUserLegacyBodyRole>("role")
        {
            request = request.body_map(|body| body.role(value.clone()))
        }

        self.over
            .execute_teams_add_or_update_membership_for_user_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_remove_membership_for_user_legacy(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_remove_membership_for_user_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_teams_remove_membership_for_user_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_projects_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_projects_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_projects_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_check_permissions_for_project_legacy(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_check_permissions_for_project_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        self.over
            .execute_teams_check_permissions_for_project_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_add_or_update_project_permissions_legacy(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_add_or_update_project_permissions_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::TeamsAddOrUpdateProjectPermissionsLegacyBodyPermission>("permission")
        {
            request = request.body_map(|body| body.permission(value.clone()))
        }

        self.over
            .execute_teams_add_or_update_project_permissions_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_remove_project_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_remove_project_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("project-id") {
            request = request.project_id(value.clone());
        }

        self.over
            .execute_teams_remove_project_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_repos_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_repos_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_repos_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_check_permissions_for_repo_legacy(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_check_permissions_for_repo_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_teams_check_permissions_for_repo_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_add_or_update_repo_permissions_legacy(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.teams_add_or_update_repo_permissions_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::TeamsAddOrUpdateRepoPermissionsLegacyBodyPermission>("permission")
        {
            request = request.body_map(|body| body.permission(value.clone()))
        }

        self.over
            .execute_teams_add_or_update_repo_permissions_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_remove_repo_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_remove_repo_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_teams_remove_repo_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_child_legacy(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_child_legacy();
        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.team_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_child_legacy(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_get_authenticated(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_get_authenticated();
        self.over
            .execute_users_get_authenticated(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_update_authenticated(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_update_authenticated();
        if let Some(value) = matches.get_one::<String>("bio") {
            request = request.body_map(|body| body.bio(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("blog") {
            request = request.body_map(|body| body.blog(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("company") {
            request = request.body_map(|body| body.company(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("email") {
            request = request.body_map(|body| body.email(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("hireable") {
            request = request.body_map(|body| body.hireable(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("location") {
            request = request.body_map(|body| body.location(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("twitter-username") {
            request = request.body_map(|body| body.twitter_username(value.clone()))
        }

        self.over
            .execute_users_update_authenticated(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_blocked_by_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.users_list_blocked_by_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_blocked_by_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_check_blocked(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_check_blocked();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_users_check_blocked(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_block(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_block();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_users_block(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_unblock(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_unblock();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_users_unblock(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_list_for_authenticated_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_list_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_codespaces_list_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_create_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_create_for_authenticated_user();
        self.over
            .execute_codespaces_create_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_list_secrets_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_list_secrets_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_codespaces_list_secrets_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_get_public_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_get_public_key_for_authenticated_user();
        self.over
            .execute_codespaces_get_public_key_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_get_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_get_secret_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_codespaces_get_secret_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_create_or_update_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_create_or_update_secret_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some (value) = matches . get_one :: < types :: CodespacesCreateOrUpdateSecretForAuthenticatedUserBodyEncryptedValue > ("encrypted-value" ,) { request = request . body_map (| body | { body . encrypted_value (value . clone ()) }) }

        if let Some(value) = matches.get_one::<String>("key-id") {
            request = request.body_map(|body| body.key_id(value.clone()))
        }

        self.over
            .execute_codespaces_create_or_update_secret_for_authenticated_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_delete_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_delete_secret_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_codespaces_delete_secret_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_list_repositories_for_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_list_repositories_for_secret_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_codespaces_list_repositories_for_secret_for_authenticated_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_set_repositories_for_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_set_repositories_for_secret_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        self.over
            .execute_codespaces_set_repositories_for_secret_for_authenticated_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_add_repository_for_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_add_repository_for_secret_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_codespaces_add_repository_for_secret_for_authenticated_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_remove_repository_for_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_remove_repository_for_secret_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("secret-name") {
            request = request.secret_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_codespaces_remove_repository_for_secret_for_authenticated_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_get_for_authenticated_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_get_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("codespace-name") {
            request = request.codespace_name(value.clone());
        }

        self.over
            .execute_codespaces_get_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_delete_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_delete_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("codespace-name") {
            request = request.codespace_name(value.clone());
        }

        self.over
            .execute_codespaces_delete_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_update_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_update_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("codespace-name") {
            request = request.codespace_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("display-name") {
            request = request.body_map(|body| body.display_name(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("machine") {
            request = request.body_map(|body| body.machine(value.clone()))
        }

        self.over
            .execute_codespaces_update_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_export_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_export_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("codespace-name") {
            request = request.codespace_name(value.clone());
        }

        self.over
            .execute_codespaces_export_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_get_export_details_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_get_export_details_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("codespace-name") {
            request = request.codespace_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("export-id") {
            request = request.export_id(value.clone());
        }

        self.over
            .execute_codespaces_get_export_details_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_codespace_machines_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .codespaces_codespace_machines_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("codespace-name") {
            request = request.codespace_name(value.clone());
        }

        self.over
            .execute_codespaces_codespace_machines_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_publish_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_publish_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("codespace-name") {
            request = request.codespace_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("private") {
            request = request.body_map(|body| body.private(value.clone()))
        }

        self.over
            .execute_codespaces_publish_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_start_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.codespaces_start_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("codespace-name") {
            request = request.codespace_name(value.clone());
        }

        self.over
            .execute_codespaces_start_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_codespaces_stop_for_authenticated_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.codespaces_stop_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("codespace-name") {
            request = request.codespace_name(value.clone());
        }

        self.over
            .execute_codespaces_stop_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_list_docker_migration_conflicting_packages_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .packages_list_docker_migration_conflicting_packages_for_authenticated_user();
        self.over
            .execute_packages_list_docker_migration_conflicting_packages_for_authenticated_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_set_primary_email_visibility_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_set_primary_email_visibility_for_authenticated_user();
        if let Some(value) = matches
            .get_one::<types::UsersSetPrimaryEmailVisibilityForAuthenticatedUserBodyVisibility>(
            "visibility",
        ) {
            request = request.body_map(|body| body.visibility(value.clone()))
        }

        self.over
            .execute_users_set_primary_email_visibility_for_authenticated_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_emails_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.users_list_emails_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_emails_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_add_email_for_authenticated_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_add_email_for_authenticated_user();
        self.over
            .execute_users_add_email_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_delete_email_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.users_delete_email_for_authenticated_user();
        self.over
            .execute_users_delete_email_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_followers_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.users_list_followers_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_followers_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_followed_by_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.users_list_followed_by_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_followed_by_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_check_person_is_followed_by_authenticated(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_check_person_is_followed_by_authenticated();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_users_check_person_is_followed_by_authenticated(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_follow(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_follow();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_users_follow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_unfollow(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_unfollow();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_users_unfollow(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_gpg_keys_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.users_list_gpg_keys_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_gpg_keys_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_create_gpg_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.users_create_gpg_key_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("armored-public-key") {
            request = request.body_map(|body| body.armored_public_key(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_users_create_gpg_key_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_get_gpg_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.users_get_gpg_key_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("gpg-key-id") {
            request = request.gpg_key_id(value.clone());
        }

        self.over
            .execute_users_get_gpg_key_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_delete_gpg_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.users_delete_gpg_key_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("gpg-key-id") {
            request = request.gpg_key_id(value.clone());
        }

        self.over
            .execute_users_delete_gpg_key_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_installations_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.apps_list_installations_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_apps_list_installations_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_installation_repos_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .apps_list_installation_repos_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("installation-id") {
            request = request.installation_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_apps_list_installation_repos_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_add_repo_to_installation_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .apps_add_repo_to_installation_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("installation-id") {
            request = request.installation_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_apps_add_repo_to_installation_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_remove_repo_from_installation_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .apps_remove_repo_from_installation_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("installation-id") {
            request = request.installation_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("repository-id") {
            request = request.repository_id(value.clone());
        }

        self.over
            .execute_apps_remove_repo_from_installation_for_authenticated_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_interactions_get_restrictions_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .interactions_get_restrictions_for_authenticated_user();
        self.over
            .execute_interactions_get_restrictions_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_interactions_set_restrictions_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .interactions_set_restrictions_for_authenticated_user();
        if let Some(value) = matches.get_one::<types::InteractionExpiry>("expiry") {
            request = request.body_map(|body| body.expiry(value.clone()))
        }

        if let Some(value) = matches.get_one::<types::InteractionGroup>("limit") {
            request = request.body_map(|body| body.limit(value.clone()))
        }

        self.over
            .execute_interactions_set_restrictions_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_interactions_remove_restrictions_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .interactions_remove_restrictions_for_authenticated_user();
        self.over
            .execute_interactions_remove_restrictions_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_issues_list_for_authenticated_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.issues_list_for_authenticated_user();
        if let Some(value) =
            matches.get_one::<types::IssuesListForAuthenticatedUserDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::IssuesListForAuthenticatedUserFilter>("filter")
        {
            request = request.filter(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("labels") {
            request = request.labels(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListForAuthenticatedUserSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::IssuesListForAuthenticatedUserState>("state")
        {
            request = request.state(value.clone());
        }

        self.over
            .execute_issues_list_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_public_ssh_keys_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_list_public_ssh_keys_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_public_ssh_keys_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_create_public_ssh_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_create_public_ssh_key_for_authenticated_user();
        if let Some(value) =
            matches.get_one::<types::UsersCreatePublicSshKeyForAuthenticatedUserBodyKey>("key")
        {
            request = request.body_map(|body| body.key(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_users_create_public_ssh_key_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_get_public_ssh_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_get_public_ssh_key_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("key-id") {
            request = request.key_id(value.clone());
        }

        self.over
            .execute_users_get_public_ssh_key_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_delete_public_ssh_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_delete_public_ssh_key_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("key-id") {
            request = request.key_id(value.clone());
        }

        self.over
            .execute_users_delete_public_ssh_key_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_subscriptions_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.apps_list_subscriptions_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_apps_list_subscriptions_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_list_subscriptions_for_authenticated_user_stubbed(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .apps_list_subscriptions_for_authenticated_user_stubbed();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_apps_list_subscriptions_for_authenticated_user_stubbed(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_memberships_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.orgs_list_memberships_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::OrgsListMembershipsForAuthenticatedUserState>("state")
        {
            request = request.state(value.clone());
        }

        self.over
            .execute_orgs_list_memberships_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_get_membership_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.orgs_get_membership_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        self.over
            .execute_orgs_get_membership_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_update_membership_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.orgs_update_membership_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::OrgsUpdateMembershipForAuthenticatedUserBodyState>("state")
        {
            request = request.body_map(|body| body.state(value.clone()))
        }

        self.over
            .execute_orgs_update_membership_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_list_for_authenticated_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.migrations_list_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_migrations_list_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_start_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.migrations_start_for_authenticated_user();
        if let Some(value) = matches.get_one::<bool>("exclude-attachments") {
            request = request.body_map(|body| body.exclude_attachments(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("exclude-git-data") {
            request = request.body_map(|body| body.exclude_git_data(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("exclude-metadata") {
            request = request.body_map(|body| body.exclude_metadata(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("exclude-owner-projects") {
            request = request.body_map(|body| body.exclude_owner_projects(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("exclude-releases") {
            request = request.body_map(|body| body.exclude_releases(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("lock-repositories") {
            request = request.body_map(|body| body.lock_repositories(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("org-metadata-only") {
            request = request.body_map(|body| body.org_metadata_only(value.clone()))
        }

        self.over
            .execute_migrations_start_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_get_status_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.migrations_get_status_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("migration-id") {
            request = request.migration_id(value.clone());
        }

        if let Some(value) = matches.get_one::<Vec<String>>("exclude") {
            request = request.exclude(value.clone());
        }

        self.over
            .execute_migrations_get_status_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_get_archive_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.migrations_get_archive_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("migration-id") {
            request = request.migration_id(value.clone());
        }

        self.over
            .execute_migrations_get_archive_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                todo!()
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_delete_archive_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .migrations_delete_archive_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("migration-id") {
            request = request.migration_id(value.clone());
        }

        self.over
            .execute_migrations_delete_archive_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_unlock_repo_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.migrations_unlock_repo_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("migration-id") {
            request = request.migration_id(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo-name") {
            request = request.repo_name(value.clone());
        }

        self.over
            .execute_migrations_unlock_repo_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_migrations_list_repos_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.migrations_list_repos_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("migration-id") {
            request = request.migration_id(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_migrations_list_repos_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_for_authenticated_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_orgs_list_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_list_packages_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.packages_list_packages_for_authenticated_user();
        if let Some(value) = matches
            .get_one::<types::PackagesListPackagesForAuthenticatedUserPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::PackagesListPackagesForAuthenticatedUserVisibility>("visibility")
        {
            request = request.visibility(value.clone());
        }

        self.over
            .execute_packages_list_packages_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_get_package_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.packages_get_package_for_authenticated_user();
        if let Some(value) = matches
            .get_one::<types::PackagesGetPackageForAuthenticatedUserPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        self.over
            .execute_packages_get_package_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_delete_package_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.packages_delete_package_for_authenticated_user();
        if let Some(value) = matches
            .get_one::<types::PackagesDeletePackageForAuthenticatedUserPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        self.over
            .execute_packages_delete_package_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_restore_package_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .packages_restore_package_for_authenticated_user();
        if let Some(value) = matches
            .get_one::<types::PackagesRestorePackageForAuthenticatedUserPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("token") {
            request = request.token(value.clone());
        }

        self.over
            .execute_packages_restore_package_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_get_all_package_versions_for_package_owned_by_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .packages_get_all_package_versions_for_package_owned_by_authenticated_user();
        if let Some (value) = matches . get_one :: < types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType > ("package-type") { request = request . package_type (value . clone ()) ; }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some (value) = matches . get_one :: < types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState > ("state") { request = request . state (value . clone ()) ; }

        self.over
            .execute_packages_get_all_package_versions_for_package_owned_by_authenticated_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_get_package_version_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .packages_get_package_version_for_authenticated_user();
        if let Some(value) = matches
            .get_one::<types::PackagesGetPackageVersionForAuthenticatedUserPackageType>(
                "package-type",
            )
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("package-version-id") {
            request = request.package_version_id(value.clone());
        }

        self.over
            .execute_packages_get_package_version_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_delete_package_version_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .packages_delete_package_version_for_authenticated_user();
        if let Some(value) = matches
            .get_one::<types::PackagesDeletePackageVersionForAuthenticatedUserPackageType>(
            "package-type",
        ) {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("package-version-id") {
            request = request.package_version_id(value.clone());
        }

        self.over
            .execute_packages_delete_package_version_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_restore_package_version_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .packages_restore_package_version_for_authenticated_user();
        if let Some(value) = matches
            .get_one::<types::PackagesRestorePackageVersionForAuthenticatedUserPackageType>(
            "package-type",
        ) {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("package-version-id") {
            request = request.package_version_id(value.clone());
        }

        self.over
            .execute_packages_restore_package_version_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_create_for_authenticated_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_create_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("body") {
            request = request.body_map(|body| body.body(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        self.over
            .execute_projects_create_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_public_emails_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_list_public_emails_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_public_emails_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_for_authenticated_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("affiliation") {
            request = request.affiliation(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("before") {
            request = request.before(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReposListForAuthenticatedUserDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReposListForAuthenticatedUserSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReposListForAuthenticatedUserType>("type") {
            request = request.type_(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ReposListForAuthenticatedUserVisibility>("visibility")
        {
            request = request.visibility(value.clone());
        }

        self.over
            .execute_repos_list_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_create_for_authenticated_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_create_for_authenticated_user();
        if let Some(value) = matches.get_one::<bool>("allow-auto-merge") {
            request = request.body_map(|body| body.allow_auto_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-merge-commit") {
            request = request.body_map(|body| body.allow_merge_commit(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-rebase-merge") {
            request = request.body_map(|body| body.allow_rebase_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("allow-squash-merge") {
            request = request.body_map(|body| body.allow_squash_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("auto-init") {
            request = request.body_map(|body| body.auto_init(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("delete-branch-on-merge") {
            request = request.body_map(|body| body.delete_branch_on_merge(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("description") {
            request = request.body_map(|body| body.description(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("gitignore-template") {
            request = request.body_map(|body| body.gitignore_template(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-discussions") {
            request = request.body_map(|body| body.has_discussions(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-downloads") {
            request = request.body_map(|body| body.has_downloads(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-issues") {
            request = request.body_map(|body| body.has_issues(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-projects") {
            request = request.body_map(|body| body.has_projects(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("has-wiki") {
            request = request.body_map(|body| body.has_wiki(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("homepage") {
            request = request.body_map(|body| body.homepage(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("is-template") {
            request = request.body_map(|body| body.is_template(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("license-template") {
            request = request.body_map(|body| body.license_template(value.clone()))
        }

        if let Some(value) = matches
            .get_one::<types::ReposCreateForAuthenticatedUserBodyMergeCommitMessage>(
                "merge-commit-message",
            )
        {
            request = request.body_map(|body| body.merge_commit_message(value.clone()))
        }

        if let Some(value) = matches
            .get_one::<types::ReposCreateForAuthenticatedUserBodyMergeCommitTitle>(
                "merge-commit-title",
            )
        {
            request = request.body_map(|body| body.merge_commit_title(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("name") {
            request = request.body_map(|body| body.name(value.clone()))
        }

        if let Some(value) = matches.get_one::<bool>("private") {
            request = request.body_map(|body| body.private(value.clone()))
        }

        if let Some(value) = matches
            .get_one::<types::ReposCreateForAuthenticatedUserBodySquashMergeCommitMessage>(
            "squash-merge-commit-message",
        ) {
            request = request.body_map(|body| body.squash_merge_commit_message(value.clone()))
        }

        if let Some(value) = matches
            .get_one::<types::ReposCreateForAuthenticatedUserBodySquashMergeCommitTitle>(
                "squash-merge-commit-title",
            )
        {
            request = request.body_map(|body| body.squash_merge_commit_title(value.clone()))
        }

        if let Some(value) = matches.get_one::<i64>("team-id") {
            request = request.body_map(|body| body.team_id(value.clone()))
        }

        self.over
            .execute_repos_create_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_invitations_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_list_invitations_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_repos_list_invitations_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_decline_invitation_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .repos_decline_invitation_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("invitation-id") {
            request = request.invitation_id(value.clone());
        }

        self.over
            .execute_repos_decline_invitation_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_accept_invitation_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.repos_accept_invitation_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("invitation-id") {
            request = request.invitation_id(value.clone());
        }

        self.over
            .execute_repos_accept_invitation_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_social_accounts_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_list_social_accounts_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_social_accounts_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_add_social_account_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_add_social_account_for_authenticated_user();
        self.over
            .execute_users_add_social_account_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_delete_social_account_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_delete_social_account_for_authenticated_user();
        self.over
            .execute_users_delete_social_account_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_ssh_signing_keys_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_list_ssh_signing_keys_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_ssh_signing_keys_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_create_ssh_signing_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_create_ssh_signing_key_for_authenticated_user();
        if let Some(value) =
            matches.get_one::<types::UsersCreateSshSigningKeyForAuthenticatedUserBodyKey>("key")
        {
            request = request.body_map(|body| body.key(value.clone()))
        }

        if let Some(value) = matches.get_one::<String>("title") {
            request = request.body_map(|body| body.title(value.clone()))
        }

        self.over
            .execute_users_create_ssh_signing_key_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_get_ssh_signing_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_get_ssh_signing_key_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("ssh-signing-key-id") {
            request = request.ssh_signing_key_id(value.clone());
        }

        self.over
            .execute_users_get_ssh_signing_key_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_delete_ssh_signing_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .users_delete_ssh_signing_key_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("ssh-signing-key-id") {
            request = request.ssh_signing_key_id(value.clone());
        }

        self.over
            .execute_users_delete_ssh_signing_key_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_repos_starred_by_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .activity_list_repos_starred_by_authenticated_user();
        if let Some(value) = matches
            .get_one::<types::ActivityListReposStarredByAuthenticatedUserDirection>("direction")
        {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::ActivityListReposStarredByAuthenticatedUserSort>("sort")
        {
            request = request.sort(value.clone());
        }

        self.over
            .execute_activity_list_repos_starred_by_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_check_repo_is_starred_by_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .activity_check_repo_is_starred_by_authenticated_user();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_activity_check_repo_is_starred_by_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_star_repo_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.activity_star_repo_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_activity_star_repo_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_unstar_repo_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.activity_unstar_repo_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("owner") {
            request = request.owner(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("repo") {
            request = request.repo(value.clone());
        }

        self.over
            .execute_activity_unstar_repo_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_watched_repos_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .activity_list_watched_repos_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_watched_repos_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_teams_list_for_authenticated_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.teams_list_for_authenticated_user();
        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_teams_list_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_list();
        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("since") {
            request = request.since(value.clone());
        }

        self.over.execute_users_list(matches, &mut request).unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_get_by_username(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_get_by_username();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_users_get_by_username(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_list_docker_migration_conflicting_packages_for_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .packages_list_docker_migration_conflicting_packages_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_packages_list_docker_migration_conflicting_packages_for_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_events_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.activity_list_events_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_events_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_org_events_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .activity_list_org_events_for_authenticated_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("org") {
            request = request.org(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_org_events_for_authenticated_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_public_events_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_list_public_events_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_public_events_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_followers_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_list_followers_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_followers_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_following_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_list_following_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_following_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_check_following_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_check_following_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("target-user") {
            request = request.target_user(value.clone());
        }

        self.over
            .execute_users_check_following_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_gists_list_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.gists_list_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<chrono::DateTime<chrono::offset::Utc>>("since") {
            request = request.since(value.clone());
        }

        self.over
            .execute_gists_list_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_gpg_keys_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_list_gpg_keys_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_gpg_keys_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_get_context_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_get_context_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("subject-id") {
            request = request.subject_id(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::UsersGetContextForUserSubjectType>("subject-type")
        {
            request = request.subject_type(value.clone());
        }

        self.over
            .execute_users_get_context_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_apps_get_user_installation(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.apps_get_user_installation();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_apps_get_user_installation(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_public_keys_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_list_public_keys_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_public_keys_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_orgs_list_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.orgs_list_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_orgs_list_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_list_packages_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.packages_list_packages_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesListPackagesForUserPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesListPackagesForUserVisibility>("visibility")
        {
            request = request.visibility(value.clone());
        }

        self.over
            .execute_packages_list_packages_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_get_package_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.packages_get_package_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesGetPackageForUserPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        self.over
            .execute_packages_get_package_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_delete_package_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.packages_delete_package_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesDeletePackageForUserPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        self.over
            .execute_packages_delete_package_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_restore_package_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.packages_restore_package_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesRestorePackageForUserPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("token") {
            request = request.token(value.clone());
        }

        self.over
            .execute_packages_restore_package_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_get_all_package_versions_for_package_owned_by_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self
            .client
            .packages_get_all_package_versions_for_package_owned_by_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType>(
            "package-type",
        ) {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        self.over
            .execute_packages_get_all_package_versions_for_package_owned_by_user(
                matches,
                &mut request,
            )
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_get_package_version_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.packages_get_package_version_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesGetPackageVersionForUserPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("package-version-id") {
            request = request.package_version_id(value.clone());
        }

        self.over
            .execute_packages_get_package_version_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_delete_package_version_for_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.packages_delete_package_version_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) =
            matches.get_one::<types::PackagesDeletePackageVersionForUserPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("package-version-id") {
            request = request.package_version_id(value.clone());
        }

        self.over
            .execute_packages_delete_package_version_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_packages_restore_package_version_for_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.packages_restore_package_version_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches
            .get_one::<types::PackagesRestorePackageVersionForUserPackageType>("package-type")
        {
            request = request.package_type(value.clone());
        }

        if let Some(value) = matches.get_one::<String>("package-name") {
            request = request.package_name(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("package-version-id") {
            request = request.package_version_id(value.clone());
        }

        self.over
            .execute_packages_restore_package_version_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_projects_list_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.projects_list_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ProjectsListForUserState>("state") {
            request = request.state(value.clone());
        }

        self.over
            .execute_projects_list_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("error\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_received_events_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.activity_list_received_events_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_received_events_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_activity_list_received_public_events_for_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.activity_list_received_public_events_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_activity_list_received_public_events_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_repos_list_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.repos_list_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReposListForUserDirection>("direction") {
            request = request.direction(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReposListForUserSort>("sort") {
            request = request.sort(value.clone());
        }

        if let Some(value) = matches.get_one::<types::ReposListForUserType>("type") {
            request = request.type_(value.clone());
        }

        self.over
            .execute_repos_list_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_billing_get_github_actions_billing_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.billing_get_github_actions_billing_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_billing_get_github_actions_billing_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_billing_get_github_packages_billing_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.billing_get_github_packages_billing_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_billing_get_github_packages_billing_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_billing_get_shared_storage_billing_user(
        &self,
        matches: &clap::ArgMatches,
    ) {
        let mut request = self.client.billing_get_shared_storage_billing_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        self.over
            .execute_billing_get_shared_storage_billing_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }

    pub async fn execute_users_list_social_accounts_for_user(&self, matches: &clap::ArgMatches) {
        let mut request = self.client.users_list_social_accounts_for_user();
        if let Some(value) = matches.get_one::<String>("username") {
            request = request.username(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("page") {
            request = request.page(value.clone());
        }

        if let Some(value) = matches.get_one::<i64>("per-page") {
            request = request.per_page(value.clone());
        }

        self.over
            .execute_users_list_social_accounts_for_user(matches, &mut request)
            .unwrap();
        let result = request.send().await;
        match result {
            Ok(r) => {
                println!("success\n{:#?}", r)
            }
            Err(r) => {
                println!("success\n{:#?}", r)
            }
        }
    }
}

pub trait CliOverride {
    fn execute_meta_root(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MetaRoot,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_get_authenticated(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsGetAuthenticated,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_create_from_manifest(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsCreateFromManifest,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_get_webhook_config_for_app(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsGetWebhookConfigForApp,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_update_webhook_config_for_app(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsUpdateWebhookConfigForApp,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_webhook_deliveries(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListWebhookDeliveries,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_get_webhook_delivery(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsGetWebhookDelivery,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_redeliver_webhook_delivery(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsRedeliverWebhookDelivery,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_installation_requests_for_authenticated_app(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListInstallationRequestsForAuthenticatedApp,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_installations(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListInstallations,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_get_installation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsGetInstallation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_delete_installation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsDeleteInstallation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_create_installation_access_token(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsCreateInstallationAccessToken,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_suspend_installation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsSuspendInstallation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_unsuspend_installation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsUnsuspendInstallation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_delete_authorization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsDeleteAuthorization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_check_token(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsCheckToken,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_delete_token(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsDeleteToken,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_reset_token(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsResetToken,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_scope_token(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsScopeToken,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_get_by_slug(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsGetBySlug,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codes_of_conduct_get_all_codes_of_conduct(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodesOfConductGetAllCodesOfConduct,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codes_of_conduct_get_conduct_code(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodesOfConductGetConductCode,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_emojis_get(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::EmojisGet,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_list_alerts_for_enterprise(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotListAlertsForEnterprise,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_secret_scanning_list_alerts_for_enterprise(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SecretScanningListAlertsForEnterprise,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_public_events(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListPublicEvents,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_get_feeds(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityGetFeeds,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_list(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsList,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_create(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsCreate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_list_public(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsListPublic,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_list_starred(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsListStarred,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_get(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsGet,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_delete(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsDelete,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_update(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsUpdate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_list_comments(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsListComments,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_create_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsCreateComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_get_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsGetComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_delete_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsDeleteComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_update_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsUpdateComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_list_commits(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsListCommits,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_list_forks(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsListForks,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_fork(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsFork,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_check_is_starred(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsCheckIsStarred,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_star(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsStar,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_unstar(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsUnstar,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_get_revision(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsGetRevision,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gitignore_get_all_templates(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitignoreGetAllTemplates,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gitignore_get_template(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitignoreGetTemplate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_repos_accessible_to_installation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListReposAccessibleToInstallation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_revoke_installation_access_token(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsRevokeInstallationAccessToken,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesList,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_licenses_get_all_commonly_used(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::LicensesGetAllCommonlyUsed,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_licenses_get(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::LicensesGet,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_markdown_render(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MarkdownRender,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_meta_get_all_versions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MetaGetAllVersions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_get_subscription_plan_for_account(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsGetSubscriptionPlanForAccount,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_plans(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListPlans,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_accounts_for_plan(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListAccountsForPlan,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_get_subscription_plan_for_account_stubbed(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsGetSubscriptionPlanForAccountStubbed,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_plans_stubbed(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListPlansStubbed,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_accounts_for_plan_stubbed(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListAccountsForPlanStubbed,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_meta_get(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MetaGet,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_public_events_for_repo_network(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListPublicEventsForRepoNetwork,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_notifications_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListNotificationsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_mark_notifications_as_read(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityMarkNotificationsAsRead,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_get_thread(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityGetThread,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_mark_thread_as_read(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityMarkThreadAsRead,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_get_thread_subscription_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityGetThreadSubscriptionForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_set_thread_subscription(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivitySetThreadSubscription,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_delete_thread_subscription(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityDeleteThreadSubscription,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_meta_get_octocat(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MetaGetOctocat,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsList,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_pat_grant_requests(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListPatGrantRequests,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_review_pat_grant_requests_in_bulk(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsReviewPatGrantRequestsInBulk,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_review_pat_grant_request(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsReviewPatGrantRequest,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_pat_grant_request_repositories(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListPatGrantRequestRepositories,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_pat_grants(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListPatGrants,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_update_pat_accesses(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsUpdatePatAccesses,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_update_pat_access(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsUpdatePatAccess,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_pat_grant_repositories(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListPatGrantRepositories,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_meta_get_zen(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MetaGetZen,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_actions_cache_usage_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetActionsCacheUsageForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_actions_cache_usage_by_repo_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetActionsCacheUsageByRepoForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_oidc_get_oidc_custom_sub_template_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OidcGetOidcCustomSubTemplateForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_oidc_update_oidc_custom_sub_template_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OidcUpdateOidcCustomSubTemplateForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_github_actions_permissions_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetGithubActionsPermissionsOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_github_actions_permissions_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetGithubActionsPermissionsOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_selected_repositories_enabled_github_actions_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListSelectedRepositoriesEnabledGithubActionsOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_selected_repositories_enabled_github_actions_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_enable_selected_repository_github_actions_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsEnableSelectedRepositoryGithubActionsOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_disable_selected_repository_github_actions_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDisableSelectedRepositoryGithubActionsOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_allowed_actions_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetAllowedActionsOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_allowed_actions_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetAllowedActionsOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_github_actions_default_workflow_permissions_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_github_actions_default_workflow_permissions_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_required_workflows(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListRequiredWorkflows,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_required_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateRequiredWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_required_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetRequiredWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_required_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteRequiredWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_update_required_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsUpdateRequiredWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_selected_repositories_required_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListSelectedRepositoriesRequiredWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_selected_repos_to_required_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetSelectedReposToRequiredWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_add_selected_repo_to_required_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsAddSelectedRepoToRequiredWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_remove_selected_repo_from_required_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsRemoveSelectedRepoFromRequiredWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_self_hosted_runners_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListSelfHostedRunnersForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_runner_applications_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListRunnerApplicationsForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_registration_token_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateRegistrationTokenForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_remove_token_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateRemoveTokenForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_self_hosted_runner_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetSelfHostedRunnerForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_self_hosted_runner_from_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteSelfHostedRunnerFromOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_labels_for_self_hosted_runner_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListLabelsForSelfHostedRunnerForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_custom_labels_for_self_hosted_runner_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetCustomLabelsForSelfHostedRunnerForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_add_custom_labels_to_self_hosted_runner_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsAddCustomLabelsToSelfHostedRunnerForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_remove_all_custom_labels_from_self_hosted_runner_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_remove_custom_label_from_self_hosted_runner_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_org_secrets(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListOrgSecrets,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_org_public_key(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetOrgPublicKey,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_or_update_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateOrUpdateOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListSelectedReposForOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetSelectedReposForOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_add_selected_repo_to_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsAddSelectedRepoToOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_remove_selected_repo_from_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsRemoveSelectedRepoFromOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_org_variables(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListOrgVariables,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_org_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateOrgVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_org_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetOrgVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_org_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteOrgVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_update_org_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsUpdateOrgVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_selected_repos_for_org_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListSelectedReposForOrgVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_selected_repos_for_org_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetSelectedReposForOrgVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_add_selected_repo_to_org_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsAddSelectedRepoToOrgVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_remove_selected_repo_from_org_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsRemoveSelectedRepoFromOrgVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_blocked_users(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListBlockedUsers,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_check_blocked_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsCheckBlockedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_block_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsBlockUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_unblock_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsUnblockUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_list_alerts_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningListAlertsForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_list_in_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesListInOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_set_codespaces_billing(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesSetCodespacesBilling,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_set_codespaces_billing_users(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesSetCodespacesBillingUsers,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_delete_codespaces_billing_users(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesDeleteCodespacesBillingUsers,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_list_org_secrets(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesListOrgSecrets,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_get_org_public_key(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesGetOrgPublicKey,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_get_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesGetOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_create_or_update_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesCreateOrUpdateOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_delete_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesDeleteOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_list_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesListSelectedReposForOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_set_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesSetSelectedReposForOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_add_selected_repo_to_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesAddSelectedRepoToOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_remove_selected_repo_from_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesRemoveSelectedRepoFromOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_list_alerts_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotListAlertsForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_list_org_secrets(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotListOrgSecrets,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_get_org_public_key(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotGetOrgPublicKey,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_get_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotGetOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_create_or_update_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotCreateOrUpdateOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_delete_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotDeleteOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_list_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotListSelectedReposForOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_set_selected_repos_for_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotSetSelectedReposForOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_add_selected_repo_to_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotAddSelectedRepoToOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_remove_selected_repo_from_org_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotRemoveSelectedRepoFromOrgSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_list_docker_migration_conflicting_packages_for_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesListDockerMigrationConflictingPackagesForOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_public_org_events(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListPublicOrgEvents,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_failed_invitations(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListFailedInvitations,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_webhooks(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListWebhooks,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_create_webhook(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsCreateWebhook,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_get_webhook(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsGetWebhook,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_delete_webhook(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsDeleteWebhook,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_update_webhook(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsUpdateWebhook,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_get_webhook_config_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsGetWebhookConfigForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_update_webhook_config_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsUpdateWebhookConfigForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_webhook_deliveries(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListWebhookDeliveries,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_get_webhook_delivery(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsGetWebhookDelivery,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_redeliver_webhook_delivery(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsRedeliverWebhookDelivery,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_ping_webhook(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsPingWebhook,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_get_org_installation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsGetOrgInstallation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_app_installations(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListAppInstallations,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_interactions_get_restrictions_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::InteractionsGetRestrictionsForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_interactions_set_restrictions_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::InteractionsSetRestrictionsForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_interactions_remove_restrictions_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::InteractionsRemoveRestrictionsForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_pending_invitations(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListPendingInvitations,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_create_invitation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsCreateInvitation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_cancel_invitation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsCancelInvitation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_invitation_teams(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListInvitationTeams,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_members(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListMembers,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_check_membership_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsCheckMembershipForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_remove_member(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsRemoveMember,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_get_codespaces_for_user_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesGetCodespacesForUserInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_delete_from_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesDeleteFromOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_stop_in_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesStopInOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_get_membership_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsGetMembershipForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_set_membership_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsSetMembershipForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_remove_membership_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsRemoveMembershipForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_list_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsListForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_start_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsStartForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_get_status_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsGetStatusForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_download_archive_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsDownloadArchiveForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_delete_archive_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsDeleteArchiveForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_unlock_repo_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsUnlockRepoForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_list_repos_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsListReposForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_outside_collaborators(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListOutsideCollaborators,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_convert_member_to_outside_collaborator(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsConvertMemberToOutsideCollaborator,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_remove_outside_collaborator(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsRemoveOutsideCollaborator,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_list_packages_for_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesListPackagesForOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_get_package_for_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesGetPackageForOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_delete_package_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesDeletePackageForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_restore_package_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesRestorePackageForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_get_all_package_versions_for_package_owned_by_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesGetAllPackageVersionsForPackageOwnedByOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_get_package_version_for_organization(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesGetPackageVersionForOrganization,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_delete_package_version_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesDeletePackageVersionForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_restore_package_version_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesRestorePackageVersionForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_list_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsListForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_create_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsCreateForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_public_members(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListPublicMembers,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_check_public_membership_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsCheckPublicMembershipForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_set_public_membership_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsSetPublicMembershipForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_remove_public_membership_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsRemovePublicMembershipForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_org_rulesets(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetOrgRulesets,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_org_ruleset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateOrgRuleset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_org_ruleset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetOrgRuleset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_org_ruleset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdateOrgRuleset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_org_ruleset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteOrgRuleset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_secret_scanning_list_alerts_for_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SecretScanningListAlertsForOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_security_manager_teams(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListSecurityManagerTeams,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_add_security_manager_team(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsAddSecurityManagerTeam,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_remove_security_manager_team(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsRemoveSecurityManagerTeam,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_billing_get_github_actions_billing_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::BillingGetGithubActionsBillingOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_billing_get_github_packages_billing_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::BillingGetGithubPackagesBillingOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_billing_get_shared_storage_billing_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::BillingGetSharedStorageBillingOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsList,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_create(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsCreate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_get_by_name(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsGetByName,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_delete_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsDeleteInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_update_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsUpdateInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_discussions_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListDiscussionsInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_create_discussion_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsCreateDiscussionInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_get_discussion_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsGetDiscussionInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_delete_discussion_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsDeleteDiscussionInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_update_discussion_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsUpdateDiscussionInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_discussion_comments_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListDiscussionCommentsInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_create_discussion_comment_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsCreateDiscussionCommentInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_get_discussion_comment_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsGetDiscussionCommentInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_delete_discussion_comment_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsDeleteDiscussionCommentInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_update_discussion_comment_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsUpdateDiscussionCommentInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_list_for_team_discussion_comment_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsListForTeamDiscussionCommentInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_create_for_team_discussion_comment_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsCreateForTeamDiscussionCommentInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_delete_for_team_discussion_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsDeleteForTeamDiscussionComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_list_for_team_discussion_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsListForTeamDiscussionInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_create_for_team_discussion_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsCreateForTeamDiscussionInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_delete_for_team_discussion(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsDeleteForTeamDiscussion,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_pending_invitations_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListPendingInvitationsInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_members_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListMembersInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_get_membership_for_user_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsGetMembershipForUserInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_add_or_update_membership_for_user_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsAddOrUpdateMembershipForUserInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_remove_membership_for_user_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsRemoveMembershipForUserInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_projects_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListProjectsInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_check_permissions_for_project_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsCheckPermissionsForProjectInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_add_or_update_project_permissions_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsAddOrUpdateProjectPermissionsInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_remove_project_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsRemoveProjectInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_repos_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListReposInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_check_permissions_for_repo_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsCheckPermissionsForRepoInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_add_or_update_repo_permissions_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsAddOrUpdateRepoPermissionsInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_remove_repo_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsRemoveRepoInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_child_in_org(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListChildInOrg,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_enable_or_disable_security_product_on_all_org_repos(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsEnableOrDisableSecurityProductOnAllOrgRepos,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_get_card(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsGetCard,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_delete_card(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsDeleteCard,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_update_card(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsUpdateCard,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_move_card(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsMoveCard,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_get_column(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsGetColumn,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_delete_column(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsDeleteColumn,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_update_column(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsUpdateColumn,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_ssh_signing_keys_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListSshSigningKeysForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_move_column(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsMoveColumn,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_get(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsGet,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_delete(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsDelete,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_update(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsUpdate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_list_collaborators(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsListCollaborators,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_add_collaborator(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsAddCollaborator,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_remove_collaborator(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsRemoveCollaborator,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_get_permission_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsGetPermissionForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_list_columns(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsListColumns,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_create_column(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsCreateColumn,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_rate_limit_get(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::RateLimitGet,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_repo_required_workflows(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListRepoRequiredWorkflows,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_repo_required_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetRepoRequiredWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_repo_required_workflow_usage(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetRepoRequiredWorkflowUsage,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGet,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDelete,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_artifacts_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListArtifactsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_artifact(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetArtifact,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_artifact(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteArtifact,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_download_artifact(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDownloadArtifact,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_actions_cache_usage(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetActionsCacheUsage,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_actions_cache_list(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetActionsCacheList,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_actions_cache_by_key(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteActionsCacheByKey,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_actions_cache_by_id(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteActionsCacheById,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_job_for_workflow_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetJobForWorkflowRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_download_job_logs_for_workflow_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDownloadJobLogsForWorkflowRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_re_run_job_for_workflow_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsReRunJobForWorkflowRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_custom_oidc_sub_claim_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetCustomOidcSubClaimForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_custom_oidc_sub_claim_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetCustomOidcSubClaimForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_repo_organization_secrets(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListRepoOrganizationSecrets,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_repo_organization_variables(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListRepoOrganizationVariables,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_github_actions_permissions_repository(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetGithubActionsPermissionsRepository,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_github_actions_permissions_repository(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetGithubActionsPermissionsRepository,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_workflow_access_to_repository(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetWorkflowAccessToRepository,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_workflow_access_to_repository(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetWorkflowAccessToRepository,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_allowed_actions_repository(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetAllowedActionsRepository,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_allowed_actions_repository(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetAllowedActionsRepository,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_github_actions_default_workflow_permissions_repository(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetGithubActionsDefaultWorkflowPermissionsRepository,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_github_actions_default_workflow_permissions_repository(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetGithubActionsDefaultWorkflowPermissionsRepository,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_required_workflow_runs(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListRequiredWorkflowRuns,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_self_hosted_runners_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListSelfHostedRunnersForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_runner_applications_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListRunnerApplicationsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_registration_token_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateRegistrationTokenForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_remove_token_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateRemoveTokenForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetSelfHostedRunnerForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_self_hosted_runner_from_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteSelfHostedRunnerFromRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_labels_for_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListLabelsForSelfHostedRunnerForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_set_custom_labels_for_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsSetCustomLabelsForSelfHostedRunnerForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_add_custom_labels_to_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsAddCustomLabelsToSelfHostedRunnerForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_remove_all_custom_labels_from_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_remove_custom_label_from_self_hosted_runner_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_workflow_runs_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListWorkflowRunsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_workflow_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetWorkflowRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_workflow_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteWorkflowRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_reviews_for_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetReviewsForRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_approve_workflow_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsApproveWorkflowRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_workflow_run_artifacts(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListWorkflowRunArtifacts,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_workflow_run_attempt(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetWorkflowRunAttempt,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_jobs_for_workflow_run_attempt(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListJobsForWorkflowRunAttempt,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_download_workflow_run_attempt_logs(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDownloadWorkflowRunAttemptLogs,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_cancel_workflow_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCancelWorkflowRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_review_custom_gates_for_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsReviewCustomGatesForRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_jobs_for_workflow_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListJobsForWorkflowRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_download_workflow_run_logs(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDownloadWorkflowRunLogs,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_workflow_run_logs(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteWorkflowRunLogs,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_pending_deployments_for_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetPendingDeploymentsForRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_review_pending_deployments_for_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsReviewPendingDeploymentsForRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_re_run_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsReRunWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_re_run_workflow_failed_jobs(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsReRunWorkflowFailedJobs,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_workflow_run_usage(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetWorkflowRunUsage,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_repo_secrets(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListRepoSecrets,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_repo_public_key(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetRepoPublicKey,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_repo_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetRepoSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_or_update_repo_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateOrUpdateRepoSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_repo_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteRepoSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_repo_variables(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListRepoVariables,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_repo_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateRepoVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_repo_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetRepoVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_repo_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteRepoVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_update_repo_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsUpdateRepoVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_repo_workflows(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListRepoWorkflows,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_disable_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDisableWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_workflow_dispatch(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateWorkflowDispatch,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_enable_workflow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsEnableWorkflow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_workflow_runs(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListWorkflowRuns,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_workflow_usage(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetWorkflowUsage,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_assignees(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListAssignees,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_check_user_can_be_assigned(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesCheckUserCanBeAssigned,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_autolinks(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListAutolinks,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_autolink(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateAutolink,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_autolink(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetAutolink,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_autolink(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteAutolink,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_enable_automated_security_fixes(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposEnableAutomatedSecurityFixes,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_disable_automated_security_fixes(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDisableAutomatedSecurityFixes,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_branches(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListBranches,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_branch(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetBranch,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_branch_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetBranchProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_branch_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdateBranchProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_branch_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteBranchProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_admin_branch_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetAdminBranchProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_set_admin_branch_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposSetAdminBranchProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_admin_branch_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteAdminBranchProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_pull_request_review_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetPullRequestReviewProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_pull_request_review_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeletePullRequestReviewProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_pull_request_review_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdatePullRequestReviewProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_commit_signature_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetCommitSignatureProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_commit_signature_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateCommitSignatureProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_commit_signature_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteCommitSignatureProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_status_checks_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetStatusChecksProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_remove_status_check_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposRemoveStatusCheckProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_status_check_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdateStatusCheckProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_all_status_check_contexts(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetAllStatusCheckContexts,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_set_status_check_contexts(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposSetStatusCheckContexts,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_add_status_check_contexts(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposAddStatusCheckContexts,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_remove_status_check_contexts(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposRemoveStatusCheckContexts,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_access_restrictions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetAccessRestrictions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_access_restrictions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteAccessRestrictions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_apps_with_access_to_protected_branch(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetAppsWithAccessToProtectedBranch,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_set_app_access_restrictions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposSetAppAccessRestrictions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_add_app_access_restrictions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposAddAppAccessRestrictions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_remove_app_access_restrictions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposRemoveAppAccessRestrictions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_teams_with_access_to_protected_branch(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetTeamsWithAccessToProtectedBranch,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_set_team_access_restrictions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposSetTeamAccessRestrictions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_add_team_access_restrictions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposAddTeamAccessRestrictions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_remove_team_access_restrictions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposRemoveTeamAccessRestrictions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_users_with_access_to_protected_branch(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetUsersWithAccessToProtectedBranch,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_set_user_access_restrictions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposSetUserAccessRestrictions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_add_user_access_restrictions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposAddUserAccessRestrictions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_remove_user_access_restrictions(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposRemoveUserAccessRestrictions,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_rename_branch(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposRenameBranch,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_create(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksCreate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_get(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksGet,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_update(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksUpdate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_list_annotations(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksListAnnotations,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_rerequest_run(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksRerequestRun,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_create_suite(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksCreateSuite,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_set_suites_preferences(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksSetSuitesPreferences,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_get_suite(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksGetSuite,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_list_for_suite(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksListForSuite,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_rerequest_suite(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksRerequestSuite,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_list_alerts_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningListAlertsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_get_alert(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningGetAlert,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_update_alert(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningUpdateAlert,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_list_alert_instances(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningListAlertInstances,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_list_recent_analyses(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningListRecentAnalyses,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_get_analysis(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningGetAnalysis,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_delete_analysis(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningDeleteAnalysis,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_list_codeql_databases(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningListCodeqlDatabases,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_get_codeql_database(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningGetCodeqlDatabase,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_get_default_setup(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningGetDefaultSetup,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_update_default_setup(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningUpdateDefaultSetup,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_upload_sarif(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningUploadSarif,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_code_scanning_get_sarif(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodeScanningGetSarif,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_codeowners_errors(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCodeownersErrors,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_list_in_repository_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesListInRepositoryForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_create_with_repo_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesCreateWithRepoForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_list_devcontainers_in_repository_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesListDevcontainersInRepositoryForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_repo_machines_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesRepoMachinesForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_pre_flight_with_repo_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesPreFlightWithRepoForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_list_repo_secrets(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesListRepoSecrets,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_get_repo_public_key(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesGetRepoPublicKey,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_get_repo_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesGetRepoSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_create_or_update_repo_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesCreateOrUpdateRepoSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_delete_repo_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesDeleteRepoSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_collaborators(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListCollaborators,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_check_collaborator(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCheckCollaborator,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_add_collaborator(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposAddCollaborator,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_remove_collaborator(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposRemoveCollaborator,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_collaborator_permission_level(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetCollaboratorPermissionLevel,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_commit_comments_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListCommitCommentsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_commit_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetCommitComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_commit_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteCommitComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_commit_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdateCommitComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_list_for_commit_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsListForCommitComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_create_for_commit_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsCreateForCommitComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_delete_for_commit_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsDeleteForCommitComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_commits(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListCommits,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_branches_for_head_commit(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListBranchesForHeadCommit,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_comments_for_commit(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListCommentsForCommit,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_commit_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateCommitComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_pull_requests_associated_with_commit(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListPullRequestsAssociatedWithCommit,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_commit(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetCommit,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_list_for_ref(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksListForRef,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_checks_list_suites_for_ref(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ChecksListSuitesForRef,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_combined_status_for_ref(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetCombinedStatusForRef,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_commit_statuses_for_ref(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListCommitStatusesForRef,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_community_profile_metrics(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetCommunityProfileMetrics,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_compare_commits(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCompareCommits,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_content(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetContent,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_or_update_file_contents(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateOrUpdateFileContents,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_file(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteFile,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_contributors(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListContributors,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_list_alerts_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotListAlertsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_get_alert(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotGetAlert,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_update_alert(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotUpdateAlert,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_list_repo_secrets(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotListRepoSecrets,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_get_repo_public_key(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotGetRepoPublicKey,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_get_repo_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotGetRepoSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_create_or_update_repo_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotCreateOrUpdateRepoSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependabot_delete_repo_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependabotDeleteRepoSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependency_graph_diff_range(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependencyGraphDiffRange,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependency_graph_export_sbom(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependencyGraphExportSbom,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_dependency_graph_create_repository_snapshot(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::DependencyGraphCreateRepositorySnapshot,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_deployments(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListDeployments,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_deployment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateDeployment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_deployment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetDeployment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_deployment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteDeployment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_deployment_statuses(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListDeploymentStatuses,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_deployment_status(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateDeploymentStatus,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_deployment_status(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetDeploymentStatus,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_dispatch_event(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateDispatchEvent,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_all_environments(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetAllEnvironments,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_environment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetEnvironment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_or_update_environment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateOrUpdateEnvironment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_an_environment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteAnEnvironment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_deployment_branch_policies(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListDeploymentBranchPolicies,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_deployment_branch_policy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateDeploymentBranchPolicy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_deployment_branch_policy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetDeploymentBranchPolicy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_deployment_branch_policy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdateDeploymentBranchPolicy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_deployment_branch_policy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteDeploymentBranchPolicy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_all_deployment_protection_rules(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetAllDeploymentProtectionRules,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_deployment_protection_rule(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateDeploymentProtectionRule,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_custom_deployment_rule_integrations(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListCustomDeploymentRuleIntegrations,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_custom_deployment_protection_rule(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetCustomDeploymentProtectionRule,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_disable_deployment_protection_rule(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDisableDeploymentProtectionRule,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_repo_events(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListRepoEvents,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_forks(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListForks,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_fork(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateFork,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_create_blob(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitCreateBlob,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_get_blob(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitGetBlob,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_create_commit(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitCreateCommit,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_get_commit(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitGetCommit,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_list_matching_refs(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitListMatchingRefs,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_get_ref(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitGetRef,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_create_ref(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitCreateRef,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_delete_ref(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitDeleteRef,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_update_ref(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitUpdateRef,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_create_tag(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitCreateTag,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_get_tag(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitGetTag,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_create_tree(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitCreateTree,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_git_get_tree(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GitGetTree,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_webhooks(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListWebhooks,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_webhook(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateWebhook,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_webhook(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetWebhook,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_webhook(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteWebhook,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_webhook(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdateWebhook,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_webhook_config_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetWebhookConfigForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_webhook_config_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdateWebhookConfigForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_webhook_deliveries(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListWebhookDeliveries,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_webhook_delivery(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetWebhookDelivery,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_redeliver_webhook_delivery(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposRedeliverWebhookDelivery,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_ping_webhook(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposPingWebhook,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_test_push_webhook(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposTestPushWebhook,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_get_import_status(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsGetImportStatus,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_start_import(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsStartImport,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_cancel_import(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsCancelImport,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_update_import(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsUpdateImport,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_get_commit_authors(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsGetCommitAuthors,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_map_commit_author(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsMapCommitAuthor,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_get_large_files(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsGetLargeFiles,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_set_lfs_preference(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsSetLfsPreference,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_get_repo_installation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsGetRepoInstallation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_interactions_get_restrictions_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::InteractionsGetRestrictionsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_interactions_set_restrictions_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::InteractionsSetRestrictionsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_interactions_remove_restrictions_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::InteractionsRemoveRestrictionsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_invitations(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListInvitations,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_invitation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteInvitation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_invitation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdateInvitation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_create(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesCreate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_comments_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListCommentsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_get_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesGetComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_delete_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesDeleteComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_update_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesUpdateComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_list_for_issue_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsListForIssueComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_create_for_issue_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsCreateForIssueComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_delete_for_issue_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsDeleteForIssueComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_events_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListEventsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_get_event(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesGetEvent,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_get(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesGet,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_update(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesUpdate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_add_assignees(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesAddAssignees,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_remove_assignees(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesRemoveAssignees,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_check_user_can_be_assigned_to_issue(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesCheckUserCanBeAssignedToIssue,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_comments(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListComments,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_create_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesCreateComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_events(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListEvents,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_labels_on_issue(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListLabelsOnIssue,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_set_labels(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesSetLabels,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_add_labels(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesAddLabels,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_remove_all_labels(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesRemoveAllLabels,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_remove_label(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesRemoveLabel,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_lock(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesLock,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_unlock(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesUnlock,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_list_for_issue(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsListForIssue,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_create_for_issue(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsCreateForIssue,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_delete_for_issue(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsDeleteForIssue,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_events_for_timeline(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListEventsForTimeline,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_deploy_keys(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListDeployKeys,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_deploy_key(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateDeployKey,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_deploy_key(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetDeployKey,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_deploy_key(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteDeployKey,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_labels_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListLabelsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_create_label(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesCreateLabel,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_get_label(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesGetLabel,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_delete_label(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesDeleteLabel,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_update_label(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesUpdateLabel,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_languages(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListLanguages,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_enable_lfs_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposEnableLfsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_disable_lfs_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDisableLfsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_licenses_get_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::LicensesGetForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_merge_upstream(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposMergeUpstream,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_merge(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposMerge,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_milestones(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListMilestones,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_create_milestone(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesCreateMilestone,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_get_milestone(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesGetMilestone,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_delete_milestone(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesDeleteMilestone,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_update_milestone(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesUpdateMilestone,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_labels_for_milestone(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListLabelsForMilestone,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_repo_notifications_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListRepoNotificationsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_mark_repo_notifications_as_read(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityMarkRepoNotificationsAsRead,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_pages(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetPages,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_information_about_pages_site(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdateInformationAboutPagesSite,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_pages_site(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreatePagesSite,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_pages_site(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeletePagesSite,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_pages_builds(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListPagesBuilds,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_request_pages_build(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposRequestPagesBuild,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_latest_pages_build(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetLatestPagesBuild,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_pages_build(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetPagesBuild,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_pages_deployment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreatePagesDeployment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_pages_health_check(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetPagesHealthCheck,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_list_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsListForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_create_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsCreateForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_list(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsList,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_create(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsCreate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_list_review_comments_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsListReviewCommentsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_get_review_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsGetReviewComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_delete_review_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsDeleteReviewComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_update_review_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsUpdateReviewComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_list_for_pull_request_review_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsListForPullRequestReviewComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_create_for_pull_request_review_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsCreateForPullRequestReviewComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_delete_for_pull_request_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsDeleteForPullRequestComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_get(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsGet,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_update(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsUpdate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_create_with_pr_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesCreateWithPrForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_list_review_comments(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsListReviewComments,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_create_review_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsCreateReviewComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_create_reply_for_review_comment(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsCreateReplyForReviewComment,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_list_commits(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsListCommits,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_list_files(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsListFiles,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_check_if_merged(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsCheckIfMerged,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_merge(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsMerge,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_list_requested_reviewers(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsListRequestedReviewers,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_request_reviewers(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsRequestReviewers,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_remove_requested_reviewers(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsRemoveRequestedReviewers,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_list_reviews(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsListReviews,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_create_review(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsCreateReview,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_get_review(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsGetReview,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_update_review(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsUpdateReview,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_delete_pending_review(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsDeletePendingReview,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_list_comments_for_review(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsListCommentsForReview,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_dismiss_review(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsDismissReview,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_submit_review(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsSubmitReview,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_pulls_update_branch(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PullsUpdateBranch,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_readme(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetReadme,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_readme_in_directory(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetReadmeInDirectory,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_repos_watched_by_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListReposWatchedByUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_release_asset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetReleaseAsset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_release_asset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteReleaseAsset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_release_asset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdateReleaseAsset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_generate_release_notes(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGenerateReleaseNotes,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_latest_release(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetLatestRelease,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_release_by_tag(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetReleaseByTag,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_repos_starred_by_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListReposStarredByUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_release_assets(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListReleaseAssets,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_upload_release_asset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUploadReleaseAsset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_list_for_release(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsListForRelease,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_create_for_release(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsCreateForRelease,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_delete_for_release(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsDeleteForRelease,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_branch_rules(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetBranchRules,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_repo_rulesets(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetRepoRulesets,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_repo_ruleset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateRepoRuleset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_repo_ruleset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetRepoRuleset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_update_repo_ruleset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposUpdateRepoRuleset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_repo_ruleset(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteRepoRuleset,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_secret_scanning_list_alerts_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SecretScanningListAlertsForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_secret_scanning_get_alert(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SecretScanningGetAlert,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_secret_scanning_update_alert(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SecretScanningUpdateAlert,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_secret_scanning_list_locations_for_alert(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SecretScanningListLocationsForAlert,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_security_advisories_list_repository_advisories(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SecurityAdvisoriesListRepositoryAdvisories,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_security_advisories_create_repository_advisory(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SecurityAdvisoriesCreateRepositoryAdvisory,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_security_advisories_create_private_vulnerability_report(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SecurityAdvisoriesCreatePrivateVulnerabilityReport,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_security_advisories_get_repository_advisory(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SecurityAdvisoriesGetRepositoryAdvisory,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_security_advisories_update_repository_advisory(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SecurityAdvisoriesUpdateRepositoryAdvisory,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_stargazers_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListStargazersForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_code_frequency_stats(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetCodeFrequencyStats,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_commit_activity_stats(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetCommitActivityStats,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_contributors_stats(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetContributorsStats,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_participation_stats(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetParticipationStats,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_punch_card_stats(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetPunchCardStats,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_commit_status(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateCommitStatus,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_watchers_for_repo(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListWatchersForRepo,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_get_repo_subscription(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityGetRepoSubscription,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_set_repo_subscription(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivitySetRepoSubscription,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_delete_repo_subscription(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityDeleteRepoSubscription,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_tags(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListTags,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_tag_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListTagProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_tag_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateTagProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_delete_tag_protection(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeleteTagProtection,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_download_tarball_archive(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDownloadTarballArchive,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_teams(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListTeams,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_all_topics(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetAllTopics,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_replace_all_topics(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposReplaceAllTopics,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_clones(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetClones,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_top_paths(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetTopPaths,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_top_referrers(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetTopReferrers,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_get_views(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposGetViews,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_transfer(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposTransfer,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_check_vulnerability_alerts(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCheckVulnerabilityAlerts,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_enable_vulnerability_alerts(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposEnableVulnerabilityAlerts,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_disable_vulnerability_alerts(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDisableVulnerabilityAlerts,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_download_zipball_archive(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDownloadZipballArchive,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_using_template(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateUsingTemplate,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_public(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListPublic,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_environment_secrets(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListEnvironmentSecrets,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_environment_public_key(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetEnvironmentPublicKey,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_environment_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetEnvironmentSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_or_update_environment_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateOrUpdateEnvironmentSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_environment_secret(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteEnvironmentSecret,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_list_environment_variables(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsListEnvironmentVariables,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_create_environment_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsCreateEnvironmentVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_get_environment_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsGetEnvironmentVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_delete_environment_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsDeleteEnvironmentVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_actions_update_environment_variable(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActionsUpdateEnvironmentVariable,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_search_code(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SearchCode,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_search_commits(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SearchCommits,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_search_issues_and_pull_requests(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SearchIssuesAndPullRequests,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_search_labels(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SearchLabels,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_search_repos(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SearchRepos,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_search_topics(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SearchTopics,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_search_users(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::SearchUsers,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_get_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsGetLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_delete_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsDeleteLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_update_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsUpdateLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_discussions_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListDiscussionsLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_create_discussion_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsCreateDiscussionLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_get_discussion_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsGetDiscussionLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_delete_discussion_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsDeleteDiscussionLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_update_discussion_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsUpdateDiscussionLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_discussion_comments_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListDiscussionCommentsLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_create_discussion_comment_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsCreateDiscussionCommentLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_get_discussion_comment_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsGetDiscussionCommentLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_delete_discussion_comment_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsDeleteDiscussionCommentLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_update_discussion_comment_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsUpdateDiscussionCommentLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_list_for_team_discussion_comment_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsListForTeamDiscussionCommentLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_create_for_team_discussion_comment_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsCreateForTeamDiscussionCommentLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_list_for_team_discussion_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsListForTeamDiscussionLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_reactions_create_for_team_discussion_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReactionsCreateForTeamDiscussionLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_pending_invitations_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListPendingInvitationsLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_members_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListMembersLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_get_member_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsGetMemberLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_add_member_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsAddMemberLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_remove_member_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsRemoveMemberLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_get_membership_for_user_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsGetMembershipForUserLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_add_or_update_membership_for_user_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsAddOrUpdateMembershipForUserLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_remove_membership_for_user_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsRemoveMembershipForUserLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_projects_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListProjectsLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_check_permissions_for_project_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsCheckPermissionsForProjectLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_add_or_update_project_permissions_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsAddOrUpdateProjectPermissionsLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_remove_project_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsRemoveProjectLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_repos_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListReposLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_check_permissions_for_repo_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsCheckPermissionsForRepoLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_add_or_update_repo_permissions_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsAddOrUpdateRepoPermissionsLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_remove_repo_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsRemoveRepoLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_child_legacy(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListChildLegacy,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_get_authenticated(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersGetAuthenticated,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_update_authenticated(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersUpdateAuthenticated,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_blocked_by_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListBlockedByAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_check_blocked(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersCheckBlocked,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_block(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersBlock,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_unblock(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersUnblock,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_list_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesListForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_create_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesCreateForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_list_secrets_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesListSecretsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_get_public_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesGetPublicKeyForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_get_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesGetSecretForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_create_or_update_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesCreateOrUpdateSecretForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_delete_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesDeleteSecretForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_list_repositories_for_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesListRepositoriesForSecretForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_set_repositories_for_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesSetRepositoriesForSecretForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_add_repository_for_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesAddRepositoryForSecretForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_remove_repository_for_secret_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesRemoveRepositoryForSecretForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_get_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesGetForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_delete_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesDeleteForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_update_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesUpdateForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_export_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesExportForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_get_export_details_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesGetExportDetailsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_codespace_machines_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesCodespaceMachinesForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_publish_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesPublishForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_start_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesStartForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_codespaces_stop_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::CodespacesStopForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_list_docker_migration_conflicting_packages_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesListDockerMigrationConflictingPackagesForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_set_primary_email_visibility_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersSetPrimaryEmailVisibilityForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_emails_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListEmailsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_add_email_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersAddEmailForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_delete_email_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersDeleteEmailForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_followers_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListFollowersForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_followed_by_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListFollowedByAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_check_person_is_followed_by_authenticated(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersCheckPersonIsFollowedByAuthenticated,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_follow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersFollow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_unfollow(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersUnfollow,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_gpg_keys_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListGpgKeysForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_create_gpg_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersCreateGpgKeyForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_get_gpg_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersGetGpgKeyForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_delete_gpg_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersDeleteGpgKeyForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_installations_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListInstallationsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_installation_repos_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListInstallationReposForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_add_repo_to_installation_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsAddRepoToInstallationForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_remove_repo_from_installation_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsRemoveRepoFromInstallationForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_interactions_get_restrictions_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::InteractionsGetRestrictionsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_interactions_set_restrictions_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::InteractionsSetRestrictionsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_interactions_remove_restrictions_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::InteractionsRemoveRestrictionsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_issues_list_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::IssuesListForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_public_ssh_keys_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListPublicSshKeysForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_create_public_ssh_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersCreatePublicSshKeyForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_get_public_ssh_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersGetPublicSshKeyForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_delete_public_ssh_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersDeletePublicSshKeyForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_subscriptions_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListSubscriptionsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_list_subscriptions_for_authenticated_user_stubbed(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsListSubscriptionsForAuthenticatedUserStubbed,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_memberships_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListMembershipsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_get_membership_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsGetMembershipForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_update_membership_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsUpdateMembershipForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_list_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsListForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_start_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsStartForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_get_status_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsGetStatusForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_get_archive_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsGetArchiveForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_delete_archive_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsDeleteArchiveForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_unlock_repo_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsUnlockRepoForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_migrations_list_repos_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::MigrationsListReposForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_list_packages_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesListPackagesForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_get_package_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesGetPackageForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_delete_package_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesDeletePackageForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_restore_package_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesRestorePackageForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_get_all_package_versions_for_package_owned_by_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_get_package_version_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesGetPackageVersionForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_delete_package_version_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesDeletePackageVersionForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_restore_package_version_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesRestorePackageVersionForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_create_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsCreateForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_public_emails_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListPublicEmailsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_create_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposCreateForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_invitations_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListInvitationsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_decline_invitation_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposDeclineInvitationForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_accept_invitation_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposAcceptInvitationForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_social_accounts_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListSocialAccountsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_add_social_account_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersAddSocialAccountForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_delete_social_account_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersDeleteSocialAccountForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_ssh_signing_keys_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListSshSigningKeysForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_create_ssh_signing_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersCreateSshSigningKeyForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_get_ssh_signing_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersGetSshSigningKeyForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_delete_ssh_signing_key_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersDeleteSshSigningKeyForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_repos_starred_by_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListReposStarredByAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_check_repo_is_starred_by_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityCheckRepoIsStarredByAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_star_repo_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityStarRepoForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_unstar_repo_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityUnstarRepoForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_watched_repos_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListWatchedReposForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_teams_list_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::TeamsListForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersList,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_get_by_username(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersGetByUsername,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_list_docker_migration_conflicting_packages_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesListDockerMigrationConflictingPackagesForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_events_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListEventsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_org_events_for_authenticated_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListOrgEventsForAuthenticatedUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_public_events_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListPublicEventsForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_followers_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListFollowersForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_following_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListFollowingForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_check_following_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersCheckFollowingForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_gists_list_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::GistsListForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_gpg_keys_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListGpgKeysForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_get_context_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersGetContextForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_apps_get_user_installation(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::AppsGetUserInstallation,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_public_keys_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListPublicKeysForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_orgs_list_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::OrgsListForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_list_packages_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesListPackagesForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_get_package_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesGetPackageForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_delete_package_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesDeletePackageForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_restore_package_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesRestorePackageForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_get_all_package_versions_for_package_owned_by_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesGetAllPackageVersionsForPackageOwnedByUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_get_package_version_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesGetPackageVersionForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_delete_package_version_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesDeletePackageVersionForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_packages_restore_package_version_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::PackagesRestorePackageVersionForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_projects_list_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ProjectsListForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_received_events_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListReceivedEventsForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_activity_list_received_public_events_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ActivityListReceivedPublicEventsForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_repos_list_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::ReposListForUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_billing_get_github_actions_billing_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::BillingGetGithubActionsBillingUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_billing_get_github_packages_billing_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::BillingGetGithubPackagesBillingUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_billing_get_shared_storage_billing_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::BillingGetSharedStorageBillingUser,
    ) -> Result<(), String> {
        Ok(())
    }

    fn execute_users_list_social_accounts_for_user(
        &self,
        matches: &clap::ArgMatches,
        request: &mut builder::UsersListSocialAccountsForUser,
    ) -> Result<(), String> {
        Ok(())
    }
}

impl CliOverride for () {}

#[derive(Copy, Clone, Debug)]
pub enum CliCommand {
    MetaRoot,
    AppsGetAuthenticated,
    AppsCreateFromManifest,
    AppsGetWebhookConfigForApp,
    AppsUpdateWebhookConfigForApp,
    AppsListWebhookDeliveries,
    AppsGetWebhookDelivery,
    AppsRedeliverWebhookDelivery,
    AppsListInstallationRequestsForAuthenticatedApp,
    AppsListInstallations,
    AppsGetInstallation,
    AppsDeleteInstallation,
    AppsCreateInstallationAccessToken,
    AppsSuspendInstallation,
    AppsUnsuspendInstallation,
    AppsDeleteAuthorization,
    AppsCheckToken,
    AppsDeleteToken,
    AppsResetToken,
    AppsScopeToken,
    AppsGetBySlug,
    CodesOfConductGetAllCodesOfConduct,
    CodesOfConductGetConductCode,
    EmojisGet,
    DependabotListAlertsForEnterprise,
    SecretScanningListAlertsForEnterprise,
    ActivityListPublicEvents,
    ActivityGetFeeds,
    GistsList,
    GistsCreate,
    GistsListPublic,
    GistsListStarred,
    GistsGet,
    GistsDelete,
    GistsUpdate,
    GistsListComments,
    GistsCreateComment,
    GistsGetComment,
    GistsDeleteComment,
    GistsUpdateComment,
    GistsListCommits,
    GistsListForks,
    GistsFork,
    GistsCheckIsStarred,
    GistsStar,
    GistsUnstar,
    GistsGetRevision,
    GitignoreGetAllTemplates,
    GitignoreGetTemplate,
    AppsListReposAccessibleToInstallation,
    AppsRevokeInstallationAccessToken,
    IssuesList,
    LicensesGetAllCommonlyUsed,
    LicensesGet,
    MarkdownRender,
    MetaGetAllVersions,
    AppsGetSubscriptionPlanForAccount,
    AppsListPlans,
    AppsListAccountsForPlan,
    AppsGetSubscriptionPlanForAccountStubbed,
    AppsListPlansStubbed,
    AppsListAccountsForPlanStubbed,
    MetaGet,
    ActivityListPublicEventsForRepoNetwork,
    ActivityListNotificationsForAuthenticatedUser,
    ActivityMarkNotificationsAsRead,
    ActivityGetThread,
    ActivityMarkThreadAsRead,
    ActivityGetThreadSubscriptionForAuthenticatedUser,
    ActivitySetThreadSubscription,
    ActivityDeleteThreadSubscription,
    MetaGetOctocat,
    OrgsList,
    OrgsListPatGrantRequests,
    OrgsReviewPatGrantRequestsInBulk,
    OrgsReviewPatGrantRequest,
    OrgsListPatGrantRequestRepositories,
    OrgsListPatGrants,
    OrgsUpdatePatAccesses,
    OrgsUpdatePatAccess,
    OrgsListPatGrantRepositories,
    MetaGetZen,
    ActionsGetActionsCacheUsageForOrg,
    ActionsGetActionsCacheUsageByRepoForOrg,
    OidcGetOidcCustomSubTemplateForOrg,
    OidcUpdateOidcCustomSubTemplateForOrg,
    ActionsGetGithubActionsPermissionsOrganization,
    ActionsSetGithubActionsPermissionsOrganization,
    ActionsListSelectedRepositoriesEnabledGithubActionsOrganization,
    ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization,
    ActionsEnableSelectedRepositoryGithubActionsOrganization,
    ActionsDisableSelectedRepositoryGithubActionsOrganization,
    ActionsGetAllowedActionsOrganization,
    ActionsSetAllowedActionsOrganization,
    ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization,
    ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization,
    ActionsListRequiredWorkflows,
    ActionsCreateRequiredWorkflow,
    ActionsGetRequiredWorkflow,
    ActionsDeleteRequiredWorkflow,
    ActionsUpdateRequiredWorkflow,
    ActionsListSelectedRepositoriesRequiredWorkflow,
    ActionsSetSelectedReposToRequiredWorkflow,
    ActionsAddSelectedRepoToRequiredWorkflow,
    ActionsRemoveSelectedRepoFromRequiredWorkflow,
    ActionsListSelfHostedRunnersForOrg,
    ActionsListRunnerApplicationsForOrg,
    ActionsCreateRegistrationTokenForOrg,
    ActionsCreateRemoveTokenForOrg,
    ActionsGetSelfHostedRunnerForOrg,
    ActionsDeleteSelfHostedRunnerFromOrg,
    ActionsListLabelsForSelfHostedRunnerForOrg,
    ActionsSetCustomLabelsForSelfHostedRunnerForOrg,
    ActionsAddCustomLabelsToSelfHostedRunnerForOrg,
    ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg,
    ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg,
    ActionsListOrgSecrets,
    ActionsGetOrgPublicKey,
    ActionsGetOrgSecret,
    ActionsCreateOrUpdateOrgSecret,
    ActionsDeleteOrgSecret,
    ActionsListSelectedReposForOrgSecret,
    ActionsSetSelectedReposForOrgSecret,
    ActionsAddSelectedRepoToOrgSecret,
    ActionsRemoveSelectedRepoFromOrgSecret,
    ActionsListOrgVariables,
    ActionsCreateOrgVariable,
    ActionsGetOrgVariable,
    ActionsDeleteOrgVariable,
    ActionsUpdateOrgVariable,
    ActionsListSelectedReposForOrgVariable,
    ActionsSetSelectedReposForOrgVariable,
    ActionsAddSelectedRepoToOrgVariable,
    ActionsRemoveSelectedRepoFromOrgVariable,
    OrgsListBlockedUsers,
    OrgsCheckBlockedUser,
    OrgsBlockUser,
    OrgsUnblockUser,
    CodeScanningListAlertsForOrg,
    CodespacesListInOrganization,
    CodespacesSetCodespacesBilling,
    CodespacesSetCodespacesBillingUsers,
    CodespacesDeleteCodespacesBillingUsers,
    CodespacesListOrgSecrets,
    CodespacesGetOrgPublicKey,
    CodespacesGetOrgSecret,
    CodespacesCreateOrUpdateOrgSecret,
    CodespacesDeleteOrgSecret,
    CodespacesListSelectedReposForOrgSecret,
    CodespacesSetSelectedReposForOrgSecret,
    CodespacesAddSelectedRepoToOrgSecret,
    CodespacesRemoveSelectedRepoFromOrgSecret,
    DependabotListAlertsForOrg,
    DependabotListOrgSecrets,
    DependabotGetOrgPublicKey,
    DependabotGetOrgSecret,
    DependabotCreateOrUpdateOrgSecret,
    DependabotDeleteOrgSecret,
    DependabotListSelectedReposForOrgSecret,
    DependabotSetSelectedReposForOrgSecret,
    DependabotAddSelectedRepoToOrgSecret,
    DependabotRemoveSelectedRepoFromOrgSecret,
    PackagesListDockerMigrationConflictingPackagesForOrganization,
    ActivityListPublicOrgEvents,
    OrgsListFailedInvitations,
    OrgsListWebhooks,
    OrgsCreateWebhook,
    OrgsGetWebhook,
    OrgsDeleteWebhook,
    OrgsUpdateWebhook,
    OrgsGetWebhookConfigForOrg,
    OrgsUpdateWebhookConfigForOrg,
    OrgsListWebhookDeliveries,
    OrgsGetWebhookDelivery,
    OrgsRedeliverWebhookDelivery,
    OrgsPingWebhook,
    AppsGetOrgInstallation,
    OrgsListAppInstallations,
    InteractionsGetRestrictionsForOrg,
    InteractionsSetRestrictionsForOrg,
    InteractionsRemoveRestrictionsForOrg,
    OrgsListPendingInvitations,
    OrgsCreateInvitation,
    OrgsCancelInvitation,
    OrgsListInvitationTeams,
    IssuesListForOrg,
    OrgsListMembers,
    OrgsCheckMembershipForUser,
    OrgsRemoveMember,
    CodespacesGetCodespacesForUserInOrg,
    CodespacesDeleteFromOrganization,
    CodespacesStopInOrganization,
    OrgsGetMembershipForUser,
    OrgsSetMembershipForUser,
    OrgsRemoveMembershipForUser,
    MigrationsListForOrg,
    MigrationsStartForOrg,
    MigrationsGetStatusForOrg,
    MigrationsDownloadArchiveForOrg,
    MigrationsDeleteArchiveForOrg,
    MigrationsUnlockRepoForOrg,
    MigrationsListReposForOrg,
    OrgsListOutsideCollaborators,
    OrgsConvertMemberToOutsideCollaborator,
    OrgsRemoveOutsideCollaborator,
    PackagesListPackagesForOrganization,
    PackagesGetPackageForOrganization,
    PackagesDeletePackageForOrg,
    PackagesRestorePackageForOrg,
    PackagesGetAllPackageVersionsForPackageOwnedByOrg,
    PackagesGetPackageVersionForOrganization,
    PackagesDeletePackageVersionForOrg,
    PackagesRestorePackageVersionForOrg,
    ProjectsListForOrg,
    ProjectsCreateForOrg,
    OrgsListPublicMembers,
    OrgsCheckPublicMembershipForUser,
    OrgsSetPublicMembershipForAuthenticatedUser,
    OrgsRemovePublicMembershipForAuthenticatedUser,
    ReposListForOrg,
    ReposCreateInOrg,
    ReposGetOrgRulesets,
    ReposCreateOrgRuleset,
    ReposGetOrgRuleset,
    ReposUpdateOrgRuleset,
    ReposDeleteOrgRuleset,
    SecretScanningListAlertsForOrg,
    OrgsListSecurityManagerTeams,
    OrgsAddSecurityManagerTeam,
    OrgsRemoveSecurityManagerTeam,
    BillingGetGithubActionsBillingOrg,
    BillingGetGithubPackagesBillingOrg,
    BillingGetSharedStorageBillingOrg,
    TeamsList,
    TeamsCreate,
    TeamsGetByName,
    TeamsDeleteInOrg,
    TeamsUpdateInOrg,
    TeamsListDiscussionsInOrg,
    TeamsCreateDiscussionInOrg,
    TeamsGetDiscussionInOrg,
    TeamsDeleteDiscussionInOrg,
    TeamsUpdateDiscussionInOrg,
    TeamsListDiscussionCommentsInOrg,
    TeamsCreateDiscussionCommentInOrg,
    TeamsGetDiscussionCommentInOrg,
    TeamsDeleteDiscussionCommentInOrg,
    TeamsUpdateDiscussionCommentInOrg,
    ReactionsListForTeamDiscussionCommentInOrg,
    ReactionsCreateForTeamDiscussionCommentInOrg,
    ReactionsDeleteForTeamDiscussionComment,
    ReactionsListForTeamDiscussionInOrg,
    ReactionsCreateForTeamDiscussionInOrg,
    ReactionsDeleteForTeamDiscussion,
    TeamsListPendingInvitationsInOrg,
    TeamsListMembersInOrg,
    TeamsGetMembershipForUserInOrg,
    TeamsAddOrUpdateMembershipForUserInOrg,
    TeamsRemoveMembershipForUserInOrg,
    TeamsListProjectsInOrg,
    TeamsCheckPermissionsForProjectInOrg,
    TeamsAddOrUpdateProjectPermissionsInOrg,
    TeamsRemoveProjectInOrg,
    TeamsListReposInOrg,
    TeamsCheckPermissionsForRepoInOrg,
    TeamsAddOrUpdateRepoPermissionsInOrg,
    TeamsRemoveRepoInOrg,
    TeamsListChildInOrg,
    OrgsEnableOrDisableSecurityProductOnAllOrgRepos,
    ProjectsGetCard,
    ProjectsDeleteCard,
    ProjectsUpdateCard,
    ProjectsMoveCard,
    ProjectsGetColumn,
    ProjectsDeleteColumn,
    ProjectsUpdateColumn,
    UsersListSshSigningKeysForUser,
    ProjectsMoveColumn,
    ProjectsGet,
    ProjectsDelete,
    ProjectsUpdate,
    ProjectsListCollaborators,
    ProjectsAddCollaborator,
    ProjectsRemoveCollaborator,
    ProjectsGetPermissionForUser,
    ProjectsListColumns,
    ProjectsCreateColumn,
    RateLimitGet,
    ActionsListRepoRequiredWorkflows,
    ActionsGetRepoRequiredWorkflow,
    ActionsGetRepoRequiredWorkflowUsage,
    ReposGet,
    ReposDelete,
    ReposUpdate,
    ActionsListArtifactsForRepo,
    ActionsGetArtifact,
    ActionsDeleteArtifact,
    ActionsDownloadArtifact,
    ActionsGetActionsCacheUsage,
    ActionsGetActionsCacheList,
    ActionsDeleteActionsCacheByKey,
    ActionsDeleteActionsCacheById,
    ActionsGetJobForWorkflowRun,
    ActionsDownloadJobLogsForWorkflowRun,
    ActionsReRunJobForWorkflowRun,
    ActionsGetCustomOidcSubClaimForRepo,
    ActionsSetCustomOidcSubClaimForRepo,
    ActionsListRepoOrganizationSecrets,
    ActionsListRepoOrganizationVariables,
    ActionsGetGithubActionsPermissionsRepository,
    ActionsSetGithubActionsPermissionsRepository,
    ActionsGetWorkflowAccessToRepository,
    ActionsSetWorkflowAccessToRepository,
    ActionsGetAllowedActionsRepository,
    ActionsSetAllowedActionsRepository,
    ActionsGetGithubActionsDefaultWorkflowPermissionsRepository,
    ActionsSetGithubActionsDefaultWorkflowPermissionsRepository,
    ActionsListRequiredWorkflowRuns,
    ActionsListSelfHostedRunnersForRepo,
    ActionsListRunnerApplicationsForRepo,
    ActionsCreateRegistrationTokenForRepo,
    ActionsCreateRemoveTokenForRepo,
    ActionsGetSelfHostedRunnerForRepo,
    ActionsDeleteSelfHostedRunnerFromRepo,
    ActionsListLabelsForSelfHostedRunnerForRepo,
    ActionsSetCustomLabelsForSelfHostedRunnerForRepo,
    ActionsAddCustomLabelsToSelfHostedRunnerForRepo,
    ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo,
    ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo,
    ActionsListWorkflowRunsForRepo,
    ActionsGetWorkflowRun,
    ActionsDeleteWorkflowRun,
    ActionsGetReviewsForRun,
    ActionsApproveWorkflowRun,
    ActionsListWorkflowRunArtifacts,
    ActionsGetWorkflowRunAttempt,
    ActionsListJobsForWorkflowRunAttempt,
    ActionsDownloadWorkflowRunAttemptLogs,
    ActionsCancelWorkflowRun,
    ActionsReviewCustomGatesForRun,
    ActionsListJobsForWorkflowRun,
    ActionsDownloadWorkflowRunLogs,
    ActionsDeleteWorkflowRunLogs,
    ActionsGetPendingDeploymentsForRun,
    ActionsReviewPendingDeploymentsForRun,
    ActionsReRunWorkflow,
    ActionsReRunWorkflowFailedJobs,
    ActionsGetWorkflowRunUsage,
    ActionsListRepoSecrets,
    ActionsGetRepoPublicKey,
    ActionsGetRepoSecret,
    ActionsCreateOrUpdateRepoSecret,
    ActionsDeleteRepoSecret,
    ActionsListRepoVariables,
    ActionsCreateRepoVariable,
    ActionsGetRepoVariable,
    ActionsDeleteRepoVariable,
    ActionsUpdateRepoVariable,
    ActionsListRepoWorkflows,
    ActionsGetWorkflow,
    ActionsDisableWorkflow,
    ActionsCreateWorkflowDispatch,
    ActionsEnableWorkflow,
    ActionsListWorkflowRuns,
    ActionsGetWorkflowUsage,
    IssuesListAssignees,
    IssuesCheckUserCanBeAssigned,
    ReposListAutolinks,
    ReposCreateAutolink,
    ReposGetAutolink,
    ReposDeleteAutolink,
    ReposEnableAutomatedSecurityFixes,
    ReposDisableAutomatedSecurityFixes,
    ReposListBranches,
    ReposGetBranch,
    ReposGetBranchProtection,
    ReposUpdateBranchProtection,
    ReposDeleteBranchProtection,
    ReposGetAdminBranchProtection,
    ReposSetAdminBranchProtection,
    ReposDeleteAdminBranchProtection,
    ReposGetPullRequestReviewProtection,
    ReposDeletePullRequestReviewProtection,
    ReposUpdatePullRequestReviewProtection,
    ReposGetCommitSignatureProtection,
    ReposCreateCommitSignatureProtection,
    ReposDeleteCommitSignatureProtection,
    ReposGetStatusChecksProtection,
    ReposRemoveStatusCheckProtection,
    ReposUpdateStatusCheckProtection,
    ReposGetAllStatusCheckContexts,
    ReposSetStatusCheckContexts,
    ReposAddStatusCheckContexts,
    ReposRemoveStatusCheckContexts,
    ReposGetAccessRestrictions,
    ReposDeleteAccessRestrictions,
    ReposGetAppsWithAccessToProtectedBranch,
    ReposSetAppAccessRestrictions,
    ReposAddAppAccessRestrictions,
    ReposRemoveAppAccessRestrictions,
    ReposGetTeamsWithAccessToProtectedBranch,
    ReposSetTeamAccessRestrictions,
    ReposAddTeamAccessRestrictions,
    ReposRemoveTeamAccessRestrictions,
    ReposGetUsersWithAccessToProtectedBranch,
    ReposSetUserAccessRestrictions,
    ReposAddUserAccessRestrictions,
    ReposRemoveUserAccessRestrictions,
    ReposRenameBranch,
    ChecksCreate,
    ChecksGet,
    ChecksUpdate,
    ChecksListAnnotations,
    ChecksRerequestRun,
    ChecksCreateSuite,
    ChecksSetSuitesPreferences,
    ChecksGetSuite,
    ChecksListForSuite,
    ChecksRerequestSuite,
    CodeScanningListAlertsForRepo,
    CodeScanningGetAlert,
    CodeScanningUpdateAlert,
    CodeScanningListAlertInstances,
    CodeScanningListRecentAnalyses,
    CodeScanningGetAnalysis,
    CodeScanningDeleteAnalysis,
    CodeScanningListCodeqlDatabases,
    CodeScanningGetCodeqlDatabase,
    CodeScanningGetDefaultSetup,
    CodeScanningUpdateDefaultSetup,
    CodeScanningUploadSarif,
    CodeScanningGetSarif,
    ReposCodeownersErrors,
    CodespacesListInRepositoryForAuthenticatedUser,
    CodespacesCreateWithRepoForAuthenticatedUser,
    CodespacesListDevcontainersInRepositoryForAuthenticatedUser,
    CodespacesRepoMachinesForAuthenticatedUser,
    CodespacesPreFlightWithRepoForAuthenticatedUser,
    CodespacesListRepoSecrets,
    CodespacesGetRepoPublicKey,
    CodespacesGetRepoSecret,
    CodespacesCreateOrUpdateRepoSecret,
    CodespacesDeleteRepoSecret,
    ReposListCollaborators,
    ReposCheckCollaborator,
    ReposAddCollaborator,
    ReposRemoveCollaborator,
    ReposGetCollaboratorPermissionLevel,
    ReposListCommitCommentsForRepo,
    ReposGetCommitComment,
    ReposDeleteCommitComment,
    ReposUpdateCommitComment,
    ReactionsListForCommitComment,
    ReactionsCreateForCommitComment,
    ReactionsDeleteForCommitComment,
    ReposListCommits,
    ReposListBranchesForHeadCommit,
    ReposListCommentsForCommit,
    ReposCreateCommitComment,
    ReposListPullRequestsAssociatedWithCommit,
    ReposGetCommit,
    ChecksListForRef,
    ChecksListSuitesForRef,
    ReposGetCombinedStatusForRef,
    ReposListCommitStatusesForRef,
    ReposGetCommunityProfileMetrics,
    ReposCompareCommits,
    ReposGetContent,
    ReposCreateOrUpdateFileContents,
    ReposDeleteFile,
    ReposListContributors,
    DependabotListAlertsForRepo,
    DependabotGetAlert,
    DependabotUpdateAlert,
    DependabotListRepoSecrets,
    DependabotGetRepoPublicKey,
    DependabotGetRepoSecret,
    DependabotCreateOrUpdateRepoSecret,
    DependabotDeleteRepoSecret,
    DependencyGraphDiffRange,
    DependencyGraphExportSbom,
    DependencyGraphCreateRepositorySnapshot,
    ReposListDeployments,
    ReposCreateDeployment,
    ReposGetDeployment,
    ReposDeleteDeployment,
    ReposListDeploymentStatuses,
    ReposCreateDeploymentStatus,
    ReposGetDeploymentStatus,
    ReposCreateDispatchEvent,
    ReposGetAllEnvironments,
    ReposGetEnvironment,
    ReposCreateOrUpdateEnvironment,
    ReposDeleteAnEnvironment,
    ReposListDeploymentBranchPolicies,
    ReposCreateDeploymentBranchPolicy,
    ReposGetDeploymentBranchPolicy,
    ReposUpdateDeploymentBranchPolicy,
    ReposDeleteDeploymentBranchPolicy,
    ReposGetAllDeploymentProtectionRules,
    ReposCreateDeploymentProtectionRule,
    ReposListCustomDeploymentRuleIntegrations,
    ReposGetCustomDeploymentProtectionRule,
    ReposDisableDeploymentProtectionRule,
    ActivityListRepoEvents,
    ReposListForks,
    ReposCreateFork,
    GitCreateBlob,
    GitGetBlob,
    GitCreateCommit,
    GitGetCommit,
    GitListMatchingRefs,
    GitGetRef,
    GitCreateRef,
    GitDeleteRef,
    GitUpdateRef,
    GitCreateTag,
    GitGetTag,
    GitCreateTree,
    GitGetTree,
    ReposListWebhooks,
    ReposCreateWebhook,
    ReposGetWebhook,
    ReposDeleteWebhook,
    ReposUpdateWebhook,
    ReposGetWebhookConfigForRepo,
    ReposUpdateWebhookConfigForRepo,
    ReposListWebhookDeliveries,
    ReposGetWebhookDelivery,
    ReposRedeliverWebhookDelivery,
    ReposPingWebhook,
    ReposTestPushWebhook,
    MigrationsGetImportStatus,
    MigrationsStartImport,
    MigrationsCancelImport,
    MigrationsUpdateImport,
    MigrationsGetCommitAuthors,
    MigrationsMapCommitAuthor,
    MigrationsGetLargeFiles,
    MigrationsSetLfsPreference,
    AppsGetRepoInstallation,
    InteractionsGetRestrictionsForRepo,
    InteractionsSetRestrictionsForRepo,
    InteractionsRemoveRestrictionsForRepo,
    ReposListInvitations,
    ReposDeleteInvitation,
    ReposUpdateInvitation,
    IssuesListForRepo,
    IssuesCreate,
    IssuesListCommentsForRepo,
    IssuesGetComment,
    IssuesDeleteComment,
    IssuesUpdateComment,
    ReactionsListForIssueComment,
    ReactionsCreateForIssueComment,
    ReactionsDeleteForIssueComment,
    IssuesListEventsForRepo,
    IssuesGetEvent,
    IssuesGet,
    IssuesUpdate,
    IssuesAddAssignees,
    IssuesRemoveAssignees,
    IssuesCheckUserCanBeAssignedToIssue,
    IssuesListComments,
    IssuesCreateComment,
    IssuesListEvents,
    IssuesListLabelsOnIssue,
    IssuesSetLabels,
    IssuesAddLabels,
    IssuesRemoveAllLabels,
    IssuesRemoveLabel,
    IssuesLock,
    IssuesUnlock,
    ReactionsListForIssue,
    ReactionsCreateForIssue,
    ReactionsDeleteForIssue,
    IssuesListEventsForTimeline,
    ReposListDeployKeys,
    ReposCreateDeployKey,
    ReposGetDeployKey,
    ReposDeleteDeployKey,
    IssuesListLabelsForRepo,
    IssuesCreateLabel,
    IssuesGetLabel,
    IssuesDeleteLabel,
    IssuesUpdateLabel,
    ReposListLanguages,
    ReposEnableLfsForRepo,
    ReposDisableLfsForRepo,
    LicensesGetForRepo,
    ReposMergeUpstream,
    ReposMerge,
    IssuesListMilestones,
    IssuesCreateMilestone,
    IssuesGetMilestone,
    IssuesDeleteMilestone,
    IssuesUpdateMilestone,
    IssuesListLabelsForMilestone,
    ActivityListRepoNotificationsForAuthenticatedUser,
    ActivityMarkRepoNotificationsAsRead,
    ReposGetPages,
    ReposUpdateInformationAboutPagesSite,
    ReposCreatePagesSite,
    ReposDeletePagesSite,
    ReposListPagesBuilds,
    ReposRequestPagesBuild,
    ReposGetLatestPagesBuild,
    ReposGetPagesBuild,
    ReposCreatePagesDeployment,
    ReposGetPagesHealthCheck,
    ProjectsListForRepo,
    ProjectsCreateForRepo,
    PullsList,
    PullsCreate,
    PullsListReviewCommentsForRepo,
    PullsGetReviewComment,
    PullsDeleteReviewComment,
    PullsUpdateReviewComment,
    ReactionsListForPullRequestReviewComment,
    ReactionsCreateForPullRequestReviewComment,
    ReactionsDeleteForPullRequestComment,
    PullsGet,
    PullsUpdate,
    CodespacesCreateWithPrForAuthenticatedUser,
    PullsListReviewComments,
    PullsCreateReviewComment,
    PullsCreateReplyForReviewComment,
    PullsListCommits,
    PullsListFiles,
    PullsCheckIfMerged,
    PullsMerge,
    PullsListRequestedReviewers,
    PullsRequestReviewers,
    PullsRemoveRequestedReviewers,
    PullsListReviews,
    PullsCreateReview,
    PullsGetReview,
    PullsUpdateReview,
    PullsDeletePendingReview,
    PullsListCommentsForReview,
    PullsDismissReview,
    PullsSubmitReview,
    PullsUpdateBranch,
    ReposGetReadme,
    ReposGetReadmeInDirectory,
    ActivityListReposWatchedByUser,
    ReposGetReleaseAsset,
    ReposDeleteReleaseAsset,
    ReposUpdateReleaseAsset,
    ReposGenerateReleaseNotes,
    ReposGetLatestRelease,
    ReposGetReleaseByTag,
    ActivityListReposStarredByUser,
    ReposListReleaseAssets,
    ReposUploadReleaseAsset,
    ReactionsListForRelease,
    ReactionsCreateForRelease,
    ReactionsDeleteForRelease,
    ReposGetBranchRules,
    ReposGetRepoRulesets,
    ReposCreateRepoRuleset,
    ReposGetRepoRuleset,
    ReposUpdateRepoRuleset,
    ReposDeleteRepoRuleset,
    SecretScanningListAlertsForRepo,
    SecretScanningGetAlert,
    SecretScanningUpdateAlert,
    SecretScanningListLocationsForAlert,
    SecurityAdvisoriesListRepositoryAdvisories,
    SecurityAdvisoriesCreateRepositoryAdvisory,
    SecurityAdvisoriesCreatePrivateVulnerabilityReport,
    SecurityAdvisoriesGetRepositoryAdvisory,
    SecurityAdvisoriesUpdateRepositoryAdvisory,
    ActivityListStargazersForRepo,
    ReposGetCodeFrequencyStats,
    ReposGetCommitActivityStats,
    ReposGetContributorsStats,
    ReposGetParticipationStats,
    ReposGetPunchCardStats,
    ReposCreateCommitStatus,
    ActivityListWatchersForRepo,
    ActivityGetRepoSubscription,
    ActivitySetRepoSubscription,
    ActivityDeleteRepoSubscription,
    ReposListTags,
    ReposListTagProtection,
    ReposCreateTagProtection,
    ReposDeleteTagProtection,
    ReposDownloadTarballArchive,
    ReposListTeams,
    ReposGetAllTopics,
    ReposReplaceAllTopics,
    ReposGetClones,
    ReposGetTopPaths,
    ReposGetTopReferrers,
    ReposGetViews,
    ReposTransfer,
    ReposCheckVulnerabilityAlerts,
    ReposEnableVulnerabilityAlerts,
    ReposDisableVulnerabilityAlerts,
    ReposDownloadZipballArchive,
    ReposCreateUsingTemplate,
    ReposListPublic,
    ActionsListEnvironmentSecrets,
    ActionsGetEnvironmentPublicKey,
    ActionsGetEnvironmentSecret,
    ActionsCreateOrUpdateEnvironmentSecret,
    ActionsDeleteEnvironmentSecret,
    ActionsListEnvironmentVariables,
    ActionsCreateEnvironmentVariable,
    ActionsGetEnvironmentVariable,
    ActionsDeleteEnvironmentVariable,
    ActionsUpdateEnvironmentVariable,
    SearchCode,
    SearchCommits,
    SearchIssuesAndPullRequests,
    SearchLabels,
    SearchRepos,
    SearchTopics,
    SearchUsers,
    TeamsGetLegacy,
    TeamsDeleteLegacy,
    TeamsUpdateLegacy,
    TeamsListDiscussionsLegacy,
    TeamsCreateDiscussionLegacy,
    TeamsGetDiscussionLegacy,
    TeamsDeleteDiscussionLegacy,
    TeamsUpdateDiscussionLegacy,
    TeamsListDiscussionCommentsLegacy,
    TeamsCreateDiscussionCommentLegacy,
    TeamsGetDiscussionCommentLegacy,
    TeamsDeleteDiscussionCommentLegacy,
    TeamsUpdateDiscussionCommentLegacy,
    ReactionsListForTeamDiscussionCommentLegacy,
    ReactionsCreateForTeamDiscussionCommentLegacy,
    ReactionsListForTeamDiscussionLegacy,
    ReactionsCreateForTeamDiscussionLegacy,
    TeamsListPendingInvitationsLegacy,
    TeamsListMembersLegacy,
    TeamsGetMemberLegacy,
    TeamsAddMemberLegacy,
    TeamsRemoveMemberLegacy,
    TeamsGetMembershipForUserLegacy,
    TeamsAddOrUpdateMembershipForUserLegacy,
    TeamsRemoveMembershipForUserLegacy,
    TeamsListProjectsLegacy,
    TeamsCheckPermissionsForProjectLegacy,
    TeamsAddOrUpdateProjectPermissionsLegacy,
    TeamsRemoveProjectLegacy,
    TeamsListReposLegacy,
    TeamsCheckPermissionsForRepoLegacy,
    TeamsAddOrUpdateRepoPermissionsLegacy,
    TeamsRemoveRepoLegacy,
    TeamsListChildLegacy,
    UsersGetAuthenticated,
    UsersUpdateAuthenticated,
    UsersListBlockedByAuthenticatedUser,
    UsersCheckBlocked,
    UsersBlock,
    UsersUnblock,
    CodespacesListForAuthenticatedUser,
    CodespacesCreateForAuthenticatedUser,
    CodespacesListSecretsForAuthenticatedUser,
    CodespacesGetPublicKeyForAuthenticatedUser,
    CodespacesGetSecretForAuthenticatedUser,
    CodespacesCreateOrUpdateSecretForAuthenticatedUser,
    CodespacesDeleteSecretForAuthenticatedUser,
    CodespacesListRepositoriesForSecretForAuthenticatedUser,
    CodespacesSetRepositoriesForSecretForAuthenticatedUser,
    CodespacesAddRepositoryForSecretForAuthenticatedUser,
    CodespacesRemoveRepositoryForSecretForAuthenticatedUser,
    CodespacesGetForAuthenticatedUser,
    CodespacesDeleteForAuthenticatedUser,
    CodespacesUpdateForAuthenticatedUser,
    CodespacesExportForAuthenticatedUser,
    CodespacesGetExportDetailsForAuthenticatedUser,
    CodespacesCodespaceMachinesForAuthenticatedUser,
    CodespacesPublishForAuthenticatedUser,
    CodespacesStartForAuthenticatedUser,
    CodespacesStopForAuthenticatedUser,
    PackagesListDockerMigrationConflictingPackagesForAuthenticatedUser,
    UsersSetPrimaryEmailVisibilityForAuthenticatedUser,
    UsersListEmailsForAuthenticatedUser,
    UsersAddEmailForAuthenticatedUser,
    UsersDeleteEmailForAuthenticatedUser,
    UsersListFollowersForAuthenticatedUser,
    UsersListFollowedByAuthenticatedUser,
    UsersCheckPersonIsFollowedByAuthenticated,
    UsersFollow,
    UsersUnfollow,
    UsersListGpgKeysForAuthenticatedUser,
    UsersCreateGpgKeyForAuthenticatedUser,
    UsersGetGpgKeyForAuthenticatedUser,
    UsersDeleteGpgKeyForAuthenticatedUser,
    AppsListInstallationsForAuthenticatedUser,
    AppsListInstallationReposForAuthenticatedUser,
    AppsAddRepoToInstallationForAuthenticatedUser,
    AppsRemoveRepoFromInstallationForAuthenticatedUser,
    InteractionsGetRestrictionsForAuthenticatedUser,
    InteractionsSetRestrictionsForAuthenticatedUser,
    InteractionsRemoveRestrictionsForAuthenticatedUser,
    IssuesListForAuthenticatedUser,
    UsersListPublicSshKeysForAuthenticatedUser,
    UsersCreatePublicSshKeyForAuthenticatedUser,
    UsersGetPublicSshKeyForAuthenticatedUser,
    UsersDeletePublicSshKeyForAuthenticatedUser,
    AppsListSubscriptionsForAuthenticatedUser,
    AppsListSubscriptionsForAuthenticatedUserStubbed,
    OrgsListMembershipsForAuthenticatedUser,
    OrgsGetMembershipForAuthenticatedUser,
    OrgsUpdateMembershipForAuthenticatedUser,
    MigrationsListForAuthenticatedUser,
    MigrationsStartForAuthenticatedUser,
    MigrationsGetStatusForAuthenticatedUser,
    MigrationsGetArchiveForAuthenticatedUser,
    MigrationsDeleteArchiveForAuthenticatedUser,
    MigrationsUnlockRepoForAuthenticatedUser,
    MigrationsListReposForAuthenticatedUser,
    OrgsListForAuthenticatedUser,
    PackagesListPackagesForAuthenticatedUser,
    PackagesGetPackageForAuthenticatedUser,
    PackagesDeletePackageForAuthenticatedUser,
    PackagesRestorePackageForAuthenticatedUser,
    PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser,
    PackagesGetPackageVersionForAuthenticatedUser,
    PackagesDeletePackageVersionForAuthenticatedUser,
    PackagesRestorePackageVersionForAuthenticatedUser,
    ProjectsCreateForAuthenticatedUser,
    UsersListPublicEmailsForAuthenticatedUser,
    ReposListForAuthenticatedUser,
    ReposCreateForAuthenticatedUser,
    ReposListInvitationsForAuthenticatedUser,
    ReposDeclineInvitationForAuthenticatedUser,
    ReposAcceptInvitationForAuthenticatedUser,
    UsersListSocialAccountsForAuthenticatedUser,
    UsersAddSocialAccountForAuthenticatedUser,
    UsersDeleteSocialAccountForAuthenticatedUser,
    UsersListSshSigningKeysForAuthenticatedUser,
    UsersCreateSshSigningKeyForAuthenticatedUser,
    UsersGetSshSigningKeyForAuthenticatedUser,
    UsersDeleteSshSigningKeyForAuthenticatedUser,
    ActivityListReposStarredByAuthenticatedUser,
    ActivityCheckRepoIsStarredByAuthenticatedUser,
    ActivityStarRepoForAuthenticatedUser,
    ActivityUnstarRepoForAuthenticatedUser,
    ActivityListWatchedReposForAuthenticatedUser,
    TeamsListForAuthenticatedUser,
    UsersList,
    UsersGetByUsername,
    PackagesListDockerMigrationConflictingPackagesForUser,
    ActivityListEventsForAuthenticatedUser,
    ActivityListOrgEventsForAuthenticatedUser,
    ActivityListPublicEventsForUser,
    UsersListFollowersForUser,
    UsersListFollowingForUser,
    UsersCheckFollowingForUser,
    GistsListForUser,
    UsersListGpgKeysForUser,
    UsersGetContextForUser,
    AppsGetUserInstallation,
    UsersListPublicKeysForUser,
    OrgsListForUser,
    PackagesListPackagesForUser,
    PackagesGetPackageForUser,
    PackagesDeletePackageForUser,
    PackagesRestorePackageForUser,
    PackagesGetAllPackageVersionsForPackageOwnedByUser,
    PackagesGetPackageVersionForUser,
    PackagesDeletePackageVersionForUser,
    PackagesRestorePackageVersionForUser,
    ProjectsListForUser,
    ActivityListReceivedEventsForUser,
    ActivityListReceivedPublicEventsForUser,
    ReposListForUser,
    BillingGetGithubActionsBillingUser,
    BillingGetGithubPackagesBillingUser,
    BillingGetSharedStorageBillingUser,
    UsersListSocialAccountsForUser,
}

impl CliCommand {
    pub fn iter() -> impl Iterator<Item = CliCommand> {
        vec![
            CliCommand::MetaRoot,
            CliCommand::AppsGetAuthenticated,
            CliCommand::AppsCreateFromManifest,
            CliCommand::AppsGetWebhookConfigForApp,
            CliCommand::AppsUpdateWebhookConfigForApp,
            CliCommand::AppsListWebhookDeliveries,
            CliCommand::AppsGetWebhookDelivery,
            CliCommand::AppsRedeliverWebhookDelivery,
            CliCommand::AppsListInstallationRequestsForAuthenticatedApp,
            CliCommand::AppsListInstallations,
            CliCommand::AppsGetInstallation,
            CliCommand::AppsDeleteInstallation,
            CliCommand::AppsCreateInstallationAccessToken,
            CliCommand::AppsSuspendInstallation,
            CliCommand::AppsUnsuspendInstallation,
            CliCommand::AppsDeleteAuthorization,
            CliCommand::AppsCheckToken,
            CliCommand::AppsDeleteToken,
            CliCommand::AppsResetToken,
            CliCommand::AppsScopeToken,
            CliCommand::AppsGetBySlug,
            CliCommand::CodesOfConductGetAllCodesOfConduct,
            CliCommand::CodesOfConductGetConductCode,
            CliCommand::EmojisGet,
            CliCommand::DependabotListAlertsForEnterprise,
            CliCommand::SecretScanningListAlertsForEnterprise,
            CliCommand::ActivityListPublicEvents,
            CliCommand::ActivityGetFeeds,
            CliCommand::GistsList,
            CliCommand::GistsCreate,
            CliCommand::GistsListPublic,
            CliCommand::GistsListStarred,
            CliCommand::GistsGet,
            CliCommand::GistsDelete,
            CliCommand::GistsUpdate,
            CliCommand::GistsListComments,
            CliCommand::GistsCreateComment,
            CliCommand::GistsGetComment,
            CliCommand::GistsDeleteComment,
            CliCommand::GistsUpdateComment,
            CliCommand::GistsListCommits,
            CliCommand::GistsListForks,
            CliCommand::GistsFork,
            CliCommand::GistsCheckIsStarred,
            CliCommand::GistsStar,
            CliCommand::GistsUnstar,
            CliCommand::GistsGetRevision,
            CliCommand::GitignoreGetAllTemplates,
            CliCommand::GitignoreGetTemplate,
            CliCommand::AppsListReposAccessibleToInstallation,
            CliCommand::AppsRevokeInstallationAccessToken,
            CliCommand::IssuesList,
            CliCommand::LicensesGetAllCommonlyUsed,
            CliCommand::LicensesGet,
            CliCommand::MarkdownRender,
            CliCommand::MetaGetAllVersions,
            CliCommand::AppsGetSubscriptionPlanForAccount,
            CliCommand::AppsListPlans,
            CliCommand::AppsListAccountsForPlan,
            CliCommand::AppsGetSubscriptionPlanForAccountStubbed,
            CliCommand::AppsListPlansStubbed,
            CliCommand::AppsListAccountsForPlanStubbed,
            CliCommand::MetaGet,
            CliCommand::ActivityListPublicEventsForRepoNetwork,
            CliCommand::ActivityListNotificationsForAuthenticatedUser,
            CliCommand::ActivityMarkNotificationsAsRead,
            CliCommand::ActivityGetThread,
            CliCommand::ActivityMarkThreadAsRead,
            CliCommand::ActivityGetThreadSubscriptionForAuthenticatedUser,
            CliCommand::ActivitySetThreadSubscription,
            CliCommand::ActivityDeleteThreadSubscription,
            CliCommand::MetaGetOctocat,
            CliCommand::OrgsList,
            CliCommand::OrgsListPatGrantRequests,
            CliCommand::OrgsReviewPatGrantRequestsInBulk,
            CliCommand::OrgsReviewPatGrantRequest,
            CliCommand::OrgsListPatGrantRequestRepositories,
            CliCommand::OrgsListPatGrants,
            CliCommand::OrgsUpdatePatAccesses,
            CliCommand::OrgsUpdatePatAccess,
            CliCommand::OrgsListPatGrantRepositories,
            CliCommand::MetaGetZen,
            CliCommand::ActionsGetActionsCacheUsageForOrg,
            CliCommand::ActionsGetActionsCacheUsageByRepoForOrg,
            CliCommand::OidcGetOidcCustomSubTemplateForOrg,
            CliCommand::OidcUpdateOidcCustomSubTemplateForOrg,
            CliCommand::ActionsGetGithubActionsPermissionsOrganization,
            CliCommand::ActionsSetGithubActionsPermissionsOrganization,
            CliCommand::ActionsListSelectedRepositoriesEnabledGithubActionsOrganization,
            CliCommand::ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization,
            CliCommand::ActionsEnableSelectedRepositoryGithubActionsOrganization,
            CliCommand::ActionsDisableSelectedRepositoryGithubActionsOrganization,
            CliCommand::ActionsGetAllowedActionsOrganization,
            CliCommand::ActionsSetAllowedActionsOrganization,
            CliCommand::ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization,
            CliCommand::ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization,
            CliCommand::ActionsListRequiredWorkflows,
            CliCommand::ActionsCreateRequiredWorkflow,
            CliCommand::ActionsGetRequiredWorkflow,
            CliCommand::ActionsDeleteRequiredWorkflow,
            CliCommand::ActionsUpdateRequiredWorkflow,
            CliCommand::ActionsListSelectedRepositoriesRequiredWorkflow,
            CliCommand::ActionsSetSelectedReposToRequiredWorkflow,
            CliCommand::ActionsAddSelectedRepoToRequiredWorkflow,
            CliCommand::ActionsRemoveSelectedRepoFromRequiredWorkflow,
            CliCommand::ActionsListSelfHostedRunnersForOrg,
            CliCommand::ActionsListRunnerApplicationsForOrg,
            CliCommand::ActionsCreateRegistrationTokenForOrg,
            CliCommand::ActionsCreateRemoveTokenForOrg,
            CliCommand::ActionsGetSelfHostedRunnerForOrg,
            CliCommand::ActionsDeleteSelfHostedRunnerFromOrg,
            CliCommand::ActionsListLabelsForSelfHostedRunnerForOrg,
            CliCommand::ActionsSetCustomLabelsForSelfHostedRunnerForOrg,
            CliCommand::ActionsAddCustomLabelsToSelfHostedRunnerForOrg,
            CliCommand::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg,
            CliCommand::ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg,
            CliCommand::ActionsListOrgSecrets,
            CliCommand::ActionsGetOrgPublicKey,
            CliCommand::ActionsGetOrgSecret,
            CliCommand::ActionsCreateOrUpdateOrgSecret,
            CliCommand::ActionsDeleteOrgSecret,
            CliCommand::ActionsListSelectedReposForOrgSecret,
            CliCommand::ActionsSetSelectedReposForOrgSecret,
            CliCommand::ActionsAddSelectedRepoToOrgSecret,
            CliCommand::ActionsRemoveSelectedRepoFromOrgSecret,
            CliCommand::ActionsListOrgVariables,
            CliCommand::ActionsCreateOrgVariable,
            CliCommand::ActionsGetOrgVariable,
            CliCommand::ActionsDeleteOrgVariable,
            CliCommand::ActionsUpdateOrgVariable,
            CliCommand::ActionsListSelectedReposForOrgVariable,
            CliCommand::ActionsSetSelectedReposForOrgVariable,
            CliCommand::ActionsAddSelectedRepoToOrgVariable,
            CliCommand::ActionsRemoveSelectedRepoFromOrgVariable,
            CliCommand::OrgsListBlockedUsers,
            CliCommand::OrgsCheckBlockedUser,
            CliCommand::OrgsBlockUser,
            CliCommand::OrgsUnblockUser,
            CliCommand::CodeScanningListAlertsForOrg,
            CliCommand::CodespacesListInOrganization,
            CliCommand::CodespacesSetCodespacesBilling,
            CliCommand::CodespacesSetCodespacesBillingUsers,
            CliCommand::CodespacesDeleteCodespacesBillingUsers,
            CliCommand::CodespacesListOrgSecrets,
            CliCommand::CodespacesGetOrgPublicKey,
            CliCommand::CodespacesGetOrgSecret,
            CliCommand::CodespacesCreateOrUpdateOrgSecret,
            CliCommand::CodespacesDeleteOrgSecret,
            CliCommand::CodespacesListSelectedReposForOrgSecret,
            CliCommand::CodespacesSetSelectedReposForOrgSecret,
            CliCommand::CodespacesAddSelectedRepoToOrgSecret,
            CliCommand::CodespacesRemoveSelectedRepoFromOrgSecret,
            CliCommand::DependabotListAlertsForOrg,
            CliCommand::DependabotListOrgSecrets,
            CliCommand::DependabotGetOrgPublicKey,
            CliCommand::DependabotGetOrgSecret,
            CliCommand::DependabotCreateOrUpdateOrgSecret,
            CliCommand::DependabotDeleteOrgSecret,
            CliCommand::DependabotListSelectedReposForOrgSecret,
            CliCommand::DependabotSetSelectedReposForOrgSecret,
            CliCommand::DependabotAddSelectedRepoToOrgSecret,
            CliCommand::DependabotRemoveSelectedRepoFromOrgSecret,
            CliCommand::PackagesListDockerMigrationConflictingPackagesForOrganization,
            CliCommand::ActivityListPublicOrgEvents,
            CliCommand::OrgsListFailedInvitations,
            CliCommand::OrgsListWebhooks,
            CliCommand::OrgsCreateWebhook,
            CliCommand::OrgsGetWebhook,
            CliCommand::OrgsDeleteWebhook,
            CliCommand::OrgsUpdateWebhook,
            CliCommand::OrgsGetWebhookConfigForOrg,
            CliCommand::OrgsUpdateWebhookConfigForOrg,
            CliCommand::OrgsListWebhookDeliveries,
            CliCommand::OrgsGetWebhookDelivery,
            CliCommand::OrgsRedeliverWebhookDelivery,
            CliCommand::OrgsPingWebhook,
            CliCommand::AppsGetOrgInstallation,
            CliCommand::OrgsListAppInstallations,
            CliCommand::InteractionsGetRestrictionsForOrg,
            CliCommand::InteractionsSetRestrictionsForOrg,
            CliCommand::InteractionsRemoveRestrictionsForOrg,
            CliCommand::OrgsListPendingInvitations,
            CliCommand::OrgsCreateInvitation,
            CliCommand::OrgsCancelInvitation,
            CliCommand::OrgsListInvitationTeams,
            CliCommand::IssuesListForOrg,
            CliCommand::OrgsListMembers,
            CliCommand::OrgsCheckMembershipForUser,
            CliCommand::OrgsRemoveMember,
            CliCommand::CodespacesGetCodespacesForUserInOrg,
            CliCommand::CodespacesDeleteFromOrganization,
            CliCommand::CodespacesStopInOrganization,
            CliCommand::OrgsGetMembershipForUser,
            CliCommand::OrgsSetMembershipForUser,
            CliCommand::OrgsRemoveMembershipForUser,
            CliCommand::MigrationsListForOrg,
            CliCommand::MigrationsStartForOrg,
            CliCommand::MigrationsGetStatusForOrg,
            CliCommand::MigrationsDownloadArchiveForOrg,
            CliCommand::MigrationsDeleteArchiveForOrg,
            CliCommand::MigrationsUnlockRepoForOrg,
            CliCommand::MigrationsListReposForOrg,
            CliCommand::OrgsListOutsideCollaborators,
            CliCommand::OrgsConvertMemberToOutsideCollaborator,
            CliCommand::OrgsRemoveOutsideCollaborator,
            CliCommand::PackagesListPackagesForOrganization,
            CliCommand::PackagesGetPackageForOrganization,
            CliCommand::PackagesDeletePackageForOrg,
            CliCommand::PackagesRestorePackageForOrg,
            CliCommand::PackagesGetAllPackageVersionsForPackageOwnedByOrg,
            CliCommand::PackagesGetPackageVersionForOrganization,
            CliCommand::PackagesDeletePackageVersionForOrg,
            CliCommand::PackagesRestorePackageVersionForOrg,
            CliCommand::ProjectsListForOrg,
            CliCommand::ProjectsCreateForOrg,
            CliCommand::OrgsListPublicMembers,
            CliCommand::OrgsCheckPublicMembershipForUser,
            CliCommand::OrgsSetPublicMembershipForAuthenticatedUser,
            CliCommand::OrgsRemovePublicMembershipForAuthenticatedUser,
            CliCommand::ReposListForOrg,
            CliCommand::ReposCreateInOrg,
            CliCommand::ReposGetOrgRulesets,
            CliCommand::ReposCreateOrgRuleset,
            CliCommand::ReposGetOrgRuleset,
            CliCommand::ReposUpdateOrgRuleset,
            CliCommand::ReposDeleteOrgRuleset,
            CliCommand::SecretScanningListAlertsForOrg,
            CliCommand::OrgsListSecurityManagerTeams,
            CliCommand::OrgsAddSecurityManagerTeam,
            CliCommand::OrgsRemoveSecurityManagerTeam,
            CliCommand::BillingGetGithubActionsBillingOrg,
            CliCommand::BillingGetGithubPackagesBillingOrg,
            CliCommand::BillingGetSharedStorageBillingOrg,
            CliCommand::TeamsList,
            CliCommand::TeamsCreate,
            CliCommand::TeamsGetByName,
            CliCommand::TeamsDeleteInOrg,
            CliCommand::TeamsUpdateInOrg,
            CliCommand::TeamsListDiscussionsInOrg,
            CliCommand::TeamsCreateDiscussionInOrg,
            CliCommand::TeamsGetDiscussionInOrg,
            CliCommand::TeamsDeleteDiscussionInOrg,
            CliCommand::TeamsUpdateDiscussionInOrg,
            CliCommand::TeamsListDiscussionCommentsInOrg,
            CliCommand::TeamsCreateDiscussionCommentInOrg,
            CliCommand::TeamsGetDiscussionCommentInOrg,
            CliCommand::TeamsDeleteDiscussionCommentInOrg,
            CliCommand::TeamsUpdateDiscussionCommentInOrg,
            CliCommand::ReactionsListForTeamDiscussionCommentInOrg,
            CliCommand::ReactionsCreateForTeamDiscussionCommentInOrg,
            CliCommand::ReactionsDeleteForTeamDiscussionComment,
            CliCommand::ReactionsListForTeamDiscussionInOrg,
            CliCommand::ReactionsCreateForTeamDiscussionInOrg,
            CliCommand::ReactionsDeleteForTeamDiscussion,
            CliCommand::TeamsListPendingInvitationsInOrg,
            CliCommand::TeamsListMembersInOrg,
            CliCommand::TeamsGetMembershipForUserInOrg,
            CliCommand::TeamsAddOrUpdateMembershipForUserInOrg,
            CliCommand::TeamsRemoveMembershipForUserInOrg,
            CliCommand::TeamsListProjectsInOrg,
            CliCommand::TeamsCheckPermissionsForProjectInOrg,
            CliCommand::TeamsAddOrUpdateProjectPermissionsInOrg,
            CliCommand::TeamsRemoveProjectInOrg,
            CliCommand::TeamsListReposInOrg,
            CliCommand::TeamsCheckPermissionsForRepoInOrg,
            CliCommand::TeamsAddOrUpdateRepoPermissionsInOrg,
            CliCommand::TeamsRemoveRepoInOrg,
            CliCommand::TeamsListChildInOrg,
            CliCommand::OrgsEnableOrDisableSecurityProductOnAllOrgRepos,
            CliCommand::ProjectsGetCard,
            CliCommand::ProjectsDeleteCard,
            CliCommand::ProjectsUpdateCard,
            CliCommand::ProjectsMoveCard,
            CliCommand::ProjectsGetColumn,
            CliCommand::ProjectsDeleteColumn,
            CliCommand::ProjectsUpdateColumn,
            CliCommand::UsersListSshSigningKeysForUser,
            CliCommand::ProjectsMoveColumn,
            CliCommand::ProjectsGet,
            CliCommand::ProjectsDelete,
            CliCommand::ProjectsUpdate,
            CliCommand::ProjectsListCollaborators,
            CliCommand::ProjectsAddCollaborator,
            CliCommand::ProjectsRemoveCollaborator,
            CliCommand::ProjectsGetPermissionForUser,
            CliCommand::ProjectsListColumns,
            CliCommand::ProjectsCreateColumn,
            CliCommand::RateLimitGet,
            CliCommand::ActionsListRepoRequiredWorkflows,
            CliCommand::ActionsGetRepoRequiredWorkflow,
            CliCommand::ActionsGetRepoRequiredWorkflowUsage,
            CliCommand::ReposGet,
            CliCommand::ReposDelete,
            CliCommand::ReposUpdate,
            CliCommand::ActionsListArtifactsForRepo,
            CliCommand::ActionsGetArtifact,
            CliCommand::ActionsDeleteArtifact,
            CliCommand::ActionsDownloadArtifact,
            CliCommand::ActionsGetActionsCacheUsage,
            CliCommand::ActionsGetActionsCacheList,
            CliCommand::ActionsDeleteActionsCacheByKey,
            CliCommand::ActionsDeleteActionsCacheById,
            CliCommand::ActionsGetJobForWorkflowRun,
            CliCommand::ActionsDownloadJobLogsForWorkflowRun,
            CliCommand::ActionsReRunJobForWorkflowRun,
            CliCommand::ActionsGetCustomOidcSubClaimForRepo,
            CliCommand::ActionsSetCustomOidcSubClaimForRepo,
            CliCommand::ActionsListRepoOrganizationSecrets,
            CliCommand::ActionsListRepoOrganizationVariables,
            CliCommand::ActionsGetGithubActionsPermissionsRepository,
            CliCommand::ActionsSetGithubActionsPermissionsRepository,
            CliCommand::ActionsGetWorkflowAccessToRepository,
            CliCommand::ActionsSetWorkflowAccessToRepository,
            CliCommand::ActionsGetAllowedActionsRepository,
            CliCommand::ActionsSetAllowedActionsRepository,
            CliCommand::ActionsGetGithubActionsDefaultWorkflowPermissionsRepository,
            CliCommand::ActionsSetGithubActionsDefaultWorkflowPermissionsRepository,
            CliCommand::ActionsListRequiredWorkflowRuns,
            CliCommand::ActionsListSelfHostedRunnersForRepo,
            CliCommand::ActionsListRunnerApplicationsForRepo,
            CliCommand::ActionsCreateRegistrationTokenForRepo,
            CliCommand::ActionsCreateRemoveTokenForRepo,
            CliCommand::ActionsGetSelfHostedRunnerForRepo,
            CliCommand::ActionsDeleteSelfHostedRunnerFromRepo,
            CliCommand::ActionsListLabelsForSelfHostedRunnerForRepo,
            CliCommand::ActionsSetCustomLabelsForSelfHostedRunnerForRepo,
            CliCommand::ActionsAddCustomLabelsToSelfHostedRunnerForRepo,
            CliCommand::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo,
            CliCommand::ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo,
            CliCommand::ActionsListWorkflowRunsForRepo,
            CliCommand::ActionsGetWorkflowRun,
            CliCommand::ActionsDeleteWorkflowRun,
            CliCommand::ActionsGetReviewsForRun,
            CliCommand::ActionsApproveWorkflowRun,
            CliCommand::ActionsListWorkflowRunArtifacts,
            CliCommand::ActionsGetWorkflowRunAttempt,
            CliCommand::ActionsListJobsForWorkflowRunAttempt,
            CliCommand::ActionsDownloadWorkflowRunAttemptLogs,
            CliCommand::ActionsCancelWorkflowRun,
            CliCommand::ActionsReviewCustomGatesForRun,
            CliCommand::ActionsListJobsForWorkflowRun,
            CliCommand::ActionsDownloadWorkflowRunLogs,
            CliCommand::ActionsDeleteWorkflowRunLogs,
            CliCommand::ActionsGetPendingDeploymentsForRun,
            CliCommand::ActionsReviewPendingDeploymentsForRun,
            CliCommand::ActionsReRunWorkflow,
            CliCommand::ActionsReRunWorkflowFailedJobs,
            CliCommand::ActionsGetWorkflowRunUsage,
            CliCommand::ActionsListRepoSecrets,
            CliCommand::ActionsGetRepoPublicKey,
            CliCommand::ActionsGetRepoSecret,
            CliCommand::ActionsCreateOrUpdateRepoSecret,
            CliCommand::ActionsDeleteRepoSecret,
            CliCommand::ActionsListRepoVariables,
            CliCommand::ActionsCreateRepoVariable,
            CliCommand::ActionsGetRepoVariable,
            CliCommand::ActionsDeleteRepoVariable,
            CliCommand::ActionsUpdateRepoVariable,
            CliCommand::ActionsListRepoWorkflows,
            CliCommand::ActionsGetWorkflow,
            CliCommand::ActionsDisableWorkflow,
            CliCommand::ActionsCreateWorkflowDispatch,
            CliCommand::ActionsEnableWorkflow,
            CliCommand::ActionsListWorkflowRuns,
            CliCommand::ActionsGetWorkflowUsage,
            CliCommand::IssuesListAssignees,
            CliCommand::IssuesCheckUserCanBeAssigned,
            CliCommand::ReposListAutolinks,
            CliCommand::ReposCreateAutolink,
            CliCommand::ReposGetAutolink,
            CliCommand::ReposDeleteAutolink,
            CliCommand::ReposEnableAutomatedSecurityFixes,
            CliCommand::ReposDisableAutomatedSecurityFixes,
            CliCommand::ReposListBranches,
            CliCommand::ReposGetBranch,
            CliCommand::ReposGetBranchProtection,
            CliCommand::ReposUpdateBranchProtection,
            CliCommand::ReposDeleteBranchProtection,
            CliCommand::ReposGetAdminBranchProtection,
            CliCommand::ReposSetAdminBranchProtection,
            CliCommand::ReposDeleteAdminBranchProtection,
            CliCommand::ReposGetPullRequestReviewProtection,
            CliCommand::ReposDeletePullRequestReviewProtection,
            CliCommand::ReposUpdatePullRequestReviewProtection,
            CliCommand::ReposGetCommitSignatureProtection,
            CliCommand::ReposCreateCommitSignatureProtection,
            CliCommand::ReposDeleteCommitSignatureProtection,
            CliCommand::ReposGetStatusChecksProtection,
            CliCommand::ReposRemoveStatusCheckProtection,
            CliCommand::ReposUpdateStatusCheckProtection,
            CliCommand::ReposGetAllStatusCheckContexts,
            CliCommand::ReposSetStatusCheckContexts,
            CliCommand::ReposAddStatusCheckContexts,
            CliCommand::ReposRemoveStatusCheckContexts,
            CliCommand::ReposGetAccessRestrictions,
            CliCommand::ReposDeleteAccessRestrictions,
            CliCommand::ReposGetAppsWithAccessToProtectedBranch,
            CliCommand::ReposSetAppAccessRestrictions,
            CliCommand::ReposAddAppAccessRestrictions,
            CliCommand::ReposRemoveAppAccessRestrictions,
            CliCommand::ReposGetTeamsWithAccessToProtectedBranch,
            CliCommand::ReposSetTeamAccessRestrictions,
            CliCommand::ReposAddTeamAccessRestrictions,
            CliCommand::ReposRemoveTeamAccessRestrictions,
            CliCommand::ReposGetUsersWithAccessToProtectedBranch,
            CliCommand::ReposSetUserAccessRestrictions,
            CliCommand::ReposAddUserAccessRestrictions,
            CliCommand::ReposRemoveUserAccessRestrictions,
            CliCommand::ReposRenameBranch,
            CliCommand::ChecksCreate,
            CliCommand::ChecksGet,
            CliCommand::ChecksUpdate,
            CliCommand::ChecksListAnnotations,
            CliCommand::ChecksRerequestRun,
            CliCommand::ChecksCreateSuite,
            CliCommand::ChecksSetSuitesPreferences,
            CliCommand::ChecksGetSuite,
            CliCommand::ChecksListForSuite,
            CliCommand::ChecksRerequestSuite,
            CliCommand::CodeScanningListAlertsForRepo,
            CliCommand::CodeScanningGetAlert,
            CliCommand::CodeScanningUpdateAlert,
            CliCommand::CodeScanningListAlertInstances,
            CliCommand::CodeScanningListRecentAnalyses,
            CliCommand::CodeScanningGetAnalysis,
            CliCommand::CodeScanningDeleteAnalysis,
            CliCommand::CodeScanningListCodeqlDatabases,
            CliCommand::CodeScanningGetCodeqlDatabase,
            CliCommand::CodeScanningGetDefaultSetup,
            CliCommand::CodeScanningUpdateDefaultSetup,
            CliCommand::CodeScanningUploadSarif,
            CliCommand::CodeScanningGetSarif,
            CliCommand::ReposCodeownersErrors,
            CliCommand::CodespacesListInRepositoryForAuthenticatedUser,
            CliCommand::CodespacesCreateWithRepoForAuthenticatedUser,
            CliCommand::CodespacesListDevcontainersInRepositoryForAuthenticatedUser,
            CliCommand::CodespacesRepoMachinesForAuthenticatedUser,
            CliCommand::CodespacesPreFlightWithRepoForAuthenticatedUser,
            CliCommand::CodespacesListRepoSecrets,
            CliCommand::CodespacesGetRepoPublicKey,
            CliCommand::CodespacesGetRepoSecret,
            CliCommand::CodespacesCreateOrUpdateRepoSecret,
            CliCommand::CodespacesDeleteRepoSecret,
            CliCommand::ReposListCollaborators,
            CliCommand::ReposCheckCollaborator,
            CliCommand::ReposAddCollaborator,
            CliCommand::ReposRemoveCollaborator,
            CliCommand::ReposGetCollaboratorPermissionLevel,
            CliCommand::ReposListCommitCommentsForRepo,
            CliCommand::ReposGetCommitComment,
            CliCommand::ReposDeleteCommitComment,
            CliCommand::ReposUpdateCommitComment,
            CliCommand::ReactionsListForCommitComment,
            CliCommand::ReactionsCreateForCommitComment,
            CliCommand::ReactionsDeleteForCommitComment,
            CliCommand::ReposListCommits,
            CliCommand::ReposListBranchesForHeadCommit,
            CliCommand::ReposListCommentsForCommit,
            CliCommand::ReposCreateCommitComment,
            CliCommand::ReposListPullRequestsAssociatedWithCommit,
            CliCommand::ReposGetCommit,
            CliCommand::ChecksListForRef,
            CliCommand::ChecksListSuitesForRef,
            CliCommand::ReposGetCombinedStatusForRef,
            CliCommand::ReposListCommitStatusesForRef,
            CliCommand::ReposGetCommunityProfileMetrics,
            CliCommand::ReposCompareCommits,
            CliCommand::ReposGetContent,
            CliCommand::ReposCreateOrUpdateFileContents,
            CliCommand::ReposDeleteFile,
            CliCommand::ReposListContributors,
            CliCommand::DependabotListAlertsForRepo,
            CliCommand::DependabotGetAlert,
            CliCommand::DependabotUpdateAlert,
            CliCommand::DependabotListRepoSecrets,
            CliCommand::DependabotGetRepoPublicKey,
            CliCommand::DependabotGetRepoSecret,
            CliCommand::DependabotCreateOrUpdateRepoSecret,
            CliCommand::DependabotDeleteRepoSecret,
            CliCommand::DependencyGraphDiffRange,
            CliCommand::DependencyGraphExportSbom,
            CliCommand::DependencyGraphCreateRepositorySnapshot,
            CliCommand::ReposListDeployments,
            CliCommand::ReposCreateDeployment,
            CliCommand::ReposGetDeployment,
            CliCommand::ReposDeleteDeployment,
            CliCommand::ReposListDeploymentStatuses,
            CliCommand::ReposCreateDeploymentStatus,
            CliCommand::ReposGetDeploymentStatus,
            CliCommand::ReposCreateDispatchEvent,
            CliCommand::ReposGetAllEnvironments,
            CliCommand::ReposGetEnvironment,
            CliCommand::ReposCreateOrUpdateEnvironment,
            CliCommand::ReposDeleteAnEnvironment,
            CliCommand::ReposListDeploymentBranchPolicies,
            CliCommand::ReposCreateDeploymentBranchPolicy,
            CliCommand::ReposGetDeploymentBranchPolicy,
            CliCommand::ReposUpdateDeploymentBranchPolicy,
            CliCommand::ReposDeleteDeploymentBranchPolicy,
            CliCommand::ReposGetAllDeploymentProtectionRules,
            CliCommand::ReposCreateDeploymentProtectionRule,
            CliCommand::ReposListCustomDeploymentRuleIntegrations,
            CliCommand::ReposGetCustomDeploymentProtectionRule,
            CliCommand::ReposDisableDeploymentProtectionRule,
            CliCommand::ActivityListRepoEvents,
            CliCommand::ReposListForks,
            CliCommand::ReposCreateFork,
            CliCommand::GitCreateBlob,
            CliCommand::GitGetBlob,
            CliCommand::GitCreateCommit,
            CliCommand::GitGetCommit,
            CliCommand::GitListMatchingRefs,
            CliCommand::GitGetRef,
            CliCommand::GitCreateRef,
            CliCommand::GitDeleteRef,
            CliCommand::GitUpdateRef,
            CliCommand::GitCreateTag,
            CliCommand::GitGetTag,
            CliCommand::GitCreateTree,
            CliCommand::GitGetTree,
            CliCommand::ReposListWebhooks,
            CliCommand::ReposCreateWebhook,
            CliCommand::ReposGetWebhook,
            CliCommand::ReposDeleteWebhook,
            CliCommand::ReposUpdateWebhook,
            CliCommand::ReposGetWebhookConfigForRepo,
            CliCommand::ReposUpdateWebhookConfigForRepo,
            CliCommand::ReposListWebhookDeliveries,
            CliCommand::ReposGetWebhookDelivery,
            CliCommand::ReposRedeliverWebhookDelivery,
            CliCommand::ReposPingWebhook,
            CliCommand::ReposTestPushWebhook,
            CliCommand::MigrationsGetImportStatus,
            CliCommand::MigrationsStartImport,
            CliCommand::MigrationsCancelImport,
            CliCommand::MigrationsUpdateImport,
            CliCommand::MigrationsGetCommitAuthors,
            CliCommand::MigrationsMapCommitAuthor,
            CliCommand::MigrationsGetLargeFiles,
            CliCommand::MigrationsSetLfsPreference,
            CliCommand::AppsGetRepoInstallation,
            CliCommand::InteractionsGetRestrictionsForRepo,
            CliCommand::InteractionsSetRestrictionsForRepo,
            CliCommand::InteractionsRemoveRestrictionsForRepo,
            CliCommand::ReposListInvitations,
            CliCommand::ReposDeleteInvitation,
            CliCommand::ReposUpdateInvitation,
            CliCommand::IssuesListForRepo,
            CliCommand::IssuesCreate,
            CliCommand::IssuesListCommentsForRepo,
            CliCommand::IssuesGetComment,
            CliCommand::IssuesDeleteComment,
            CliCommand::IssuesUpdateComment,
            CliCommand::ReactionsListForIssueComment,
            CliCommand::ReactionsCreateForIssueComment,
            CliCommand::ReactionsDeleteForIssueComment,
            CliCommand::IssuesListEventsForRepo,
            CliCommand::IssuesGetEvent,
            CliCommand::IssuesGet,
            CliCommand::IssuesUpdate,
            CliCommand::IssuesAddAssignees,
            CliCommand::IssuesRemoveAssignees,
            CliCommand::IssuesCheckUserCanBeAssignedToIssue,
            CliCommand::IssuesListComments,
            CliCommand::IssuesCreateComment,
            CliCommand::IssuesListEvents,
            CliCommand::IssuesListLabelsOnIssue,
            CliCommand::IssuesSetLabels,
            CliCommand::IssuesAddLabels,
            CliCommand::IssuesRemoveAllLabels,
            CliCommand::IssuesRemoveLabel,
            CliCommand::IssuesLock,
            CliCommand::IssuesUnlock,
            CliCommand::ReactionsListForIssue,
            CliCommand::ReactionsCreateForIssue,
            CliCommand::ReactionsDeleteForIssue,
            CliCommand::IssuesListEventsForTimeline,
            CliCommand::ReposListDeployKeys,
            CliCommand::ReposCreateDeployKey,
            CliCommand::ReposGetDeployKey,
            CliCommand::ReposDeleteDeployKey,
            CliCommand::IssuesListLabelsForRepo,
            CliCommand::IssuesCreateLabel,
            CliCommand::IssuesGetLabel,
            CliCommand::IssuesDeleteLabel,
            CliCommand::IssuesUpdateLabel,
            CliCommand::ReposListLanguages,
            CliCommand::ReposEnableLfsForRepo,
            CliCommand::ReposDisableLfsForRepo,
            CliCommand::LicensesGetForRepo,
            CliCommand::ReposMergeUpstream,
            CliCommand::ReposMerge,
            CliCommand::IssuesListMilestones,
            CliCommand::IssuesCreateMilestone,
            CliCommand::IssuesGetMilestone,
            CliCommand::IssuesDeleteMilestone,
            CliCommand::IssuesUpdateMilestone,
            CliCommand::IssuesListLabelsForMilestone,
            CliCommand::ActivityListRepoNotificationsForAuthenticatedUser,
            CliCommand::ActivityMarkRepoNotificationsAsRead,
            CliCommand::ReposGetPages,
            CliCommand::ReposUpdateInformationAboutPagesSite,
            CliCommand::ReposCreatePagesSite,
            CliCommand::ReposDeletePagesSite,
            CliCommand::ReposListPagesBuilds,
            CliCommand::ReposRequestPagesBuild,
            CliCommand::ReposGetLatestPagesBuild,
            CliCommand::ReposGetPagesBuild,
            CliCommand::ReposCreatePagesDeployment,
            CliCommand::ReposGetPagesHealthCheck,
            CliCommand::ProjectsListForRepo,
            CliCommand::ProjectsCreateForRepo,
            CliCommand::PullsList,
            CliCommand::PullsCreate,
            CliCommand::PullsListReviewCommentsForRepo,
            CliCommand::PullsGetReviewComment,
            CliCommand::PullsDeleteReviewComment,
            CliCommand::PullsUpdateReviewComment,
            CliCommand::ReactionsListForPullRequestReviewComment,
            CliCommand::ReactionsCreateForPullRequestReviewComment,
            CliCommand::ReactionsDeleteForPullRequestComment,
            CliCommand::PullsGet,
            CliCommand::PullsUpdate,
            CliCommand::CodespacesCreateWithPrForAuthenticatedUser,
            CliCommand::PullsListReviewComments,
            CliCommand::PullsCreateReviewComment,
            CliCommand::PullsCreateReplyForReviewComment,
            CliCommand::PullsListCommits,
            CliCommand::PullsListFiles,
            CliCommand::PullsCheckIfMerged,
            CliCommand::PullsMerge,
            CliCommand::PullsListRequestedReviewers,
            CliCommand::PullsRequestReviewers,
            CliCommand::PullsRemoveRequestedReviewers,
            CliCommand::PullsListReviews,
            CliCommand::PullsCreateReview,
            CliCommand::PullsGetReview,
            CliCommand::PullsUpdateReview,
            CliCommand::PullsDeletePendingReview,
            CliCommand::PullsListCommentsForReview,
            CliCommand::PullsDismissReview,
            CliCommand::PullsSubmitReview,
            CliCommand::PullsUpdateBranch,
            CliCommand::ReposGetReadme,
            CliCommand::ReposGetReadmeInDirectory,
            CliCommand::ActivityListReposWatchedByUser,
            CliCommand::ReposGetReleaseAsset,
            CliCommand::ReposDeleteReleaseAsset,
            CliCommand::ReposUpdateReleaseAsset,
            CliCommand::ReposGenerateReleaseNotes,
            CliCommand::ReposGetLatestRelease,
            CliCommand::ReposGetReleaseByTag,
            CliCommand::ActivityListReposStarredByUser,
            CliCommand::ReposListReleaseAssets,
            CliCommand::ReposUploadReleaseAsset,
            CliCommand::ReactionsListForRelease,
            CliCommand::ReactionsCreateForRelease,
            CliCommand::ReactionsDeleteForRelease,
            CliCommand::ReposGetBranchRules,
            CliCommand::ReposGetRepoRulesets,
            CliCommand::ReposCreateRepoRuleset,
            CliCommand::ReposGetRepoRuleset,
            CliCommand::ReposUpdateRepoRuleset,
            CliCommand::ReposDeleteRepoRuleset,
            CliCommand::SecretScanningListAlertsForRepo,
            CliCommand::SecretScanningGetAlert,
            CliCommand::SecretScanningUpdateAlert,
            CliCommand::SecretScanningListLocationsForAlert,
            CliCommand::SecurityAdvisoriesListRepositoryAdvisories,
            CliCommand::SecurityAdvisoriesCreateRepositoryAdvisory,
            CliCommand::SecurityAdvisoriesCreatePrivateVulnerabilityReport,
            CliCommand::SecurityAdvisoriesGetRepositoryAdvisory,
            CliCommand::SecurityAdvisoriesUpdateRepositoryAdvisory,
            CliCommand::ActivityListStargazersForRepo,
            CliCommand::ReposGetCodeFrequencyStats,
            CliCommand::ReposGetCommitActivityStats,
            CliCommand::ReposGetContributorsStats,
            CliCommand::ReposGetParticipationStats,
            CliCommand::ReposGetPunchCardStats,
            CliCommand::ReposCreateCommitStatus,
            CliCommand::ActivityListWatchersForRepo,
            CliCommand::ActivityGetRepoSubscription,
            CliCommand::ActivitySetRepoSubscription,
            CliCommand::ActivityDeleteRepoSubscription,
            CliCommand::ReposListTags,
            CliCommand::ReposListTagProtection,
            CliCommand::ReposCreateTagProtection,
            CliCommand::ReposDeleteTagProtection,
            CliCommand::ReposDownloadTarballArchive,
            CliCommand::ReposListTeams,
            CliCommand::ReposGetAllTopics,
            CliCommand::ReposReplaceAllTopics,
            CliCommand::ReposGetClones,
            CliCommand::ReposGetTopPaths,
            CliCommand::ReposGetTopReferrers,
            CliCommand::ReposGetViews,
            CliCommand::ReposTransfer,
            CliCommand::ReposCheckVulnerabilityAlerts,
            CliCommand::ReposEnableVulnerabilityAlerts,
            CliCommand::ReposDisableVulnerabilityAlerts,
            CliCommand::ReposDownloadZipballArchive,
            CliCommand::ReposCreateUsingTemplate,
            CliCommand::ReposListPublic,
            CliCommand::ActionsListEnvironmentSecrets,
            CliCommand::ActionsGetEnvironmentPublicKey,
            CliCommand::ActionsGetEnvironmentSecret,
            CliCommand::ActionsCreateOrUpdateEnvironmentSecret,
            CliCommand::ActionsDeleteEnvironmentSecret,
            CliCommand::ActionsListEnvironmentVariables,
            CliCommand::ActionsCreateEnvironmentVariable,
            CliCommand::ActionsGetEnvironmentVariable,
            CliCommand::ActionsDeleteEnvironmentVariable,
            CliCommand::ActionsUpdateEnvironmentVariable,
            CliCommand::SearchCode,
            CliCommand::SearchCommits,
            CliCommand::SearchIssuesAndPullRequests,
            CliCommand::SearchLabels,
            CliCommand::SearchRepos,
            CliCommand::SearchTopics,
            CliCommand::SearchUsers,
            CliCommand::TeamsGetLegacy,
            CliCommand::TeamsDeleteLegacy,
            CliCommand::TeamsUpdateLegacy,
            CliCommand::TeamsListDiscussionsLegacy,
            CliCommand::TeamsCreateDiscussionLegacy,
            CliCommand::TeamsGetDiscussionLegacy,
            CliCommand::TeamsDeleteDiscussionLegacy,
            CliCommand::TeamsUpdateDiscussionLegacy,
            CliCommand::TeamsListDiscussionCommentsLegacy,
            CliCommand::TeamsCreateDiscussionCommentLegacy,
            CliCommand::TeamsGetDiscussionCommentLegacy,
            CliCommand::TeamsDeleteDiscussionCommentLegacy,
            CliCommand::TeamsUpdateDiscussionCommentLegacy,
            CliCommand::ReactionsListForTeamDiscussionCommentLegacy,
            CliCommand::ReactionsCreateForTeamDiscussionCommentLegacy,
            CliCommand::ReactionsListForTeamDiscussionLegacy,
            CliCommand::ReactionsCreateForTeamDiscussionLegacy,
            CliCommand::TeamsListPendingInvitationsLegacy,
            CliCommand::TeamsListMembersLegacy,
            CliCommand::TeamsGetMemberLegacy,
            CliCommand::TeamsAddMemberLegacy,
            CliCommand::TeamsRemoveMemberLegacy,
            CliCommand::TeamsGetMembershipForUserLegacy,
            CliCommand::TeamsAddOrUpdateMembershipForUserLegacy,
            CliCommand::TeamsRemoveMembershipForUserLegacy,
            CliCommand::TeamsListProjectsLegacy,
            CliCommand::TeamsCheckPermissionsForProjectLegacy,
            CliCommand::TeamsAddOrUpdateProjectPermissionsLegacy,
            CliCommand::TeamsRemoveProjectLegacy,
            CliCommand::TeamsListReposLegacy,
            CliCommand::TeamsCheckPermissionsForRepoLegacy,
            CliCommand::TeamsAddOrUpdateRepoPermissionsLegacy,
            CliCommand::TeamsRemoveRepoLegacy,
            CliCommand::TeamsListChildLegacy,
            CliCommand::UsersGetAuthenticated,
            CliCommand::UsersUpdateAuthenticated,
            CliCommand::UsersListBlockedByAuthenticatedUser,
            CliCommand::UsersCheckBlocked,
            CliCommand::UsersBlock,
            CliCommand::UsersUnblock,
            CliCommand::CodespacesListForAuthenticatedUser,
            CliCommand::CodespacesCreateForAuthenticatedUser,
            CliCommand::CodespacesListSecretsForAuthenticatedUser,
            CliCommand::CodespacesGetPublicKeyForAuthenticatedUser,
            CliCommand::CodespacesGetSecretForAuthenticatedUser,
            CliCommand::CodespacesCreateOrUpdateSecretForAuthenticatedUser,
            CliCommand::CodespacesDeleteSecretForAuthenticatedUser,
            CliCommand::CodespacesListRepositoriesForSecretForAuthenticatedUser,
            CliCommand::CodespacesSetRepositoriesForSecretForAuthenticatedUser,
            CliCommand::CodespacesAddRepositoryForSecretForAuthenticatedUser,
            CliCommand::CodespacesRemoveRepositoryForSecretForAuthenticatedUser,
            CliCommand::CodespacesGetForAuthenticatedUser,
            CliCommand::CodespacesDeleteForAuthenticatedUser,
            CliCommand::CodespacesUpdateForAuthenticatedUser,
            CliCommand::CodespacesExportForAuthenticatedUser,
            CliCommand::CodespacesGetExportDetailsForAuthenticatedUser,
            CliCommand::CodespacesCodespaceMachinesForAuthenticatedUser,
            CliCommand::CodespacesPublishForAuthenticatedUser,
            CliCommand::CodespacesStartForAuthenticatedUser,
            CliCommand::CodespacesStopForAuthenticatedUser,
            CliCommand::PackagesListDockerMigrationConflictingPackagesForAuthenticatedUser,
            CliCommand::UsersSetPrimaryEmailVisibilityForAuthenticatedUser,
            CliCommand::UsersListEmailsForAuthenticatedUser,
            CliCommand::UsersAddEmailForAuthenticatedUser,
            CliCommand::UsersDeleteEmailForAuthenticatedUser,
            CliCommand::UsersListFollowersForAuthenticatedUser,
            CliCommand::UsersListFollowedByAuthenticatedUser,
            CliCommand::UsersCheckPersonIsFollowedByAuthenticated,
            CliCommand::UsersFollow,
            CliCommand::UsersUnfollow,
            CliCommand::UsersListGpgKeysForAuthenticatedUser,
            CliCommand::UsersCreateGpgKeyForAuthenticatedUser,
            CliCommand::UsersGetGpgKeyForAuthenticatedUser,
            CliCommand::UsersDeleteGpgKeyForAuthenticatedUser,
            CliCommand::AppsListInstallationsForAuthenticatedUser,
            CliCommand::AppsListInstallationReposForAuthenticatedUser,
            CliCommand::AppsAddRepoToInstallationForAuthenticatedUser,
            CliCommand::AppsRemoveRepoFromInstallationForAuthenticatedUser,
            CliCommand::InteractionsGetRestrictionsForAuthenticatedUser,
            CliCommand::InteractionsSetRestrictionsForAuthenticatedUser,
            CliCommand::InteractionsRemoveRestrictionsForAuthenticatedUser,
            CliCommand::IssuesListForAuthenticatedUser,
            CliCommand::UsersListPublicSshKeysForAuthenticatedUser,
            CliCommand::UsersCreatePublicSshKeyForAuthenticatedUser,
            CliCommand::UsersGetPublicSshKeyForAuthenticatedUser,
            CliCommand::UsersDeletePublicSshKeyForAuthenticatedUser,
            CliCommand::AppsListSubscriptionsForAuthenticatedUser,
            CliCommand::AppsListSubscriptionsForAuthenticatedUserStubbed,
            CliCommand::OrgsListMembershipsForAuthenticatedUser,
            CliCommand::OrgsGetMembershipForAuthenticatedUser,
            CliCommand::OrgsUpdateMembershipForAuthenticatedUser,
            CliCommand::MigrationsListForAuthenticatedUser,
            CliCommand::MigrationsStartForAuthenticatedUser,
            CliCommand::MigrationsGetStatusForAuthenticatedUser,
            CliCommand::MigrationsGetArchiveForAuthenticatedUser,
            CliCommand::MigrationsDeleteArchiveForAuthenticatedUser,
            CliCommand::MigrationsUnlockRepoForAuthenticatedUser,
            CliCommand::MigrationsListReposForAuthenticatedUser,
            CliCommand::OrgsListForAuthenticatedUser,
            CliCommand::PackagesListPackagesForAuthenticatedUser,
            CliCommand::PackagesGetPackageForAuthenticatedUser,
            CliCommand::PackagesDeletePackageForAuthenticatedUser,
            CliCommand::PackagesRestorePackageForAuthenticatedUser,
            CliCommand::PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser,
            CliCommand::PackagesGetPackageVersionForAuthenticatedUser,
            CliCommand::PackagesDeletePackageVersionForAuthenticatedUser,
            CliCommand::PackagesRestorePackageVersionForAuthenticatedUser,
            CliCommand::ProjectsCreateForAuthenticatedUser,
            CliCommand::UsersListPublicEmailsForAuthenticatedUser,
            CliCommand::ReposListForAuthenticatedUser,
            CliCommand::ReposCreateForAuthenticatedUser,
            CliCommand::ReposListInvitationsForAuthenticatedUser,
            CliCommand::ReposDeclineInvitationForAuthenticatedUser,
            CliCommand::ReposAcceptInvitationForAuthenticatedUser,
            CliCommand::UsersListSocialAccountsForAuthenticatedUser,
            CliCommand::UsersAddSocialAccountForAuthenticatedUser,
            CliCommand::UsersDeleteSocialAccountForAuthenticatedUser,
            CliCommand::UsersListSshSigningKeysForAuthenticatedUser,
            CliCommand::UsersCreateSshSigningKeyForAuthenticatedUser,
            CliCommand::UsersGetSshSigningKeyForAuthenticatedUser,
            CliCommand::UsersDeleteSshSigningKeyForAuthenticatedUser,
            CliCommand::ActivityListReposStarredByAuthenticatedUser,
            CliCommand::ActivityCheckRepoIsStarredByAuthenticatedUser,
            CliCommand::ActivityStarRepoForAuthenticatedUser,
            CliCommand::ActivityUnstarRepoForAuthenticatedUser,
            CliCommand::ActivityListWatchedReposForAuthenticatedUser,
            CliCommand::TeamsListForAuthenticatedUser,
            CliCommand::UsersList,
            CliCommand::UsersGetByUsername,
            CliCommand::PackagesListDockerMigrationConflictingPackagesForUser,
            CliCommand::ActivityListEventsForAuthenticatedUser,
            CliCommand::ActivityListOrgEventsForAuthenticatedUser,
            CliCommand::ActivityListPublicEventsForUser,
            CliCommand::UsersListFollowersForUser,
            CliCommand::UsersListFollowingForUser,
            CliCommand::UsersCheckFollowingForUser,
            CliCommand::GistsListForUser,
            CliCommand::UsersListGpgKeysForUser,
            CliCommand::UsersGetContextForUser,
            CliCommand::AppsGetUserInstallation,
            CliCommand::UsersListPublicKeysForUser,
            CliCommand::OrgsListForUser,
            CliCommand::PackagesListPackagesForUser,
            CliCommand::PackagesGetPackageForUser,
            CliCommand::PackagesDeletePackageForUser,
            CliCommand::PackagesRestorePackageForUser,
            CliCommand::PackagesGetAllPackageVersionsForPackageOwnedByUser,
            CliCommand::PackagesGetPackageVersionForUser,
            CliCommand::PackagesDeletePackageVersionForUser,
            CliCommand::PackagesRestorePackageVersionForUser,
            CliCommand::ProjectsListForUser,
            CliCommand::ActivityListReceivedEventsForUser,
            CliCommand::ActivityListReceivedPublicEventsForUser,
            CliCommand::ReposListForUser,
            CliCommand::BillingGetGithubActionsBillingUser,
            CliCommand::BillingGetGithubPackagesBillingUser,
            CliCommand::BillingGetSharedStorageBillingUser,
            CliCommand::UsersListSocialAccountsForUser,
        ]
        .into_iter()
    }
}
