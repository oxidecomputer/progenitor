#[allow(unused_imports)]
use progenitor_client::encode_path;
pub use progenitor_client::{ByteStream, Error, ResponseValue};
pub mod types {
    use serde::{Deserialize, Serialize};
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct BlockSize(i64);
    impl std::ops::Deref for BlockSize {
        type Target = i64;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl std::convert::TryFrom<i64> for BlockSize {
        type Error = &'static str;
        fn try_from(value: i64) -> Result<Self, Self::Error> {
            if ![512_i64, 2048_i64, 4096_i64].contains(&value) {
                Err("invalid value")
            } else {
                Ok(Self(value))
            }
        }
    }

    ///A count of bytes, typically used either for memory or storage capacity
    ///
    ///The maximum supported byte count is [`i64::MAX`].  This makes it
    /// somewhat inconvenient to define constructors: a u32 constructor can be
    /// infallible, but an i64 constructor can fail (if the value is negative)
    /// and a u64 constructor can fail (if the value is larger than i64::MAX).
    /// We provide all of these for consumers' convenience.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ByteCount(pub u64);
    impl std::ops::Deref for ByteCount {
        type Target = u64;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    ///The type of an individual datum of a metric.
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum DatumType {
        #[serde(rename = "bool")]
        Bool,
        #[serde(rename = "i64")]
        I64,
        #[serde(rename = "f64")]
        F64,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "bytes")]
        Bytes,
        #[serde(rename = "cumulative_i64")]
        CumulativeI64,
        #[serde(rename = "cumulative_f64")]
        CumulativeF64,
        #[serde(rename = "histogram_i64")]
        HistogramI64,
        #[serde(rename = "histogram_f64")]
        HistogramF64,
    }

    impl ToString for DatumType {
        fn to_string(&self) -> String {
            match *self {
                DatumType::Bool => "bool".to_string(),
                DatumType::I64 => "i64".to_string(),
                DatumType::F64 => "f64".to_string(),
                DatumType::String => "string".to_string(),
                DatumType::Bytes => "bytes".to_string(),
                DatumType::CumulativeI64 => "cumulative_i64".to_string(),
                DatumType::CumulativeF64 => "cumulative_f64".to_string(),
                DatumType::HistogramI64 => "histogram_i64".to_string(),
                DatumType::HistogramF64 => "histogram_f64".to_string(),
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Digest {
        #[serde(rename = "type")]
        pub type_: DigestType,
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum DigestType {
        #[serde(rename = "sha256")]
        Sha256,
    }

    impl ToString for DigestType {
        fn to_string(&self) -> String {
            match *self {
                DigestType::Sha256 => "sha256".to_string(),
            }
        }
    }

    ///Client view of an [`Disk`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Disk {
        pub block_size: ByteCount,
        ///human-readable free-form text about a resource
        pub description: String,
        pub device_path: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub image_id: Option<uuid::Uuid>,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub project_id: uuid::Uuid,
        pub size: ByteCount,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snapshot_id: Option<uuid::Uuid>,
        pub state: DiskState,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    ///Create-time parameters for a
    /// [`Disk`](omicron_common::api::external::Disk)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct DiskCreate {
        pub description: String,
        ///initial source for this disk
        pub disk_source: DiskSource,
        pub name: Name,
        ///total size of the Disk in bytes
        pub size: ByteCount,
    }

    ///Parameters for the [`Disk`](omicron_common::api::external::Disk) to be
    /// attached or detached to an instance
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct DiskIdentifier {
        pub name: Name,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct DiskResultsPage {
        ///list of items on this page of results
        pub items: Vec<Disk>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Different sources for a disk
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type")]
    pub enum DiskSource {
        ///Create a blank disk
        #[serde(rename = "blank")]
        Blank {
            ///size of blocks for this Disk. valid values are: 512, 2048, or
            /// 4096
            block_size: BlockSize,
        },
        ///Create a disk from a disk snapshot
        #[serde(rename = "snapshot")]
        Snapshot { snapshot_id: uuid::Uuid },
        ///Create a disk from a project image
        #[serde(rename = "image")]
        Image { image_id: uuid::Uuid },
        ///Create a disk from a global image
        #[serde(rename = "global_image")]
        GlobalImage { image_id: uuid::Uuid },
    }

    ///State of a Disk (primarily: attached or not)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "state", content = "instance")]
    pub enum DiskState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "detached")]
        Detached,
        ///Disk is being attached to the given Instance
        #[serde(rename = "attaching")]
        Attaching(uuid::Uuid),
        ///Disk is attached to the given Instance
        #[serde(rename = "attached")]
        Attached(uuid::Uuid),
        ///Disk is being detached from the given Instance
        #[serde(rename = "detaching")]
        Detaching(uuid::Uuid),
        #[serde(rename = "destroyed")]
        Destroyed,
        #[serde(rename = "faulted")]
        Faulted,
    }

    ///Error information from a response.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Error {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_code: Option<String>,
        pub message: String,
        pub request_id: String,
    }

    ///The name and type information for a field of a timeseries schema.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct FieldSchema {
        pub name: String,
        pub source: FieldSource,
        pub ty: FieldType,
    }

    ///The source from which a field is derived, the target or metric.
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum FieldSource {
        #[serde(rename = "target")]
        Target,
        #[serde(rename = "metric")]
        Metric,
    }

    impl ToString for FieldSource {
        fn to_string(&self) -> String {
            match *self {
                FieldSource::Target => "target".to_string(),
                FieldSource::Metric => "metric".to_string(),
            }
        }
    }

    ///The `FieldType` identifies the data type of a target or metric field.
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum FieldType {
        #[serde(rename = "string")]
        String,
        #[serde(rename = "i64")]
        I64,
        #[serde(rename = "ip_addr")]
        IpAddr,
        #[serde(rename = "uuid")]
        Uuid,
        #[serde(rename = "bool")]
        Bool,
    }

    impl ToString for FieldType {
        fn to_string(&self) -> String {
            match *self {
                FieldType::String => "string".to_string(),
                FieldType::I64 => "i64".to_string(),
                FieldType::IpAddr => "ip_addr".to_string(),
                FieldType::Uuid => "uuid".to_string(),
                FieldType::Bool => "bool".to_string(),
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum FleetRoles {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl ToString for FleetRoles {
        fn to_string(&self) -> String {
            match *self {
                FleetRoles::Admin => "admin".to_string(),
                FleetRoles::Collaborator => "collaborator".to_string(),
                FleetRoles::Viewer => "viewer".to_string(),
            }
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct FleetRolesPolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: Vec<FleetRolesRoleAssignment>,
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct FleetRolesRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: FleetRoles,
    }

    ///Client view of global Images
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct GlobalImage {
        ///size of blocks in bytes
        pub block_size: ByteCount,
        ///human-readable free-form text about a resource
        pub description: String,
        ///Hash of the image contents, if applicable
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub digest: Option<Digest>,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///total size in bytes
        pub size: ByteCount,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///URL source of this image, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        ///Version of this, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub version: Option<String>,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct GlobalImageResultsPage {
        ///list of items on this page of results
        pub items: Vec<GlobalImage>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Supported set of sort modes for scanning by id only.
    ///
    ///Currently, we only support scanning in ascending order.
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum IdSortMode {
        #[serde(rename = "id_ascending")]
        IdAscending,
    }

    impl ToString for IdSortMode {
        fn to_string(&self) -> String {
            match *self {
                IdSortMode::IdAscending => "id_ascending".to_string(),
            }
        }
    }

    ///Describes what kind of identity is described by an id
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum IdentityType {
        #[serde(rename = "silo_user")]
        SiloUser,
    }

    impl ToString for IdentityType {
        fn to_string(&self) -> String {
            match *self {
                IdentityType::SiloUser => "silo_user".to_string(),
            }
        }
    }

    ///Client view of project Images
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Image {
        ///size of blocks in bytes
        pub block_size: ByteCount,
        ///human-readable free-form text about a resource
        pub description: String,
        ///Hash of the image contents, if applicable
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub digest: Option<Digest>,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///The project the disk belongs to
        pub project_id: uuid::Uuid,
        ///total size in bytes
        pub size: ByteCount,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///URL source of this image, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        ///Version of this, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub version: Option<String>,
    }

    ///Create-time parameters for an
    /// [`Image`](omicron_common::api::external::Image)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ImageCreate {
        ///block size in bytes
        pub block_size: BlockSize,
        pub description: String,
        pub name: Name,
        ///The source of the image's contents.
        pub source: ImageSource,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ImageResultsPage {
        ///list of items on this page of results
        pub items: Vec<Image>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///The source of the underlying image.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type", content = "src")]
    pub enum ImageSource {
        #[serde(rename = "url")]
        Url(String),
        #[serde(rename = "snapshot")]
        Snapshot(uuid::Uuid),
    }

    ///Client view of an [`Instance`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Instance {
        ///human-readable free-form text about a resource
        pub description: String,
        ///RFC1035-compliant hostname for the Instance.
        pub hostname: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///memory allocated for this Instance
        pub memory: ByteCount,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///number of CPUs allocated for this Instance
        pub ncpus: InstanceCpuCount,
        ///id for the project containing this Instance
        pub project_id: uuid::Uuid,
        pub run_state: InstanceState,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub time_run_state_updated: chrono::DateTime<chrono::offset::Utc>,
    }

    ///The number of CPUs in an Instance
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct InstanceCpuCount(pub u16);
    impl std::ops::Deref for InstanceCpuCount {
        type Target = u16;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    ///Create-time parameters for an
    /// [`Instance`](omicron_common::api::external::Instance)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct InstanceCreate {
        pub description: String,
        ///The disks to be created or attached for this instance.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub disks: Vec<InstanceDiskAttachment>,
        pub hostname: String,
        pub memory: ByteCount,
        pub name: Name,
        pub ncpus: InstanceCpuCount,
        ///The network interfaces to be created for this instance.
        #[serde(default = "instance_create_network_interfaces")]
        pub network_interfaces: InstanceNetworkInterfaceAttachment,
        ///User data for instance initialization systems (such as cloud-init).
        /// Must be a Base64-encoded string, as specified in RFC 4648 § 4 (+ and
        /// / characters with padding). Maximum 32 KiB unencoded data.
        #[serde(default)]
        pub user_data: String,
    }

    fn instance_create_network_interfaces() -> InstanceNetworkInterfaceAttachment {
        InstanceNetworkInterfaceAttachment::Default
    }

    ///Describe the instance's disks at creation time
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type")]
    pub enum InstanceDiskAttachment {
        ///During instance creation, create and attach disks
        #[serde(rename = "create")]
        Create {
            description: String,
            ///initial source for this disk
            disk_source: DiskSource,
            name: Name,
            ///total size of the Disk in bytes
            size: ByteCount,
        },
        ///During instance creation, attach this disk
        #[serde(rename = "attach")]
        Attach {
            ///A disk name to attach
            name: Name,
        },
    }

    ///Migration parameters for an
    /// [`Instance`](omicron_common::api::external::Instance)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct InstanceMigrate {
        pub dst_sled_uuid: uuid::Uuid,
    }

    ///Describes an attachment of a `NetworkInterface` to an `Instance`, at the
    /// time the instance is created.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type", content = "params")]
    pub enum InstanceNetworkInterfaceAttachment {
        ///Create one or more `NetworkInterface`s for the `Instance`
        #[serde(rename = "create")]
        Create(Vec<NetworkInterfaceCreate>),
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "none")]
        None,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct InstanceResultsPage {
        ///list of items on this page of results
        pub items: Vec<Instance>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Running state of an Instance (primarily: booted or stopped)
    ///
    ///This typically reflects whether it's starting, running, stopping, or
    /// stopped, but also includes states related to the Instance's lifecycle
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum InstanceState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "starting")]
        Starting,
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "stopping")]
        Stopping,
        #[serde(rename = "stopped")]
        Stopped,
        #[serde(rename = "rebooting")]
        Rebooting,
        #[serde(rename = "migrating")]
        Migrating,
        #[serde(rename = "repairing")]
        Repairing,
        #[serde(rename = "failed")]
        Failed,
        #[serde(rename = "destroyed")]
        Destroyed,
    }

    impl ToString for InstanceState {
        fn to_string(&self) -> String {
            match *self {
                InstanceState::Creating => "creating".to_string(),
                InstanceState::Starting => "starting".to_string(),
                InstanceState::Running => "running".to_string(),
                InstanceState::Stopping => "stopping".to_string(),
                InstanceState::Stopped => "stopped".to_string(),
                InstanceState::Rebooting => "rebooting".to_string(),
                InstanceState::Migrating => "migrating".to_string(),
                InstanceState::Repairing => "repairing".to_string(),
                InstanceState::Failed => "failed".to_string(),
                InstanceState::Destroyed => "destroyed".to_string(),
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(untagged)]
    pub enum IpNet {
        V4(Ipv4Net),
        V6(Ipv6Net),
    }

    ///An IPv4 subnet, including prefix and subnet mask
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Ipv4Net(pub String);
    impl std::ops::Deref for Ipv4Net {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    ///An IPv6 subnet, including prefix and subnet mask
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Ipv6Net(pub String);
    impl std::ops::Deref for Ipv6Net {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    ///An inclusive-inclusive range of IP ports. The second port may be omitted
    /// to represent a single port
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct L4PortRange(pub String);
    impl std::ops::Deref for L4PortRange {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct LoginParams {
        pub username: String,
    }

    ///A Media Access Control address, in EUI-48 format
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct MacAddr(pub String);
    impl std::ops::Deref for MacAddr {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    ///Names must begin with a lower case ASCII letter, be composed exclusively
    /// of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end
    /// with a '-'.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Name(pub String);
    impl std::ops::Deref for Name {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    ///Supported set of sort modes for scanning by name or id
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum NameOrIdSortMode {
        #[serde(rename = "name_ascending")]
        NameAscending,
        #[serde(rename = "name_descending")]
        NameDescending,
        #[serde(rename = "id_ascending")]
        IdAscending,
    }

    impl ToString for NameOrIdSortMode {
        fn to_string(&self) -> String {
            match *self {
                NameOrIdSortMode::NameAscending => "name_ascending".to_string(),
                NameOrIdSortMode::NameDescending => "name_descending".to_string(),
                NameOrIdSortMode::IdAscending => "id_ascending".to_string(),
            }
        }
    }

    ///Supported set of sort modes for scanning by name only
    ///
    ///Currently, we only support scanning in ascending order.
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum NameSortMode {
        #[serde(rename = "name_ascending")]
        NameAscending,
    }

    impl ToString for NameSortMode {
        fn to_string(&self) -> String {
            match *self {
                NameSortMode::NameAscending => "name_ascending".to_string(),
            }
        }
    }

    ///A `NetworkInterface` represents a virtual network interface device.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct NetworkInterface {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///The Instance to which the interface belongs.
        pub instance_id: uuid::Uuid,
        ///The IP address assigned to this interface.
        pub ip: String,
        ///The MAC address assigned to this interface.
        pub mac: MacAddr,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///The subnet to which the interface belongs.
        pub subnet_id: uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///The VPC to which the interface belongs.
        pub vpc_id: uuid::Uuid,
    }

    ///Create-time parameters for a
    /// [`NetworkInterface`](omicron_common::api::external::NetworkInterface)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct NetworkInterfaceCreate {
        pub description: String,
        ///The IP address for the interface. One will be auto-assigned if not
        /// provided.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ip: Option<String>,
        pub name: Name,
        ///The VPC Subnet in which to create the interface.
        pub subnet_name: Name,
        ///The VPC in which to create the interface.
        pub vpc_name: Name,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct NetworkInterfaceResultsPage {
        ///list of items on this page of results
        pub items: Vec<NetworkInterface>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Client view of an [`Organization`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Organization {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    ///Create-time parameters for an
    /// [`Organization`](crate::external_api::views::Organization)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct OrganizationCreate {
        pub description: String,
        pub name: Name,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct OrganizationResultsPage {
        ///list of items on this page of results
        pub items: Vec<Organization>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum OrganizationRoles {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
    }

    impl ToString for OrganizationRoles {
        fn to_string(&self) -> String {
            match *self {
                OrganizationRoles::Admin => "admin".to_string(),
                OrganizationRoles::Collaborator => "collaborator".to_string(),
            }
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct OrganizationRolesPolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: Vec<OrganizationRolesRoleAssignment>,
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct OrganizationRolesRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: OrganizationRoles,
    }

    ///Updateable properties of an
    /// [`Organization`](crate::external_api::views::Organization)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct OrganizationUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    ///Client view of a [`Project`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Project {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub organization_id: uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    ///Create-time parameters for a
    /// [`Project`](crate::external_api::views::Project)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ProjectCreate {
        pub description: String,
        pub name: Name,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ProjectResultsPage {
        ///list of items on this page of results
        pub items: Vec<Project>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum ProjectRoles {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl ToString for ProjectRoles {
        fn to_string(&self) -> String {
            match *self {
                ProjectRoles::Admin => "admin".to_string(),
                ProjectRoles::Collaborator => "collaborator".to_string(),
                ProjectRoles::Viewer => "viewer".to_string(),
            }
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ProjectRolesPolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: Vec<ProjectRolesRoleAssignment>,
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ProjectRolesRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: ProjectRoles,
    }

    ///Updateable properties of a
    /// [`Project`](crate::external_api::views::Project)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ProjectUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    ///Client view of an [`Rack`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Rack {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RackResultsPage {
        ///list of items on this page of results
        pub items: Vec<Rack>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Client view of a [`Role`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Role {
        pub description: String,
        pub name: RoleName,
    }

    ///Role names consist of two string components separated by dot (".").
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RoleName(pub String);
    impl std::ops::Deref for RoleName {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RoleResultsPage {
        ///list of items on this page of results
        pub items: Vec<Role>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///A `RouteDestination` is used to match traffic with a routing rule, on
    /// the destination of that traffic.
    ///
    ///When traffic is to be sent to a destination that is within a given
    /// `RouteDestination`, the corresponding [`RouterRoute`] applies, and
    /// traffic will be forward to the [`RouteTarget`] for that rule.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteDestination {
        ///Route applies to traffic destined for a specific IP address
        #[serde(rename = "ip")]
        Ip(String),
        ///Route applies to traffic destined for a specific IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
        ///Route applies to traffic destined for the given VPC.
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///Route applies to traffic
        #[serde(rename = "subnet")]
        Subnet(Name),
    }

    ///A `RouteTarget` describes the possible locations that traffic matching a
    /// route destination can be sent.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteTarget {
        ///Forward traffic to a particular IP address.
        #[serde(rename = "ip")]
        Ip(String),
        ///Forward traffic to a VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///Forward traffic to a VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        ///Forward traffic to a specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        ///Forward traffic to an internet gateway
        #[serde(rename = "internet_gateway")]
        InternetGateway(Name),
    }

    ///A route defines a rule that governs where traffic should be sent based
    /// on its destination.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RouterRoute {
        ///human-readable free-form text about a resource
        pub description: String,
        pub destination: RouteDestination,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///Describes the kind of router. Set at creation. `read-only`
        pub kind: RouterRouteKind,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub target: RouteTarget,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///The VPC Router to which the route belongs.
        pub vpc_router_id: uuid::Uuid,
    }

    ///Create-time parameters for a [`RouterRoute`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RouterRouteCreateParams {
        pub description: String,
        pub destination: RouteDestination,
        pub name: Name,
        pub target: RouteTarget,
    }

    ///The classification of a [`RouterRoute`] as defined by the system. The
    /// kind determines certain attributes such as if the route is modifiable
    /// and describes how or where the route was created.
    ///
    ///See [RFD-21](https://rfd.shared.oxide.computer/rfd/0021#concept-router) for more context
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum RouterRouteKind {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "vpc_subnet")]
        VpcSubnet,
        #[serde(rename = "vpc_peering")]
        VpcPeering,
        #[serde(rename = "custom")]
        Custom,
    }

    impl ToString for RouterRouteKind {
        fn to_string(&self) -> String {
            match *self {
                RouterRouteKind::Default => "default".to_string(),
                RouterRouteKind::VpcSubnet => "vpc_subnet".to_string(),
                RouterRouteKind::VpcPeering => "vpc_peering".to_string(),
                RouterRouteKind::Custom => "custom".to_string(),
            }
        }
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RouterRouteResultsPage {
        ///list of items on this page of results
        pub items: Vec<RouterRoute>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Updateable properties of a [`RouterRoute`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct RouterRouteUpdateParams {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        pub destination: RouteDestination,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
        pub target: RouteTarget,
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Saga {
        pub id: uuid::Uuid,
        pub state: SagaState,
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "error")]
    pub enum SagaErrorInfo {
        #[serde(rename = "action_failed")]
        ActionFailed { source_error: serde_json::Value },
        #[serde(rename = "deserialize_failed")]
        DeserializeFailed { message: String },
        #[serde(rename = "injected_error")]
        InjectedError,
        #[serde(rename = "serialize_failed")]
        SerializeFailed { message: String },
        #[serde(rename = "subsaga_create_failed")]
        SubsagaCreateFailed { message: String },
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SagaResultsPage {
        ///list of items on this page of results
        pub items: Vec<Saga>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "state")]
    pub enum SagaState {
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "succeeded")]
        Succeeded,
        #[serde(rename = "failed")]
        Failed {
            error_info: SagaErrorInfo,
            error_node_name: String,
        },
    }

    ///Client view of currently authed user.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SessionUser {
        pub id: uuid::Uuid,
    }

    ///Client view of a ['Silo']
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Silo {
        ///human-readable free-form text about a resource
        pub description: String,
        ///A silo where discoverable is false can be retrieved only by its id -
        /// it will not be part of the "list all silos" output.
        pub discoverable: bool,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    ///Create-time parameters for a [`Silo`](crate::external_api::views::Silo)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SiloCreate {
        pub description: String,
        pub discoverable: bool,
        pub name: Name,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SiloResultsPage {
        ///list of items on this page of results
        pub items: Vec<Silo>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum SiloRoles {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl ToString for SiloRoles {
        fn to_string(&self) -> String {
            match *self {
                SiloRoles::Admin => "admin".to_string(),
                SiloRoles::Collaborator => "collaborator".to_string(),
                SiloRoles::Viewer => "viewer".to_string(),
            }
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SiloRolesPolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: Vec<SiloRolesRoleAssignment>,
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SiloRolesRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: SiloRoles,
    }

    ///Client view of an [`Sled`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Sled {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub service_address: String,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SledResultsPage {
        ///list of items on this page of results
        pub items: Vec<Sled>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Client view of a Snapshot
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Snapshot {
        ///human-readable free-form text about a resource
        pub description: String,
        pub disk_id: uuid::Uuid,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub project_id: uuid::Uuid,
        pub size: ByteCount,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    ///Create-time parameters for a
    /// [`Snapshot`](omicron_common::api::external::Snapshot)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SnapshotCreate {
        pub description: String,
        ///The name of the disk to be snapshotted
        pub disk: Name,
        pub name: Name,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SnapshotResultsPage {
        ///list of items on this page of results
        pub items: Vec<Snapshot>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Client view of a [`SshKey`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SshKey {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///SSH public key, e.g., `"ssh-ed25519 AAAAC3NzaC..."`
        pub public_key: String,
        ///The user to whom this key belongs
        pub silo_user_id: uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    ///Create-time parameters for an
    /// [`SshKey`](crate::external_api::views::SshKey)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SshKeyCreate {
        pub description: String,
        pub name: Name,
        ///SSH public key, e.g., `"ssh-ed25519 AAAAC3NzaC..."`
        pub public_key: String,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct SshKeyResultsPage {
        ///list of items on this page of results
        pub items: Vec<SshKey>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Names are constructed by concatenating the target and metric names with
    /// ':'. Target and metric names must be lowercase alphanumeric characters
    /// with '_' separating words.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct TimeseriesName(pub String);
    impl std::ops::Deref for TimeseriesName {
        type Target = String;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    ///The schema for a timeseries.
    ///
    ///This includes the name of the timeseries, as well as the datum type of
    /// its metric and the schema for each field.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct TimeseriesSchema {
        pub created: chrono::DateTime<chrono::offset::Utc>,
        pub datum_type: DatumType,
        pub field_schema: Vec<FieldSchema>,
        pub timeseries_name: TimeseriesName,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct TimeseriesSchemaResultsPage {
        ///list of items on this page of results
        pub items: Vec<TimeseriesSchema>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Client view of a [`User`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct User {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct UserResultsPage {
        ///list of items on this page of results
        pub items: Vec<User>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Client view of a [`Vpc`]
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Vpc {
        ///human-readable free-form text about a resource
        pub description: String,
        ///The name used for the VPC in DNS.
        pub dns_name: Name,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///The unique local IPv6 address range for subnets in this VPC
        pub ipv6_prefix: Ipv6Net,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///id for the project containing this VPC
        pub project_id: uuid::Uuid,
        ///id for the system router where subnet default routes are registered
        pub system_router_id: uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    ///Create-time parameters for a [`Vpc`](crate::external_api::views::Vpc)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcCreate {
        pub description: String,
        pub dns_name: Name,
        ///The IPv6 prefix for this VPC.
        ///
        ///All IPv6 subnets created from this VPC must be taken from this
        /// range, which sould be a Unique Local Address in the range
        /// `fd00::/48`. The default VPC Subnet will have the first `/64` range
        /// from this prefix.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ipv6_prefix: Option<Ipv6Net>,
        pub name: Name,
    }

    ///A single rule in a VPC firewall
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcFirewallRule {
        ///whether traffic matching the rule should be allowed or dropped
        pub action: VpcFirewallRuleAction,
        ///human-readable free-form text about a resource
        pub description: String,
        ///whether this rule is for incoming or outgoing traffic
        pub direction: VpcFirewallRuleDirection,
        ///reductions on the scope of the rule
        pub filters: VpcFirewallRuleFilter,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///the relative priority of this rule
        pub priority: u16,
        ///whether this rule is in effect
        pub status: VpcFirewallRuleStatus,
        ///list of sets of instances that the rule applies to
        pub targets: Vec<VpcFirewallRuleTarget>,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///the VPC to which this rule belongs
        pub vpc_id: uuid::Uuid,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum VpcFirewallRuleAction {
        #[serde(rename = "allow")]
        Allow,
        #[serde(rename = "deny")]
        Deny,
    }

    impl ToString for VpcFirewallRuleAction {
        fn to_string(&self) -> String {
            match *self {
                VpcFirewallRuleAction::Allow => "allow".to_string(),
                VpcFirewallRuleAction::Deny => "deny".to_string(),
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum VpcFirewallRuleDirection {
        #[serde(rename = "inbound")]
        Inbound,
        #[serde(rename = "outbound")]
        Outbound,
    }

    impl ToString for VpcFirewallRuleDirection {
        fn to_string(&self) -> String {
            match *self {
                VpcFirewallRuleDirection::Inbound => "inbound".to_string(),
                VpcFirewallRuleDirection::Outbound => "outbound".to_string(),
            }
        }
    }

    ///Filter for a firewall rule. A given packet must match every field that
    /// is present for the rule to apply to it. A packet matches a field if any
    /// entry in that field matches the packet.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcFirewallRuleFilter {
        ///If present, the sources (if incoming) or destinations (if outgoing)
        /// this rule applies to.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hosts: Option<Vec<VpcFirewallRuleHostFilter>>,
        ///If present, the destination ports this rule applies to.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ports: Option<Vec<L4PortRange>>,
        ///If present, the networking protocols this rule applies to.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub protocols: Option<Vec<VpcFirewallRuleProtocol>>,
    }

    ///The `VpcFirewallRuleHostFilter` is used to filter traffic on the basis
    /// of its source or destination host.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleHostFilter {
        ///The rule applies to traffic from/to all instances in the VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///The rule applies to traffic from/to all instances in the VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        ///The rule applies to traffic from/to this specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        ///The rule applies to traffic from/to a specific IP address
        #[serde(rename = "ip")]
        Ip(String),
        ///The rule applies to traffic from/to a specific IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    ///The protocols that may be specified in a firewall rule's filter
    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum VpcFirewallRuleProtocol {
        #[serde(rename = "TCP")]
        Tcp,
        #[serde(rename = "UDP")]
        Udp,
        #[serde(rename = "ICMP")]
        Icmp,
    }

    impl ToString for VpcFirewallRuleProtocol {
        fn to_string(&self) -> String {
            match *self {
                VpcFirewallRuleProtocol::Tcp => "TCP".to_string(),
                VpcFirewallRuleProtocol::Udp => "UDP".to_string(),
                VpcFirewallRuleProtocol::Icmp => "ICMP".to_string(),
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum VpcFirewallRuleStatus {
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "enabled")]
        Enabled,
    }

    impl ToString for VpcFirewallRuleStatus {
        fn to_string(&self) -> String {
            match *self {
                VpcFirewallRuleStatus::Disabled => "disabled".to_string(),
                VpcFirewallRuleStatus::Enabled => "enabled".to_string(),
            }
        }
    }

    ///A `VpcFirewallRuleTarget` is used to specify the set of [`Instance`]s to
    /// which a firewall rule applies.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleTarget {
        ///The rule applies to all instances in the VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///The rule applies to all instances in the VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        ///The rule applies to this specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        ///The rule applies to a specific IP address
        #[serde(rename = "ip")]
        Ip(String),
        ///The rule applies to a specific IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    ///A single rule in a VPC firewall
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcFirewallRuleUpdate {
        ///whether traffic matching the rule should be allowed or dropped
        pub action: VpcFirewallRuleAction,
        ///human-readable free-form text about a resource
        pub description: String,
        ///whether this rule is for incoming or outgoing traffic
        pub direction: VpcFirewallRuleDirection,
        ///reductions on the scope of the rule
        pub filters: VpcFirewallRuleFilter,
        ///name of the rule, unique to this VPC
        pub name: Name,
        ///the relative priority of this rule
        pub priority: u16,
        ///whether this rule is in effect
        pub status: VpcFirewallRuleStatus,
        ///list of sets of instances that the rule applies to
        pub targets: Vec<VpcFirewallRuleTarget>,
    }

    ///Updateable properties of a `Vpc`'s firewall Note that VpcFirewallRules
    /// are implicitly created along with a Vpc, so there is no explicit
    /// creation.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcFirewallRuleUpdateParams {
        pub rules: Vec<VpcFirewallRuleUpdate>,
    }

    ///Collection of a [`Vpc`]'s firewall rules
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcFirewallRules {
        pub rules: Vec<VpcFirewallRule>,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcResultsPage {
        ///list of items on this page of results
        pub items: Vec<Vpc>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///A VPC router defines a series of rules that indicate where traffic
    /// should be sent depending on its destination.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcRouter {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        pub kind: VpcRouterKind,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///The VPC to which the router belongs.
        pub vpc_id: uuid::Uuid,
    }

    ///Create-time parameters for a
    /// [`VpcRouter`](crate::external_api::views::VpcRouter)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcRouterCreate {
        pub description: String,
        pub name: Name,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]
    pub enum VpcRouterKind {
        #[serde(rename = "system")]
        System,
        #[serde(rename = "custom")]
        Custom,
    }

    impl ToString for VpcRouterKind {
        fn to_string(&self) -> String {
            match *self {
                VpcRouterKind::System => "system".to_string(),
                VpcRouterKind::Custom => "custom".to_string(),
            }
        }
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcRouterResultsPage {
        ///list of items on this page of results
        pub items: Vec<VpcRouter>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Updateable properties of a
    /// [`VpcRouter`](crate::external_api::views::VpcRouter)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcRouterUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    ///A VPC subnet represents a logical grouping for instances that allows
    /// network traffic between them, within a IPv4 subnetwork or optionall an
    /// IPv6 subnetwork.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcSubnet {
        ///human-readable free-form text about a resource
        pub description: String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: uuid::Uuid,
        ///The IPv4 subnet CIDR block.
        pub ipv4_block: Ipv4Net,
        ///The IPv6 subnet CIDR block.
        pub ipv6_block: Ipv6Net,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        ///The VPC to which the subnet belongs.
        pub vpc_id: uuid::Uuid,
    }

    ///Create-time parameters for a
    /// [`VpcSubnet`](crate::external_api::views::VpcSubnet)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcSubnetCreate {
        pub description: String,
        ///The IPv4 address range for this subnet.
        ///
        ///It must be allocated from an RFC 1918 private address range, and
        /// must not overlap with any other existing subnet in the VPC.
        pub ipv4_block: Ipv4Net,
        ///The IPv6 address range for this subnet.
        ///
        ///It must be allocated from the RFC 4193 Unique Local Address range,
        /// with the prefix equal to the parent VPC's prefix. A random `/64`
        /// block will be assigned if one is not provided. It must not overlap
        /// with any existing subnet in the VPC.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ipv6_block: Option<Ipv6Net>,
        pub name: Name,
    }

    ///A single page of results
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcSubnetResultsPage {
        ///list of items on this page of results
        pub items: Vec<VpcSubnet>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    ///Updateable properties of a
    /// [`VpcSubnet`](crate::external_api::views::VpcSubnet)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcSubnetUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    ///Updateable properties of a [`Vpc`](crate::external_api::views::Vpc)
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct VpcUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dns_name: Option<Name>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }
}

#[derive(Clone)]
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    pub fn new(baseurl: &str) -> Self {
        let dur = std::time::Duration::from_secs(15);
        let client = reqwest::ClientBuilder::new()
            .connect_timeout(dur)
            .timeout(dur)
            .build()
            .unwrap();
        Self::new_with_client(baseurl, client)
    }

    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }

    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }

    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }
}

pub trait ClientDisksExt {
    ///List disks in a project
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/disks`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.project_disks_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn project_disks_get(&self) -> builder::ProjectDisksGet;
    ///Create a disk in a project
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/disks`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///
    ///```ignore
    /// let response = client.project_disks_post()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_disks_post(&self) -> builder::ProjectDisksPost;
    ///Fetch a single disk in a project
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}` ```ignore
    /// let response = client.project_disks_get_disk()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .disk_name(disk_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_disks_get_disk(&self) -> builder::ProjectDisksGetDisk;
    ///Delete a disk from a project
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}` ```ignore
    /// let response = client.project_disks_delete_disk()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .disk_name(disk_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_disks_delete_disk(&self) -> builder::ProjectDisksDeleteDisk;
}

impl ClientDisksExt for Client {
    fn project_disks_get(&self) -> builder::ProjectDisksGet {
        builder::ProjectDisksGet::new(self)
    }

    fn project_disks_post(&self) -> builder::ProjectDisksPost {
        builder::ProjectDisksPost::new(self)
    }

    fn project_disks_get_disk(&self) -> builder::ProjectDisksGetDisk {
        builder::ProjectDisksGetDisk::new(self)
    }

    fn project_disks_delete_disk(&self) -> builder::ProjectDisksDeleteDisk {
        builder::ProjectDisksDeleteDisk::new(self)
    }
}

pub trait ClientFirewallExt {
    ///List firewall rules for a VPC
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/firewall/rules` ```ignore
    /// let response = client.vpc_firewall_rules_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_firewall_rules_get(&self) -> builder::VpcFirewallRulesGet;
    ///Replace the firewall rules for a VPC
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/firewall/rules` ```ignore
    /// let response = client.vpc_firewall_rules_put()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_firewall_rules_put(&self) -> builder::VpcFirewallRulesPut;
}

impl ClientFirewallExt for Client {
    fn vpc_firewall_rules_get(&self) -> builder::VpcFirewallRulesGet {
        builder::VpcFirewallRulesGet::new(self)
    }

    fn vpc_firewall_rules_put(&self) -> builder::VpcFirewallRulesPut {
        builder::VpcFirewallRulesPut::new(self)
    }
}

pub trait ClientHiddenExt {
    ///Sends a `POST` request to `/login`
    ///```ignore
    /// let response = client.spoof_login()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn spoof_login(&self) -> builder::SpoofLogin;
    ///Sends a `POST` request to `/logout`
    ///```ignore
    /// let response = client.logout()
    ///    .send()
    ///    .await;
    /// ```
    fn logout(&self) -> builder::Logout;
    ///Fetch the user associated with the current session
    ///
    ///Sends a `GET` request to `/session/me`
    ///```ignore
    /// let response = client.session_me()
    ///    .send()
    ///    .await;
    /// ```
    fn session_me(&self) -> builder::SessionMe;
}

impl ClientHiddenExt for Client {
    fn spoof_login(&self) -> builder::SpoofLogin {
        builder::SpoofLogin::new(self)
    }

    fn logout(&self) -> builder::Logout {
        builder::Logout::new(self)
    }

    fn session_me(&self) -> builder::SessionMe {
        builder::SessionMe::new(self)
    }
}

pub trait ClientImagesExt {
    ///List images
    ///
    ///List images in a project. The images are returned sorted by creation
    /// date, with the most recent images appearing first.
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/images`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.project_images_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn project_images_get(&self) -> builder::ProjectImagesGet;
    ///Create an image
    ///
    ///Create a new image in a project.
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/images`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///
    ///```ignore
    /// let response = client.project_images_post()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_images_post(&self) -> builder::ProjectImagesPost;
    ///Get an image
    ///
    ///Get the details of a specific image in a project.
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/images/
    /// {image_name}` ```ignore
    /// let response = client.project_images_get_image()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .image_name(image_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_images_get_image(&self) -> builder::ProjectImagesGetImage;
    ///Delete an image
    ///
    ///Permanently delete an image from a project. This operation cannot be
    /// undone. Any instances in the project using the image will continue to
    /// run, however new instances can not be created with this image.
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/images/
    /// {image_name}` ```ignore
    /// let response = client.project_images_delete_image()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .image_name(image_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_images_delete_image(&self) -> builder::ProjectImagesDeleteImage;
}

impl ClientImagesExt for Client {
    fn project_images_get(&self) -> builder::ProjectImagesGet {
        builder::ProjectImagesGet::new(self)
    }

    fn project_images_post(&self) -> builder::ProjectImagesPost {
        builder::ProjectImagesPost::new(self)
    }

    fn project_images_get_image(&self) -> builder::ProjectImagesGetImage {
        builder::ProjectImagesGetImage::new(self)
    }

    fn project_images_delete_image(&self) -> builder::ProjectImagesDeleteImage {
        builder::ProjectImagesDeleteImage::new(self)
    }
}

pub trait ClientImagesGlobalExt {
    ///List global images
    ///
    ///Returns a list of all the global images. Global images are returned
    /// sorted by creation date, with the most recent images appearing first.
    ///
    ///Sends a `GET` request to `/images`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.images_get()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn images_get(&self) -> builder::ImagesGet;
    ///Create a global image
    ///
    ///Create a new global image. This image can then be used by any user as a
    /// base for instances.
    ///
    ///Sends a `POST` request to `/images`
    ///```ignore
    /// let response = client.images_post()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn images_post(&self) -> builder::ImagesPost;
    ///Get a global image
    ///
    ///Returns the details of a specific global image.
    ///
    ///Sends a `GET` request to `/images/{image_name}`
    ///```ignore
    /// let response = client.images_get_image()
    ///    .image_name(image_name)
    ///    .send()
    ///    .await;
    /// ```
    fn images_get_image(&self) -> builder::ImagesGetImage;
    ///Delete a global image
    ///
    ///Permanently delete a global image. This operation cannot be undone. Any
    /// instances using the global image will continue to run, however new
    /// instances can not be created with this image.
    ///
    ///Sends a `DELETE` request to `/images/{image_name}`
    ///```ignore
    /// let response = client.images_delete_image()
    ///    .image_name(image_name)
    ///    .send()
    ///    .await;
    /// ```
    fn images_delete_image(&self) -> builder::ImagesDeleteImage;
}

impl ClientImagesGlobalExt for Client {
    fn images_get(&self) -> builder::ImagesGet {
        builder::ImagesGet::new(self)
    }

    fn images_post(&self) -> builder::ImagesPost {
        builder::ImagesPost::new(self)
    }

    fn images_get_image(&self) -> builder::ImagesGetImage {
        builder::ImagesGetImage::new(self)
    }

    fn images_delete_image(&self) -> builder::ImagesDeleteImage {
        builder::ImagesDeleteImage::new(self)
    }
}

pub trait ClientInstancesExt {
    ///List instances in a project
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.project_instances_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn project_instances_get(&self) -> builder::ProjectInstancesGet;
    ///Create an instance in a project
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///
    ///```ignore
    /// let response = client.project_instances_post()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_instances_post(&self) -> builder::ProjectInstancesPost;
    ///Get an instance in a project
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}` ```ignore
    /// let response = client.project_instances_get_instance()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_instances_get_instance(&self) -> builder::ProjectInstancesGetInstance;
    ///Delete an instance from a project
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}` ```ignore
    /// let response = client.project_instances_delete_instance()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_instances_delete_instance(&self) -> builder::ProjectInstancesDeleteInstance;
    ///List disks attached to this instance
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.instance_disks_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disks_get(&self) -> builder::InstanceDisksGet;
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks/attach` ```ignore
    /// let response = client.instance_disks_attach()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disks_attach(&self) -> builder::InstanceDisksAttach;
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks/detach` ```ignore
    /// let response = client.instance_disks_detach()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disks_detach(&self) -> builder::InstanceDisksDetach;
    ///Migrate an instance to a different propolis-server, possibly on a
    /// different sled
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/migrate` ```ignore
    /// let response = client.project_instances_migrate_instance()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_instances_migrate_instance(&self) -> builder::ProjectInstancesMigrateInstance;
    ///List network interfaces attached to this instance
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.instance_network_interfaces_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interfaces_get(&self) -> builder::InstanceNetworkInterfacesGet;
    ///Create a network interface for an instance
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces` ```ignore
    /// let response = client.instance_network_interfaces_post()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interfaces_post(&self) -> builder::InstanceNetworkInterfacesPost;
    ///Get an interface attached to an instance
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces/{interface_name}` ```ignore
    /// let response = client.instance_network_interfaces_get_interface()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .interface_name(interface_name)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interfaces_get_interface(
        &self,
    ) -> builder::InstanceNetworkInterfacesGetInterface;
    ///Detach a network interface from an instance
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces/{interface_name}` ```ignore
    /// let response = client.instance_network_interfaces_delete_interface()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .interface_name(interface_name)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interfaces_delete_interface(
        &self,
    ) -> builder::InstanceNetworkInterfacesDeleteInterface;
    ///Reboot an instance
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/reboot` ```ignore
    /// let response = client.project_instances_instance_reboot()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_instances_instance_reboot(&self) -> builder::ProjectInstancesInstanceReboot;
    ///Boot an instance
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/start` ```ignore
    /// let response = client.project_instances_instance_start()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_instances_instance_start(&self) -> builder::ProjectInstancesInstanceStart;
    ///Halt an instance
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/stop` ```ignore
    /// let response = client.project_instances_instance_stop()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .instance_name(instance_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_instances_instance_stop(&self) -> builder::ProjectInstancesInstanceStop;
}

impl ClientInstancesExt for Client {
    fn project_instances_get(&self) -> builder::ProjectInstancesGet {
        builder::ProjectInstancesGet::new(self)
    }

    fn project_instances_post(&self) -> builder::ProjectInstancesPost {
        builder::ProjectInstancesPost::new(self)
    }

    fn project_instances_get_instance(&self) -> builder::ProjectInstancesGetInstance {
        builder::ProjectInstancesGetInstance::new(self)
    }

    fn project_instances_delete_instance(&self) -> builder::ProjectInstancesDeleteInstance {
        builder::ProjectInstancesDeleteInstance::new(self)
    }

    fn instance_disks_get(&self) -> builder::InstanceDisksGet {
        builder::InstanceDisksGet::new(self)
    }

    fn instance_disks_attach(&self) -> builder::InstanceDisksAttach {
        builder::InstanceDisksAttach::new(self)
    }

    fn instance_disks_detach(&self) -> builder::InstanceDisksDetach {
        builder::InstanceDisksDetach::new(self)
    }

    fn project_instances_migrate_instance(&self) -> builder::ProjectInstancesMigrateInstance {
        builder::ProjectInstancesMigrateInstance::new(self)
    }

    fn instance_network_interfaces_get(&self) -> builder::InstanceNetworkInterfacesGet {
        builder::InstanceNetworkInterfacesGet::new(self)
    }

    fn instance_network_interfaces_post(&self) -> builder::InstanceNetworkInterfacesPost {
        builder::InstanceNetworkInterfacesPost::new(self)
    }

    fn instance_network_interfaces_get_interface(
        &self,
    ) -> builder::InstanceNetworkInterfacesGetInterface {
        builder::InstanceNetworkInterfacesGetInterface::new(self)
    }

    fn instance_network_interfaces_delete_interface(
        &self,
    ) -> builder::InstanceNetworkInterfacesDeleteInterface {
        builder::InstanceNetworkInterfacesDeleteInterface::new(self)
    }

    fn project_instances_instance_reboot(&self) -> builder::ProjectInstancesInstanceReboot {
        builder::ProjectInstancesInstanceReboot::new(self)
    }

    fn project_instances_instance_start(&self) -> builder::ProjectInstancesInstanceStart {
        builder::ProjectInstancesInstanceStart::new(self)
    }

    fn project_instances_instance_stop(&self) -> builder::ProjectInstancesInstanceStop {
        builder::ProjectInstancesInstanceStop::new(self)
    }
}

pub trait ClientMetricsExt {
    ///List all timeseries schema
    ///
    ///Sends a `GET` request to `/timeseries/schema`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    ///
    ///```ignore
    /// let response = client.timeseries_schema_get()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn timeseries_schema_get(&self) -> builder::TimeseriesSchemaGet;
}

impl ClientMetricsExt for Client {
    fn timeseries_schema_get(&self) -> builder::TimeseriesSchemaGet {
        builder::TimeseriesSchemaGet::new(self)
    }
}

pub trait ClientOrganizationsExt {
    ///List all organizations
    ///
    ///Sends a `GET` request to `/organizations`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.organizations_get()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn organizations_get(&self) -> builder::OrganizationsGet;
    ///Create a new organization
    ///
    ///Sends a `POST` request to `/organizations`
    ///```ignore
    /// let response = client.organizations_post()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organizations_post(&self) -> builder::OrganizationsPost;
    ///Fetch a specific organization
    ///
    ///Sends a `GET` request to `/organizations/{organization_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    ///
    ///```ignore
    /// let response = client.organizations_get_organization()
    ///    .organization_name(organization_name)
    ///    .send()
    ///    .await;
    /// ```
    fn organizations_get_organization(&self) -> builder::OrganizationsGetOrganization;
    ///Update a specific organization
    ///
    ///Sends a `PUT` request to `/organizations/{organization_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    ///
    ///```ignore
    /// let response = client.organizations_put_organization()
    ///    .organization_name(organization_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organizations_put_organization(&self) -> builder::OrganizationsPutOrganization;
    ///Delete a specific organization
    ///
    ///Sends a `DELETE` request to `/organizations/{organization_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    ///
    ///```ignore
    /// let response = client.organizations_delete_organization()
    ///    .organization_name(organization_name)
    ///    .send()
    ///    .await;
    /// ```
    fn organizations_delete_organization(&self) -> builder::OrganizationsDeleteOrganization;
    ///Fetch the IAM policy for this Organization
    ///
    ///Sends a `GET` request to `/organizations/{organization_name}/policy`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    ///
    ///```ignore
    /// let response = client.organization_get_policy()
    ///    .organization_name(organization_name)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_get_policy(&self) -> builder::OrganizationGetPolicy;
    ///Update the IAM policy for this Organization
    ///
    ///Sends a `PUT` request to `/organizations/{organization_name}/policy`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    ///
    ///```ignore
    /// let response = client.organization_put_policy()
    ///    .organization_name(organization_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_put_policy(&self) -> builder::OrganizationPutPolicy;
}

impl ClientOrganizationsExt for Client {
    fn organizations_get(&self) -> builder::OrganizationsGet {
        builder::OrganizationsGet::new(self)
    }

    fn organizations_post(&self) -> builder::OrganizationsPost {
        builder::OrganizationsPost::new(self)
    }

    fn organizations_get_organization(&self) -> builder::OrganizationsGetOrganization {
        builder::OrganizationsGetOrganization::new(self)
    }

    fn organizations_put_organization(&self) -> builder::OrganizationsPutOrganization {
        builder::OrganizationsPutOrganization::new(self)
    }

    fn organizations_delete_organization(&self) -> builder::OrganizationsDeleteOrganization {
        builder::OrganizationsDeleteOrganization::new(self)
    }

    fn organization_get_policy(&self) -> builder::OrganizationGetPolicy {
        builder::OrganizationGetPolicy::new(self)
    }

    fn organization_put_policy(&self) -> builder::OrganizationPutPolicy {
        builder::OrganizationPutPolicy::new(self)
    }
}

pub trait ClientPolicyExt {
    ///Fetch the top-level IAM policy
    ///
    ///Sends a `GET` request to `/policy`
    ///```ignore
    /// let response = client.policy_get()
    ///    .send()
    ///    .await;
    /// ```
    fn policy_get(&self) -> builder::PolicyGet;
    ///Update the top-level IAM policy
    ///
    ///Sends a `PUT` request to `/policy`
    ///```ignore
    /// let response = client.policy_put()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn policy_put(&self) -> builder::PolicyPut;
}

impl ClientPolicyExt for Client {
    fn policy_get(&self) -> builder::PolicyGet {
        builder::PolicyGet::new(self)
    }

    fn policy_put(&self) -> builder::PolicyPut {
        builder::PolicyPut::new(self)
    }
}

pub trait ClientProjectsExt {
    ///List all projects
    ///
    ///Sends a `GET` request to `/organizations/{organization_name}/projects`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.organization_projects_get()
    ///    .organization_name(organization_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_projects_get(&self) -> builder::OrganizationProjectsGet;
    ///Create a new project
    ///
    ///Sends a `POST` request to `/organizations/{organization_name}/projects`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    ///
    ///```ignore
    /// let response = client.organization_projects_post()
    ///    .organization_name(organization_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_projects_post(&self) -> builder::OrganizationProjectsPost;
    ///Fetch a specific project
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    ///
    ///```ignore
    /// let response = client.organization_projects_get_project()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_projects_get_project(&self) -> builder::OrganizationProjectsGetProject;
    ///Update a specific project
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///
    ///```ignore
    /// let response = client.organization_projects_put_project()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_projects_put_project(&self) -> builder::OrganizationProjectsPutProject;
    ///Delete a specific project
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    ///
    ///```ignore
    /// let response = client.organization_projects_delete_project()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_projects_delete_project(&self) -> builder::OrganizationProjectsDeleteProject;
    ///Fetch the IAM policy for this Project
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/policy`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    ///
    ///```ignore
    /// let response = client.organization_projects_get_project_policy()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_projects_get_project_policy(
        &self,
    ) -> builder::OrganizationProjectsGetProjectPolicy;
    ///Update the IAM policy for this Project
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/policy`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///
    ///```ignore
    /// let response = client.organization_projects_put_project_policy()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn organization_projects_put_project_policy(
        &self,
    ) -> builder::OrganizationProjectsPutProjectPolicy;
}

impl ClientProjectsExt for Client {
    fn organization_projects_get(&self) -> builder::OrganizationProjectsGet {
        builder::OrganizationProjectsGet::new(self)
    }

    fn organization_projects_post(&self) -> builder::OrganizationProjectsPost {
        builder::OrganizationProjectsPost::new(self)
    }

    fn organization_projects_get_project(&self) -> builder::OrganizationProjectsGetProject {
        builder::OrganizationProjectsGetProject::new(self)
    }

    fn organization_projects_put_project(&self) -> builder::OrganizationProjectsPutProject {
        builder::OrganizationProjectsPutProject::new(self)
    }

    fn organization_projects_delete_project(&self) -> builder::OrganizationProjectsDeleteProject {
        builder::OrganizationProjectsDeleteProject::new(self)
    }

    fn organization_projects_get_project_policy(
        &self,
    ) -> builder::OrganizationProjectsGetProjectPolicy {
        builder::OrganizationProjectsGetProjectPolicy::new(self)
    }

    fn organization_projects_put_project_policy(
        &self,
    ) -> builder::OrganizationProjectsPutProjectPolicy {
        builder::OrganizationProjectsPutProjectPolicy::new(self)
    }
}

pub trait ClientRacksExt {
    ///List racks in the system
    ///
    ///Sends a `GET` request to `/hardware/racks`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.hardware_racks_get()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn hardware_racks_get(&self) -> builder::HardwareRacksGet;
    ///Fetch information about a particular rack
    ///
    ///Sends a `GET` request to `/hardware/racks/{rack_id}`
    ///
    ///Arguments:
    /// - `rack_id`: The rack's unique ID.
    ///
    ///```ignore
    /// let response = client.hardware_racks_get_rack()
    ///    .rack_id(rack_id)
    ///    .send()
    ///    .await;
    /// ```
    fn hardware_racks_get_rack(&self) -> builder::HardwareRacksGetRack;
}

impl ClientRacksExt for Client {
    fn hardware_racks_get(&self) -> builder::HardwareRacksGet {
        builder::HardwareRacksGet::new(self)
    }

    fn hardware_racks_get_rack(&self) -> builder::HardwareRacksGetRack {
        builder::HardwareRacksGetRack::new(self)
    }
}

pub trait ClientRolesExt {
    ///List the built-in roles
    ///
    ///Sends a `GET` request to `/roles`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    ///
    ///```ignore
    /// let response = client.roles_get()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn roles_get(&self) -> builder::RolesGet;
    ///Fetch a specific built-in role
    ///
    ///Sends a `GET` request to `/roles/{role_name}`
    ///
    ///Arguments:
    /// - `role_name`: The built-in role's unique name.
    ///
    ///```ignore
    /// let response = client.roles_get_role()
    ///    .role_name(role_name)
    ///    .send()
    ///    .await;
    /// ```
    fn roles_get_role(&self) -> builder::RolesGetRole;
}

impl ClientRolesExt for Client {
    fn roles_get(&self) -> builder::RolesGet {
        builder::RolesGet::new(self)
    }

    fn roles_get_role(&self) -> builder::RolesGetRole {
        builder::RolesGetRole::new(self)
    }
}

pub trait ClientRoutersExt {
    ///List VPC Custom and System Routers
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.vpc_routers_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_routers_get(&self) -> builder::VpcRoutersGet;
    ///Create a VPC Router
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers` ```ignore
    /// let response = client.vpc_routers_post()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_routers_post(&self) -> builder::VpcRoutersPost;
    ///Get a VPC Router
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}` ```ignore
    /// let response = client.vpc_routers_get_router()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_routers_get_router(&self) -> builder::VpcRoutersGetRouter;
    ///Update a VPC Router
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}` ```ignore
    /// let response = client.vpc_routers_put_router()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_routers_put_router(&self) -> builder::VpcRoutersPutRouter;
    ///Delete a router from its VPC
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}` ```ignore
    /// let response = client.vpc_routers_delete_router()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_routers_delete_router(&self) -> builder::VpcRoutersDeleteRouter;
}

impl ClientRoutersExt for Client {
    fn vpc_routers_get(&self) -> builder::VpcRoutersGet {
        builder::VpcRoutersGet::new(self)
    }

    fn vpc_routers_post(&self) -> builder::VpcRoutersPost {
        builder::VpcRoutersPost::new(self)
    }

    fn vpc_routers_get_router(&self) -> builder::VpcRoutersGetRouter {
        builder::VpcRoutersGetRouter::new(self)
    }

    fn vpc_routers_put_router(&self) -> builder::VpcRoutersPutRouter {
        builder::VpcRoutersPutRouter::new(self)
    }

    fn vpc_routers_delete_router(&self) -> builder::VpcRoutersDeleteRouter {
        builder::VpcRoutersDeleteRouter::new(self)
    }
}

pub trait ClientRoutesExt {
    ///List a Router's routes
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `router_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.routers_routes_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn routers_routes_get(&self) -> builder::RoutersRoutesGet;
    ///Create a VPC Router
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes` ```ignore
    /// let response = client.routers_routes_post()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn routers_routes_post(&self) -> builder::RoutersRoutesPost;
    ///Get a VPC Router route
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}` ```ignore
    /// let response = client.routers_routes_get_route()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .route_name(route_name)
    ///    .send()
    ///    .await;
    /// ```
    fn routers_routes_get_route(&self) -> builder::RoutersRoutesGetRoute;
    ///Update a Router route
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}` ```ignore
    /// let response = client.routers_routes_put_route()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .route_name(route_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn routers_routes_put_route(&self) -> builder::RoutersRoutesPutRoute;
    ///Delete a route from its router
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}` ```ignore
    /// let response = client.routers_routes_delete_route()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .router_name(router_name)
    ///    .route_name(route_name)
    ///    .send()
    ///    .await;
    /// ```
    fn routers_routes_delete_route(&self) -> builder::RoutersRoutesDeleteRoute;
}

impl ClientRoutesExt for Client {
    fn routers_routes_get(&self) -> builder::RoutersRoutesGet {
        builder::RoutersRoutesGet::new(self)
    }

    fn routers_routes_post(&self) -> builder::RoutersRoutesPost {
        builder::RoutersRoutesPost::new(self)
    }

    fn routers_routes_get_route(&self) -> builder::RoutersRoutesGetRoute {
        builder::RoutersRoutesGetRoute::new(self)
    }

    fn routers_routes_put_route(&self) -> builder::RoutersRoutesPutRoute {
        builder::RoutersRoutesPutRoute::new(self)
    }

    fn routers_routes_delete_route(&self) -> builder::RoutersRoutesDeleteRoute {
        builder::RoutersRoutesDeleteRoute::new(self)
    }
}

pub trait ClientSagasExt {
    ///List all sagas (for debugging)
    ///
    ///Sends a `GET` request to `/sagas`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.sagas_get()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn sagas_get(&self) -> builder::SagasGet;
    ///Fetch information about a single saga (for debugging)
    ///
    ///Sends a `GET` request to `/sagas/{saga_id}`
    ///```ignore
    /// let response = client.sagas_get_saga()
    ///    .saga_id(saga_id)
    ///    .send()
    ///    .await;
    /// ```
    fn sagas_get_saga(&self) -> builder::SagasGetSaga;
}

impl ClientSagasExt for Client {
    fn sagas_get(&self) -> builder::SagasGet {
        builder::SagasGet::new(self)
    }

    fn sagas_get_saga(&self) -> builder::SagasGetSaga {
        builder::SagasGetSaga::new(self)
    }
}

pub trait ClientSilosExt {
    ///Sends a `GET` request to `/silos`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.silos_get()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn silos_get(&self) -> builder::SilosGet;
    ///Create a new silo
    ///
    ///Sends a `POST` request to `/silos`
    ///```ignore
    /// let response = client.silos_post()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn silos_post(&self) -> builder::SilosPost;
    ///Fetch a specific silo
    ///
    ///Sends a `GET` request to `/silos/{silo_name}`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    ///
    ///```ignore
    /// let response = client.silos_get_silo()
    ///    .silo_name(silo_name)
    ///    .send()
    ///    .await;
    /// ```
    fn silos_get_silo(&self) -> builder::SilosGetSilo;
    ///Delete a specific silo
    ///
    ///Sends a `DELETE` request to `/silos/{silo_name}`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    ///
    ///```ignore
    /// let response = client.silos_delete_silo()
    ///    .silo_name(silo_name)
    ///    .send()
    ///    .await;
    /// ```
    fn silos_delete_silo(&self) -> builder::SilosDeleteSilo;
    ///Fetch the IAM policy for this Silo
    ///
    ///Sends a `GET` request to `/silos/{silo_name}/policy`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    ///
    ///```ignore
    /// let response = client.silos_get_silo_policy()
    ///    .silo_name(silo_name)
    ///    .send()
    ///    .await;
    /// ```
    fn silos_get_silo_policy(&self) -> builder::SilosGetSiloPolicy;
    ///Update the IAM policy for this Silo
    ///
    ///Sends a `PUT` request to `/silos/{silo_name}/policy`
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `body`
    ///
    ///```ignore
    /// let response = client.silos_put_silo_policy()
    ///    .silo_name(silo_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn silos_put_silo_policy(&self) -> builder::SilosPutSiloPolicy;
}

impl ClientSilosExt for Client {
    fn silos_get(&self) -> builder::SilosGet {
        builder::SilosGet::new(self)
    }

    fn silos_post(&self) -> builder::SilosPost {
        builder::SilosPost::new(self)
    }

    fn silos_get_silo(&self) -> builder::SilosGetSilo {
        builder::SilosGetSilo::new(self)
    }

    fn silos_delete_silo(&self) -> builder::SilosDeleteSilo {
        builder::SilosDeleteSilo::new(self)
    }

    fn silos_get_silo_policy(&self) -> builder::SilosGetSiloPolicy {
        builder::SilosGetSiloPolicy::new(self)
    }

    fn silos_put_silo_policy(&self) -> builder::SilosPutSiloPolicy {
        builder::SilosPutSiloPolicy::new(self)
    }
}

pub trait ClientSledsExt {
    ///List sleds in the system
    ///
    ///Sends a `GET` request to `/hardware/sleds`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.hardware_sleds_get()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn hardware_sleds_get(&self) -> builder::HardwareSledsGet;
    ///Fetch information about a sled in the system
    ///
    ///Sends a `GET` request to `/hardware/sleds/{sled_id}`
    ///
    ///Arguments:
    /// - `sled_id`: The sled's unique ID.
    ///
    ///```ignore
    /// let response = client.hardware_sleds_get_sled()
    ///    .sled_id(sled_id)
    ///    .send()
    ///    .await;
    /// ```
    fn hardware_sleds_get_sled(&self) -> builder::HardwareSledsGetSled;
}

impl ClientSledsExt for Client {
    fn hardware_sleds_get(&self) -> builder::HardwareSledsGet {
        builder::HardwareSledsGet::new(self)
    }

    fn hardware_sleds_get_sled(&self) -> builder::HardwareSledsGetSled {
        builder::HardwareSledsGetSled::new(self)
    }
}

pub trait ClientSnapshotsExt {
    ///List snapshots in a project
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/snapshots`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.project_snapshots_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn project_snapshots_get(&self) -> builder::ProjectSnapshotsGet;
    ///Create a snapshot of a disk
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/snapshots`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///
    ///```ignore
    /// let response = client.project_snapshots_post()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_snapshots_post(&self) -> builder::ProjectSnapshotsPost;
    ///Get a snapshot in a project
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/snapshots/
    /// {snapshot_name}` ```ignore
    /// let response = client.project_snapshots_get_snapshot()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .snapshot_name(snapshot_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_snapshots_get_snapshot(&self) -> builder::ProjectSnapshotsGetSnapshot;
    ///Delete a snapshot from a project
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/snapshots/
    /// {snapshot_name}` ```ignore
    /// let response = client.project_snapshots_delete_snapshot()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .snapshot_name(snapshot_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_snapshots_delete_snapshot(&self) -> builder::ProjectSnapshotsDeleteSnapshot;
}

impl ClientSnapshotsExt for Client {
    fn project_snapshots_get(&self) -> builder::ProjectSnapshotsGet {
        builder::ProjectSnapshotsGet::new(self)
    }

    fn project_snapshots_post(&self) -> builder::ProjectSnapshotsPost {
        builder::ProjectSnapshotsPost::new(self)
    }

    fn project_snapshots_get_snapshot(&self) -> builder::ProjectSnapshotsGetSnapshot {
        builder::ProjectSnapshotsGetSnapshot::new(self)
    }

    fn project_snapshots_delete_snapshot(&self) -> builder::ProjectSnapshotsDeleteSnapshot {
        builder::ProjectSnapshotsDeleteSnapshot::new(self)
    }
}

pub trait ClientSshkeysExt {
    ///List the current user's SSH public keys
    ///
    ///Sends a `GET` request to `/session/me/sshkeys`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.sshkeys_get()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn sshkeys_get(&self) -> builder::SshkeysGet;
    ///Create a new SSH public key for the current user
    ///
    ///Sends a `POST` request to `/session/me/sshkeys`
    ///```ignore
    /// let response = client.sshkeys_post()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn sshkeys_post(&self) -> builder::SshkeysPost;
    ///Get (by name) an SSH public key belonging to the current user
    ///
    ///Sends a `GET` request to `/session/me/sshkeys/{ssh_key_name}`
    ///```ignore
    /// let response = client.sshkeys_get_key()
    ///    .ssh_key_name(ssh_key_name)
    ///    .send()
    ///    .await;
    /// ```
    fn sshkeys_get_key(&self) -> builder::SshkeysGetKey;
    ///Delete (by name) an SSH public key belonging to the current user
    ///
    ///Sends a `DELETE` request to `/session/me/sshkeys/{ssh_key_name}`
    ///```ignore
    /// let response = client.sshkeys_delete_key()
    ///    .ssh_key_name(ssh_key_name)
    ///    .send()
    ///    .await;
    /// ```
    fn sshkeys_delete_key(&self) -> builder::SshkeysDeleteKey;
}

impl ClientSshkeysExt for Client {
    fn sshkeys_get(&self) -> builder::SshkeysGet {
        builder::SshkeysGet::new(self)
    }

    fn sshkeys_post(&self) -> builder::SshkeysPost {
        builder::SshkeysPost::new(self)
    }

    fn sshkeys_get_key(&self) -> builder::SshkeysGetKey {
        builder::SshkeysGetKey::new(self)
    }

    fn sshkeys_delete_key(&self) -> builder::SshkeysDeleteKey {
        builder::SshkeysDeleteKey::new(self)
    }
}

pub trait ClientSubnetsExt {
    ///List subnets in a VPC
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.vpc_subnets_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnets_get(&self) -> builder::VpcSubnetsGet;
    ///Create a subnet in a VPC
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets` ```ignore
    /// let response = client.vpc_subnets_post()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnets_post(&self) -> builder::VpcSubnetsPost;
    ///Get subnet in a VPC
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}` ```ignore
    /// let response = client.vpc_subnets_get_subnet()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .subnet_name(subnet_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnets_get_subnet(&self) -> builder::VpcSubnetsGetSubnet;
    ///Update a VPC Subnet
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}` ```ignore
    /// let response = client.vpc_subnets_put_subnet()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .subnet_name(subnet_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnets_put_subnet(&self) -> builder::VpcSubnetsPutSubnet;
    ///Delete a subnet from a VPC
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}` ```ignore
    /// let response = client.vpc_subnets_delete_subnet()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .subnet_name(subnet_name)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnets_delete_subnet(&self) -> builder::VpcSubnetsDeleteSubnet;
    ///List network interfaces in a VPC subnet
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}/network-interfaces`
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `subnet_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.subnet_network_interfaces_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .subnet_name(subnet_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn subnet_network_interfaces_get(&self) -> builder::SubnetNetworkInterfacesGet;
}

impl ClientSubnetsExt for Client {
    fn vpc_subnets_get(&self) -> builder::VpcSubnetsGet {
        builder::VpcSubnetsGet::new(self)
    }

    fn vpc_subnets_post(&self) -> builder::VpcSubnetsPost {
        builder::VpcSubnetsPost::new(self)
    }

    fn vpc_subnets_get_subnet(&self) -> builder::VpcSubnetsGetSubnet {
        builder::VpcSubnetsGetSubnet::new(self)
    }

    fn vpc_subnets_put_subnet(&self) -> builder::VpcSubnetsPutSubnet {
        builder::VpcSubnetsPutSubnet::new(self)
    }

    fn vpc_subnets_delete_subnet(&self) -> builder::VpcSubnetsDeleteSubnet {
        builder::VpcSubnetsDeleteSubnet::new(self)
    }

    fn subnet_network_interfaces_get(&self) -> builder::SubnetNetworkInterfacesGet {
        builder::SubnetNetworkInterfacesGet::new(self)
    }
}

pub trait ClientUpdatesExt {
    ///Refresh update metadata
    ///
    ///Sends a `POST` request to `/updates/refresh`
    ///```ignore
    /// let response = client.updates_refresh()
    ///    .send()
    ///    .await;
    /// ```
    fn updates_refresh(&self) -> builder::UpdatesRefresh;
}

impl ClientUpdatesExt for Client {
    fn updates_refresh(&self) -> builder::UpdatesRefresh {
        builder::UpdatesRefresh::new(self)
    }
}

pub trait ClientUsersExt {
    ///List the built-in system users
    ///
    ///Sends a `GET` request to `/users`
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.users_get()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn users_get(&self) -> builder::UsersGet;
    ///Fetch a specific built-in system user
    ///
    ///Sends a `GET` request to `/users/{user_name}`
    ///
    ///Arguments:
    /// - `user_name`: The built-in user's unique name.
    ///
    ///```ignore
    /// let response = client.users_get_user()
    ///    .user_name(user_name)
    ///    .send()
    ///    .await;
    /// ```
    fn users_get_user(&self) -> builder::UsersGetUser;
}

impl ClientUsersExt for Client {
    fn users_get(&self) -> builder::UsersGet {
        builder::UsersGet::new(self)
    }

    fn users_get_user(&self) -> builder::UsersGetUser {
        builder::UsersGetUser::new(self)
    }
}

pub trait ClientVpcsExt {
    ///List VPCs in a project
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retreive the
    ///   subsequent page
    /// - `sort_by`
    ///
    ///```ignore
    /// let response = client.project_vpcs_get()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn project_vpcs_get(&self) -> builder::ProjectVpcsGet;
    ///Create a VPC in a project
    ///
    ///Sends a `POST` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs`
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    ///
    ///```ignore
    /// let response = client.project_vpcs_post()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_vpcs_post(&self) -> builder::ProjectVpcsPost;
    ///Get a VPC in a project
    ///
    ///Sends a `GET` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}` ```ignore
    /// let response = client.project_vpcs_get_vpc()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_vpcs_get_vpc(&self) -> builder::ProjectVpcsGetVpc;
    ///Update a VPC
    ///
    ///Sends a `PUT` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}` ```ignore
    /// let response = client.project_vpcs_put_vpc()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_vpcs_put_vpc(&self) -> builder::ProjectVpcsPutVpc;
    ///Delete a vpc from a project
    ///
    ///Sends a `DELETE` request to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}` ```ignore
    /// let response = client.project_vpcs_delete_vpc()
    ///    .organization_name(organization_name)
    ///    .project_name(project_name)
    ///    .vpc_name(vpc_name)
    ///    .send()
    ///    .await;
    /// ```
    fn project_vpcs_delete_vpc(&self) -> builder::ProjectVpcsDeleteVpc;
}

impl ClientVpcsExt for Client {
    fn project_vpcs_get(&self) -> builder::ProjectVpcsGet {
        builder::ProjectVpcsGet::new(self)
    }

    fn project_vpcs_post(&self) -> builder::ProjectVpcsPost {
        builder::ProjectVpcsPost::new(self)
    }

    fn project_vpcs_get_vpc(&self) -> builder::ProjectVpcsGetVpc {
        builder::ProjectVpcsGetVpc::new(self)
    }

    fn project_vpcs_put_vpc(&self) -> builder::ProjectVpcsPutVpc {
        builder::ProjectVpcsPutVpc::new(self)
    }

    fn project_vpcs_delete_vpc(&self) -> builder::ProjectVpcsDeleteVpc {
        builder::ProjectVpcsDeleteVpc::new(self)
    }
}

pub mod builder {
    #[allow(unused_imports)]
    use super::encode_path;
    use super::types;
    #[allow(unused_imports)]
    use super::{ByteStream, Error, ResponseValue};
    ///Builder for [`ClientRacksExt::hardware_racks_get`]
    ///
    ///[`ClientRacksExt::hardware_racks_get`]: super::ClientRacksExt::hardware_racks_get
    #[derive(Clone)]
    pub struct HardwareRacksGet<'a> {
        client: &'a super::Client,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::IdSortMode>,
    }

    impl<'a> HardwareRacksGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::IdSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to `/hardware/racks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RackResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let url = format!("{}/hardware/racks", client.baseurl,);
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/hardware/racks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Rack, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientRacksExt::hardware_racks_get_rack`]
    ///
    ///[`ClientRacksExt::hardware_racks_get_rack`]: super::ClientRacksExt::hardware_racks_get_rack
    #[derive(Clone)]
    pub struct HardwareRacksGetRack<'a> {
        client: &'a super::Client,
        rack_id: Option<uuid::Uuid>,
    }

    impl<'a> HardwareRacksGetRack<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                rack_id: None,
            }
        }

        pub fn rack_id(mut self, value: uuid::Uuid) -> Self {
            self.rack_id = Some(value);
            self
        }

        ///Sends a `GET` request to `/hardware/racks/{rack_id}`
        pub async fn send(self) -> Result<ResponseValue<types::Rack>, Error<types::Error>> {
            let Self { client, rack_id } = self;
            let (rack_id,) = match (rack_id,) {
                (Some(rack_id),) => (rack_id,),
                (rack_id,) => {
                    let mut missing = Vec::new();
                    if rack_id.is_none() {
                        missing.push(stringify!(rack_id));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/hardware/racks/{}",
                client.baseurl,
                encode_path(&rack_id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSledsExt::hardware_sleds_get`]
    ///
    ///[`ClientSledsExt::hardware_sleds_get`]: super::ClientSledsExt::hardware_sleds_get
    #[derive(Clone)]
    pub struct HardwareSledsGet<'a> {
        client: &'a super::Client,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::IdSortMode>,
    }

    impl<'a> HardwareSledsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::IdSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to `/hardware/sleds`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SledResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let url = format!("{}/hardware/sleds", client.baseurl,);
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/hardware/sleds`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Sled, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientSledsExt::hardware_sleds_get_sled`]
    ///
    ///[`ClientSledsExt::hardware_sleds_get_sled`]: super::ClientSledsExt::hardware_sleds_get_sled
    #[derive(Clone)]
    pub struct HardwareSledsGetSled<'a> {
        client: &'a super::Client,
        sled_id: Option<uuid::Uuid>,
    }

    impl<'a> HardwareSledsGetSled<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                sled_id: None,
            }
        }

        pub fn sled_id(mut self, value: uuid::Uuid) -> Self {
            self.sled_id = Some(value);
            self
        }

        ///Sends a `GET` request to `/hardware/sleds/{sled_id}`
        pub async fn send(self) -> Result<ResponseValue<types::Sled>, Error<types::Error>> {
            let Self { client, sled_id } = self;
            let (sled_id,) = match (sled_id,) {
                (Some(sled_id),) => (sled_id,),
                (sled_id,) => {
                    let mut missing = Vec::new();
                    if sled_id.is_none() {
                        missing.push(stringify!(sled_id));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/hardware/sleds/{}",
                client.baseurl,
                encode_path(&sled_id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientImagesGlobalExt::images_get`]
    ///
    ///[`ClientImagesGlobalExt::images_get`]: super::ClientImagesGlobalExt::images_get
    #[derive(Clone)]
    pub struct ImagesGet<'a> {
        client: &'a super::Client,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> ImagesGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to `/images`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GlobalImageResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let url = format!("{}/images", client.baseurl,);
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/images`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::GlobalImage, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientImagesGlobalExt::images_post`]
    ///
    ///[`ClientImagesGlobalExt::images_post`]: super::ClientImagesGlobalExt::images_post
    #[derive(Clone)]
    pub struct ImagesPost<'a> {
        client: &'a super::Client,
        body: Option<types::ImageCreate>,
    }

    impl<'a> ImagesPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client, body: None }
        }

        pub fn body(mut self, value: types::ImageCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to `/images`
        pub async fn send(self) -> Result<ResponseValue<types::GlobalImage>, Error<types::Error>> {
            let Self { client, body } = self;
            let (body,) = match (body,) {
                (Some(body),) => (body,),
                (body,) => {
                    let mut missing = Vec::new();
                    if body.is_none() {
                        missing.push(stringify!(body));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!("{}/images", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientImagesGlobalExt::images_get_image`]
    ///
    ///[`ClientImagesGlobalExt::images_get_image`]: super::ClientImagesGlobalExt::images_get_image
    #[derive(Clone)]
    pub struct ImagesGetImage<'a> {
        client: &'a super::Client,
        image_name: Option<types::Name>,
    }

    impl<'a> ImagesGetImage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                image_name: None,
            }
        }

        pub fn image_name(mut self, value: types::Name) -> Self {
            self.image_name = Some(value);
            self
        }

        ///Sends a `GET` request to `/images/{image_name}`
        pub async fn send(self) -> Result<ResponseValue<types::GlobalImage>, Error<types::Error>> {
            let Self { client, image_name } = self;
            let (image_name,) = match (image_name,) {
                (Some(image_name),) => (image_name,),
                (image_name,) => {
                    let mut missing = Vec::new();
                    if image_name.is_none() {
                        missing.push(stringify!(image_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/images/{}",
                client.baseurl,
                encode_path(&image_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientImagesGlobalExt::images_delete_image`]
    ///
    ///[`ClientImagesGlobalExt::images_delete_image`]: super::ClientImagesGlobalExt::images_delete_image
    #[derive(Clone)]
    pub struct ImagesDeleteImage<'a> {
        client: &'a super::Client,
        image_name: Option<types::Name>,
    }

    impl<'a> ImagesDeleteImage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                image_name: None,
            }
        }

        pub fn image_name(mut self, value: types::Name) -> Self {
            self.image_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to `/images/{image_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, image_name } = self;
            let (image_name,) = match (image_name,) {
                (Some(image_name),) => (image_name,),
                (image_name,) => {
                    let mut missing = Vec::new();
                    if image_name.is_none() {
                        missing.push(stringify!(image_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/images/{}",
                client.baseurl,
                encode_path(&image_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientHiddenExt::spoof_login`]
    ///
    ///[`ClientHiddenExt::spoof_login`]: super::ClientHiddenExt::spoof_login
    #[derive(Clone)]
    pub struct SpoofLogin<'a> {
        client: &'a super::Client,
        body: Option<types::LoginParams>,
    }

    impl<'a> SpoofLogin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client, body: None }
        }

        pub fn body(mut self, value: types::LoginParams) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to `/login`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self { client, body } = self;
            let (body,) = match (body,) {
                (Some(body),) => (body,),
                (body,) => {
                    let mut missing = Vec::new();
                    if body.is_none() {
                        missing.push(stringify!(body));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!("{}/login", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    ///Builder for [`ClientHiddenExt::logout`]
    ///
    ///[`ClientHiddenExt::logout`]: super::ClientHiddenExt::logout
    #[derive(Clone)]
    pub struct Logout<'a> {
        client: &'a super::Client,
    }

    impl<'a> Logout<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `POST` request to `/logout`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self { client } = self;
            let url = format!("{}/logout", client.baseurl,);
            let request = client.client.post(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organizations_get`]
    ///
    ///[`ClientOrganizationsExt::organizations_get`]: super::ClientOrganizationsExt::organizations_get
    #[derive(Clone)]
    pub struct OrganizationsGet<'a> {
        client: &'a super::Client,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameOrIdSortMode>,
    }

    impl<'a> OrganizationsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameOrIdSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to `/organizations`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let url = format!("{}/organizations", client.baseurl,);
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/organizations`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Organization, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientOrganizationsExt::organizations_post`]
    ///
    ///[`ClientOrganizationsExt::organizations_post`]: super::ClientOrganizationsExt::organizations_post
    #[derive(Clone)]
    pub struct OrganizationsPost<'a> {
        client: &'a super::Client,
        body: Option<types::OrganizationCreate>,
    }

    impl<'a> OrganizationsPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client, body: None }
        }

        pub fn body(mut self, value: types::OrganizationCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to `/organizations`
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self { client, body } = self;
            let (body,) = match (body,) {
                (Some(body),) => (body,),
                (body,) => {
                    let mut missing = Vec::new();
                    if body.is_none() {
                        missing.push(stringify!(body));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!("{}/organizations", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organizations_get_organization`]
    ///
    ///[`ClientOrganizationsExt::organizations_get_organization`]: super::ClientOrganizationsExt::organizations_get_organization
    #[derive(Clone)]
    pub struct OrganizationsGetOrganization<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
    }

    impl<'a> OrganizationsGetOrganization<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        ///Sends a `GET` request to `/organizations/{organization_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
            } = self;
            let (organization_name,) = match (organization_name,) {
                (Some(organization_name),) => (organization_name,),
                (organization_name,) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organizations_put_organization`]
    ///
    ///[`ClientOrganizationsExt::organizations_put_organization`]: super::ClientOrganizationsExt::organizations_put_organization
    #[derive(Clone)]
    pub struct OrganizationsPutOrganization<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        body: Option<types::OrganizationUpdate>,
    }

    impl<'a> OrganizationsPutOrganization<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::OrganizationUpdate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `PUT` request to `/organizations/{organization_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                body,
            } = self;
            let (organization_name, body) = match (organization_name, body) {
                (Some(organization_name), Some(body)) => (organization_name, body),
                (organization_name, body) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if body.is_none() {
                        missing.push(stringify!(body));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for
    /// [`ClientOrganizationsExt::organizations_delete_organization`]
    ///
    ///[`ClientOrganizationsExt::organizations_delete_organization`]: super::ClientOrganizationsExt::organizations_delete_organization
    #[derive(Clone)]
    pub struct OrganizationsDeleteOrganization<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
    }

    impl<'a> OrganizationsDeleteOrganization<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to `/organizations/{organization_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
            } = self;
            let (organization_name,) = match (organization_name,) {
                (Some(organization_name),) => (organization_name,),
                (organization_name,) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_get_policy`]
    ///
    ///[`ClientOrganizationsExt::organization_get_policy`]: super::ClientOrganizationsExt::organization_get_policy
    #[derive(Clone)]
    pub struct OrganizationGetPolicy<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
    }

    impl<'a> OrganizationGetPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        ///Sends a `GET` request to `/organizations/{organization_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationRolesPolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
            } = self;
            let (organization_name,) = match (organization_name,) {
                (Some(organization_name),) => (organization_name,),
                (organization_name,) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientOrganizationsExt::organization_put_policy`]
    ///
    ///[`ClientOrganizationsExt::organization_put_policy`]: super::ClientOrganizationsExt::organization_put_policy
    #[derive(Clone)]
    pub struct OrganizationPutPolicy<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        body: Option<types::OrganizationRolesPolicy>,
    }

    impl<'a> OrganizationPutPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::OrganizationRolesPolicy) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `PUT` request to `/organizations/{organization_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationRolesPolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                body,
            } = self;
            let (organization_name, body) = match (organization_name, body) {
                (Some(organization_name), Some(body)) => (organization_name, body),
                (organization_name, body) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if body.is_none() {
                        missing.push(stringify!(body));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::organization_projects_get`]
    ///
    ///[`ClientProjectsExt::organization_projects_get`]: super::ClientProjectsExt::organization_projects_get
    #[derive(Clone)]
    pub struct OrganizationProjectsGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameOrIdSortMode>,
    }

    impl<'a> OrganizationProjectsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameOrIdSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name,) = match (organization_name,) {
                (Some(organization_name),) => (organization_name,),
                (organization_name,) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Project, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientProjectsExt::organization_projects_post`]
    ///
    ///[`ClientProjectsExt::organization_projects_post`]: super::ClientProjectsExt::organization_projects_post
    #[derive(Clone)]
    pub struct OrganizationProjectsPost<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        body: Option<types::ProjectCreate>,
    }

    impl<'a> OrganizationProjectsPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::ProjectCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                body,
            } = self;
            let (organization_name, body) = match (organization_name, body) {
                (Some(organization_name), Some(body)) => (organization_name, body),
                (organization_name, body) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if body.is_none() {
                        missing.push(stringify!(body));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::organization_projects_get_project`]
    ///
    ///[`ClientProjectsExt::organization_projects_get_project`]: super::ClientProjectsExt::organization_projects_get_project
    #[derive(Clone)]
    pub struct OrganizationProjectsGetProject<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
    }

    impl<'a> OrganizationProjectsGetProject<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
            } = self;
            let (organization_name, project_name) = match (organization_name, project_name) {
                (Some(organization_name), Some(project_name)) => (organization_name, project_name),
                (organization_name, project_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::organization_projects_put_project`]
    ///
    ///[`ClientProjectsExt::organization_projects_put_project`]: super::ClientProjectsExt::organization_projects_put_project
    #[derive(Clone)]
    pub struct OrganizationProjectsPutProject<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        body: Option<types::ProjectUpdate>,
    }

    impl<'a> OrganizationProjectsPutProject<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::ProjectUpdate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let (organization_name, project_name, body) =
                match (organization_name, project_name, body) {
                    (Some(organization_name), Some(project_name), Some(body)) => {
                        (organization_name, project_name, body)
                    }
                    (organization_name, project_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientProjectsExt::organization_projects_delete_project`]
    ///
    ///[`ClientProjectsExt::organization_projects_delete_project`]: super::ClientProjectsExt::organization_projects_delete_project
    #[derive(Clone)]
    pub struct OrganizationProjectsDeleteProject<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
    }

    impl<'a> OrganizationProjectsDeleteProject<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
            } = self;
            let (organization_name, project_name) = match (organization_name, project_name) {
                (Some(organization_name), Some(project_name)) => (organization_name, project_name),
                (organization_name, project_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientDisksExt::project_disks_get`]
    ///
    ///[`ClientDisksExt::project_disks_get`]: super::ClientDisksExt::project_disks_get
    #[derive(Clone)]
    pub struct ProjectDisksGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> ProjectDisksGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name, project_name) = match (organization_name, project_name) {
                (Some(organization_name), Some(project_name)) => (organization_name, project_name),
                (organization_name, project_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}/disks",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientDisksExt::project_disks_post`]
    ///
    ///[`ClientDisksExt::project_disks_post`]: super::ClientDisksExt::project_disks_post
    #[derive(Clone)]
    pub struct ProjectDisksPost<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        body: Option<types::DiskCreate>,
    }

    impl<'a> ProjectDisksPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::DiskCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/disks`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let (organization_name, project_name, body) =
                match (organization_name, project_name, body) {
                    (Some(organization_name), Some(project_name), Some(body)) => {
                        (organization_name, project_name, body)
                    }
                    (organization_name, project_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/disks",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientDisksExt::project_disks_get_disk`]
    ///
    ///[`ClientDisksExt::project_disks_get_disk`]: super::ClientDisksExt::project_disks_get_disk
    #[derive(Clone)]
    pub struct ProjectDisksGetDisk<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        disk_name: Option<types::Name>,
    }

    impl<'a> ProjectDisksGetDisk<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                disk_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn disk_name(mut self, value: types::Name) -> Self {
            self.disk_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/disks/
        /// {disk_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                disk_name,
            } = self;
            let (organization_name, project_name, disk_name) =
                match (organization_name, project_name, disk_name) {
                    (Some(organization_name), Some(project_name), Some(disk_name)) => {
                        (organization_name, project_name, disk_name)
                    }
                    (organization_name, project_name, disk_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if disk_name.is_none() {
                            missing.push(stringify!(disk_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/disks/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&disk_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientDisksExt::project_disks_delete_disk`]
    ///
    ///[`ClientDisksExt::project_disks_delete_disk`]: super::ClientDisksExt::project_disks_delete_disk
    #[derive(Clone)]
    pub struct ProjectDisksDeleteDisk<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        disk_name: Option<types::Name>,
    }

    impl<'a> ProjectDisksDeleteDisk<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                disk_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn disk_name(mut self, value: types::Name) -> Self {
            self.disk_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/disks/
        /// {disk_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                disk_name,
            } = self;
            let (organization_name, project_name, disk_name) =
                match (organization_name, project_name, disk_name) {
                    (Some(organization_name), Some(project_name), Some(disk_name)) => {
                        (organization_name, project_name, disk_name)
                    }
                    (organization_name, project_name, disk_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if disk_name.is_none() {
                            missing.push(stringify!(disk_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/disks/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&disk_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientImagesExt::project_images_get`]
    ///
    ///[`ClientImagesExt::project_images_get`]: super::ClientImagesExt::project_images_get
    #[derive(Clone)]
    pub struct ProjectImagesGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> ProjectImagesGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/images`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ImageResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name, project_name) = match (organization_name, project_name) {
                (Some(organization_name), Some(project_name)) => (organization_name, project_name),
                (organization_name, project_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}/images",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/images`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Image, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientImagesExt::project_images_post`]
    ///
    ///[`ClientImagesExt::project_images_post`]: super::ClientImagesExt::project_images_post
    #[derive(Clone)]
    pub struct ProjectImagesPost<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        body: Option<types::ImageCreate>,
    }

    impl<'a> ProjectImagesPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::ImageCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/images`
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let (organization_name, project_name, body) =
                match (organization_name, project_name, body) {
                    (Some(organization_name), Some(project_name), Some(body)) => {
                        (organization_name, project_name, body)
                    }
                    (organization_name, project_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/images",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientImagesExt::project_images_get_image`]
    ///
    ///[`ClientImagesExt::project_images_get_image`]: super::ClientImagesExt::project_images_get_image
    #[derive(Clone)]
    pub struct ProjectImagesGetImage<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        image_name: Option<types::Name>,
    }

    impl<'a> ProjectImagesGetImage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                image_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn image_name(mut self, value: types::Name) -> Self {
            self.image_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/images/
        /// {image_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                image_name,
            } = self;
            let (organization_name, project_name, image_name) =
                match (organization_name, project_name, image_name) {
                    (Some(organization_name), Some(project_name), Some(image_name)) => {
                        (organization_name, project_name, image_name)
                    }
                    (organization_name, project_name, image_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if image_name.is_none() {
                            missing.push(stringify!(image_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/images/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&image_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientImagesExt::project_images_delete_image`]
    ///
    ///[`ClientImagesExt::project_images_delete_image`]: super::ClientImagesExt::project_images_delete_image
    #[derive(Clone)]
    pub struct ProjectImagesDeleteImage<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        image_name: Option<types::Name>,
    }

    impl<'a> ProjectImagesDeleteImage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                image_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn image_name(mut self, value: types::Name) -> Self {
            self.image_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/images/
        /// {image_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                image_name,
            } = self;
            let (organization_name, project_name, image_name) =
                match (organization_name, project_name, image_name) {
                    (Some(organization_name), Some(project_name), Some(image_name)) => {
                        (organization_name, project_name, image_name)
                    }
                    (organization_name, project_name, image_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if image_name.is_none() {
                            missing.push(stringify!(image_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/images/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&image_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::project_instances_get`]
    ///
    ///[`ClientInstancesExt::project_instances_get`]: super::ClientInstancesExt::project_instances_get
    #[derive(Clone)]
    pub struct ProjectInstancesGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> ProjectInstancesGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name, project_name) = match (organization_name, project_name) {
                (Some(organization_name), Some(project_name)) => (organization_name, project_name),
                (organization_name, project_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Instance, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientInstancesExt::project_instances_post`]
    ///
    ///[`ClientInstancesExt::project_instances_post`]: super::ClientInstancesExt::project_instances_post
    #[derive(Clone)]
    pub struct ProjectInstancesPost<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        body: Option<types::InstanceCreate>,
    }

    impl<'a> ProjectInstancesPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::InstanceCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let (organization_name, project_name, body) =
                match (organization_name, project_name, body) {
                    (Some(organization_name), Some(project_name), Some(body)) => {
                        (organization_name, project_name, body)
                    }
                    (organization_name, project_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::project_instances_get_instance`]
    ///
    ///[`ClientInstancesExt::project_instances_get_instance`]: super::ClientInstancesExt::project_instances_get_instance
    #[derive(Clone)]
    pub struct ProjectInstancesGetInstance<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
    }

    impl<'a> ProjectInstancesGetInstance<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let (organization_name, project_name, instance_name) =
                match (organization_name, project_name, instance_name) {
                    (Some(organization_name), Some(project_name), Some(instance_name)) => {
                        (organization_name, project_name, instance_name)
                    }
                    (organization_name, project_name, instance_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if instance_name.is_none() {
                            missing.push(stringify!(instance_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::project_instances_delete_instance`]
    ///
    ///[`ClientInstancesExt::project_instances_delete_instance`]: super::ClientInstancesExt::project_instances_delete_instance
    #[derive(Clone)]
    pub struct ProjectInstancesDeleteInstance<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
    }

    impl<'a> ProjectInstancesDeleteInstance<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let (organization_name, project_name, instance_name) =
                match (organization_name, project_name, instance_name) {
                    (Some(organization_name), Some(project_name), Some(instance_name)) => {
                        (organization_name, project_name, instance_name)
                    }
                    (organization_name, project_name, instance_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if instance_name.is_none() {
                            missing.push(stringify!(instance_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_disks_get`]
    ///
    ///[`ClientInstancesExt::instance_disks_get`]: super::ClientInstancesExt::instance_disks_get
    #[derive(Clone)]
    pub struct InstanceDisksGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> InstanceDisksGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name, project_name, instance_name) =
                match (organization_name, project_name, instance_name) {
                    (Some(organization_name), Some(project_name), Some(instance_name)) => {
                        (organization_name, project_name, instance_name)
                    }
                    (organization_name, project_name, instance_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if instance_name.is_none() {
                            missing.push(stringify!(instance_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/disks",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientInstancesExt::instance_disks_attach`]
    ///
    ///[`ClientInstancesExt::instance_disks_attach`]: super::ClientInstancesExt::instance_disks_attach
    #[derive(Clone)]
    pub struct InstanceDisksAttach<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
        body: Option<types::DiskIdentifier>,
    }

    impl<'a> InstanceDisksAttach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::DiskIdentifier) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/disks/attach`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let (organization_name, project_name, instance_name, body) =
                match (organization_name, project_name, instance_name, body) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(instance_name),
                        Some(body),
                    ) => (organization_name, project_name, instance_name, body),
                    (organization_name, project_name, instance_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if instance_name.is_none() {
                            missing.push(stringify!(instance_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/disks/attach",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_disks_detach`]
    ///
    ///[`ClientInstancesExt::instance_disks_detach`]: super::ClientInstancesExt::instance_disks_detach
    #[derive(Clone)]
    pub struct InstanceDisksDetach<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
        body: Option<types::DiskIdentifier>,
    }

    impl<'a> InstanceDisksDetach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::DiskIdentifier) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/disks/detach`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let (organization_name, project_name, instance_name, body) =
                match (organization_name, project_name, instance_name, body) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(instance_name),
                        Some(body),
                    ) => (organization_name, project_name, instance_name, body),
                    (organization_name, project_name, instance_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if instance_name.is_none() {
                            missing.push(stringify!(instance_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/disks/detach",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::project_instances_migrate_instance`]
    ///
    ///[`ClientInstancesExt::project_instances_migrate_instance`]: super::ClientInstancesExt::project_instances_migrate_instance
    #[derive(Clone)]
    pub struct ProjectInstancesMigrateInstance<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
        body: Option<types::InstanceMigrate>,
    }

    impl<'a> ProjectInstancesMigrateInstance<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::InstanceMigrate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/migrate`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let (organization_name, project_name, instance_name, body) =
                match (organization_name, project_name, instance_name, body) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(instance_name),
                        Some(body),
                    ) => (organization_name, project_name, instance_name, body),
                    (organization_name, project_name, instance_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if instance_name.is_none() {
                            missing.push(stringify!(instance_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/migrate",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::instance_network_interfaces_get`]
    ///
    ///[`ClientInstancesExt::instance_network_interfaces_get`]: super::ClientInstancesExt::instance_network_interfaces_get
    #[derive(Clone)]
    pub struct InstanceNetworkInterfacesGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> InstanceNetworkInterfacesGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/network-interfaces`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterfaceResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name, project_name, instance_name) =
                match (organization_name, project_name, instance_name) {
                    (Some(organization_name), Some(project_name), Some(instance_name)) => {
                        (organization_name, project_name, instance_name)
                    }
                    (organization_name, project_name, instance_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if instance_name.is_none() {
                            missing.push(stringify!(instance_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/network-interfaces`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::NetworkInterface, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientInstancesExt::instance_network_interfaces_post`]
    ///
    ///[`ClientInstancesExt::instance_network_interfaces_post`]: super::ClientInstancesExt::instance_network_interfaces_post
    #[derive(Clone)]
    pub struct InstanceNetworkInterfacesPost<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
        body: Option<types::NetworkInterfaceCreate>,
    }

    impl<'a> InstanceNetworkInterfacesPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::NetworkInterfaceCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/network-interfaces`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let (organization_name, project_name, instance_name, body) =
                match (organization_name, project_name, instance_name, body) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(instance_name),
                        Some(body),
                    ) => (organization_name, project_name, instance_name, body),
                    (organization_name, project_name, instance_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if instance_name.is_none() {
                            missing.push(stringify!(instance_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for
    /// [`ClientInstancesExt::instance_network_interfaces_get_interface`]
    ///
    ///[`ClientInstancesExt::instance_network_interfaces_get_interface`]: super::ClientInstancesExt::instance_network_interfaces_get_interface
    #[derive(Clone)]
    pub struct InstanceNetworkInterfacesGetInterface<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
        interface_name: Option<types::Name>,
    }

    impl<'a> InstanceNetworkInterfacesGetInterface<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
                interface_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        pub fn interface_name(mut self, value: types::Name) -> Self {
            self.interface_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/network-interfaces/{interface_name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                interface_name,
            } = self;
            let (organization_name, project_name, instance_name, interface_name) = match (
                organization_name,
                project_name,
                instance_name,
                interface_name,
            ) {
                (
                    Some(organization_name),
                    Some(project_name),
                    Some(instance_name),
                    Some(interface_name),
                ) => (
                    organization_name,
                    project_name,
                    instance_name,
                    interface_name,
                ),
                (organization_name, project_name, instance_name, interface_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    if instance_name.is_none() {
                        missing.push(stringify!(instance_name));
                    }
                    if interface_name.is_none() {
                        missing.push(stringify!(interface_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
                encode_path(&interface_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for
    /// [`ClientInstancesExt::instance_network_interfaces_delete_interface`]
    ///
    ///[`ClientInstancesExt::instance_network_interfaces_delete_interface`]: super::ClientInstancesExt::instance_network_interfaces_delete_interface
    #[derive(Clone)]
    pub struct InstanceNetworkInterfacesDeleteInterface<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
        interface_name: Option<types::Name>,
    }

    impl<'a> InstanceNetworkInterfacesDeleteInterface<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
                interface_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        pub fn interface_name(mut self, value: types::Name) -> Self {
            self.interface_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/network-interfaces/{interface_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                interface_name,
            } = self;
            let (organization_name, project_name, instance_name, interface_name) = match (
                organization_name,
                project_name,
                instance_name,
                interface_name,
            ) {
                (
                    Some(organization_name),
                    Some(project_name),
                    Some(instance_name),
                    Some(interface_name),
                ) => (
                    organization_name,
                    project_name,
                    instance_name,
                    interface_name,
                ),
                (organization_name, project_name, instance_name, interface_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    if instance_name.is_none() {
                        missing.push(stringify!(instance_name));
                    }
                    if interface_name.is_none() {
                        missing.push(stringify!(interface_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
                encode_path(&interface_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::project_instances_instance_reboot`]
    ///
    ///[`ClientInstancesExt::project_instances_instance_reboot`]: super::ClientInstancesExt::project_instances_instance_reboot
    #[derive(Clone)]
    pub struct ProjectInstancesInstanceReboot<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
    }

    impl<'a> ProjectInstancesInstanceReboot<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/reboot`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let (organization_name, project_name, instance_name) =
                match (organization_name, project_name, instance_name) {
                    (Some(organization_name), Some(project_name), Some(instance_name)) => {
                        (organization_name, project_name, instance_name)
                    }
                    (organization_name, project_name, instance_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if instance_name.is_none() {
                            missing.push(stringify!(instance_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/reboot",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::project_instances_instance_start`]
    ///
    ///[`ClientInstancesExt::project_instances_instance_start`]: super::ClientInstancesExt::project_instances_instance_start
    #[derive(Clone)]
    pub struct ProjectInstancesInstanceStart<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
    }

    impl<'a> ProjectInstancesInstanceStart<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/start`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let (organization_name, project_name, instance_name) =
                match (organization_name, project_name, instance_name) {
                    (Some(organization_name), Some(project_name), Some(instance_name)) => {
                        (organization_name, project_name, instance_name)
                    }
                    (organization_name, project_name, instance_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if instance_name.is_none() {
                            missing.push(stringify!(instance_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/start",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientInstancesExt::project_instances_instance_stop`]
    ///
    ///[`ClientInstancesExt::project_instances_instance_stop`]: super::ClientInstancesExt::project_instances_instance_stop
    #[derive(Clone)]
    pub struct ProjectInstancesInstanceStop<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        instance_name: Option<types::Name>,
    }

    impl<'a> ProjectInstancesInstanceStop<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                instance_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn instance_name(mut self, value: types::Name) -> Self {
            self.instance_name = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// instances/{instance_name}/stop`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let (organization_name, project_name, instance_name) =
                match (organization_name, project_name, instance_name) {
                    (Some(organization_name), Some(project_name), Some(instance_name)) => {
                        (organization_name, project_name, instance_name)
                    }
                    (organization_name, project_name, instance_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if instance_name.is_none() {
                            missing.push(stringify!(instance_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/stop",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for
    /// [`ClientProjectsExt::organization_projects_get_project_policy`]
    ///
    ///[`ClientProjectsExt::organization_projects_get_project_policy`]: super::ClientProjectsExt::organization_projects_get_project_policy
    #[derive(Clone)]
    pub struct OrganizationProjectsGetProjectPolicy<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
    }

    impl<'a> OrganizationProjectsGetProjectPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolesPolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
            } = self;
            let (organization_name, project_name) = match (organization_name, project_name) {
                (Some(organization_name), Some(project_name)) => (organization_name, project_name),
                (organization_name, project_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for
    /// [`ClientProjectsExt::organization_projects_put_project_policy`]
    ///
    ///[`ClientProjectsExt::organization_projects_put_project_policy`]: super::ClientProjectsExt::organization_projects_put_project_policy
    #[derive(Clone)]
    pub struct OrganizationProjectsPutProjectPolicy<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        body: Option<types::ProjectRolesPolicy>,
    }

    impl<'a> OrganizationProjectsPutProjectPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::ProjectRolesPolicy) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolesPolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let (organization_name, project_name, body) =
                match (organization_name, project_name, body) {
                    (Some(organization_name), Some(project_name), Some(body)) => {
                        (organization_name, project_name, body)
                    }
                    (organization_name, project_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSnapshotsExt::project_snapshots_get`]
    ///
    ///[`ClientSnapshotsExt::project_snapshots_get`]: super::ClientSnapshotsExt::project_snapshots_get
    #[derive(Clone)]
    pub struct ProjectSnapshotsGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> ProjectSnapshotsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// snapshots`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SnapshotResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name, project_name) = match (organization_name, project_name) {
                (Some(organization_name), Some(project_name)) => (organization_name, project_name),
                (organization_name, project_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// snapshots`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Snapshot, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientSnapshotsExt::project_snapshots_post`]
    ///
    ///[`ClientSnapshotsExt::project_snapshots_post`]: super::ClientSnapshotsExt::project_snapshots_post
    #[derive(Clone)]
    pub struct ProjectSnapshotsPost<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        body: Option<types::SnapshotCreate>,
    }

    impl<'a> ProjectSnapshotsPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::SnapshotCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// snapshots`
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let (organization_name, project_name, body) =
                match (organization_name, project_name, body) {
                    (Some(organization_name), Some(project_name), Some(body)) => {
                        (organization_name, project_name, body)
                    }
                    (organization_name, project_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSnapshotsExt::project_snapshots_get_snapshot`]
    ///
    ///[`ClientSnapshotsExt::project_snapshots_get_snapshot`]: super::ClientSnapshotsExt::project_snapshots_get_snapshot
    #[derive(Clone)]
    pub struct ProjectSnapshotsGetSnapshot<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        snapshot_name: Option<types::Name>,
    }

    impl<'a> ProjectSnapshotsGetSnapshot<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                snapshot_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn snapshot_name(mut self, value: types::Name) -> Self {
            self.snapshot_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// snapshots/{snapshot_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                snapshot_name,
            } = self;
            let (organization_name, project_name, snapshot_name) =
                match (organization_name, project_name, snapshot_name) {
                    (Some(organization_name), Some(project_name), Some(snapshot_name)) => {
                        (organization_name, project_name, snapshot_name)
                    }
                    (organization_name, project_name, snapshot_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if snapshot_name.is_none() {
                            missing.push(stringify!(snapshot_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&snapshot_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSnapshotsExt::project_snapshots_delete_snapshot`]
    ///
    ///[`ClientSnapshotsExt::project_snapshots_delete_snapshot`]: super::ClientSnapshotsExt::project_snapshots_delete_snapshot
    #[derive(Clone)]
    pub struct ProjectSnapshotsDeleteSnapshot<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        snapshot_name: Option<types::Name>,
    }

    impl<'a> ProjectSnapshotsDeleteSnapshot<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                snapshot_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn snapshot_name(mut self, value: types::Name) -> Self {
            self.snapshot_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/
        /// snapshots/{snapshot_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                snapshot_name,
            } = self;
            let (organization_name, project_name, snapshot_name) =
                match (organization_name, project_name, snapshot_name) {
                    (Some(organization_name), Some(project_name), Some(snapshot_name)) => {
                        (organization_name, project_name, snapshot_name)
                    }
                    (organization_name, project_name, snapshot_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if snapshot_name.is_none() {
                            missing.push(stringify!(snapshot_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&snapshot_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::project_vpcs_get`]
    ///
    ///[`ClientVpcsExt::project_vpcs_get`]: super::ClientVpcsExt::project_vpcs_get
    #[derive(Clone)]
    pub struct ProjectVpcsGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> ProjectVpcsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name, project_name) = match (organization_name, project_name) {
                (Some(organization_name), Some(project_name)) => (organization_name, project_name),
                (organization_name, project_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Vpc, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientVpcsExt::project_vpcs_post`]
    ///
    ///[`ClientVpcsExt::project_vpcs_post`]: super::ClientVpcsExt::project_vpcs_post
    #[derive(Clone)]
    pub struct ProjectVpcsPost<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        body: Option<types::VpcCreate>,
    }

    impl<'a> ProjectVpcsPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::VpcCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs`
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let (organization_name, project_name, body) =
                match (organization_name, project_name, body) {
                    (Some(organization_name), Some(project_name), Some(body)) => {
                        (organization_name, project_name, body)
                    }
                    (organization_name, project_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::project_vpcs_get_vpc`]
    ///
    ///[`ClientVpcsExt::project_vpcs_get_vpc`]: super::ClientVpcsExt::project_vpcs_get_vpc
    #[derive(Clone)]
    pub struct ProjectVpcsGetVpc<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
    }

    impl<'a> ProjectVpcsGetVpc<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
            } = self;
            let (organization_name, project_name, vpc_name) =
                match (organization_name, project_name, vpc_name) {
                    (Some(organization_name), Some(project_name), Some(vpc_name)) => {
                        (organization_name, project_name, vpc_name)
                    }
                    (organization_name, project_name, vpc_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::project_vpcs_put_vpc`]
    ///
    ///[`ClientVpcsExt::project_vpcs_put_vpc`]: super::ClientVpcsExt::project_vpcs_put_vpc
    #[derive(Clone)]
    pub struct ProjectVpcsPutVpc<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        body: Option<types::VpcUpdate>,
    }

    impl<'a> ProjectVpcsPutVpc<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::VpcUpdate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let (organization_name, project_name, vpc_name, body) =
                match (organization_name, project_name, vpc_name, body) {
                    (Some(organization_name), Some(project_name), Some(vpc_name), Some(body)) => {
                        (organization_name, project_name, vpc_name, body)
                    }
                    (organization_name, project_name, vpc_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientVpcsExt::project_vpcs_delete_vpc`]
    ///
    ///[`ClientVpcsExt::project_vpcs_delete_vpc`]: super::ClientVpcsExt::project_vpcs_delete_vpc
    #[derive(Clone)]
    pub struct ProjectVpcsDeleteVpc<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
    }

    impl<'a> ProjectVpcsDeleteVpc<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
            } = self;
            let (organization_name, project_name, vpc_name) =
                match (organization_name, project_name, vpc_name) {
                    (Some(organization_name), Some(project_name), Some(vpc_name)) => {
                        (organization_name, project_name, vpc_name)
                    }
                    (organization_name, project_name, vpc_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientFirewallExt::vpc_firewall_rules_get`]
    ///
    ///[`ClientFirewallExt::vpc_firewall_rules_get`]: super::ClientFirewallExt::vpc_firewall_rules_get
    #[derive(Clone)]
    pub struct VpcFirewallRulesGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
    }

    impl<'a> VpcFirewallRulesGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/firewall/rules`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
            } = self;
            let (organization_name, project_name, vpc_name) =
                match (organization_name, project_name, vpc_name) {
                    (Some(organization_name), Some(project_name), Some(vpc_name)) => {
                        (organization_name, project_name, vpc_name)
                    }
                    (organization_name, project_name, vpc_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientFirewallExt::vpc_firewall_rules_put`]
    ///
    ///[`ClientFirewallExt::vpc_firewall_rules_put`]: super::ClientFirewallExt::vpc_firewall_rules_put
    #[derive(Clone)]
    pub struct VpcFirewallRulesPut<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        body: Option<types::VpcFirewallRuleUpdateParams>,
    }

    impl<'a> VpcFirewallRulesPut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::VpcFirewallRuleUpdateParams) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/firewall/rules`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let (organization_name, project_name, vpc_name, body) =
                match (organization_name, project_name, vpc_name, body) {
                    (Some(organization_name), Some(project_name), Some(vpc_name), Some(body)) => {
                        (organization_name, project_name, vpc_name, body)
                    }
                    (organization_name, project_name, vpc_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientRoutersExt::vpc_routers_get`]
    ///
    ///[`ClientRoutersExt::vpc_routers_get`]: super::ClientRoutersExt::vpc_routers_get
    #[derive(Clone)]
    pub struct VpcRoutersGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> VpcRoutersGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcRouterResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name, project_name, vpc_name) =
                match (organization_name, project_name, vpc_name) {
                    (Some(organization_name), Some(project_name), Some(vpc_name)) => {
                        (organization_name, project_name, vpc_name)
                    }
                    (organization_name, project_name, vpc_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::VpcRouter, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientRoutersExt::vpc_routers_post`]
    ///
    ///[`ClientRoutersExt::vpc_routers_post`]: super::ClientRoutersExt::vpc_routers_post
    #[derive(Clone)]
    pub struct VpcRoutersPost<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        body: Option<types::VpcRouterCreate>,
    }

    impl<'a> VpcRoutersPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::VpcRouterCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers`
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let (organization_name, project_name, vpc_name, body) =
                match (organization_name, project_name, vpc_name, body) {
                    (Some(organization_name), Some(project_name), Some(vpc_name), Some(body)) => {
                        (organization_name, project_name, vpc_name, body)
                    }
                    (organization_name, project_name, vpc_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientRoutersExt::vpc_routers_get_router`]
    ///
    ///[`ClientRoutersExt::vpc_routers_get_router`]: super::ClientRoutersExt::vpc_routers_get_router
    #[derive(Clone)]
    pub struct VpcRoutersGetRouter<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        router_name: Option<types::Name>,
    }

    impl<'a> VpcRoutersGetRouter<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                router_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn router_name(mut self, value: types::Name) -> Self {
            self.router_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
            } = self;
            let (organization_name, project_name, vpc_name, router_name) =
                match (organization_name, project_name, vpc_name, router_name) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(vpc_name),
                        Some(router_name),
                    ) => (organization_name, project_name, vpc_name, router_name),
                    (organization_name, project_name, vpc_name, router_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if router_name.is_none() {
                            missing.push(stringify!(router_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientRoutersExt::vpc_routers_put_router`]
    ///
    ///[`ClientRoutersExt::vpc_routers_put_router`]: super::ClientRoutersExt::vpc_routers_put_router
    #[derive(Clone)]
    pub struct VpcRoutersPutRouter<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        router_name: Option<types::Name>,
        body: Option<types::VpcRouterUpdate>,
    }

    impl<'a> VpcRoutersPutRouter<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                router_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn router_name(mut self, value: types::Name) -> Self {
            self.router_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::VpcRouterUpdate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                body,
            } = self;
            let (organization_name, project_name, vpc_name, router_name, body) =
                match (organization_name, project_name, vpc_name, router_name, body) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(vpc_name),
                        Some(router_name),
                        Some(body),
                    ) => (organization_name, project_name, vpc_name, router_name, body),
                    (organization_name, project_name, vpc_name, router_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if router_name.is_none() {
                            missing.push(stringify!(router_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientRoutersExt::vpc_routers_delete_router`]
    ///
    ///[`ClientRoutersExt::vpc_routers_delete_router`]: super::ClientRoutersExt::vpc_routers_delete_router
    #[derive(Clone)]
    pub struct VpcRoutersDeleteRouter<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        router_name: Option<types::Name>,
    }

    impl<'a> VpcRoutersDeleteRouter<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                router_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn router_name(mut self, value: types::Name) -> Self {
            self.router_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
            } = self;
            let (organization_name, project_name, vpc_name, router_name) =
                match (organization_name, project_name, vpc_name, router_name) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(vpc_name),
                        Some(router_name),
                    ) => (organization_name, project_name, vpc_name, router_name),
                    (organization_name, project_name, vpc_name, router_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if router_name.is_none() {
                            missing.push(stringify!(router_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientRoutesExt::routers_routes_get`]
    ///
    ///[`ClientRoutesExt::routers_routes_get`]: super::ClientRoutesExt::routers_routes_get
    #[derive(Clone)]
    pub struct RoutersRoutesGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        router_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> RoutersRoutesGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                router_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn router_name(mut self, value: types::Name) -> Self {
            self.router_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RouterRouteResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name, project_name, vpc_name, router_name) =
                match (organization_name, project_name, vpc_name, router_name) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(vpc_name),
                        Some(router_name),
                    ) => (organization_name, project_name, vpc_name, router_name),
                    (organization_name, project_name, vpc_name, router_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if router_name.is_none() {
                            missing.push(stringify!(router_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::RouterRoute, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientRoutesExt::routers_routes_post`]
    ///
    ///[`ClientRoutesExt::routers_routes_post`]: super::ClientRoutesExt::routers_routes_post
    #[derive(Clone)]
    pub struct RoutersRoutesPost<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        router_name: Option<types::Name>,
        body: Option<types::RouterRouteCreateParams>,
    }

    impl<'a> RoutersRoutesPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                router_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn router_name(mut self, value: types::Name) -> Self {
            self.router_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::RouterRouteCreateParams) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes`
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                body,
            } = self;
            let (organization_name, project_name, vpc_name, router_name, body) =
                match (organization_name, project_name, vpc_name, router_name, body) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(vpc_name),
                        Some(router_name),
                        Some(body),
                    ) => (organization_name, project_name, vpc_name, router_name, body),
                    (organization_name, project_name, vpc_name, router_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if router_name.is_none() {
                            missing.push(stringify!(router_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientRoutesExt::routers_routes_get_route`]
    ///
    ///[`ClientRoutesExt::routers_routes_get_route`]: super::ClientRoutesExt::routers_routes_get_route
    #[derive(Clone)]
    pub struct RoutersRoutesGetRoute<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        router_name: Option<types::Name>,
        route_name: Option<types::Name>,
    }

    impl<'a> RoutersRoutesGetRoute<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                router_name: None,
                route_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn router_name(mut self, value: types::Name) -> Self {
            self.router_name = Some(value);
            self
        }

        pub fn route_name(mut self, value: types::Name) -> Self {
            self.route_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes/{route_name}`
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
            } = self;
            let (organization_name, project_name, vpc_name, router_name, route_name) = match (
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
            ) {
                (
                    Some(organization_name),
                    Some(project_name),
                    Some(vpc_name),
                    Some(router_name),
                    Some(route_name),
                ) => (
                    organization_name,
                    project_name,
                    vpc_name,
                    router_name,
                    route_name,
                ),
                (organization_name, project_name, vpc_name, router_name, route_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    if vpc_name.is_none() {
                        missing.push(stringify!(vpc_name));
                    }
                    if router_name.is_none() {
                        missing.push(stringify!(router_name));
                    }
                    if route_name.is_none() {
                        missing.push(stringify!(route_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
                encode_path(&route_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientRoutesExt::routers_routes_put_route`]
    ///
    ///[`ClientRoutesExt::routers_routes_put_route`]: super::ClientRoutesExt::routers_routes_put_route
    #[derive(Clone)]
    pub struct RoutersRoutesPutRoute<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        router_name: Option<types::Name>,
        route_name: Option<types::Name>,
        body: Option<types::RouterRouteUpdateParams>,
    }

    impl<'a> RoutersRoutesPutRoute<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                router_name: None,
                route_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn router_name(mut self, value: types::Name) -> Self {
            self.router_name = Some(value);
            self
        }

        pub fn route_name(mut self, value: types::Name) -> Self {
            self.route_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::RouterRouteUpdateParams) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes/{route_name}`
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
                body,
            } = self;
            let (organization_name, project_name, vpc_name, router_name, route_name, body) = match (
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
                body,
            ) {
                (
                    Some(organization_name),
                    Some(project_name),
                    Some(vpc_name),
                    Some(router_name),
                    Some(route_name),
                    Some(body),
                ) => (
                    organization_name,
                    project_name,
                    vpc_name,
                    router_name,
                    route_name,
                    body,
                ),
                (organization_name, project_name, vpc_name, router_name, route_name, body) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    if vpc_name.is_none() {
                        missing.push(stringify!(vpc_name));
                    }
                    if router_name.is_none() {
                        missing.push(stringify!(router_name));
                    }
                    if route_name.is_none() {
                        missing.push(stringify!(route_name));
                    }
                    if body.is_none() {
                        missing.push(stringify!(body));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
                encode_path(&route_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientRoutesExt::routers_routes_delete_route`]
    ///
    ///[`ClientRoutesExt::routers_routes_delete_route`]: super::ClientRoutesExt::routers_routes_delete_route
    #[derive(Clone)]
    pub struct RoutersRoutesDeleteRoute<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        router_name: Option<types::Name>,
        route_name: Option<types::Name>,
    }

    impl<'a> RoutersRoutesDeleteRoute<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                router_name: None,
                route_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn router_name(mut self, value: types::Name) -> Self {
            self.router_name = Some(value);
            self
        }

        pub fn route_name(mut self, value: types::Name) -> Self {
            self.route_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/routers/{router_name}/routes/{route_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
            } = self;
            let (organization_name, project_name, vpc_name, router_name, route_name) = match (
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
            ) {
                (
                    Some(organization_name),
                    Some(project_name),
                    Some(vpc_name),
                    Some(router_name),
                    Some(route_name),
                ) => (
                    organization_name,
                    project_name,
                    vpc_name,
                    router_name,
                    route_name,
                ),
                (organization_name, project_name, vpc_name, router_name, route_name) => {
                    let mut missing = Vec::new();
                    if organization_name.is_none() {
                        missing.push(stringify!(organization_name));
                    }
                    if project_name.is_none() {
                        missing.push(stringify!(project_name));
                    }
                    if vpc_name.is_none() {
                        missing.push(stringify!(vpc_name));
                    }
                    if router_name.is_none() {
                        missing.push(stringify!(router_name));
                    }
                    if route_name.is_none() {
                        missing.push(stringify!(route_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
                encode_path(&route_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSubnetsExt::vpc_subnets_get`]
    ///
    ///[`ClientSubnetsExt::vpc_subnets_get`]: super::ClientSubnetsExt::vpc_subnets_get
    #[derive(Clone)]
    pub struct VpcSubnetsGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> VpcSubnetsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcSubnetResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name, project_name, vpc_name) =
                match (organization_name, project_name, vpc_name) {
                    (Some(organization_name), Some(project_name), Some(vpc_name)) => {
                        (organization_name, project_name, vpc_name)
                    }
                    (organization_name, project_name, vpc_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::VpcSubnet, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientSubnetsExt::vpc_subnets_post`]
    ///
    ///[`ClientSubnetsExt::vpc_subnets_post`]: super::ClientSubnetsExt::vpc_subnets_post
    #[derive(Clone)]
    pub struct VpcSubnetsPost<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        body: Option<types::VpcSubnetCreate>,
    }

    impl<'a> VpcSubnetsPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::VpcSubnetCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets`
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let (organization_name, project_name, vpc_name, body) =
                match (organization_name, project_name, vpc_name, body) {
                    (Some(organization_name), Some(project_name), Some(vpc_name), Some(body)) => {
                        (organization_name, project_name, vpc_name, body)
                    }
                    (organization_name, project_name, vpc_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSubnetsExt::vpc_subnets_get_subnet`]
    ///
    ///[`ClientSubnetsExt::vpc_subnets_get_subnet`]: super::ClientSubnetsExt::vpc_subnets_get_subnet
    #[derive(Clone)]
    pub struct VpcSubnetsGetSubnet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        subnet_name: Option<types::Name>,
    }

    impl<'a> VpcSubnetsGetSubnet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                subnet_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn subnet_name(mut self, value: types::Name) -> Self {
            self.subnet_name = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets/{subnet_name}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
            } = self;
            let (organization_name, project_name, vpc_name, subnet_name) =
                match (organization_name, project_name, vpc_name, subnet_name) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(vpc_name),
                        Some(subnet_name),
                    ) => (organization_name, project_name, vpc_name, subnet_name),
                    (organization_name, project_name, vpc_name, subnet_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if subnet_name.is_none() {
                            missing.push(stringify!(subnet_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSubnetsExt::vpc_subnets_put_subnet`]
    ///
    ///[`ClientSubnetsExt::vpc_subnets_put_subnet`]: super::ClientSubnetsExt::vpc_subnets_put_subnet
    #[derive(Clone)]
    pub struct VpcSubnetsPutSubnet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        subnet_name: Option<types::Name>,
        body: Option<types::VpcSubnetUpdate>,
    }

    impl<'a> VpcSubnetsPutSubnet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                subnet_name: None,
                body: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn subnet_name(mut self, value: types::Name) -> Self {
            self.subnet_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::VpcSubnetUpdate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `PUT` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets/{subnet_name}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
                body,
            } = self;
            let (organization_name, project_name, vpc_name, subnet_name, body) =
                match (organization_name, project_name, vpc_name, subnet_name, body) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(vpc_name),
                        Some(subnet_name),
                        Some(body),
                    ) => (organization_name, project_name, vpc_name, subnet_name, body),
                    (organization_name, project_name, vpc_name, subnet_name, body) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if subnet_name.is_none() {
                            missing.push(stringify!(subnet_name));
                        }
                        if body.is_none() {
                            missing.push(stringify!(body));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSubnetsExt::vpc_subnets_delete_subnet`]
    ///
    ///[`ClientSubnetsExt::vpc_subnets_delete_subnet`]: super::ClientSubnetsExt::vpc_subnets_delete_subnet
    #[derive(Clone)]
    pub struct VpcSubnetsDeleteSubnet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        subnet_name: Option<types::Name>,
    }

    impl<'a> VpcSubnetsDeleteSubnet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                subnet_name: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn subnet_name(mut self, value: types::Name) -> Self {
            self.subnet_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets/{subnet_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
            } = self;
            let (organization_name, project_name, vpc_name, subnet_name) =
                match (organization_name, project_name, vpc_name, subnet_name) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(vpc_name),
                        Some(subnet_name),
                    ) => (organization_name, project_name, vpc_name, subnet_name),
                    (organization_name, project_name, vpc_name, subnet_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if subnet_name.is_none() {
                            missing.push(stringify!(subnet_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSubnetsExt::subnet_network_interfaces_get`]
    ///
    ///[`ClientSubnetsExt::subnet_network_interfaces_get`]: super::ClientSubnetsExt::subnet_network_interfaces_get
    #[derive(Clone)]
    pub struct SubnetNetworkInterfacesGet<'a> {
        client: &'a super::Client,
        organization_name: Option<types::Name>,
        project_name: Option<types::Name>,
        vpc_name: Option<types::Name>,
        subnet_name: Option<types::Name>,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> SubnetNetworkInterfacesGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: None,
                project_name: None,
                vpc_name: None,
                subnet_name: None,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn organization_name(mut self, value: types::Name) -> Self {
            self.organization_name = Some(value);
            self
        }

        pub fn project_name(mut self, value: types::Name) -> Self {
            self.project_name = Some(value);
            self
        }

        pub fn vpc_name(mut self, value: types::Name) -> Self {
            self.vpc_name = Some(value);
            self
        }

        pub fn subnet_name(mut self, value: types::Name) -> Self {
            self.subnet_name = Some(value);
            self
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets/{subnet_name}/network-interfaces`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterfaceResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let (organization_name, project_name, vpc_name, subnet_name) =
                match (organization_name, project_name, vpc_name, subnet_name) {
                    (
                        Some(organization_name),
                        Some(project_name),
                        Some(vpc_name),
                        Some(subnet_name),
                    ) => (organization_name, project_name, vpc_name, subnet_name),
                    (organization_name, project_name, vpc_name, subnet_name) => {
                        let mut missing = Vec::new();
                        if organization_name.is_none() {
                            missing.push(stringify!(organization_name));
                        }
                        if project_name.is_none() {
                            missing.push(stringify!(project_name));
                        }
                        if vpc_name.is_none() {
                            missing.push(stringify!(vpc_name));
                        }
                        if subnet_name.is_none() {
                            missing.push(stringify!(subnet_name));
                        }
                        return Err(super::Error::InvalidRequest(format!(
                            "the following parameters are required: {}",
                            missing.join(", "),
                        )));
                    }
                };
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}/network-interfaces",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to
        /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
        /// {vpc_name}/subnets/{subnet_name}/network-interfaces`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::NetworkInterface, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientPolicyExt::policy_get`]
    ///
    ///[`ClientPolicyExt::policy_get`]: super::ClientPolicyExt::policy_get
    #[derive(Clone)]
    pub struct PolicyGet<'a> {
        client: &'a super::Client,
    }

    impl<'a> PolicyGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FleetRolesPolicy>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/policy", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientPolicyExt::policy_put`]
    ///
    ///[`ClientPolicyExt::policy_put`]: super::ClientPolicyExt::policy_put
    #[derive(Clone)]
    pub struct PolicyPut<'a> {
        client: &'a super::Client,
        body: Option<types::FleetRolesPolicy>,
    }

    impl<'a> PolicyPut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client, body: None }
        }

        pub fn body(mut self, value: types::FleetRolesPolicy) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `PUT` request to `/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FleetRolesPolicy>, Error<types::Error>> {
            let Self { client, body } = self;
            let (body,) = match (body,) {
                (Some(body),) => (body,),
                (body,) => {
                    let mut missing = Vec::new();
                    if body.is_none() {
                        missing.push(stringify!(body));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!("{}/policy", client.baseurl,);
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientRolesExt::roles_get`]
    ///
    ///[`ClientRolesExt::roles_get`]: super::ClientRolesExt::roles_get
    #[derive(Clone)]
    pub struct RolesGet<'a> {
        client: &'a super::Client,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
    }

    impl<'a> RolesGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: None,
                page_token: None,
            }
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        ///Sends a `GET` request to `/roles`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RoleResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let url = format!("{}/roles", client.baseurl,);
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/roles`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Role, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientRolesExt::roles_get_role`]
    ///
    ///[`ClientRolesExt::roles_get_role`]: super::ClientRolesExt::roles_get_role
    #[derive(Clone)]
    pub struct RolesGetRole<'a> {
        client: &'a super::Client,
        role_name: Option<String>,
    }

    impl<'a> RolesGetRole<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                role_name: None,
            }
        }

        pub fn role_name<S: ToString>(mut self, value: S) -> Self {
            self.role_name = Some(value.to_string());
            self
        }

        ///Sends a `GET` request to `/roles/{role_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Role>, Error<types::Error>> {
            let Self { client, role_name } = self;
            let (role_name,) = match (role_name,) {
                (Some(role_name),) => (role_name,),
                (role_name,) => {
                    let mut missing = Vec::new();
                    if role_name.is_none() {
                        missing.push(stringify!(role_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/roles/{}",
                client.baseurl,
                encode_path(&role_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSagasExt::sagas_get`]
    ///
    ///[`ClientSagasExt::sagas_get`]: super::ClientSagasExt::sagas_get
    #[derive(Clone)]
    pub struct SagasGet<'a> {
        client: &'a super::Client,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::IdSortMode>,
    }

    impl<'a> SagasGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::IdSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to `/sagas`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SagaResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let url = format!("{}/sagas", client.baseurl,);
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/sagas`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Saga, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientSagasExt::sagas_get_saga`]
    ///
    ///[`ClientSagasExt::sagas_get_saga`]: super::ClientSagasExt::sagas_get_saga
    #[derive(Clone)]
    pub struct SagasGetSaga<'a> {
        client: &'a super::Client,
        saga_id: Option<uuid::Uuid>,
    }

    impl<'a> SagasGetSaga<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                saga_id: None,
            }
        }

        pub fn saga_id(mut self, value: uuid::Uuid) -> Self {
            self.saga_id = Some(value);
            self
        }

        ///Sends a `GET` request to `/sagas/{saga_id}`
        pub async fn send(self) -> Result<ResponseValue<types::Saga>, Error<types::Error>> {
            let Self { client, saga_id } = self;
            let (saga_id,) = match (saga_id,) {
                (Some(saga_id),) => (saga_id,),
                (saga_id,) => {
                    let mut missing = Vec::new();
                    if saga_id.is_none() {
                        missing.push(stringify!(saga_id));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/sagas/{}",
                client.baseurl,
                encode_path(&saga_id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientHiddenExt::session_me`]
    ///
    ///[`ClientHiddenExt::session_me`]: super::ClientHiddenExt::session_me
    #[derive(Clone)]
    pub struct SessionMe<'a> {
        client: &'a super::Client,
    }

    impl<'a> SessionMe<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/session/me`
        pub async fn send(self) -> Result<ResponseValue<types::SessionUser>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/session/me", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSshkeysExt::sshkeys_get`]
    ///
    ///[`ClientSshkeysExt::sshkeys_get`]: super::ClientSshkeysExt::sshkeys_get
    #[derive(Clone)]
    pub struct SshkeysGet<'a> {
        client: &'a super::Client,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> SshkeysGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to `/session/me/sshkeys`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SshKeyResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let url = format!("{}/session/me/sshkeys", client.baseurl,);
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/session/me/sshkeys`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SshKey, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientSshkeysExt::sshkeys_post`]
    ///
    ///[`ClientSshkeysExt::sshkeys_post`]: super::ClientSshkeysExt::sshkeys_post
    #[derive(Clone)]
    pub struct SshkeysPost<'a> {
        client: &'a super::Client,
        body: Option<types::SshKeyCreate>,
    }

    impl<'a> SshkeysPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client, body: None }
        }

        pub fn body(mut self, value: types::SshKeyCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to `/session/me/sshkeys`
        pub async fn send(self) -> Result<ResponseValue<types::SshKey>, Error<types::Error>> {
            let Self { client, body } = self;
            let (body,) = match (body,) {
                (Some(body),) => (body,),
                (body,) => {
                    let mut missing = Vec::new();
                    if body.is_none() {
                        missing.push(stringify!(body));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!("{}/session/me/sshkeys", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSshkeysExt::sshkeys_get_key`]
    ///
    ///[`ClientSshkeysExt::sshkeys_get_key`]: super::ClientSshkeysExt::sshkeys_get_key
    #[derive(Clone)]
    pub struct SshkeysGetKey<'a> {
        client: &'a super::Client,
        ssh_key_name: Option<types::Name>,
    }

    impl<'a> SshkeysGetKey<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ssh_key_name: None,
            }
        }

        pub fn ssh_key_name(mut self, value: types::Name) -> Self {
            self.ssh_key_name = Some(value);
            self
        }

        ///Sends a `GET` request to `/session/me/sshkeys/{ssh_key_name}`
        pub async fn send(self) -> Result<ResponseValue<types::SshKey>, Error<types::Error>> {
            let Self {
                client,
                ssh_key_name,
            } = self;
            let (ssh_key_name,) = match (ssh_key_name,) {
                (Some(ssh_key_name),) => (ssh_key_name,),
                (ssh_key_name,) => {
                    let mut missing = Vec::new();
                    if ssh_key_name.is_none() {
                        missing.push(stringify!(ssh_key_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/session/me/sshkeys/{}",
                client.baseurl,
                encode_path(&ssh_key_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSshkeysExt::sshkeys_delete_key`]
    ///
    ///[`ClientSshkeysExt::sshkeys_delete_key`]: super::ClientSshkeysExt::sshkeys_delete_key
    #[derive(Clone)]
    pub struct SshkeysDeleteKey<'a> {
        client: &'a super::Client,
        ssh_key_name: Option<types::Name>,
    }

    impl<'a> SshkeysDeleteKey<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ssh_key_name: None,
            }
        }

        pub fn ssh_key_name(mut self, value: types::Name) -> Self {
            self.ssh_key_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to `/session/me/sshkeys/{ssh_key_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                ssh_key_name,
            } = self;
            let (ssh_key_name,) = match (ssh_key_name,) {
                (Some(ssh_key_name),) => (ssh_key_name,),
                (ssh_key_name,) => {
                    let mut missing = Vec::new();
                    if ssh_key_name.is_none() {
                        missing.push(stringify!(ssh_key_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/session/me/sshkeys/{}",
                client.baseurl,
                encode_path(&ssh_key_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSilosExt::silos_get`]
    ///
    ///[`ClientSilosExt::silos_get`]: super::ClientSilosExt::silos_get
    #[derive(Clone)]
    pub struct SilosGet<'a> {
        client: &'a super::Client,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameOrIdSortMode>,
    }

    impl<'a> SilosGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameOrIdSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to `/silos`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let url = format!("{}/silos", client.baseurl,);
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/silos`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Silo, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientSilosExt::silos_post`]
    ///
    ///[`ClientSilosExt::silos_post`]: super::ClientSilosExt::silos_post
    #[derive(Clone)]
    pub struct SilosPost<'a> {
        client: &'a super::Client,
        body: Option<types::SiloCreate>,
    }

    impl<'a> SilosPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client, body: None }
        }

        pub fn body(mut self, value: types::SiloCreate) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `POST` request to `/silos`
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, body } = self;
            let (body,) = match (body,) {
                (Some(body),) => (body,),
                (body,) => {
                    let mut missing = Vec::new();
                    if body.is_none() {
                        missing.push(stringify!(body));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!("{}/silos", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSilosExt::silos_get_silo`]
    ///
    ///[`ClientSilosExt::silos_get_silo`]: super::ClientSilosExt::silos_get_silo
    #[derive(Clone)]
    pub struct SilosGetSilo<'a> {
        client: &'a super::Client,
        silo_name: Option<types::Name>,
    }

    impl<'a> SilosGetSilo<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: None,
            }
        }

        pub fn silo_name(mut self, value: types::Name) -> Self {
            self.silo_name = Some(value);
            self
        }

        ///Sends a `GET` request to `/silos/{silo_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, silo_name } = self;
            let (silo_name,) = match (silo_name,) {
                (Some(silo_name),) => (silo_name,),
                (silo_name,) => {
                    let mut missing = Vec::new();
                    if silo_name.is_none() {
                        missing.push(stringify!(silo_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/silos/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSilosExt::silos_delete_silo`]
    ///
    ///[`ClientSilosExt::silos_delete_silo`]: super::ClientSilosExt::silos_delete_silo
    #[derive(Clone)]
    pub struct SilosDeleteSilo<'a> {
        client: &'a super::Client,
        silo_name: Option<types::Name>,
    }

    impl<'a> SilosDeleteSilo<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: None,
            }
        }

        pub fn silo_name(mut self, value: types::Name) -> Self {
            self.silo_name = Some(value);
            self
        }

        ///Sends a `DELETE` request to `/silos/{silo_name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, silo_name } = self;
            let (silo_name,) = match (silo_name,) {
                (Some(silo_name),) => (silo_name,),
                (silo_name,) => {
                    let mut missing = Vec::new();
                    if silo_name.is_none() {
                        missing.push(stringify!(silo_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/silos/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSilosExt::silos_get_silo_policy`]
    ///
    ///[`ClientSilosExt::silos_get_silo_policy`]: super::ClientSilosExt::silos_get_silo_policy
    #[derive(Clone)]
    pub struct SilosGetSiloPolicy<'a> {
        client: &'a super::Client,
        silo_name: Option<types::Name>,
    }

    impl<'a> SilosGetSiloPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: None,
            }
        }

        pub fn silo_name(mut self, value: types::Name) -> Self {
            self.silo_name = Some(value);
            self
        }

        ///Sends a `GET` request to `/silos/{silo_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolesPolicy>, Error<types::Error>> {
            let Self { client, silo_name } = self;
            let (silo_name,) = match (silo_name,) {
                (Some(silo_name),) => (silo_name,),
                (silo_name,) => {
                    let mut missing = Vec::new();
                    if silo_name.is_none() {
                        missing.push(stringify!(silo_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/silos/{}/policy",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientSilosExt::silos_put_silo_policy`]
    ///
    ///[`ClientSilosExt::silos_put_silo_policy`]: super::ClientSilosExt::silos_put_silo_policy
    #[derive(Clone)]
    pub struct SilosPutSiloPolicy<'a> {
        client: &'a super::Client,
        silo_name: Option<types::Name>,
        body: Option<types::SiloRolesPolicy>,
    }

    impl<'a> SilosPutSiloPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: None,
                body: None,
            }
        }

        pub fn silo_name(mut self, value: types::Name) -> Self {
            self.silo_name = Some(value);
            self
        }

        pub fn body(mut self, value: types::SiloRolesPolicy) -> Self {
            self.body = Some(value);
            self
        }

        ///Sends a `PUT` request to `/silos/{silo_name}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolesPolicy>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                body,
            } = self;
            let (silo_name, body) = match (silo_name, body) {
                (Some(silo_name), Some(body)) => (silo_name, body),
                (silo_name, body) => {
                    let mut missing = Vec::new();
                    if silo_name.is_none() {
                        missing.push(stringify!(silo_name));
                    }
                    if body.is_none() {
                        missing.push(stringify!(body));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/silos/{}/policy",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientMetricsExt::timeseries_schema_get`]
    ///
    ///[`ClientMetricsExt::timeseries_schema_get`]: super::ClientMetricsExt::timeseries_schema_get
    #[derive(Clone)]
    pub struct TimeseriesSchemaGet<'a> {
        client: &'a super::Client,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
    }

    impl<'a> TimeseriesSchemaGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: None,
                page_token: None,
            }
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        ///Sends a `GET` request to `/timeseries/schema`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TimeseriesSchemaResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let url = format!("{}/timeseries/schema", client.baseurl,);
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/timeseries/schema`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::TimeseriesSchema, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientUpdatesExt::updates_refresh`]
    ///
    ///[`ClientUpdatesExt::updates_refresh`]: super::ClientUpdatesExt::updates_refresh
    #[derive(Clone)]
    pub struct UpdatesRefresh<'a> {
        client: &'a super::Client,
    }

    impl<'a> UpdatesRefresh<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `POST` request to `/updates/refresh`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/updates/refresh", client.baseurl,);
            let request = client.client.post(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`ClientUsersExt::users_get`]
    ///
    ///[`ClientUsersExt::users_get`]: super::ClientUsersExt::users_get
    #[derive(Clone)]
    pub struct UsersGet<'a> {
        client: &'a super::Client,
        limit: Option<std::num::NonZeroU32>,
        page_token: Option<String>,
        sort_by: Option<types::NameSortMode>,
    }

    impl<'a> UsersGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: None,
                page_token: None,
                sort_by: None,
            }
        }

        pub fn limit(mut self, value: std::num::NonZeroU32) -> Self {
            self.limit = Some(value);
            self
        }

        pub fn page_token(mut self, value: String) -> Self {
            self.page_token = Some(value);
            self
        }

        pub fn sort_by(mut self, value: types::NameSortMode) -> Self {
            self.sort_by = Some(value);
            self
        }

        ///Sends a `GET` request to `/users`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let url = format!("{}/users", client.baseurl,);
            let mut query = Vec::new();
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        ///Streams `GET` requests to `/users`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::User, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: None,
                page_token: None,
                sort_by: None,
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: next_page,
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    ///Builder for [`ClientUsersExt::users_get_user`]
    ///
    ///[`ClientUsersExt::users_get_user`]: super::ClientUsersExt::users_get_user
    #[derive(Clone)]
    pub struct UsersGetUser<'a> {
        client: &'a super::Client,
        user_name: Option<types::Name>,
    }

    impl<'a> UsersGetUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                user_name: None,
            }
        }

        pub fn user_name(mut self, value: types::Name) -> Self {
            self.user_name = Some(value);
            self
        }

        ///Sends a `GET` request to `/users/{user_name}`
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self { client, user_name } = self;
            let (user_name,) = match (user_name,) {
                (Some(user_name),) => (user_name,),
                (user_name,) => {
                    let mut missing = Vec::new();
                    if user_name.is_none() {
                        missing.push(stringify!(user_name));
                    }
                    return Err(super::Error::InvalidRequest(format!(
                        "the following parameters are required: {}",
                        missing.join(", "),
                    )));
                }
            };
            let url = format!(
                "{}/users/{}",
                client.baseurl,
                encode_path(&user_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}
